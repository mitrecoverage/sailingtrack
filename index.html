<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sailing Steering Analysis Dashboard</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mp4-muxer@5.1.3/build/mp4-muxer.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mp4box@0.5.2/dist/mp4box.all.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f3f4f6; min-height: 100vh; padding: 16px; }
    
    /* GPU-accelerated video rendering with performance hints */
    video {
      transform: translateZ(0);
      will-change: transform, contents;
      backface-visibility: hidden;
      -webkit-transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      contain: strict;
      content-visibility: auto;
    }
    
    /* Video container isolation for better performance */
    #video-container {
      contain: layout style;
      isolation: isolate;
      max-width: 100%;
    }
    
    /* 360 Video orientation tags */
    .orient-tag {
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 9px;
      font-weight: 600;
      cursor: pointer;
      user-select: none;
      transition: transform 0.15s, box-shadow 0.15s;
    }
    .orient-tag:hover { transform: scale(1.1); }
    .orient-tag.vertical { background: linear-gradient(90deg, #ff6b6b, #ee5a24); }
    .orient-tag.horizontal { background: linear-gradient(90deg, #00d4ff, #7b2cbf); }
    
    .view-mode-tag {
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 9px;
      font-weight: 600;
      cursor: pointer;
      user-select: none;
      background: rgba(255,255,255,0.2);
    }
    .view-mode-tag:hover { background: rgba(255,255,255,0.3); }
    
    @keyframes spin360 {
      to { transform: rotate(360deg); }
    }
    
    /* Fullscreen video styles */
    #video-wrapper:fullscreen {
      width: 100vw;
      height: 100vh;
      background: #000 !important;
      border-radius: 0 !important;
      display: flex;
      flex-direction: column;
    }
    
    #video-wrapper:fullscreen #active-video-element {
      flex: 1;
      width: 100%;
      aspect-ratio: auto;
      max-height: none;
      position: relative;
    }
    
    #video-wrapper:fullscreen video {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    
    #video-wrapper:fullscreen #video-unavailable-overlay {
      pointer-events: auto !important;
      background: rgba(0,0,0,0.85) !important;
    }
    
    #video-wrapper:fullscreen #video-unavailable-overlay > div {
      font-size: 20px !important;
    }
    
    #video-wrapper:fullscreen #video-unavailable-overlay > div > div:last-child {
      font-size: 18px !important;
      padding: 12px 24px !important;
    }
    
    #video-wrapper:fullscreen #video-countdown {
      font-size: 18px !important;
    }
    
    /* Fullscreen widget controls */
    .fs-widget {
      transition: opacity 0.2s;
    }
    
    .fs-widget-header {
      display: none;
      cursor: move;
      padding: 2px 4px;
      margin: -6px -10px 4px -10px;
      border-bottom: 1px solid rgba(255,255,255,0.2);
      font-size: 10px;
      color: #9ca3af;
      user-select: none;
    }
    
    .fs-widget-header .fs-minimize-btn {
      cursor: pointer;
      float: right;
      opacity: 0.7;
      font-size: 12px;
      margin-left: 8px;
    }
    
    .fs-widget-header .fs-minimize-btn:hover {
      opacity: 1;
    }
    
    .fs-widget.minimized .fs-widget-content {
      display: none !important;
    }
    
    .fs-widget.minimized {
      padding: 4px 8px !important;
      min-width: auto !important;
      width: auto !important;
      height: auto !important;
    }
    
    .fs-widget.minimized .fs-widget-header {
      margin: 0 !important;
      padding: 0 !important;
      border: none !important;
    }
    
    #video-wrapper:fullscreen .fs-widget-header {
      display: block;
    }
    
    #video-wrapper:fullscreen #video-overlays-container {
      overflow: visible !important;
    }
    
    #video-wrapper:fullscreen .fs-widget {
      pointer-events: auto;
      overflow: hidden;
    }
    
    #video-wrapper:fullscreen .fs-widget.dragged {
      top: auto;
      bottom: auto;
      left: auto;
      right: auto;
      /* transform handled by JS to preserve scale */
    }
    
    /* Minimized state - keep corner positions */
    #video-wrapper:fullscreen .fs-widget.minimized .fs-widget-content {
      display: none !important;
    }
    
    /* Non-fullscreen widget positions */
    #video-telemetry-overlay:not(.dragged) {
      top: 8px;
      right: 8px;
    }
    
    #video-leg-overlay:not(.dragged) {
      bottom: 40px;
      right: 8px;
    }
    
    #video-distance-overlay:not(.dragged) {
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
    }
    
    #video-wrapper:fullscreen #video-telemetry-overlay {
      padding: 12px 20px !important;
    }
    
    #video-wrapper:fullscreen #video-telemetry-overlay .fs-widget-content {
      font-size: 28px !important;
    }
    
    #video-wrapper:fullscreen #video-telemetry-overlay:not(.dragged) {
      top: 15%;
      right: 8px;
    }
    
    #video-wrapper:fullscreen #video-telemetry-overlay .fs-widget-header {
      margin: -12px -20px 8px -20px;
      padding: 4px 8px;
      font-size: 14px;
    }
    
    #video-wrapper:fullscreen #video-leg-overlay {
      padding: 12px 20px !important;
    }
    
    #video-wrapper:fullscreen #video-leg-overlay .fs-widget-content {
      font-size: 28px !important;
    }
    
    #video-wrapper:fullscreen #video-leg-overlay:not(.dragged) {
      bottom: 15%;
      right: 8px;
    }
    
    #video-wrapper:fullscreen #video-leg-overlay.minimized:not(.dragged) {
      bottom: 15%;
      right: 8px;
      top: auto;
    }
    
    #video-wrapper:fullscreen #video-leg-overlay .fs-widget-header {
      margin: -12px -20px 8px -20px;
      padding: 4px 8px;
      font-size: 14px;
    }
    
    #minimap-leg2-telemetry {
      display: none;
    }
    
    /* Only show boat 2 telemetry in fullscreen when there are 2+ boats (controlled via JS) */
    #video-wrapper:fullscreen #minimap-leg2-telemetry {
      font-size: 14px !important;
      min-width: 70px;
      max-width: 120px;
      width: 30%;
      flex-shrink: 0;
    }
    
    #video-wrapper:fullscreen #minimap-leg2-telemetry.show-boat2 {
      display: flex !important;
    }
    
    #video-wrapper:fullscreen #telem-leg2-label {
      font-size: 11px !important;
      margin-bottom: 4px !important;
    }
    
    #video-wrapper:fullscreen #video-distance-overlay {
      padding: 12px 16px !important;
    }
    
    #video-wrapper:fullscreen #video-distance-overlay .fs-widget-content {
      font-size: 14px !important;
      line-height: 1.5 !important;
    }
    
    #video-wrapper:fullscreen #video-distance-overlay:not(.dragged) {
      bottom: 15%;
      left: 50%;
      transform: translateX(-50%);
    }
    
    #video-wrapper:fullscreen #video-distance-overlay.minimized:not(.dragged) {
      bottom: 15%;
      left: 50%;
      transform: translateX(-50%);
      top: auto;
    }
    
    #video-wrapper:fullscreen #video-distance-overlay .fs-widget-header {
      margin: -12px -16px 8px -16px;
      padding: 4px 8px;
      font-size: 14px;
    }
    
    #video-minimap-overlay {
      display: none;
      position: relative;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay {
      display: block !important;
      position: absolute !important;
      width: 270px;
      height: 200px;
      min-width: 150px;
      min-height: 120px;
      max-width: 600px;
      max-height: 500px;
      background: rgba(0,0,0,0.7) !important;
      border-radius: 8px !important;
      padding: 8px !important;
      box-sizing: border-box !important;
      resize: both;
      overflow: hidden;
    }
    
    /* Resize handle indicator */
    #video-wrapper:fullscreen #video-minimap-overlay::after {
      content: '';
      position: absolute;
      right: 2px;
      bottom: 2px;
      width: 12px;
      height: 12px;
      background: linear-gradient(135deg, transparent 50%, rgba(255,255,255,0.3) 50%);
      border-radius: 0 0 6px 0;
      pointer-events: none;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay.single-boat {
      width: 180px;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay:not(.dragged) {
      bottom: 15%;
      left: 8px;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay.minimized:not(.dragged) {
      bottom: 15%;
      left: 8px;
      top: auto;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay .fs-widget-header {
      margin: -8px -8px 4px -8px;
      padding: 2px 6px;
      font-size: 14px;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay.minimized {
      width: auto !important;
      height: auto !important;
      min-width: auto !important;
      min-height: auto !important;
      resize: none !important;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay.minimized::after {
      display: none;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay.minimized .fs-widget-content {
      display: none !important;
      height: 0 !important;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay .fs-widget-content {
      height: calc(100% - 24px);
    }
    
    #video-wrapper:fullscreen #video-minimap-svg {
      flex: 1;
      height: 100% !important;
      min-width: 0;
    }
    
    #video-wrapper:fullscreen #video-time-display {
      display: none !important;
    }
    
    #video-wrapper:fullscreen #video-status-badge {
      display: none !important;
    }
    
    #video-wrapper:fullscreen #video-fps-selector-container.insv-controls {
      display: flex !important;
      bottom: 80px !important;
      left: 16px !important;
      font-size: 12px !important;
      padding: 6px 10px !important;
    }
    
    #video-wrapper:fullscreen #video-fps-sync {
      bottom: 110px !important;
      left: 16px !important;
      font-size: 12px !important;
      padding: 6px 10px !important;
    }
    
    #video-wrapper:fullscreen #video-fps-sync.perf-visible {
      display: flex !important;
    }
    
    #video-wrapper:fullscreen #video-performance-notification {
      bottom: 100px !important;
    }
    
    #video-wrapper:fullscreen #video-fullscreen-btn {
      font-size: 22px !important;
    }
    
    #video-wrapper:fullscreen .fs-overlay-btn {
      display: inline-block !important;
    }
    
    #video-wrapper:fullscreen #video-replay-controls {
      position: fixed !important;
      bottom: 0 !important;
      left: 0 !important;
      right: 0 !important;
      width: 100% !important;
      padding: 0;
      box-sizing: border-box;
      pointer-events: auto;
      background: #000;
      z-index: 100;
    }
    
    #video-wrapper:fullscreen #fullscreen-status-row {
      padding: 4px 16px;
      background: #000;
    }
    
    #video-wrapper:fullscreen #video-replay-controls .race-replay-container {
      background: #000 !important;
      border: none !important;
      border-radius: 0 !important;
      padding: 8px 16px !important;
    }
    
    #video-wrapper:fullscreen #video-replay-controls .playback-time {
      color: white !important;
    }
    
    #video-wrapper:fullscreen #video-replay-controls .btn-play {
      background: rgba(34,197,94,0.3);
      color: white;
      border: 1px solid rgba(34,197,94,0.5);
    }
    
    #video-wrapper:fullscreen #video-replay-controls .btn-play.playing {
      background: rgba(239,68,68,0.3);
      border-color: rgba(239,68,68,0.5);
    }
    
    #video-wrapper:fullscreen #video-replay-controls .speed-btn {
      background: transparent;
      color: rgba(255,255,255,0.7);
      border-color: rgba(255,255,255,0.3);
    }
    
    #video-wrapper:fullscreen #video-replay-controls .speed-btn.active {
      background: transparent;
      color: white;
      border-color: #22c55e;
    }
    
    #video-wrapper:fullscreen #video-replay-controls .timeline-wrapper {
      flex: 1;
      min-width: 150px;
    }
    
    #video-wrapper:fullscreen #video-replay-controls .playback-timeline {
      background: rgba(255,255,255,0.2);
    }
    
    #video-wrapper:fullscreen #video-replay-controls .video-coverage-bar {
      background: rgba(255,255,255,0.1);
    }
    
    #video-wrapper:fullscreen #video-replay-controls .video-coverage-segment {
      background: #3b82f6;
    }
    
    #video-wrapper:fullscreen #video-replay-controls .btn-exit-replay {
      display: none;
    }
    
    #video-wrapper:fullscreen #video-replay-controls .status-dot {
      display: block !important;
    }
    
    #video-wrapper:fullscreen #video-replay-controls .race-replay-title {
      display: none;
    }
    
    /* Responsive video section */
    #video-replay-section {
      max-width: 100%;
      overflow: hidden;
    }
    
    /* Map and content flex container - no wrap to keep side-by-side layout */
    #map-and-content-card > .flex {
      flex-wrap: nowrap;
      overflow: visible;
    }
    
    /* Make map and video sections shrink proportionally */
    #map-container {
      flex: 0 0 auto;
      width: 500px;
      min-width: 350px;
      position: relative;
      overflow: visible;
    }
    
    /* Map fullscreen mode - map left full height, controls right */
    #map-container.map-fullscreen {
      position: fixed !important;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100vw !important;
      height: 100vh !important;
      max-width: none !important;
      min-width: unset !important;
      z-index: 10000;
      background: #1f2937;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
      padding: 0;
    }
    
    /* Fullscreen header - not used in new layout, keep hidden */
    #map-fullscreen-header {
      display: none;
      height: 0;
      overflow: hidden;
    }
    
    #map-container.map-fullscreen #map-fullscreen-header {
      display: none;
    }
    
    /* Main content area - map on left, wider panel on right */
    #map-fullscreen-content {
      position: relative;
    }
    
    #map-container.map-fullscreen #map-fullscreen-content {
      display: flex;
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }
    
    /* Map wrapper - fits map content, no extra black space */
    #fs-map-wrapper {
      position: relative;
      display: inline-block;
      line-height: 0;
    }
    
    #map-container.map-fullscreen #fs-map-wrapper {
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: normal;
      height: 100%;
      position: relative;
      padding: 16px;
      box-sizing: border-box;
      background: #1f2937;
      flex-shrink: 0;
      overflow: visible;
    }
    
    #map-container.map-fullscreen #map {
      background: white;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }
    
    /* Telemetry overlay on fullscreen map - fs-widget style */
    #fs-map-telemetry-overlay {
      display: none;
    }
    
    #map-container.map-fullscreen #fs-map-telemetry-overlay {
      display: block;
      position: absolute;
      bottom: 60px;
      left: 16px;
      background: rgba(0, 0, 0, 0.75);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-family: monospace;
      font-size: 13px;
      z-index: 50;
      min-width: 160px;
      cursor: move;
    }
    
    #fs-map-telemetry-overlay.hidden {
      display: none !important;
    }
    
    #fs-map-telemetry-overlay .fs-widget-header {
      font-weight: bold;
      margin-bottom: 6px;
      border-bottom: 1px solid rgba(255,255,255,0.3);
      padding-bottom: 4px;
      cursor: move;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    #fs-map-telemetry-overlay .fs-minimize-btn {
      cursor: pointer;
      opacity: 0.7;
      font-size: 10px;
    }
    
    #fs-map-telemetry-overlay .fs-minimize-btn:hover {
      opacity: 1;
    }
    
    #fs-map-telemetry-overlay .fs-widget-content {
      text-align: right;
      line-height: 1.5;
    }
    
    #fs-map-telemetry-overlay.minimized .fs-widget-content {
      display: none;
    }
    
    /* Leg overlay on fullscreen map */
    #fs-map-leg-overlay {
      display: none;
    }
    
    #map-container.map-fullscreen #fs-map-leg-overlay {
      display: block;
      position: absolute;
      bottom: 60px;
      left: 200px;
      background: rgba(0, 0, 0, 0.75);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-family: monospace;
      font-size: 13px;
      z-index: 50;
      min-width: 140px;
      cursor: move;
    }
    
    #fs-map-leg-overlay.hidden {
      display: none !important;
    }
    
    #fs-map-leg-overlay .fs-widget-header {
      font-weight: bold;
      margin-bottom: 6px;
      border-bottom: 1px solid rgba(255,255,255,0.3);
      padding-bottom: 4px;
      cursor: move;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    #fs-map-leg-overlay .fs-minimize-btn {
      cursor: pointer;
      opacity: 0.7;
      font-size: 10px;
    }
    
    #fs-map-leg-overlay .fs-minimize-btn:hover {
      opacity: 1;
    }
    
    #fs-map-leg-overlay .fs-widget-content {
      text-align: right;
      line-height: 1.5;
    }
    
    #fs-map-leg-overlay.minimized .fs-widget-content {
      display: none;
    }
    
    /* Resize handle for widgets */
    .fs-resize-handle {
      position: absolute;
      bottom: 0;
      right: 0;
      width: 12px;
      height: 12px;
      cursor: se-resize;
      background: linear-gradient(135deg, transparent 50%, rgba(255,255,255,0.3) 50%);
    }
    
    /* Right panel for timeline + leg details in fullscreen */
    #fs-details-panel {
      display: none;
    }
    
    #map-container.map-fullscreen #fs-details-panel {
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
      flex: 1;
      min-width: 400px;
      max-width: 600px;
      padding: 16px;
      background: #f3f4f6;
      border-left: 1px solid #e5e7eb;
      height: 100%;
      box-sizing: border-box;
    }
    
    #fs-details-panel .card {
      background: white !important;
      border: 1px solid #e5e7eb !important;
      margin-bottom: 0 !important;
    }
    
    /* Timeline styling in right panel - light theme */
    #fs-details-panel .timeline-track {
      background: #f9fafb !important;
      border: 1px solid #e5e7eb !important;
    }
    
    #fs-details-panel .timeline-track.active {
      background: #ede9fe !important;
      border: 1px solid #a78bfa !important;
    }
    
    /* Fix text colors in fullscreen panel to black - but preserve badges */
    #fs-details-panel {
      color: #1f2937;
    }
    
    #fs-details-panel .card {
      color: #1f2937 !important;
    }
    
    /* Preserve badge styling completely */
    #fs-details-panel .badge-up { 
      background: #dcfce7 !important; 
      color: #166534 !important; 
    }
    #fs-details-panel .badge-down { 
      background: #fef3c7 !important; 
      color: #92400e !important; 
    }
    #fs-details-panel .badge-reach { 
      background: #dbeafe !important; 
      color: #1e40af !important; 
    }
    
    /* Fullscreen footer - not used */
    #map-fullscreen-footer {
      display: none !important;
      height: 0;
      overflow: hidden;
    }
    
    /* Overlays positioning in fullscreen - relative to map wrapper */
    #map-container.map-fullscreen #map-legend {
      position: absolute !important;
      top: 16px !important;
      left: 16px !important;
      font-size: 12px !important;
      padding: 10px 14px !important;
      background: rgba(255, 255, 255, 0.95) !important;
      border-radius: 8px !important;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15) !important;
    }
    
    #map-container.map-fullscreen #map-wind {
      position: absolute !important;
      top: 16px !important;
      right: 16px !important;
      left: auto !important;
      font-size: 11px !important;
      padding: 8px 12px !important;
      background: rgba(255, 255, 255, 0.95) !important;
      border-radius: 8px !important;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15) !important;
    }
    
    #map-container.map-fullscreen .zoom-btn {
      width: 40px !important;
      height: 40px !important;
      font-size: 18px !important;
      background: rgba(255, 255, 255, 0.95) !important;
      border-radius: 8px !important;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15) !important;
      border: none !important;
    }
    
    #map-container.map-fullscreen .zoom-btn:hover {
      background: white !important;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2) !important;
    }
    
    #map-container.map-fullscreen #map-zoom-indicator {
      position: absolute !important;
      font-size: 11px !important;
      bottom: 100px !important;
      right: 16px !important;
      color: #9ca3af !important;
      background: rgba(31, 41, 55, 0.9) !important;
      padding: 4px 10px !important;
      border-radius: 6px !important;
    }
    
    /* Zoom buttons container in fullscreen */
    #map-container.map-fullscreen #fs-map-wrapper > div[style*="bottom: 10px"][style*="right: 10px"] {
      position: absolute !important;
      bottom: 16px !important;
      right: 16px !important;
    }
    
    /* Projection toggle in fullscreen */
    #map-container.map-fullscreen #fs-map-wrapper > div[style*="bottom: 45px"][style*="left: 10px"]:not(#hide-gray-toggle-container) {
      position: absolute !important;
      bottom: 16px !important;
      left: 16px !important;
      font-size: 11px !important;
      padding: 6px 10px !important;
      background: rgba(255, 255, 255, 0.95) !important;
      border-radius: 6px !important;
    }
    
    /* Hide gray toggle in fullscreen */
    #map-container.map-fullscreen #hide-gray-toggle-container {
      position: absolute !important;
      bottom: 56px !important;
      left: 16px !important;
      font-size: 11px !important;
      padding: 6px 10px !important;
      background: rgba(255, 255, 255, 0.95) !important;
      border-radius: 6px !important;
    }
    
    /* Instructions text in fullscreen - hide */
    #map-container.map-fullscreen #fs-map-wrapper > div[style*="bottom: 10px"][style*="left: 10px"]:not([style*="right"]):not(#hide-gray-toggle-container) {
      display: none !important;
    }
    
    /* Close button on map - hide (use dedicated button in right panel) */
    #map-fullscreen-close {
      display: none !important;
    }
    
    /* Keep close button hidden in fullscreen - use right panel button instead */
    #map-container.map-fullscreen #map-fullscreen-close {
      display: none !important;
    }
    
    #race-replay-right-column {
      flex: 1 1 auto;
      min-width: 300px;
    }
    
    .container { max-width: 1400px; margin: 0 auto; }
    .card { background: white; border-radius: 12px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); padding: 16px; margin-bottom: 16px; }
    h1 { font-size: 1.5rem; color: #1f2937; }
    h3 { font-size: 1.1rem; color: #374151; margin-bottom: 8px; }
    .subtitle { color: #6b7280; font-size: 0.875rem; }
    .flex { display: flex; gap: 16px; flex-wrap: wrap; }
    .flex-1 { flex: 1; min-width: 200px; }
    .grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; }
    .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
    .grid-6 { display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; }
    .stat-box { background: #f9fafb; border-radius: 8px; padding: 12px; border-left: 4px solid #3b82f6; }
    .stat-label { font-size: 0.7rem; color: #6b7280; text-transform: uppercase; }
    .stat-value { font-size: 1.25rem; font-weight: bold; }
    .stat-sub { font-size: 0.75rem; color: #9ca3af; }
    .tabs { display: flex; gap: 8px; margin-bottom: 16px; }
    .tab { padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 500; background: white; color: #4b5563; border: none; transition: all 0.2s; }
    .tab.active { background: #3b82f6; color: white; box-shadow: 0 2px 4px rgba(59,130,246,0.3); }
    .tab:hover:not(.active) { background: #f3f4f6; }
    table { width: 100%; border-collapse: collapse; font-size: 0.875rem; }
    th, td { padding: 8px 12px; text-align: left; border-bottom: 1px solid #e5e7eb; }
    th { background: #f9fafb; font-weight: 600; position: sticky; top: 0; }
    
    /* Sailing legs table column widths */
    #legs-table th:first-child, #legs-table td:first-child,
    #legs-table-side th:first-child, #legs-table-side td:first-child {
      width: 28px;
      min-width: 28px;
      max-width: 28px;
      text-align: center;
      padding-left: 8px;
      padding-right: 4px;
    }
    #legs-table th:nth-child(2), #legs-table td:nth-child(2),
    #legs-table-side th:nth-child(2), #legs-table-side td:nth-child(2) {
      width: 36px;
      min-width: 36px;
      max-width: 36px;
      text-align: left;
      padding-left: 4px;
      padding-right: 8px;
    }
    
    /* Limit legs table to ~8 rows with scroll - only for multi-session/side view */
    /* In single-view legs mode, this matches map height (500px - header ~60px = 440px) */
    #legs-scroll-container-side {
      max-height: 440px;
      overflow-y: auto;
      overflow-x: hidden;
    }
    tr:hover { background: #f3f4f6; }
    tr.selected { background: #ede9fe; }
    tr { cursor: pointer; }
    .badge { display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; font-weight: 600; }
    .badge-up { background: #dcfce7; color: #166534; }
    .badge-reach { background: #dbeafe; color: #1e40af; }
    .badge-down { background: #fef3c7; color: #92400e; }
    .badge-tack { background: #d1fae5; color: #065f46; }
    .badge-gybe { background: #fef3c7; color: #92400e; }
    .chart-container { height: 160px; position: relative; }
    .legend { display: flex; gap: 12px; font-size: 0.75rem; margin-bottom: 8px; flex-wrap: wrap; }
    .legend-item { display: flex; align-items: center; gap: 4px; }
    .legend-dot { width: 8px; height: 8px; border-radius: 50%; }
    
    /* Wizard/Onboarding Styles */
    .wizard-container { margin-bottom: 32px; }
    .wizard-header { text-align: center; margin-bottom: 24px; }
    .wizard-header h1 { font-size: 2rem; color: #1e3a5f; margin-bottom: 8px; display: flex; align-items: center; justify-content: center; gap: 12px; }
    .wizard-header p { color: #6b7280; font-size: 1.1rem; }
    .wizard-steps { display: flex; justify-content: center; gap: 0; margin-bottom: 32px; position: relative; }
    .wizard-step { display: flex; flex-direction: column; align-items: center; flex: 1; max-width: 220px; position: relative; z-index: 1; }
    .wizard-step-icon { 
      width: 72px; height: 72px; border-radius: 50%; 
      display: flex; align-items: center; justify-content: center; 
      font-size: 32px; margin-bottom: 12px;
      transition: all 0.3s ease;
      position: relative;
    }
    .wizard-step.step-1 .wizard-step-icon { background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%); border: 3px solid #3b82f6; }
    .wizard-step.step-2 .wizard-step-icon { background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border: 3px solid #f59e0b; }
    .wizard-step.step-3 .wizard-step-icon { background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%); border: 3px solid #10b981; }
    .wizard-step.active .wizard-step-icon { transform: scale(1.1); box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3); }
    .wizard-step.completed .wizard-step-icon::after {
      content: '‚úì'; position: absolute; top: -4px; right: -4px;
      width: 24px; height: 24px; background: #10b981; border-radius: 50%;
      color: white; font-size: 14px; display: flex; align-items: center; justify-content: center;
      border: 2px solid white;
    }
    .wizard-step-number { 
      position: absolute; top: -8px; left: -8px;
      width: 28px; height: 28px; background: #374151; border-radius: 50%;
      color: white; font-size: 14px; font-weight: 600;
      display: flex; align-items: center; justify-content: center;
      border: 2px solid white;
    }
    .wizard-step.active .wizard-step-number { background: #3b82f6; }
    .wizard-step.completed .wizard-step-number { background: #10b981; }
    .wizard-step-title { font-weight: 600; color: #1f2937; margin-bottom: 4px; font-size: 1rem; }
    .wizard-step-desc { color: #6b7280; font-size: 0.85rem; text-align: center; line-height: 1.4; }
    .wizard-connector { 
      position: absolute; top: 36px; left: calc(50% + 36px); 
      width: calc(100% - 72px); height: 3px; 
      background: #e5e7eb; z-index: 0;
    }
    .wizard-step:last-child .wizard-connector { display: none; }
    .wizard-connector-progress { height: 100%; background: #10b981; width: 0%; transition: width 0.5s ease; }
    .wizard-step.completed .wizard-connector .wizard-connector-progress { width: 100%; }
    
    .upload-zone { border: 2px dashed #d1d5db; border-radius: 12px; padding: 40px; text-align: center; cursor: pointer; transition: all 0.2s; }
    .upload-zone:hover { border-color: #3b82f6; background: #eff6ff; }
    .upload-zone.dragover { border-color: #3b82f6; background: #dbeafe; }
    .upload-icon { font-size: 3rem; color: #9ca3af; margin-bottom: 8px; }
    .btn { padding: 8px 16px; border-radius: 8px; border: none; cursor: pointer; font-weight: 500; transition: all 0.2s; }
    .btn-primary { background: #3b82f6; color: white; }
    .btn-primary:hover { background: #2563eb; }
    .btn-sm { padding: 4px 8px; font-size: 0.75rem; }
    .text-green { color: #16a34a; }
    .text-blue { color: #2563eb; }
    .text-amber { color: #d97706; }
    .text-red { color: #dc2626; }
    .text-purple { color: #7c3aed; }
    .text-xs { font-size: 0.75rem; }
    .text-sm { font-size: 0.875rem; }
    .mt-2 { margin-top: 8px; }
    .mt-4 { margin-top: 16px; }
    .mb-2 { margin-bottom: 8px; }
    .hidden { display: none; }
    .scroll-table { max-height: 500px; overflow-y: auto; overflow-x: hidden; border: 1px solid #e5e7eb; border-radius: 8px; }
    
    /* Main legs table - match map height (500px) minus header (~60px) */
    #legs-scroll-container {
      height: 440px;
      max-height: 440px;
      overflow-x: hidden;
    }
    .detail-box { background: #faf5ff; border: 1px solid #e9d5ff; border-radius: 8px; padding: 12px; }
    .detail-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .detail-title { font-weight: 600; color: #7c3aed; }
    .maneuver-banner { padding: 8px; border-radius: 6px; text-align: center; font-weight: 500; margin-top: 8px; }
    .maneuver-tack { background: #d1fae5; color: #065f46; }
    .maneuver-gybe { background: #fef3c7; color: #92400e; }
    #map { border: 1px solid #e5e7eb; border-radius: 8px; background: #eff6ff; display: block; max-width: 100%; margin: 0; padding: 0; vertical-align: top; line-height: 0; }
    .pos-breakdown { background: #f9fafb; border-radius: 8px; padding: 16px; }
    .pos-title { font-weight: 600; margin-bottom: 8px; }
    .pos-stat { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #e5e7eb; }
    .pos-stat:last-child { border-bottom: none; }
    .filter-row { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
    select { padding: 6px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 0.875rem; }
    .clear-btn { background: #faf5ff; color: #7c3aed; padding: 4px 12px; border-radius: 9999px; font-size: 0.875rem; display: flex; align-items: center; gap: 4px; cursor: pointer; border: none; }
    .loading { text-align: center; padding: 40px; }
    .spinner { width: 40px; height: 40px; border: 3px solid #e5e7eb; border-top-color: #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 16px; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .scatter-dot { cursor: pointer; transition: all 0.15s; }
    .scatter-dot:hover { transform: scale(1.3); }
    .zoom-btn { width: 28px; height: 28px; border: 1px solid #d1d5db; border-radius: 4px; background: white; cursor: pointer; font-size: 16px; font-weight: bold; color: #4b5563; display: flex; align-items: center; justify-content: center; }
    .zoom-btn:hover { background: #f3f4f6; }
    #map { cursor: grab; }
    #map:active { cursor: grabbing; }
    .timeline-handle:hover { fill: #6d28d9; }
    .timeline-milestone:hover { transform: scale(1.2); transform-origin: center; }
    .timeline-range:hover { cursor: grab; }
    .timeline-range:active { cursor: grabbing; }
    .timeline-track { background: #f3f4f6; border-radius: 8px; padding: 8px 12px; margin-bottom: 8px; transition: all 0.2s; }
    .timeline-track.active { background: #faf5ff; border: 1px solid #e9d5ff; }
    .timeline-track.inactive { opacity: 0.6; }
    .timeline-track.inactive:hover { opacity: 0.8; }
    .timeline-track.draggable { cursor: grab; }
    .timeline-track.draggable:active { cursor: grabbing; }
    .timeline-track.dragging { opacity: 0.5; background: #e0e7ff; }
    .timeline-track.drag-over { border: 2px dashed #7c3aed !important; background: #faf5ff !important; }
    .timeline-track .drag-handle { cursor: grab; padding: 2px 6px; color: #6b7280; font-size: 16px; font-weight: bold; background: #e5e7eb; border-radius: 3px; user-select: none; }
    .timeline-track .drag-handle:hover { color: #374151; background: #d1d5db; }
    .timeline-track .drag-handle:active { cursor: grabbing; }
    #timeline-content.collapsed { display: none; }
    #timeline-fold-icon.collapsed { transform: rotate(-90deg); }
    
    /* Race Replay Mode */
    .race-replay-container { background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 8px; padding: 8px 12px; }
    .race-replay-header { display: flex; align-items: center; gap: 8px; }
    .race-replay-title { font-size: 0.85rem; font-weight: 600; color: #166534; display: flex; align-items: center; gap: 4px; white-space: nowrap; }
    .btn-exit-replay { background: #f3f4f6; color: #374151; border: 1px solid #d1d5db; padding: 2px 8px; font-size: 11px; }
    .btn-exit-replay:hover { background: #e5e7eb; }
    .playback-row { display: flex; align-items: center; gap: 8px; flex-wrap: nowrap; }
    .timeline-wrapper { flex: 1; min-width: 150px; display: flex; flex-direction: column; gap: 2px; }
    .video-coverage-bar { height: 4px; background: #e5e7eb; border-radius: 2px; position: relative; overflow: hidden; cursor: pointer; }
    .video-coverage-segment { position: absolute; height: 100%; background: #3b82f6; opacity: 0.7; }
    .playback-timeline { width: 100%; height: 8px; background: #e5e7eb; border-radius: 4px; cursor: pointer; position: relative; }
    .playback-progress { height: 100%; background: #22c55e; border-radius: 4px; pointer-events: none; }
    .playback-handle { position: absolute; top: 50%; width: 14px; height: 14px; background: #22c55e; border: 2px solid white; border-radius: 50%; transform: translate(-50%, -50%); cursor: grab; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    .playback-handle:hover { background: #16a34a; }
    .btn-play { min-width: 70px; background: #22c55e; color: white; font-size: 0.8rem; padding: 4px 8px; }
    .btn-play:hover { background: #16a34a; }
    .btn-play.playing { background: #ef4444; }
    .btn-play.playing:hover { background: #dc2626; }
    .speed-btn { padding: 2px 6px; border: 1px solid #d1d5db; border-radius: 4px; background: white; cursor: pointer; font-size: 11px; }
    .speed-btn:hover { background: #f3f4f6; }
    .speed-btn.active { background: #22c55e; color: white; border-color: #22c55e; }
    .playback-time { font-size: 11px; color: #374151; min-width: 80px; text-align: center; font-family: monospace; font-weight: 500; }
    .boat-info-panel { background: white; border-radius: 8px; padding: 12px; border: 1px solid #e5e7eb; }
    .boat-info-row { display: flex; align-items: center; gap: 10px; padding: 8px 0; border-bottom: 1px solid #f3f4f6; }
    .boat-info-row:last-child { border-bottom: none; }
    .boat-marker { width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 12px; }
    .boat-name { font-weight: 500; min-width: 100px; }
    .boat-stats { display: flex; gap: 12px; font-size: 12px; color: #6b7280; }
    .boat-stat { display: flex; flex-direction: column; align-items: center; }
    .boat-stat-value { font-weight: 600; color: #374151; font-size: 14px; }
    .boat-stat-label { font-size: 10px; text-transform: uppercase; }
    .current-leg-panel { background: white; border-radius: 8px; padding: 12px; border: 1px solid #e5e7eb; margin-top: 12px; }
    .current-leg-header { font-weight: 600; color: #374151; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
    .session-select-row { display: flex; align-items: center; gap: 8px; padding: 4px 0; }
    .session-select-row input[type="checkbox"] { width: 16px; height: 16px; cursor: pointer; }
    .btn-start-replay { background: #22c55e; color: white; padding: 8px 16px; }
    .btn-start-replay:hover { background: #16a34a; }
    .btn-start-replay:disabled { background: #9ca3af; cursor: not-allowed; }
    
    /* Mobile-specific styles */
    @media (max-width: 768px) {
      .container { padding: 8px; }
      .card { padding: 12px; margin-bottom: 12px; }
      
      /* Larger touch targets for buttons */
      button, .speed-btn, .btn { min-height: 44px; min-width: 44px; }
      .speed-btn { padding: 8px 12px; font-size: 14px; }
      
      /* Upload zone improvements */
      .upload-zone { padding: 24px 16px; }
      .upload-icon { font-size: 36px; }
      
      /* Wizard mobile adjustments */
      .wizard-header h1 { font-size: 1.4rem; }
      .wizard-header p { font-size: 0.9rem; }
      .wizard-steps { flex-direction: column; gap: 16px; align-items: center; }
      .wizard-step { max-width: 100%; flex-direction: row; gap: 12px; }
      .wizard-step-icon { width: 56px; height: 56px; font-size: 24px; flex-shrink: 0; }
      .wizard-step-number { width: 22px; height: 22px; font-size: 12px; top: -4px; left: -4px; }
      .wizard-connector { display: none; }
      .wizard-step-title { font-size: 0.9rem; }
      .wizard-step-desc { font-size: 0.75rem; text-align: left; }
      #features-grid { grid-template-columns: 1fr; gap: 8px; }
      #features-grid > div { padding: 12px; }
      
      /* Playback controls for mobile */
      .playback-controls { gap: 6px; padding: 8px; flex-wrap: wrap; }
      .playback-handle { width: 20px; height: 20px; }
      .playback-timeline { height: 12px; }
      
      /* Video panel adjustments */
      #video-panel { min-height: 200px; }
      
      /* Better spacing for checkboxes */
      .session-select-row input[type="checkbox"] { width: 24px; height: 24px; }
      
      /* Tab navigation */
      .tabs { flex-wrap: wrap; gap: 4px; }
      .tab { padding: 8px 12px; font-size: 12px; }
      
      /* Hide folder picker buttons on mobile - webkitdirectory not supported */
      .folder-picker-btn { display: none !important; }
      
      /* CRITICAL: Make map/video layout stack vertically on mobile */
      #map-and-content-card > .flex {
        flex-wrap: wrap !important;
        flex-direction: column !important;
      }
      
      #map-container {
        width: 100% !important;
        max-width: 100% !important;
        min-width: 0 !important;
        flex: 0 0 auto !important;
      }
      
      #map-container svg {
        width: 100% !important;
        height: auto !important;
        max-height: 350px;
      }
      
      #race-replay-right-column {
        min-width: 0 !important;
        width: 100% !important;
        max-width: 100% !important;
      }
      
      #stats-panel {
        width: 100% !important;
        min-width: 0 !important;
      }
      
      #video-replay-section {
        width: 100% !important;
      }
      
      /* Grid adjustments for mobile */
      .grid-2, .grid-3, .grid-6 {
        grid-template-columns: repeat(2, 1fr) !important;
      }
    }
    
    /* Fullscreen mobile adjustments */
    @media (max-width: 768px) {
      #video-wrapper:fullscreen .fs-widget {
        font-size: 14px !important;
      }
      
      #video-wrapper:fullscreen #video-telemetry-overlay .fs-widget-content,
      #video-wrapper:fullscreen #video-leg-overlay .fs-widget-content {
        font-size: 20px !important;
      }
      
      #video-wrapper:fullscreen #video-distance-overlay .fs-widget-content {
        font-size: 12px !important;
        line-height: 1.4 !important;
      }
      
      #video-wrapper:fullscreen #video-minimap-overlay {
        width: 200px;
        height: 150px;
      }
      
      #video-wrapper:fullscreen #minimap-leg2-telemetry {
        font-size: 11px !important;
        min-width: 60px;
        max-width: 80px;
      }
      
      #video-wrapper:fullscreen #video-replay-controls {
        padding: 8px !important;
      }
      
      #video-wrapper:fullscreen .speed-btn {
        padding: 6px 10px;
        font-size: 12px;
      }
      
      #video-wrapper:fullscreen .fs-overlay-btn {
        min-height: 36px;
        min-width: 36px;
        font-size: 14px !important;
      }
    }
    
    /* Prevent text selection during drag on touch devices */
    .fs-widget-header {
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }
    
    /* Improve touch scrolling in panels */
    .analysis-panel, .tabs-content {
      -webkit-overflow-scrolling: touch;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Upload Section -->
    <div id="upload-section" class="card">
      <!-- Wizard Header & Steps -->
      <div class="wizard-container">
        <div class="wizard-header">
          <h1>‚õµ Sailing Performance Analyzer</h1>
          <p>Analyze your sailing telemetry with synchronized 360¬∞ video playback</p>
        </div>
        
        <div class="wizard-steps">
          <!-- Step 1: Upload Track -->
          <div class="wizard-step step-1 active" id="wizard-step-1">
            <div class="wizard-step-icon">
              <span class="wizard-step-number">1</span>
              üìä
            </div>
            <div class="wizard-step-title">Upload Track</div>
            <div class="wizard-step-desc">Import your GPS telemetry data (VKX, FIT, GPX)</div>
            <div class="wizard-connector"><div class="wizard-connector-progress"></div></div>
          </div>
          
          <!-- Step 2: Upload Video -->
          <div class="wizard-step step-2" id="wizard-step-2">
            <div class="wizard-step-icon">
              <span class="wizard-step-number">2</span>
              üé¨
            </div>
            <div class="wizard-step-title">Add 360¬∞ Video</div>
            <div class="wizard-step-desc">Sync your Insta360 footage with telemetry</div>
            <div class="wizard-connector"><div class="wizard-connector-progress"></div></div>
          </div>
          
          <!-- Step 3: Analyze -->
          <div class="wizard-step step-3" id="wizard-step-3">
            <div class="wizard-step-icon">
              <span class="wizard-step-number">3</span>
              üèÜ
            </div>
            <div class="wizard-step-title">Review & Analyze</div>
            <div class="wizard-step-desc">Watch video with live telemetry overlay</div>
          </div>
        </div>
      </div>
      
      <!-- Upload Zone -->
      <div id="upload-zone" class="upload-zone">
        <div class="upload-icon">üìÅ</div>
        <p style="font-size: 1.1rem; color: #374151; margin-bottom: 8px;">Drop your sailing data files here or click to browse</p>
        <p class="text-sm" style="color: #6b7280;">Supports Vakaros VKX, CSV, Garmin FIT, and GPX files ‚Ä¢ .vkx, .csv, .fit, .gpx, .gz</p>
        <input type="file" id="file-input" multiple style="display: none;">
      </div>
      
      <!-- Features highlight -->
      <div id="features-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-top: 24px; padding-top: 24px; border-top: 1px solid #e5e7eb;">
        <div style="text-align: center; padding: 16px;">
          <div style="font-size: 24px; margin-bottom: 8px;">üó∫Ô∏è</div>
          <div style="font-weight: 600; color: #374151; margin-bottom: 4px;">GPS Track Analysis</div>
          <div style="font-size: 0.8rem; color: #6b7280;">Interactive map with leg detection and course deviation metrics</div>
        </div>
        <div style="text-align: center; padding: 16px;">
          <div style="font-size: 24px; margin-bottom: 8px;">üìà</div>
          <div style="font-weight: 600; color: #374151; margin-bottom: 4px;">Performance Metrics</div>
          <div style="font-size: 0.8rem; color: #6b7280;">VMG, steering rate, point of sail breakdown, wind analysis</div>
        </div>
        <div style="text-align: center; padding: 16px;">
          <div style="font-size: 24px; margin-bottom: 8px;">üé•</div>
          <div style="font-weight: 600; color: #374151; margin-bottom: 4px;">360¬∞ Video Sync</div>
          <div style="font-size: 0.8rem; color: #6b7280;">INSV & MP4 playback with real-time telemetry overlay</div>
        </div>
      </div>
      
      <div id="loading" class="loading hidden">
        <div class="spinner"></div>
        <p>Processing telemetry data...</p>
      </div>
    </div>

    <!-- Dashboard Section (hidden until file loaded) -->
    <div id="dashboard" class="hidden">
      <!-- Header -->
      <div class="card">
        <div class="flex" style="justify-content: space-between; align-items: center;">
          <div>
            <h1 id="session-title">Steering Analysis</h1>
            <p class="subtitle" id="session-subtitle"></p>
          </div>
          <div class="filter-row">
            <button class="btn btn-sm" id="add-files-btn" onclick="resetDashboard()">Add More Files</button>
            <button class="btn btn-sm hidden" id="back-to-sessions-header-btn" onclick="exitRaceReplay()" style="background:#f3f4f6;color:#374151;border:1px solid #d1d5db;">‚Üê Back to Sessions</button>
          </div>
        </div>
      </div>

      <!-- Multi-file Comparison (hidden if single file) -->
      <div id="comparison-section" class="card hidden"></div>

      <!-- Timeline Selection (Foldable) -->
      <div id="timeline-section" class="card">
        <div style="display:flex;justify-content:space-between;align-items:center;cursor:pointer;" onclick="toggleTimelineSection()">
          <div style="display:flex;align-items:center;gap:8px;">
            <span id="timeline-fold-icon" style="font-size:12px;transition:transform 0.2s;">‚ñº</span>
            <h3 style="margin:0;">Timeline Selection</h3>
            <span class="text-xs" style="color:#6b7280;" id="timeline-summary"></span>
          </div>
          <div style="display:flex;gap:8px;align-items:center;" onclick="event.stopPropagation();">
            <label class="text-xs" style="display:flex;align-items:center;gap:4px;color:#6b7280;cursor:pointer;">
              <input type="checkbox" id="auto-trim-checkbox" checked onchange="toggleAutoTrim()" style="cursor:pointer;">
              Auto-trim
            </label>
            <button class="btn btn-sm" onclick="resetAllTimelines()" id="reset-all-btn" style="display:none;">Reset All</button>
          </div>
        </div>
        <div id="timeline-content" style="margin-top:12px;">
          <p class="text-xs" style="color:#6b7280;margin-bottom:8px;">Drag handles to select analysis range. Click milestones to snap. Auto-trim removes marina transit legs.</p>
          <div id="all-timelines-container"></div>
        </div>
      </div>

      <!-- View Configuration Card -->
      <div id="view-config-section" class="card" style="padding: 12px 16px;">
        <div style="display:flex;flex-wrap:wrap;align-items:center;gap:12px;">
          <div id="view-mode-toggle-config" style="display:flex;align-items:center;gap:6px;">
            <span style="font-size:11px;color:#6b7280;">View:</span>
            <button id="view-mode-legs-config" class="btn btn-sm" onclick="setViewMode('legs')" style="background:#3b82f6;color:white;padding:4px 8px;">Legs</button>
            <button id="view-mode-stats-config" class="btn btn-sm" onclick="setViewMode('stats')" style="background:#f3f4f6;color:#374151;padding:4px 8px;">Stats</button>
          </div>
          <div id="selected-leg-badge-config" class="hidden">
            <button class="clear-btn" onclick="clearSelection()">
              <span id="selected-leg-text-config">Leg #1</span>
              <span style="font-weight: bold;">√ó</span>
            </button>
          </div>
          <select id="pos-filter-config" onchange="applyFilterConfig()" style="padding:4px 8px;border:1px solid #d1d5db;border-radius:6px;font-size:12px;">
            <option value="all">All Points of Sail</option>
            <option value="upwind">Upwind Only</option>
            <option value="reaching">Reaching Only</option>
            <option value="downwind">Downwind Only</option>
          </select>
          <label id="multi-session-toggle-config" class="text-xs hidden" style="display:flex;align-items:center;gap:4px;color:#6b7280;cursor:pointer;padding:4px 8px;border:1px solid #d1d5db;border-radius:6px;background:white;" title="Show data from all sessions for comparison">
            <input type="checkbox" id="multi-session-view-checkbox-config" onchange="toggleMultiSessionViewConfig()" style="cursor:pointer;">
            Multi-session view
          </label>
          <button class="btn btn-sm hidden" id="start-race-replay-btn-config" onclick="startRaceReplayFromConfig()" style="background:#22c55e;color:white;padding:4px 12px;">üèÅ Start Race Replay</button>
        </div>
      </div>

      <!-- Map and Stats/Race Replay wrapper -->
      <div class="card" id="map-and-content-card">
        <div class="flex">
          <!-- Map container (always visible, on left) -->
          <div id="map-container">
            <!-- Fullscreen header - timeline with legs -->
            <div id="map-fullscreen-header">
              <!-- Content cloned from all-timelines-container when entering fullscreen -->
            </div>
            
            <!-- Main content area -->
            <div id="map-fullscreen-content">
              <!-- Map wrapper for fullscreen positioning -->
              <div id="fs-map-wrapper">
                <!-- Close button (only visible in fullscreen) -->
                <button id="map-fullscreen-close" onclick="toggleMapFullscreen()" title="Exit Fullscreen (Esc)">√ó</button>
                <svg id="map" width="500" height="500"></svg>
                <!-- Legend overlay (fixed position, not affected by zoom) -->
                <div id="map-legend" style="position: absolute; top: 8px; left: 8px; font-size: 11px; pointer-events: auto; background: rgba(255,255,255,0.9); padding: 8px 12px; border-radius: 6px;"></div>
                <!-- Wind indicator overlay (fixed position) -->
                <div id="map-wind" style="position: absolute; top: 8px; right: 8px; text-align: center; pointer-events: none; background: rgba(255,255,255,0.85); padding: 4px; border-radius: 4px;"></div>
                <!-- Projection toggle -->
                <div style="position: absolute; bottom: 45px; left: 10px; font-size: 8px; display: flex; align-items: center; gap: 4px; background: rgba(255,255,255,0.85); padding: 3px 6px; border-radius: 4px;">
                  <span id="proj-label" style="color: #666;" title="Compass: angles as sailed. Geo: true geography">Compass</span>
                  <label style="position: relative; display: inline-block; width: 28px; height: 14px; cursor: pointer;">
                    <input type="checkbox" id="proj-toggle" onchange="toggleProjection()" style="opacity: 0; width: 0; height: 0;">
                    <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; border-radius: 14px; transition: .2s;"></span>
                    <span id="proj-slider" style="position: absolute; height: 10px; width: 10px; left: 2px; bottom: 2px; background-color: white; border-radius: 50%; transition: .2s; box-shadow: 0 1px 3px rgba(0,0,0,0.3);"></span>
                  </label>
                </div>
                <!-- Hide gray toggle (only visible in race replay mode) -->
                <div id="hide-gray-toggle-container" style="position: absolute; bottom: 65px; left: 10px; font-size: 8px; display: none; align-items: center; gap: 4px; background: rgba(255,255,255,0.85); padding: 3px 6px; border-radius: 4px;">
                  <span id="hide-gray-label" style="color: #666;" title="Hide past and future track portions">Hide gray</span>
                  <label style="position: relative; display: inline-block; width: 28px; height: 14px; cursor: pointer;">
                    <input type="checkbox" id="hide-gray-tracks-map" onchange="toggleHideGrayTracksMap()" style="opacity: 0; width: 0; height: 0;">
                    <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; border-radius: 14px; transition: .2s;"></span>
                    <span id="hide-gray-slider" style="position: absolute; height: 10px; width: 10px; left: 2px; bottom: 2px; background-color: white; border-radius: 50%; transition: .2s; box-shadow: 0 1px 3px rgba(0,0,0,0.3);"></span>
                  </label>
                  <button onclick="openTrackFadeConfigDialog()" style="background: none; border: none; cursor: pointer; padding: 0; font-size: 10px; color: #666;" title="Configure fade timing">‚öôÔ∏è</button>
                </div>
                <!-- Telemetry overlay (only visible in fullscreen mode when enabled) - fs-widget style -->
                <div id="fs-map-telemetry-overlay" class="fs-widget hidden">
                  <div class="fs-widget-header" onmousedown="startDragFsMapTelemetry(event)">
                    Telemetry <span class="fs-minimize-btn" onclick="toggleFsMapTelemetryMinimize(event)">‚ñº</span>
                  </div>
                  <div class="fs-widget-content" id="fs-telemetry-content">
                    <div><span style="color:#9ca3af;">SPD</span> <span id="fs-telem-spd">-.-</span></div>
                    <div><span style="color:#9ca3af;">VMG</span> <span id="fs-telem-vmg">-.-</span></div>
                    <div><span style="color:#9ca3af;">HDG</span> <span id="fs-telem-hdg">---</span></div>
                    <div><span style="color:#9ca3af;">HEEL</span> <span id="fs-telem-heel">--</span></div>
                    <div><span style="color:#9ca3af;">STR</span> <span id="fs-telem-str">-.-</span></div>
                  </div>
                  <div class="fs-resize-handle" onmousedown="startResizeFsWidget(event, 'fs-map-telemetry-overlay')"></div>
                </div>
                <!-- Leg telemetry overlay (only visible in fullscreen mode when enabled) -->
                <div id="fs-map-leg-overlay" class="fs-widget hidden">
                  <div class="fs-widget-header" onmousedown="startDragFsMapLegOverlay(event)">
                    <span id="fs-leg-label">Leg</span> <span class="fs-minimize-btn" onclick="toggleFsMapLegMinimize(event)">‚ñº</span>
                  </div>
                  <div class="fs-widget-content" id="fs-leg-content">
                    <div><span style="color:#9ca3af;">SPD</span> <span id="fs-leg-spd">-.-</span></div>
                    <div><span style="color:#9ca3af;">VMG</span> <span id="fs-leg-vmg">-.-</span></div>
                    <div><span style="color:#9ca3af;">HDG</span> <span id="fs-leg-hdg">---</span></div>
                    <div><span style="color:#9ca3af;">Next</span> <span id="fs-leg-next">--</span></div>
                  </div>
                  <div class="fs-resize-handle" onmousedown="startResizeFsWidget(event, 'fs-map-leg-overlay')"></div>
                </div>
                <!-- Zoom indicator -->
                <div id="map-zoom-indicator" style="position: absolute; bottom: 45px; right: 12px; font-size: 9px; color: #666;"></div>
                <div style="position: absolute; bottom: 10px; right: 10px; display: flex; flex-direction: column; gap: 4px;">
                  <button class="zoom-btn" onclick="zoomMap(1.5)" title="Zoom In">+</button>
                  <button class="zoom-btn" onclick="zoomMap(1/1.5)" title="Zoom Out">‚àí</button>
                  <button class="zoom-btn" onclick="resetMapZoom()" title="Reset">‚ü≤</button>
                  <button id="map-fullscreen-btn" class="zoom-btn" onclick="toggleMapFullscreen()" title="Fullscreen Map" style="display:none;">‚õ∂</button>
                  <button id="fs-telemetry-toggle-btn" class="zoom-btn" onclick="toggleFsMapTelemetry()" title="Toggle Telemetry Overlay" style="display:none;font-size:12px;">üìä</button>
                </div>
                <div style="position: absolute; bottom: 10px; left: 10px; font-size: 9px; color: #9ca3af;">Scroll to zoom ‚Ä¢ Drag to pan</div>
              </div>
              
              <!-- Right panel for leg details (only visible in fullscreen) -->
              <div id="fs-details-panel">
                <!-- Content populated when entering fullscreen -->
              </div>
            </div>
            
            <!-- Fullscreen footer - playback controls -->
            <div id="map-fullscreen-footer">
              <!-- Content cloned from race-replay-section when entering fullscreen -->
            </div>
          </div>
          <!-- Stats panel (visible in normal mode) -->
          <div class="flex-1" id="stats-panel">
            <div class="grid-2">
              <div class="stat-box" style="border-color: #3b82f6;">
                <div class="stat-label">Avg Spd / VMG</div>
                <div><span class="stat-value text-green" id="speed-up">-</span><span class="stat-sub"> Up</span> <span class="stat-value text-amber" id="speed-down">-</span><span class="stat-sub"> Dn</span></div>
              </div>
              <div class="stat-box" id="heel-box" style="border-color: #eab308;">
                <div class="stat-label">Avg Heel</div>
                <div><span class="stat-value text-green" id="heel-up">-</span><span class="stat-sub"> Up</span> <span class="stat-value text-amber" id="heel-down">-</span><span class="stat-sub"> Dn</span></div>
              </div>
              <div class="stat-box" style="border-color: #a855f7;">
                <div class="stat-label">COG Corridor</div>
                <div><span class="stat-value text-green" id="corr-up">-</span><span class="stat-sub"> Up</span> <span class="stat-value text-amber" id="corr-down">-</span><span class="stat-sub"> Dn</span></div>
              </div>
              <div class="stat-box" id="mag-box" style="border-color: #8b5cf6;">
                <div class="stat-label">MAG 70/90</div>
                <div><span class="stat-value text-green" id="mag70-up">-</span>/<span class="stat-value text-green" id="mag-up">-</span><span class="stat-sub"> Up</span></div>
                <div><span class="stat-value text-amber" id="mag70-down">-</span>/<span class="stat-value text-amber" id="mag-down">-</span><span class="stat-sub"> Dn</span></div>
              </div>
              <div class="stat-box" style="border-color: #06b6d4;">
                <div class="stat-label">Line Dev</div>
                <div><span class="stat-value text-green" id="linedev-up">-</span><span class="stat-sub"> Up</span> <span class="stat-value text-amber" id="linedev-down">-</span><span class="stat-sub"> Dn</span></div>
              </div>
              <div class="stat-box" style="border-color: #ef4444;">
                <div class="stat-label">Steer Rate</div>
                <div><span class="stat-value text-green" id="rate-up">-</span><span class="stat-sub"> Up</span> <span class="stat-value text-amber" id="rate-down">-</span><span class="stat-sub"> Dn</span></div>
              </div>
              <div class="stat-box" style="border-color: #10b981;">
                <div class="stat-label">Tacks</div>
                <div><span class="stat-value" id="tack-count">-</span> <span class="stat-sub">avg</span> <span class="stat-value" id="tack-angle">-</span></div>
              </div>
              <div class="stat-box" style="border-color: #f59e0b;">
                <div class="stat-label">Gybes</div>
                <div><span class="stat-value" id="gybe-count">-</span> <span class="stat-sub">avg</span> <span class="stat-value" id="gybe-angle">-</span></div>
              </div>
            </div>
          </div>
          <!-- Legs panel (visible in legs view mode) -->
          <div class="flex-1" id="legs-panel" style="display:none;">
            <div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:8px;">
              <div>
                <h3 style="margin:0;">Sailing Legs</h3>
                <p class="text-xs" style="color:#6b7280;">Click row to see details below</p>
              </div>
              <div class="text-sm" style="text-align:right;">
                <div id="legs-summary-side"></div>
                <div>Best COG: <span id="best-corridor-side" class="text-green" style="font-weight:bold;">-</span></div>
              </div>
            </div>
            <div class="scroll-table" id="legs-scroll-container-side">
              <table id="legs-table-side">
                <thead>
                  <tr>
                    <th>#</th>
                    <th>POS</th>
                    <th style="text-align:right;">Dur</th>
                    <th style="text-align:right;">Spd/VMG</th>
                    <th style="text-align:right;">MAG70/90</th>
                    <th style="text-align:right;">Rate</th>
                    <th style="text-align:right;">COG</th>
                    <th style="text-align:right;">Dev</th>
                    <th style="text-align:right;">Heel</th>
                    <th style="text-align:right;">Wind</th>
                    <th style="text-align:right;">TWA</th>
                    <th style="text-align:right;">Hdg</th>
                    <th>Next</th>
                  </tr>
                </thead>
                <tbody id="legs-tbody-side"></tbody>
              </table>
            </div>
          </div>
          <!-- Right column for race replay mode -->
          <div id="race-replay-right-column" style="display:none;flex-direction:column;gap:12px;min-width:0;max-width:100%;overflow:hidden;">
            <!-- Video Replay Section (next to map) -->
            <div id="video-replay-section" style="min-width:0;width:100%;max-width:100%;flex-shrink:1;">
              <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">
                <div style="display:flex;align-items:center;gap:8px;">
                  <span style="font-weight:600;font-size:14px;">üé¨ Video Replay</span>
                  <span id="video-buffer-status"></span>
                </div>
                <div style="display:flex;align-items:center;gap:4px;flex-wrap:wrap;">
                  <div style="position:relative;display:inline-block;">
                    <span class="btn btn-sm" style="background:#6b7280;color:white;cursor:pointer;display:inline-block;font-size:11px;" title="Select any file type">
                      üìÑ File
                    </span>
                    <input type="file" id="video-file-any" style="position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer;font-size:0;" onchange="handleVideoFiles(event)">
                  </div>
                  <div style="position:relative;display:inline-block;">
                    <span class="btn btn-sm" style="background:#3b82f6;color:white;cursor:pointer;display:inline-block;font-size:11px;" title="Select MP4/video files (multiple)">
                      üé¨ MP4
                    </span>
                    <input type="file" id="video-file-mp4" accept=".mp4,.mov,.avi,.mkv,.webm,.m4v" multiple style="position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer;font-size:0;" onchange="handleVideoFiles(event)">
                  </div>
                  <div style="position:relative;display:inline-block;" class="folder-picker-btn">
                    <span class="btn btn-sm" style="background:#8b5cf6;color:white;cursor:pointer;display:inline-block;font-size:11px;" title="Select folder with LRV files">
                      üìÅ LRV
                    </span>
                    <input type="file" id="video-folder-lrv" webkitdirectory data-filter="lrv" style="position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer;font-size:0;" onchange="handleVideoFiles(event)">
                  </div>
                  <div style="position:relative;display:inline-block;" class="folder-picker-btn">
                    <span class="btn btn-sm" style="background:#7c3aed;color:white;cursor:pointer;display:inline-block;font-size:11px;" title="Select folder with INSV files">
                      üìÅ INSV
                    </span>
                    <input type="file" id="video-folder-insv" webkitdirectory data-filter="insv" style="position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer;font-size:0;" onchange="handleVideoFiles(event)">
                  </div>
                  <button class="btn btn-sm" onclick="removeAllVideos()" id="remove-videos-btn" style="display:none;">‚úï Remove All</button>
                </div>
              </div>
              <div id="video-container" style="width:100%;max-width:100%;min-width:0;box-sizing:border-box;">
                <div id="video-placeholder" style="color:#9ca3af;text-align:center;padding:20px;width:100%;font-size:12px;">No videos loaded. Add MP4/LRV/INSV files with timestamp in filename (e.g., VID_20251130_142618_00_015.mp4)</div>
              </div>
            </div>
            <!-- Race Replay Panel (timeline controls) -->
            <div id="race-replay-section"></div>
          </div>
        </div>
      </div>

      <!-- Legs Comparison Section (visible only in race replay mode, below map) -->
      <div id="legs-comparison-section" class="card hidden" style="min-height:280px;max-width:none;width:100%;box-sizing:border-box;">
        <div class="current-leg-header" style="margin-bottom:8px;">üìä Legs Comparison</div>
        <div id="current-legs-content" style="min-height:240px;width:100%;box-sizing:border-box;">Move the playback slider to see leg details</div>
      </div>

      <!-- Multi-Session Split-Screen Comparison (visible only when multi-session view enabled) -->
      <div id="multi-session-split-screen" class="hidden" style="display:none;">
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:24px;width:100%;">
          
          <!-- Left Session Dashboard -->
          <div id="session-dashboard-0" style="display:flex;flex-direction:column;gap:16px;">
            <!-- Session Header -->
            <div class="card" style="padding:12px;border-left:4px solid #3b82f6;">
              <h3 id="session-title-0" style="margin:0;color:#3b82f6;">Session 1</h3>
              <p id="session-subtitle-0" class="text-xs" style="color:#6b7280;margin:4px 0 0 0;">Loading...</p>
            </div>
            
            <!-- Session Stats Card -->
            <div id="session-stats-0" class="card" style="padding:12px;">
              <h4 style="margin:0 0 12px 0;font-size:13px;color:#4b5563;">Session Overview</h4>
              <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px;">
                <div style="text-align:center;">
                  <div class="text-xs" style="color:#6b7280;">Total Legs</div>
                  <div id="stat-legs-0" style="font-size:20px;font-weight:bold;color:#3b82f6;">-</div>
                </div>
                <div style="text-align:center;">
                  <div class="text-xs" style="color:#6b7280;">Avg Speed</div>
                  <div id="stat-speed-0" style="font-size:20px;font-weight:bold;color:#3b82f6;">-</div>
                </div>
                <div style="text-align:center;">
                  <div class="text-xs" style="color:#6b7280;">Best VMG</div>
                  <div id="stat-vmg-0" style="font-size:20px;font-weight:bold;color:#22c55e;">-</div>
                </div>
              </div>
            </div>
            
            <!-- Map Card -->
            <div class="card">
              <div id="map-container-0" style="position:relative;">
                <svg id="map-0" width="100%" height="400"></svg>
                <div id="map-legend-0" style="position:absolute;top:8px;left:8px;font-size:11px;background:rgba(255,255,255,0.9);padding:8px 12px;border-radius:6px;"></div>
                <div id="map-wind-0" style="position:absolute;top:8px;right:8px;text-align:center;background:rgba(255,255,255,0.85);padding:4px;border-radius:4px;font-size:10px;"></div>
                
                <!-- Projection toggle -->
                <div style="position:absolute;bottom:45px;left:10px;font-size:8px;display:flex;align-items:center;gap:4px;background:rgba(255,255,255,0.85);padding:3px 6px;border-radius:4px;">
                  <span id="proj-label-0" style="color:#666;" title="Compass: angles as sailed. Geo: true geography">Compass</span>
                  <label style="position:relative;display:inline-block;width:28px;height:14px;cursor:pointer;">
                    <input type="checkbox" id="proj-toggle-0" onchange="toggleSessionProjection(0)" style="opacity:0;width:0;height:0;">
                    <span style="position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:#ccc;border-radius:14px;transition:.2s;"></span>
                    <span id="proj-slider-0" style="position:absolute;height:10px;width:10px;left:2px;bottom:2px;background-color:white;border-radius:50%;transition:.2s;box-shadow:0 1px 3px rgba(0,0,0,0.3);"></span>
                  </label>
                </div>
                
                <!-- Hide gray toggle -->
                <div style="position:absolute;bottom:65px;left:10px;font-size:8px;display:flex;align-items:center;gap:4px;background:rgba(255,255,255,0.85);padding:3px 6px;border-radius:4px;">
                  <span id="hide-gray-label-0" style="color:#666;" title="Hide past and future track portions">Hide gray</span>
                  <label style="position:relative;display:inline-block;width:28px;height:14px;cursor:pointer;">
                    <input type="checkbox" id="hide-gray-tracks-0" onchange="toggleHideGraySession(0)" style="opacity:0;width:0;height:0;">
                    <span style="position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:#ccc;border-radius:14px;transition:.2s;"></span>
                    <span id="hide-gray-slider-0" style="position:absolute;height:10px;width:10px;left:2px;bottom:2px;background-color:white;border-radius:50%;transition:.2s;box-shadow:0 1px 3px rgba(0,0,0,0.3);"></span>
                  </label>
                </div>
                
                <div id="map-zoom-indicator-0" style="position:absolute;bottom:45px;right:12px;font-size:9px;color:#666;"></div>
                <div style="position:absolute;bottom:10px;right:10px;display:flex;flex-direction:column;gap:4px;">
                  <button class="zoom-btn" onclick="zoomMapSession(0, 1.5)">+</button>
                  <button class="zoom-btn" onclick="zoomMapSession(0, 1/1.5)">‚àí</button>
                  <button class="zoom-btn" onclick="resetMapZoomSession(0)">‚ü≤</button>
                </div>
                <div style="position:absolute;bottom:10px;left:10px;font-size:9px;color:#9ca3af;">Scroll to zoom ‚Ä¢ Drag to pan</div>
              </div>
            </div>
            
            <!-- Tabs -->
            <div class="tabs">
              <button class="tab active" onclick="switchTabSession(0, 'legs')">Legs Analysis</button>
              <button class="tab" onclick="switchTabSession(0, 'steering')">1-Min Intervals</button>
              <button class="tab" onclick="switchTabSession(0, 'pos')">Point of Sail</button>
            </div>
            
            <!-- Tab Content -->
            <div class="card">
              <!-- Legs Tab -->
              <div id="tab-legs-0" class="tab-content">
                <div style="margin-bottom:12px;">
                  <h4 style="margin:0 0 4px 0;">Sailing Legs</h4>
                  <div id="legs-summary-0" style="font-size:11px;color:#6b7280;"></div>
                </div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;">
                  <div class="scroll-table" style="max-height:400px;">
                    <table id="legs-table-0" style="width:100%;font-size:11px;">
                      <thead><tr>
                        <th>#</th>
                        <th>POS</th>
                        <th style="text-align:right;">Dur</th>
                        <th style="text-align:right;">Rate</th>
                        <th style="text-align:right;">COG</th>
                        <th style="text-align:right;">Dev</th>
                        <th id="mag-header-0" style="text-align:right;">MAG70/90</th>
                        <th id="heel-header-0" style="text-align:right;">Heel</th>
                        <th style="text-align:right;">Spd/VMG</th>
                        <th style="text-align:right;">Hdg</th>
                        <th>Next</th>
                      </tr></thead>
                      <tbody id="legs-tbody-0"></tbody>
                    </table>
                  </div>
                  <div id="leg-detail-0" style="max-height:400px;overflow-y:auto;"></div>
                </div>
              </div>
              
              <!-- Steering Tab -->
              <div id="tab-steering-0" class="tab-content hidden">
                <h4 style="margin:0 0 8px 0;">1-Min Intervals</h4>
                <p id="interval-help-0" class="text-xs" style="color:#6b7280;margin-bottom:12px;">Click dots to select leg on map.</p>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:16px;">
                  <div style="height:200px;"><canvas id="rate-chart-0"></canvas></div>
                  <div style="height:200px;"><canvas id="corridor-chart-0"></canvas></div>
                </div>
              </div>
              
              <!-- POS Tab -->
              <div id="tab-pos-0" class="tab-content hidden">
                <h4 style="margin:0 0 12px 0;">Point of Sail</h4>
                <div id="pos-breakdown-0"></div>
              </div>
            </div>
          </div>
          
          <!-- Right Session Dashboard -->
          <div id="session-dashboard-1" style="display:flex;flex-direction:column;gap:16px;">
            <!-- Session Header -->
            <div class="card" style="padding:12px;border-left:4px solid #22c55e;">
              <h3 id="session-title-1" style="margin:0;color:#22c55e;">Session 2</h3>
              <p id="session-subtitle-1" class="text-xs" style="color:#6b7280;margin:4px 0 0 0;">Loading...</p>
            </div>
            
            <!-- Session Stats Card -->
            <div id="session-stats-1" class="card" style="padding:12px;">
              <h4 style="margin:0 0 12px 0;font-size:13px;color:#4b5563;">Session Overview</h4>
              <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px;">
                <div style="text-align:center;">
                  <div class="text-xs" style="color:#6b7280;">Total Legs</div>
                  <div id="stat-legs-1" style="font-size:20px;font-weight:bold;color:#22c55e;">-</div>
                </div>
                <div style="text-align:center;">
                  <div class="text-xs" style="color:#6b7280;">Avg Speed</div>
                  <div id="stat-speed-1" style="font-size:20px;font-weight:bold;color:#22c55e;">-</div>
                </div>
                <div style="text-align:center;">
                  <div class="text-xs" style="color:#6b7280;">Best VMG</div>
                  <div id="stat-vmg-1" style="font-size:20px;font-weight:bold;color:#22c55e;">-</div>
                </div>
              </div>
            </div>
            
            <!-- Map Card -->
            <div class="card">
              <div id="map-container-1" style="position:relative;">
                <svg id="map-1" width="100%" height="400"></svg>
                <div id="map-legend-1" style="position:absolute;top:8px;left:8px;font-size:11px;background:rgba(255,255,255,0.9);padding:8px 12px;border-radius:6px;"></div>
                <div id="map-wind-1" style="position:absolute;top:8px;right:8px;text-align:center;background:rgba(255,255,255,0.85);padding:4px;border-radius:4px;font-size:10px;"></div>
                
                <!-- Projection toggle -->
                <div style="position:absolute;bottom:45px;left:10px;font-size:8px;display:flex;align-items:center;gap:4px;background:rgba(255,255,255,0.85);padding:3px 6px;border-radius:4px;">
                  <span id="proj-label-1" style="color:#666;" title="Compass: angles as sailed. Geo: true geography">Compass</span>
                  <label style="position:relative;display:inline-block;width:28px;height:14px;cursor:pointer;">
                    <input type="checkbox" id="proj-toggle-1" onchange="toggleSessionProjection(1)" style="opacity:0;width:0;height:0;">
                    <span style="position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:#ccc;border-radius:14px;transition:.2s;"></span>
                    <span id="proj-slider-1" style="position:absolute;height:10px;width:10px;left:2px;bottom:2px;background-color:white;border-radius:50%;transition:.2s;box-shadow:0 1px 3px rgba(0,0,0,0.3);"></span>
                  </label>
                </div>
                
                <!-- Hide gray toggle -->
                <div style="position:absolute;bottom:65px;left:10px;font-size:8px;display:flex;align-items:center;gap:4px;background:rgba(255,255,255,0.85);padding:3px 6px;border-radius:4px;">
                  <span id="hide-gray-label-1" style="color:#666;" title="Hide past and future track portions">Hide gray</span>
                  <label style="position:relative;display:inline-block;width:28px;height:14px;cursor:pointer;">
                    <input type="checkbox" id="hide-gray-tracks-1" onchange="toggleHideGraySession(1)" style="opacity:0;width:0;height:0;">
                    <span style="position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:#ccc;border-radius:14px;transition:.2s;"></span>
                    <span id="hide-gray-slider-1" style="position:absolute;height:10px;width:10px;left:2px;bottom:2px;background-color:white;border-radius:50%;transition:.2s;box-shadow:0 1px 3px rgba(0,0,0,0.3);"></span>
                  </label>
                </div>
                
                <div id="map-zoom-indicator-1" style="position:absolute;bottom:45px;right:12px;font-size:9px;color:#666;"></div>
                <div style="position:absolute;bottom:10px;right:10px;display:flex;flex-direction:column;gap:4px;">
                  <button class="zoom-btn" onclick="zoomMapSession(1, 1.5)">+</button>
                  <button class="zoom-btn" onclick="zoomMapSession(1, 1/1.5)">‚àí</button>
                  <button class="zoom-btn" onclick="resetMapZoomSession(1)">‚ü≤</button>
                </div>
                <div style="position:absolute;bottom:10px;left:10px;font-size:9px;color:#9ca3af;">Scroll to zoom ‚Ä¢ Drag to pan</div>
              </div>
            </div>
            
            <!-- Tabs -->
            <div class="tabs">
              <button class="tab active" onclick="switchTabSession(1, 'legs')">Legs Analysis</button>
              <button class="tab" onclick="switchTabSession(1, 'steering')">1-Min Intervals</button>
              <button class="tab" onclick="switchTabSession(1, 'pos')">Point of Sail</button>
            </div>
            
            <!-- Tab Content -->
            <div class="card">
              <!-- Legs Tab -->
              <div id="tab-legs-1" class="tab-content">
                <div style="margin-bottom:12px;">
                  <h4 style="margin:0 0 4px 0;">Sailing Legs</h4>
                  <div id="legs-summary-1" style="font-size:11px;color:#6b7280;"></div>
                </div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;">
                  <div class="scroll-table" style="max-height:400px;">
                    <table id="legs-table-1" style="width:100%;font-size:11px;">
                      <thead><tr>
                        <th>#</th>
                        <th>POS</th>
                        <th style="text-align:right;">Dur</th>
                        <th style="text-align:right;">Rate</th>
                        <th style="text-align:right;">COG</th>
                        <th style="text-align:right;">Dev</th>
                        <th id="mag-header-1" style="text-align:right;">MAG70/90</th>
                        <th id="heel-header-1" style="text-align:right;">Heel</th>
                        <th style="text-align:right;">Spd/VMG</th>
                        <th style="text-align:right;">Hdg</th>
                        <th>Next</th>
                      </tr></thead>
                      <tbody id="legs-tbody-1"></tbody>
                    </table>
                  </div>
                  <div id="leg-detail-1" style="max-height:400px;overflow-y:auto;"></div>
                </div>
              </div>
              
              <!-- Steering Tab -->
              <div id="tab-steering-1" class="tab-content hidden">
                <h4 style="margin:0 0 8px 0;">1-Min Intervals</h4>
                <p id="interval-help-1" class="text-xs" style="color:#6b7280;margin-bottom:12px;">Click dots to select leg on map.</p>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:16px;">
                  <div style="height:200px;"><canvas id="rate-chart-1"></canvas></div>
                  <div style="height:200px;"><canvas id="corridor-chart-1"></canvas></div>
                </div>
              </div>
              
              <!-- POS Tab -->
              <div id="tab-pos-1" class="tab-content hidden">
                <h4 style="margin:0 0 12px 0;">Point of Sail</h4>
                <div id="pos-breakdown-1"></div>
              </div>
            </div>
          </div>
          
        </div>
      </div>

      <!-- Tabs section (hidden in race replay mode) -->
      <div id="stats-and-tabs-section">
      <div class="tabs">
        <button class="tab" data-tab="leg-details" id="tab-btn-leg-details" onclick="switchTab('leg-details')" style="display:none;">Leg Details</button>
        <button class="tab active" data-tab="legs" id="tab-btn-legs" onclick="switchTab('legs')">Legs Analysis</button>
        <button class="tab" data-tab="steering" onclick="switchTab('steering')">1-Min Intervals</button>
        <button class="tab" data-tab="pos" onclick="switchTab('pos')">Point of Sail</button>
      </div>

      <!-- Tab Content -->
      <div class="card">
        <!-- Leg Details Tab (for legs view mode) -->
        <div id="tab-leg-details" class="tab-content hidden">
          <h3>Leg Details</h3>
          <p class="text-xs" style="color:#6b7280;margin-bottom:12px;">Select a leg from the table on the right to view details.</p>
          <div id="leg-detail-container-side">
            <!-- leg-detail element will be moved here in legs view mode -->
          </div>
        </div>
        
        <!-- Legs Tab -->
        <div id="tab-legs" class="tab-content">
          <div class="flex" style="justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
            <div>
              <h3>Sailing Legs Analysis</h3>
              <p class="text-xs" style="color: #6b7280;">Select leg to see details and highlighted intervals.</p>
            </div>
            <div class="text-sm" style="text-align: right;">
              <div id="legs-summary"></div>
              <div>Best COG: <span id="best-corridor" class="text-green" style="font-weight: bold;">-</span></div>
            </div>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
            <div>
              <div class="scroll-table" id="legs-scroll-container">
                <table id="legs-table">
                  <thead>
                    <tr>
                      <th>#</th>
                      <th>POS</th>
                      <th style="text-align: right;">Dur</th>
                      <th style="text-align: right;">Spd/VMG</th>
                      <th style="text-align: right;">MAG70/90</th>
                      <th style="text-align: right;">Rate</th>
                      <th style="text-align: right;">COG</th>
                      <th style="text-align: right;">Dev</th>
                      <th style="text-align: right;">Heel</th>
                      <th style="text-align: right;">Wind</th>
                      <th style="text-align: right;">TWA</th>
                      <th style="text-align: right;">Hdg</th>
                      <th>Next</th>
                    </tr>
                  </thead>
                  <tbody id="legs-tbody"></tbody>
                </table>
              </div>
            </div>
            <div id="leg-detail-container-main">
              <div style="max-height: 500px; overflow-y: auto;" id="leg-detail">
                <div style="color: #6b7280; text-align: center; padding: 40px;">
                  Select a leg to view details
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Steering Tab -->
        <div id="tab-steering" class="tab-content hidden">
          <div class="flex" style="justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
            <div>
              <h3>1-Minute Interval Analysis</h3>
              <p class="text-xs" id="interval-help" style="color: #6b7280;">Click dots to select leg on map.</p>
            </div>
            <div class="text-sm" style="text-align: right;">
              <div>Best Rate: <span id="best-rate" style="font-weight: bold;">-</span></div>
              <div>Best Corridor: <span id="best-int-corridor" style="font-weight: bold;">-</span></div>
            </div>
          </div>
          
          <div style="border: 1px solid #e5e7eb; border-radius: 8px; padding: 12px; margin-bottom: 16px;">
            <h4 style="font-weight: 500; margin-bottom: 8px;">Steering Rate</h4>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background: #22c55e;"></div>Expert ‚â§1.5</div>
              <div class="legend-item"><div class="legend-dot" style="background: #3b82f6;"></div>Club 1.5-3</div>
              <div class="legend-item"><div class="legend-dot" style="background: #f59e0b;"></div>Rec 3-5</div>
              <div class="legend-item"><div class="legend-dot" style="background: #ef4444;"></div>Learning &gt;5</div>
              <div class="legend-item" id="legend-selected-rate" style="display: none;"><div class="legend-dot" style="background: #a855f7;"></div><span id="legend-leg-rate">Leg #1</span></div>
            </div>
            <div id="rate-pct" style="font-size: 11px; color: #6b7280; margin-bottom: 8px;"></div>
            <div class="chart-container">
              <canvas id="rate-scatter"></canvas>
            </div>
          </div>

          <div id="mag-corridor-chart-container" style="border: 1px solid #e5e7eb; border-radius: 8px; padding: 12px; margin-bottom: 16px;">
            <h4 style="font-weight: 500; margin-bottom: 8px;">MAG Corridor (¬±)</h4>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background: #22c55e;"></div>Excellent ‚â§¬±5¬∞</div>
              <div class="legend-item"><div class="legend-dot" style="background: #3b82f6;"></div>Good ¬±5-8¬∞</div>
              <div class="legend-item"><div class="legend-dot" style="background: #f59e0b;"></div>Fair ¬±8-12¬∞</div>
              <div class="legend-item"><div class="legend-dot" style="background: #ef4444;"></div>Needs Work &gt;¬±12¬∞</div>
              <div class="legend-item" id="legend-selected-mag" style="display: none;"><div class="legend-dot" style="background: #a855f7;"></div><span id="legend-leg-mag">Leg #1</span></div>
            </div>
            <div id="mag-pct" style="font-size: 11px; color: #6b7280; margin-bottom: 8px;"></div>
            <div class="chart-container">
              <canvas id="mag-corridor-scatter"></canvas>
            </div>
          </div>

          <div style="border: 1px solid #e5e7eb; border-radius: 8px; padding: 12px;">
            <h4 style="font-weight: 500; margin-bottom: 8px;">COG Corridor (¬±)</h4>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background: #22c55e;"></div>Excellent ‚â§¬±8¬∞</div>
              <div class="legend-item"><div class="legend-dot" style="background: #3b82f6;"></div>Good ¬±8-12¬∞</div>
              <div class="legend-item"><div class="legend-dot" style="background: #f59e0b;"></div>Fair ¬±12-18¬∞</div>
              <div class="legend-item"><div class="legend-dot" style="background: #ef4444;"></div>Needs Work &gt;¬±18¬∞</div>
              <div class="legend-item" id="legend-selected-corr" style="display: none;"><div class="legend-dot" style="background: #a855f7;"></div><span id="legend-leg-corr">Leg #1</span></div>
            </div>
            <div id="corr-pct" style="font-size: 11px; color: #6b7280; margin-bottom: 8px;"></div>
            <div class="chart-container">
              <canvas id="corridor-scatter"></canvas>
            </div>
          </div>
        </div>

        <!-- POS Tab -->
        <div id="tab-pos" class="tab-content hidden">
          <h3>Point of Sail Breakdown</h3>
          <div class="grid-3 mt-4" id="pos-breakdown"></div>
        </div>
      </div>
      </div><!-- end stats-and-tabs-section -->
    </div>
  </div>

  <script>
    // ===== PLATFORM DETECTION =====
    // Mobile detection for file input handling (mobile has issues with accept filters)
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    const isAndroid = /Android/i.test(navigator.userAgent);
    const isMobile = isIOS || isAndroid;
    
    // ===== VKX PARSER =====
    const ROW_DEFINITIONS = {
      0xFF: [7, 'page_header'],
      0xFE: [2, 'page_terminator'],
      0x02: [44, 'position_velocity'],
      0x03: [20, 'declination'],
      0x04: [13, 'race_timer'],
      0x05: [17, 'line_position'],
      0x06: [18, 'shift_angle'],
      0x08: [13, 'device_config'],
      0x0A: [16, 'wind'],
      0x0B: [16, 'speed_through_water'],
      0x0C: [12, 'depth'],
      0x10: [12, 'temperature'],
      0x0F: [16, 'load'],
      0x01: [32, 'internal'],
      0x07: [12, 'internal'],
      0x0E: [16, 'internal'],
      0x20: [13, 'internal'],
      0x21: [52, 'internal'],
    };

    // Lazy load pako for gzip decompression
    let pakoLib = null;
    async function loadPako() {
      if (pakoLib) return pakoLib;
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js';
        script.onload = () => {
          pakoLib = window.pako;
          resolve(pakoLib);
        };
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }

    function quaternionToEuler(w, x, y, z) {
      const sinr = 2 * (w * x + y * z);
      const cosr = 1 - 2 * (x * x + y * y);
      const roll = Math.atan2(sinr, cosr);
      
      let pitch;
      const sinp = 2 * (w * y - z * x);
      if (Math.abs(sinp) >= 1) pitch = Math.sign(sinp) * Math.PI / 2;
      else pitch = Math.asin(sinp);
      
      const siny = 2 * (w * z + x * y);
      const cosy = 1 - 2 * (y * y + z * z);
      const yaw = Math.atan2(siny, cosy);
      
      return [roll * 180 / Math.PI, pitch * 180 / Math.PI, yaw * 180 / Math.PI];
    }

    function parseVKX(arrayBuffer) {
      const data = new Uint8Array(arrayBuffer);
      const view = new DataView(arrayBuffer);
      const records = [];
      let pos = 0;

      while (pos < data.length) {
        const key = data[pos];
        pos++;

        if (!ROW_DEFINITIONS[key]) continue;
        const [payloadSize, parserName] = ROW_DEFINITIONS[key];
        if (pos + payloadSize > data.length) break;

        if (parserName === 'position_velocity') {
          const ts = Number(view.getBigUint64(pos, true));
          const latRaw = view.getInt32(pos + 8, true);
          const lonRaw = view.getInt32(pos + 12, true);
          const sog = view.getFloat32(pos + 16, true);
          const cog = view.getFloat32(pos + 20, true);
          const alt = view.getFloat32(pos + 24, true);
          const qw = view.getFloat32(pos + 28, true);
          const qx = view.getFloat32(pos + 32, true);
          const qy = view.getFloat32(pos + 36, true);
          const qz = view.getFloat32(pos + 40, true);

          const lat = latRaw / 1e7;
          const lon = lonRaw / 1e7;
          let cogDeg = cog * 180 / Math.PI;
          if (cogDeg < 0) cogDeg += 360;
          const sogKnots = sog * 1.94384;
          const [roll, pitch, heading] = quaternionToEuler(qw, qx, qy, qz);
          let hdgNorm = heading;
          if (hdgNorm < 0) hdgNorm += 360;

          records.push({
            timestamp_ms: ts,
            lat, lon,
            sog_knots: sogKnots,
            cog_deg: cogDeg,
            heading_deg: hdgNorm,
            roll_deg: roll,
            pitch_deg: pitch
          });
        }
        pos += payloadSize;
      }
      return records;
    }

    function parseFIT(arrayBuffer) {
      const buf = new Uint8Array(arrayBuffer);
      const view = new DataView(arrayBuffer);
      
      // Check FIT signature
      const signature = String.fromCharCode(buf[8], buf[9], buf[10], buf[11]);
      if (signature !== '.FIT') {
        throw new Error('Invalid FIT file signature');
      }
      
      const headerSize = buf[0];
      const dataSize = view.getUint32(4, true);
      const dataEnd = headerSize + dataSize;
      
      let offset = headerSize;
      const definitions = {};
      const gpsRecords = [];
      
      function readValue(offset, baseType, size) {
        if (baseType === 133 || baseType === 134 || baseType === 139) {
          return view.getInt32(offset, true);
        } else if (baseType === 131 || baseType === 132) {
          return view.getInt16(offset, true);
        } else if (baseType === 136) {
          return view.getFloat32(offset, true);
        }
        if (size === 4) return view.getUint32(offset, true);
        if (size === 2) return view.getUint16(offset, true);
        return buf[offset];
      }
      
      // FIT epoch: Dec 31, 1989 00:00:00 UTC
      const fitEpoch = Date.UTC(1989, 11, 31, 0, 0, 0);
      
      while (offset < dataEnd && offset < buf.length - 2) {
        const recordHeader = buf[offset++];
        const isDefinition = (recordHeader & 0x40) !== 0;
        const localMessageType = recordHeader & 0x0F;
        
        if (isDefinition) {
          offset++; // reserved
          offset++; // architecture
          const globalMsgNum = view.getUint16(offset, true);
          offset += 2;
          const numFields = buf[offset++];
          
          const fields = [];
          for (let i = 0; i < numFields; i++) {
            fields.push({
              fieldDefNum: buf[offset++],
              size: buf[offset++],
              baseType: buf[offset++]
            });
          }
          definitions[localMessageType] = { globalMsgNum, fields };
        } else {
          const def = definitions[localMessageType];
          if (!def) break;
          
          const record = {};
          for (const field of def.fields) {
            record[field.fieldDefNum] = readValue(offset, field.baseType, field.size);
            offset += field.size;
          }
          
          // Record message (20) = GPS data
          if (def.globalMsgNum === 20) {
            const lat = record[0] * (180 / Math.pow(2, 31));
            const lon = record[1] * (180 / Math.pow(2, 31));
            const timestamp = record[253];
            const speedMmS = record[73] || record[6] || 0; // enhanced_speed or speed
            const speedKnots = speedMmS / 1000 * 1.94384;
            
            if (lat !== 0 && lon !== 0 && !isNaN(lat) && !isNaN(lon)) {
              gpsRecords.push({
                timestamp_ms: fitEpoch + timestamp * 1000,
                lat,
                lon,
                sog_knots: speedKnots,
                cog_deg: null, // Will be calculated from positions
                heading_deg: null, // Not available in Garmin
                roll_deg: 0 // Not available
              });
            }
          }
        }
      }
      
      // Calculate COG from consecutive positions
      for (let i = 1; i < gpsRecords.length; i++) {
        const p0 = gpsRecords[i - 1];
        const p1 = gpsRecords[i];
        const dLon = (p1.lon - p0.lon) * Math.PI / 180;
        const lat0 = p0.lat * Math.PI / 180;
        const lat1 = p1.lat * Math.PI / 180;
        
        const x = Math.sin(dLon) * Math.cos(lat1);
        const y = Math.cos(lat0) * Math.sin(lat1) - Math.sin(lat0) * Math.cos(lat1) * Math.cos(dLon);
        let cog = Math.atan2(x, y) * 180 / Math.PI;
        if (cog < 0) cog += 360;
        
        p1.cog_deg = cog;
      }
      
      // Set first record COG same as second
      if (gpsRecords.length > 1) {
        gpsRecords[0].cog_deg = gpsRecords[1].cog_deg;
      }
      
      // Apply speed-weighted COG smoothing for heading
      // This reduces noise from GPS position errors, especially at low speeds
      const minSpeedForCog = 1.5; // knots - below this, COG is unreliable
      
      // Adaptive smooth window: target ~5 seconds of data
      // At 1Hz: 5 samples, at 0.25Hz: ~2 samples
      const avgInterval = (gpsRecords[gpsRecords.length-1].timestamp_ms - gpsRecords[0].timestamp_ms) / (gpsRecords.length - 1);
      const targetWindowSec = 5; // seconds
      const smoothWindow = Math.max(2, Math.round(targetWindowSec * 1000 / avgInterval));
      console.log(`GPS smoothing: avgInterval=${(avgInterval/1000).toFixed(1)}s, smoothWindow=${smoothWindow} samples`);
      
      for (let i = 0; i < gpsRecords.length; i++) {
        const p = gpsRecords[i];
        
        // If speed is very low, COG is meaningless - will interpolate later
        if (p.sog_knots < minSpeedForCog) {
          p.heading_deg = null;
          continue;
        }
        
        // Speed-weighted circular average over window
        let sinSum = 0, cosSum = 0, weightSum = 0;
        for (let j = Math.max(0, i - smoothWindow); j <= Math.min(gpsRecords.length - 1, i + smoothWindow); j++) {
          const sample = gpsRecords[j];
          if (sample.sog_knots >= minSpeedForCog) {
            const weight = sample.sog_knots; // Weight by speed
            sinSum += Math.sin(sample.cog_deg * Math.PI / 180) * weight;
            cosSum += Math.cos(sample.cog_deg * Math.PI / 180) * weight;
            weightSum += weight;
          }
        }
        
        if (weightSum > 0) {
          let smoothedHdg = Math.atan2(sinSum, cosSum) * 180 / Math.PI;
          if (smoothedHdg < 0) smoothedHdg += 360;
          p.heading_deg = smoothedHdg;
        } else {
          p.heading_deg = p.cog_deg;
        }
      }
      
      // Interpolate heading for low-speed gaps
      let lastValidIdx = -1;
      for (let i = 0; i < gpsRecords.length; i++) {
        if (gpsRecords[i].heading_deg !== null) {
          // Fill gap from lastValidIdx+1 to i-1
          if (lastValidIdx >= 0 && i - lastValidIdx > 1) {
            const startHdg = gpsRecords[lastValidIdx].heading_deg;
            const endHdg = gpsRecords[i].heading_deg;
            let diff = endHdg - startHdg;
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;
            
            for (let j = lastValidIdx + 1; j < i; j++) {
              const t = (j - lastValidIdx) / (i - lastValidIdx);
              let interpHdg = startHdg + diff * t;
              if (interpHdg < 0) interpHdg += 360;
              if (interpHdg >= 360) interpHdg -= 360;
              gpsRecords[j].heading_deg = interpHdg;
            }
          }
          lastValidIdx = i;
        }
      }
      
      // Fill any remaining nulls at start/end
      const firstValid = gpsRecords.find(p => p.heading_deg !== null);
      const lastValid = [...gpsRecords].reverse().find(p => p.heading_deg !== null);
      for (let i = 0; i < gpsRecords.length; i++) {
        if (gpsRecords[i].heading_deg === null) {
          gpsRecords[i].heading_deg = firstValid ? firstValid.heading_deg : gpsRecords[i].cog_deg;
        }
      }
      
      return gpsRecords;
    }

    function parseGPX(arrayBuffer) {
      // Convert ArrayBuffer to string
      const decoder = new TextDecoder('utf-8');
      const xmlString = decoder.decode(arrayBuffer);
      
      // Parse XML
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
      
      // Extract trackpoints
      const trkpts = xmlDoc.querySelectorAll('trkpt');
      const records = [];
      
      trkpts.forEach(trkpt => {
        const lat = parseFloat(trkpt.getAttribute('lat'));
        const lon = parseFloat(trkpt.getAttribute('lon'));
        const timeEl = trkpt.querySelector('time');
        
        if (!isNaN(lat) && !isNaN(lon) && timeEl) {
          const timestamp = new Date(timeEl.textContent).getTime();
          
          // Try to get elevation if available
          const eleEl = trkpt.querySelector('ele');
          const altitude = eleEl ? parseFloat(eleEl.textContent) : 0;
          
          records.push({
            timestamp_ms: timestamp,
            lat: lat,
            lon: lon,
            altitude_m: altitude,
            sog_knots: 0,  // Will calculate from position
            cog_deg: 0,    // Will calculate from position
            heading_deg: 0,
            roll_deg: 0
          });
        }
      });
      
      if (records.length < 2) {
        throw new Error('GPX file contains insufficient trackpoints');
      }
      
      // Sort by timestamp
      records.sort((a, b) => a.timestamp_ms - b.timestamp_ms);
      
      // Calculate speed (knots) and COG from position changes
      for (let i = 1; i < records.length; i++) {
        const p0 = records[i - 1];
        const p1 = records[i];
        const dt = (p1.timestamp_ms - p0.timestamp_ms) / 1000; // seconds
        
        if (dt > 0) {
          // Calculate distance using Haversine formula
          const R = 6371000; // Earth radius in meters
          const lat1 = p0.lat * Math.PI / 180;
          const lat2 = p1.lat * Math.PI / 180;
          const dLat = (p1.lat - p0.lat) * Math.PI / 180;
          const dLon = (p1.lon - p0.lon) * Math.PI / 180;
          
          const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1) * Math.cos(lat2) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
          const distanceM = R * c;
          
          // Speed in knots (1 knot = 0.514444 m/s)
          const speedMs = distanceM / dt;
          p1.sog_knots = speedMs / 0.514444;
          
          // Calculate bearing (COG)
          const y = Math.sin(dLon) * Math.cos(lat2);
          const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
          let cog = Math.atan2(y, x) * 180 / Math.PI;
          if (cog < 0) cog += 360;
          p1.cog_deg = cog;
          p1.heading_deg = cog;
        }
      }
      
      // Copy first point values from second point
      if (records.length > 1) {
        records[0].sog_knots = records[1].sog_knots;
        records[0].cog_deg = records[1].cog_deg;
        records[0].heading_deg = records[1].heading_deg;
      }
      
      // Apply COG smoothing (same as FIT parser)
      // Speed-weighted circular averaging over ¬±5 samples
      const windowRadius = 5;
      const lowSpeedThreshold = 1.5;
      const smoothedHeadings = [];
      
      for (let i = 0; i < records.length; i++) {
        let sinSum = 0, cosSum = 0, weightSum = 0;
        for (let j = Math.max(0, i - windowRadius); j <= Math.min(records.length - 1, i + windowRadius); j++) {
          const weight = records[j].sog_knots;
          if (weight > lowSpeedThreshold) {
            sinSum += weight * Math.sin(records[j].cog_deg * Math.PI / 180);
            cosSum += weight * Math.cos(records[j].cog_deg * Math.PI / 180);
            weightSum += weight;
          }
        }
        if (weightSum > 0) {
          let avgHdg = Math.atan2(sinSum, cosSum) * 180 / Math.PI;
          if (avgHdg < 0) avgHdg += 360;
          smoothedHeadings.push(avgHdg);
        } else {
          smoothedHeadings.push(null);
        }
      }
      
      // Apply smoothed headings and interpolate gaps
      let lastValidIdx = -1;
      for (let i = 0; i < records.length; i++) {
        if (smoothedHeadings[i] !== null) {
          if (lastValidIdx >= 0 && i - lastValidIdx > 1) {
            const startHdg = smoothedHeadings[lastValidIdx];
            const endHdg = smoothedHeadings[i];
            let diff = endHdg - startHdg;
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;
            for (let j = lastValidIdx + 1; j < i; j++) {
              const t = (j - lastValidIdx) / (i - lastValidIdx);
              let interpHdg = startHdg + diff * t;
              if (interpHdg < 0) interpHdg += 360;
              if (interpHdg >= 360) interpHdg -= 360;
              records[j].heading_deg = interpHdg;
            }
          }
          records[i].heading_deg = smoothedHeadings[i];
          lastValidIdx = i;
        }
      }
      
      // Fill remaining nulls
      const firstValid = records.find(p => smoothedHeadings[records.indexOf(p)] !== null);
      for (let i = 0; i < records.length; i++) {
        if (records[i].heading_deg === 0 || records[i].heading_deg === null) {
          records[i].heading_deg = firstValid ? firstValid.heading_deg : records[i].cog_deg;
        }
      }
      
      console.log(`GPX parsed: ${records.length} trackpoints`);
      return records;
    }

    function parseCSV(arrayBuffer) {
      // Convert ArrayBuffer to text
      const decoder = new TextDecoder('utf-8');
      const text = decoder.decode(arrayBuffer);
      const lines = text.split('\n').filter(line => line.trim());
      
      if (lines.length < 2) {
        throw new Error('CSV file is empty or has no data rows');
      }
      
      // Parse header
      const header = lines[0].split(',').map(h => h.trim());
      
      // Verify required columns
      const requiredCols = ['timestamp', 'latitude', 'longitude'];
      const missingCols = requiredCols.filter(col => !header.includes(col));
      if (missingCols.length > 0) {
        throw new Error(`CSV missing required columns: ${missingCols.join(', ')}`);
      }
      
      // Find column indices
      const colIndices = {
        timestamp: header.indexOf('timestamp'),
        latitude: header.indexOf('latitude'),
        longitude: header.indexOf('longitude'),
        sog_kts: header.indexOf('sog_kts'),
        cog: header.indexOf('cog'),
        hdg_true: header.indexOf('hdg_true'),
        heel: header.indexOf('heel'),
        trim: header.indexOf('trim')
      };
      
      const records = [];
      
      // Parse data rows
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        const values = line.split(',').map(v => v.trim());
        
        // Parse timestamp (ISO 8601 format: 2026-01-17T12:06:56.031+0400)
        const timestampStr = values[colIndices.timestamp];
        const timestampMs = new Date(timestampStr).getTime();
        
        // Parse coordinates
        const lat = parseFloat(values[colIndices.latitude]);
        const lon = parseFloat(values[colIndices.longitude]);
        
        if (isNaN(lat) || isNaN(lon) || isNaN(timestampMs)) {
          continue; // Skip invalid records
        }
        
        // Parse optional fields
        const sog_knots = colIndices.sog_kts >= 0 ? parseFloat(values[colIndices.sog_kts]) : 0;
        const cog_deg = colIndices.cog >= 0 ? parseFloat(values[colIndices.cog]) : null;
        const heading_deg = colIndices.hdg_true >= 0 ? parseFloat(values[colIndices.hdg_true]) : null;
        const roll_deg = colIndices.heel >= 0 ? parseFloat(values[colIndices.heel]) : 0;
        const pitch_deg = colIndices.trim >= 0 ? parseFloat(values[colIndices.trim]) : 0;
        
        records.push({
          timestamp_ms: timestampMs,
          lat,
          lon,
          sog_knots: isNaN(sog_knots) ? 0 : sog_knots,
          cog_deg: isNaN(cog_deg) ? null : cog_deg,
          heading_deg: isNaN(heading_deg) ? null : heading_deg,
          roll_deg: isNaN(roll_deg) ? 0 : roll_deg,
          pitch_deg: isNaN(pitch_deg) ? 0 : pitch_deg
        });
      }
      
      // Calculate COG from consecutive positions if not provided
      if (records.length > 1 && records[0].cog_deg === null) {
        for (let i = 1; i < records.length; i++) {
          const p0 = records[i - 1];
          const p1 = records[i];
          const dLon = (p1.lon - p0.lon) * Math.PI / 180;
          const lat0 = p0.lat * Math.PI / 180;
          const lat1 = p1.lat * Math.PI / 180;
          
          const x = Math.sin(dLon) * Math.cos(lat1);
          const y = Math.cos(lat0) * Math.sin(lat1) - Math.sin(lat0) * Math.cos(lat1) * Math.cos(dLon);
          let cog = Math.atan2(x, y) * 180 / Math.PI;
          if (cog < 0) cog += 360;
          
          p1.cog_deg = cog;
        }
        // Set first record COG same as second
        if (records.length > 1) {
          records[0].cog_deg = records[1].cog_deg;
        }
      }
      
      // Use heading if provided, otherwise use COG
      for (let i = 0; i < records.length; i++) {
        if (records[i].heading_deg === null || isNaN(records[i].heading_deg)) {
          records[i].heading_deg = records[i].cog_deg;
        }
      }
      
      console.log(`CSV parsed: ${records.length} records`);
      return records;
    }

    function detectFileType(arrayBuffer) {
      const buf = new Uint8Array(arrayBuffer);
      // Check for FIT signature at byte 8-11
      if (buf.length > 12) {
        const sig = String.fromCharCode(buf[8], buf[9], buf[10], buf[11]);
        if (sig === '.FIT') return 'FIT';
      }
      // Check for GPX (XML file starting with <?xml or <gpx)
      if (buf.length > 10) {
        const start = String.fromCharCode(...buf.slice(0, 100)).toLowerCase();
        if (start.includes('<?xml') || start.includes('<gpx')) return 'GPX';
      }
      // Check for CSV (starts with 'timestamp,latitude,longitude')
      if (buf.length > 40) {
        const start = String.fromCharCode(...buf.slice(0, 40));
        if (start.startsWith('timestamp,latitude,longitude')) return 'CSV';
      }
      // Check for VKX - starts with row key
      if (buf[0] >= 0 && buf[0] < 20) return 'VKX';
      return 'UNKNOWN';
    }

    // ===== ANALYSIS ENGINE =====
    let DATA = null;
    let selectedLeg = null;
    let rateChart = null;
    let corridorChart = null;
    let magCorridorChart = null;
    
    // ===== PERFORMANCE MONITORING =====
    const perfMonitor = {
      enabled: true,
      logInterval: 5000,  // Log summary every 5 seconds
      lastLogTime: 0,
      // CPU metrics
      metrics: {
        mapRender: { count: 0, totalMs: 0, maxMs: 0 },
        boatPanel: { count: 0, totalMs: 0, maxMs: 0 },
        legsPanel: { count: 0, totalMs: 0, maxMs: 0 },
        chartPointers: { count: 0, totalMs: 0, maxMs: 0 },
        timelinePointer: { count: 0, totalMs: 0, maxMs: 0 },
        playbackUI: { count: 0, totalMs: 0, maxMs: 0 },
        videoOverlays: { count: 0, totalMs: 0, maxMs: 0 },
        videoSync: { count: 0, totalMs: 0, maxMs: 0 },
        videoDecode: { count: 0, totalMs: 0, maxMs: 0 },
        videoRender: { count: 0, totalMs: 0, maxMs: 0 },
        audioProcess: { count: 0, totalMs: 0, maxMs: 0 },
        threeJsRender: { count: 0, totalMs: 0, maxMs: 0 }
      },
      // GPU metrics (frame timing based)
      gpu: {
        lastFrameTime: 0,
        frameTimes: [],  // Last 60 frame times for analysis
        textureUploads: 0,
        longFrames: 0,  // Frames > 20ms (GPU stall indicator)
        totalFrameTime: 0,
        frameCount: 0
      },
      // Track a frame for GPU timing
      trackFrame() {
        const now = performance.now();
        if (this.gpu.lastFrameTime > 0) {
          const frameTime = now - this.gpu.lastFrameTime;
          this.gpu.frameTimes.push(frameTime);
          if (this.gpu.frameTimes.length > 60) this.gpu.frameTimes.shift();
          this.gpu.totalFrameTime += frameTime;
          this.gpu.frameCount++;
          if (frameTime > 20) this.gpu.longFrames++;
        }
        this.gpu.lastFrameTime = now;
      },
      // Track texture upload
      trackTextureUpload() {
        this.gpu.textureUploads++;
      },
      track(name, fn) {
        if (!this.enabled) return fn();
        const start = performance.now();
        const result = fn();
        const elapsed = performance.now() - start;
        const m = this.metrics[name];
        if (m) {
          m.count++;
          m.totalMs += elapsed;
          if (elapsed > m.maxMs) m.maxMs = elapsed;
        }
        return result;
      },
      async trackAsync(name, fn) {
        if (!this.enabled) return fn();
        const start = performance.now();
        const result = await fn();
        const elapsed = performance.now() - start;
        const m = this.metrics[name];
        if (m) {
          m.count++;
          m.totalMs += elapsed;
          if (elapsed > m.maxMs) m.maxMs = elapsed;
        }
        return result;
      },
      logSummary() {
        const now = performance.now();
        if (now - this.lastLogTime < this.logInterval) return;
        this.lastLogTime = now;
        
        // CPU metrics
        const entries = Object.entries(this.metrics)
          .filter(([_, m]) => m.count > 0)
          .map(([name, m]) => ({
            name,
            count: m.count,
            avgMs: (m.totalMs / m.count).toFixed(1),
            maxMs: m.maxMs.toFixed(1),
            totalMs: m.totalMs.toFixed(0)
          }))
          .sort((a, b) => parseFloat(b.totalMs) - parseFloat(a.totalMs));
        
        if (entries.length > 0) {
          console.log('=== PERF SUMMARY (5s) ===');
          console.log('--- CPU ---');
          entries.forEach(e => {
            console.log(`  ${e.name}: ${e.count}x, avg=${e.avgMs}ms, max=${e.maxMs}ms, total=${e.totalMs}ms`);
          });
          
          // GPU metrics
          if (this.gpu.frameCount > 0) {
            const avgFrameTime = this.gpu.totalFrameTime / this.gpu.frameCount;
            const maxFrameTime = this.gpu.frameTimes.length > 0 ? Math.max(...this.gpu.frameTimes) : 0;
            const minFrameTime = this.gpu.frameTimes.length > 0 ? Math.min(...this.gpu.frameTimes) : 0;
            const effectiveFps = 1000 / avgFrameTime;
            const jitter = maxFrameTime - minFrameTime;
            
            console.log('--- GPU (frame timing) ---');
            console.log(`  frames: ${this.gpu.frameCount}, avgFrame=${avgFrameTime.toFixed(1)}ms, effectiveFPS=${effectiveFps.toFixed(1)}`);
            console.log(`  frameRange: ${minFrameTime.toFixed(1)}-${maxFrameTime.toFixed(1)}ms, jitter=${jitter.toFixed(1)}ms`);
            console.log(`  textureUploads: ${this.gpu.textureUploads}, longFrames(>20ms): ${this.gpu.longFrames}`);
            
            // GPU memory estimate (if available)
            if (typeof threeRenderer !== 'undefined' && threeRenderer && threeRenderer.info) {
              const info = threeRenderer.info;
              console.log(`  WebGL: geometries=${info.memory.geometries}, textures=${info.memory.textures}, programs=${info.programs?.length || 0}`);
              console.log(`  render: calls=${info.render.calls}, triangles=${info.render.triangles}, points=${info.render.points}`);
            }
          }
        }
        
        // Reset metrics
        Object.values(this.metrics).forEach(m => {
          m.count = 0;
          m.totalMs = 0;
          m.maxMs = 0;
        });
        // Reset GPU metrics
        this.gpu.textureUploads = 0;
        this.gpu.longFrames = 0;
        this.gpu.totalFrameTime = 0;
        this.gpu.frameCount = 0;
        // Keep frameTimes for rolling analysis
      }
    };
    
    // ===== RACE REPLAY STATE =====
    let raceReplayMode = false;
    let selectedSessionsForReplay = new Set();
    let replaySessionOrder = []; // Ordered array of session indices for replay
    let isPlaying = false;
    let playbackSpeed = 1;
    let playbackTime = 0;  // Current playback time in minutes
    let playbackAnimationId = null;
    let playbackLastFrameTime = 0;
    let isDraggingPlayback = false;
    let videoStalled = false;  // True when active video is buffering/stalled
    let hideGrayTracks = false;  // When true, hide past and future track portions
    let trackRecentWindow = 15;   // Minutes of full opacity (recent track)
    let trackFadeWindow = 30;     // Minutes before track turns fully gray
    let minimapZoomLevel = 1.0;   // Minimap zoom level (0.5 = zoomed out, 2.0 = zoomed in on boat)
    let cachedRacingMarks = null; // Cached racing marks (upmarks/downmarks)
    const BOAT_COLORS = ['#3b82f6', '#f59e0b', '#22c55e', '#ef4444', '#8b5cf6', '#ec4899'];
    
    // ===== VIEW MODE STATE =====
    let viewMode = 'legs';  // 'legs' or 'stats' - legs is default
    let multiSessionView = false;  // false = single session, true = multi-session comparison
    
    // ===== IFRAME MODE STATE =====
    let isIframeMode = false;
    let iframeSessionIndex = 0;
    let parentOrigin = '';
    
    // ===== UNIFIED TIME RANGE HELPERS =====
    // All times are in absolute milliseconds (GPS timestamp style)
    // This ensures consistency across all filtering operations
    
    /**
     * Get the visible time range in absolute milliseconds.
     * This considers both trim range and analysis range.
     * Uses absolute timestamps (analysisRangeStartMs/EndMs) when available.
     * @param {Object} session - Optional session object, defaults to DATA
     * @returns {Object} { startMs, endMs } or null if no data
     */
    function getVisibleTimeRangeMs(session = null) {
      const s = session || DATA;
      if (!s) return null;
      
      const sessionStartMs = s.startTimestampMs || 0;
      const fullDuration = s.fullDuration || s.s?.dur || 60;
      const trimStartMin = s.timelineStart || 0;
      const trimEndMin = s.timelineEnd || fullDuration;
      
      // Trim range in absolute ms
      let visibleStartMs = sessionStartMs + trimStartMin * 60000;
      let visibleEndMs = sessionStartMs + trimEndMin * 60000;
      
      // Apply analysis range if absolute values are set
      const hasAbsoluteAnalysisRange = analysisRangeStartMs !== null && analysisRangeEndMs !== null;
      const shouldApplyAnalysis = (ALL_SESSIONS.length > 1 || isIframeMode) && !raceReplayMode;
      
      if (isIframeMode && hasAbsoluteAnalysisRange) {
        console.log('[getVisibleTimeRangeMs] iframe mode, shouldApply:', shouldApplyAnalysis, 'hasRange:', hasAbsoluteAnalysisRange, 'analysisRange:', analysisRangeStartMs, '-', analysisRangeEndMs);
      }
      
      if (shouldApplyAnalysis && hasAbsoluteAnalysisRange) {
        // Use absolute timestamps directly - no percentage conversion needed
        // Intersect with trim range
        visibleStartMs = Math.max(visibleStartMs, analysisRangeStartMs);
        visibleEndMs = Math.min(visibleEndMs, analysisRangeEndMs);
      }
      
      return { startMs: visibleStartMs, endMs: visibleEndMs };
    }
    
    /**
     * Convert leg time (relative to trimmed track) to absolute milliseconds
     * @param {number} legTime - Time in minutes relative to trim start
     * @param {Object} session - Optional session object, defaults to DATA
     * @returns {number} Absolute time in milliseconds
     */
    function legTimeToAbsoluteMs(legTime, session = null) {
      const s = session || DATA;
      if (!s) return 0;
      
      const sessionStartMs = s.startTimestampMs || 0;
      const trimStartMin = s.timelineStart || 0;
      
      return sessionStartMs + (trimStartMin + legTime) * 60000;
    }
    
    /**
     * Convert track point time to absolute milliseconds
     * Track points have .t which is minutes from trim start
     * @param {number} pointT - Track point time (.t property)
     * @param {Object} session - Optional session object, defaults to DATA
     * @returns {number} Absolute time in milliseconds
     */
    function trackPointToAbsoluteMs(pointT, session = null) {
      const s = session || DATA;
      if (!s) return 0;
      
      const sessionStartMs = s.startTimestampMs || 0;
      const trimStartMin = s.timelineStart || 0;
      
      return sessionStartMs + (trimStartMin + pointT) * 60000;
    }
    
    /**
     * Check if a leg is visible within the current visible time range
     * @param {Object} leg - Leg object with start and end properties
     * @param {Object} session - Optional session object, defaults to DATA
     * @returns {boolean} True if leg overlaps with visible range
     */
    function isLegVisible(leg, session = null) {
      const range = getVisibleTimeRangeMs(session);
      if (!range) return true;
      
      const legStartMs = legTimeToAbsoluteMs(leg.start, session);
      const legEndMs = legTimeToAbsoluteMs(leg.end, session);
      
      // Leg is visible if it overlaps with visible range
      return legEndMs > range.startMs && legStartMs < range.endMs;
    }
    
    /**
     * Check if a track point is visible within the current visible time range
     * @param {Object} point - Track point with .t property
     * @param {Object} session - Optional session object, defaults to DATA
     * @returns {boolean} True if point is within visible range
     */
    function isTrackPointVisible(point, session = null) {
      const range = getVisibleTimeRangeMs(session);
      if (!range) return true;
      
      const pointMs = trackPointToAbsoluteMs(point.t, session);
      return pointMs >= range.startMs && pointMs <= range.endMs;
    }
    
    /**
     * Filter legs to only those visible in current range
     * @param {Array} legs - Array of leg objects
     * @param {string} posFilter - Point of sail filter ('all', 'upwind', 'reaching', 'downwind')
     * @param {Object} session - Optional session object, defaults to DATA
     * @returns {Array} Filtered array of visible legs
     */
    function getVisibleLegs(legs, posFilter = 'all', session = null) {
      if (!legs) return [];
      
      let filtered = legs;
      
      // Apply POS filter
      if (posFilter !== 'all') {
        filtered = filtered.filter(leg => leg.pos === posFilter);
      }
      
      // Apply visibility filter (trim + analysis range)
      filtered = filtered.filter(leg => isLegVisible(leg, session));
      
      return filtered;
    }
    
    /**
     * Filter intervals to only those visible in current range
     * @param {Array} intervals - Array of interval objects with .minute property
     * @param {string} posFilter - Point of sail filter
     * @param {Object} session - Optional session object, defaults to DATA
     * @returns {Array} Filtered array of visible intervals
     */
    function getVisibleIntervals(intervals, posFilter = 'all', session = null) {
      if (!intervals) return [];
      
      const s = session || DATA;
      const range = getVisibleTimeRangeMs(s);
      
      let filtered = intervals;
      
      // Apply POS filter
      if (posFilter !== 'all') {
        filtered = filtered.filter(i => i.pos === posFilter);
      }
      
      // Apply visibility filter
      if (range) {
        filtered = filtered.filter(interval => {
          const intervalMs = legTimeToAbsoluteMs(interval.minute, s);
          return intervalMs >= range.startMs && intervalMs <= range.endMs;
        });
      }
      
      return filtered;
    }
    
    // ===== END UNIFIED TIME RANGE HELPERS =====
    
    // Check if running in iframe mode via URL parameters
    (function initIframeMode() {
      const urlParams = new URLSearchParams(window.location.search);
      isIframeMode = urlParams.get('iframe') === 'true';
      iframeSessionIndex = parseInt(urlParams.get('sessionIndex') || '0', 10);
      
      if (isIframeMode) {
        console.log('[IframeMode] Running in iframe mode, session index:', iframeSessionIndex);
        
        // Add iframe-specific styles
        document.body.classList.add('iframe-mode');
        
        // Add CSS to hide elements in iframe mode
        const style = document.createElement('style');
        style.textContent = `
          .iframe-mode #upload-section { display: none !important; }
          .iframe-mode #upload-zone { display: none !important; }
          .iframe-mode #session-section { display: none !important; }
          .iframe-mode #comparison-section { display: none !important; }
          .iframe-mode #timeline-card { display: none !important; }
          .iframe-mode #timeline-section { display: none !important; }
          .iframe-mode #view-config-section { display: none !important; }
          .iframe-mode #multi-session-toggle { display: none !important; }
          .iframe-mode #multi-session-toggle-config { display: none !important; }
          .iframe-mode #start-race-replay-btn-config { display: none !important; }
          .iframe-mode .filter-row { display: none !important; }
          .iframe-mode #add-files-btn { display: none !important; }
          .iframe-mode #back-to-sessions-btn { display: none !important; }
          .iframe-mode #multi-session-split-screen { display: none !important; }
          .iframe-mode #loading { display: none !important; }
          .iframe-mode #dashboard > .card:first-child { display: none !important; }
          .iframe-mode body { 
            padding: 4px; 
            background: #f9fafb; 
            overflow: hidden !important;
            margin: 0;
            width: 100%;
          }
          .iframe-mode html {
            overflow: hidden !important;
            width: 100%;
          }
          .iframe-mode #dashboard { margin-top: 0; display: block !important; width: 100%; }
          .iframe-mode #dashboard.hidden { display: block !important; }
          .iframe-mode #dashboard-header { padding: 8px 12px; display: none !important; }
          .iframe-mode #dashboard-header h2 { font-size: 14px; }
          .iframe-mode .card { margin-bottom: 8px; width: 100%; box-sizing: border-box; }
          .iframe-mode .container { max-width: 100% !important; padding: 0 4px; }
          
          /* Prevent horizontal overflow - critical for iframe width */
          .iframe-mode #map-and-content-card {
            width: 100% !important;
            max-width: 100% !important;
            overflow: hidden;
            box-sizing: border-box;
            padding: 8px !important;
          }
          .iframe-mode #map-and-content-card > .flex {
            flex-direction: column !important;
            gap: 8px !important;
          }
          .iframe-mode #map-container {
            width: 100% !important;
            max-width: 100% !important;
            min-width: unset !important;
            position: relative;
          }
          .iframe-mode #map {
            width: 100% !important;
            max-width: 100% !important;
            height: auto !important;
            aspect-ratio: 1;
          }
          .iframe-mode #stats-panel,
          .iframe-mode #legs-panel {
            width: 100% !important;
            min-width: unset !important;
          }
          .iframe-mode #stats-and-tabs-section {
            width: 100% !important;
            max-width: 100% !important;
            overflow: hidden;
            box-sizing: border-box;
          }
          .iframe-mode .tabs-header {
            flex-wrap: wrap;
          }
          .iframe-mode table {
            width: 100% !important;
            table-layout: fixed;
          }
          .iframe-mode #legs-scroll-container,
          .iframe-mode #legs-scroll-container-side {
            overflow-x: hidden;
            overflow-y: auto;
            max-height: 320px !important;
          }
          .iframe-mode #leg-detail {
            overflow: visible;
            max-height: none !important;
          }
          /* Stack legs table and details vertically in iframe */
          .iframe-mode #tab-legs > div > div[style*="grid-template-columns"] {
            grid-template-columns: 1fr !important;
          }
          .iframe-mode #tab-legs-0 div[style*="grid-template-columns"],
          .iframe-mode #tab-legs-1 div[style*="grid-template-columns"] {
            grid-template-columns: 1fr !important;
          }
          .iframe-mode #leg-detail-0,
          .iframe-mode #leg-detail-1 {
            max-height: none !important;
            margin-top: 12px;
          }
          /* Limit iframe body height to prevent unlimited scrolling */
          .iframe-mode body {
            max-height: 3000px !important;
            overflow-y: auto !important;
          }
          .iframe-mode .card {
            margin-bottom: 8px;
          }
          .iframe-mode .chart-container {
            width: 100% !important;
            max-width: 100% !important;
          }
          .iframe-mode .chart-container canvas {
            max-width: 100% !important;
          }
          .iframe-mode #pos-breakdown {
            width: 100% !important;
          }
          .iframe-mode .flex {
            flex-wrap: wrap;
          }
          .iframe-mode #race-replay-right-column {
            min-width: unset !important;
            width: 100% !important;
          }
        `;
        document.head.appendChild(style);
        
        // Listen for messages from parent
        window.addEventListener('message', handleParentMessage);
        
        // Add keyboard listener for arrow navigation inside iframe
        document.addEventListener('keydown', function(e) {
          // Don't handle if focus is in an input field
          const activeElement = document.activeElement;
          if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT')) {
            return;
          }
          
          if (e.code === 'ArrowDown' || e.code === 'ArrowRight') {
            e.preventDefault();
            navigateLegs('next');
            // Also notify parent to sync other iframe
            sendToParent('syncNavigation', { direction: 'next' });
          } else if (e.code === 'ArrowUp' || e.code === 'ArrowLeft') {
            e.preventDefault();
            navigateLegs('prev');
            // Also notify parent to sync other iframe
            sendToParent('syncNavigation', { direction: 'prev' });
          }
        });
        
        // Signal to parent that iframe is ready
        setTimeout(() => {
          if (window.parent && window.parent !== window) {
            console.log('[IframeMode] Sending ready signal to parent');
            window.parent.postMessage({ 
              type: 'iframeReady', 
              sessionIndex: iframeSessionIndex 
            }, '*');
          }
        }, 100);
      }
    })();
    
    // Handle messages from parent window
    function handleParentMessage(event) {
      if (!isIframeMode) return;
      
      const { type, payload } = event.data || {};
      console.log('[IframeMode] Received message:', type, payload);
      
      switch (type) {
        case 'loadSession':
          // Load session data passed from parent
          if (payload.sessionData) {
            DATA = payload.sessionData;
            ALL_SESSIONS = [DATA];
            renderDashboard();
            // Pre-select first leg
            if (DATA.legs && DATA.legs.length > 0) {
              selectLeg(DATA.legs[0]);
            }
          }
          break;
          
        case 'setViewMode':
          setViewMode(payload.mode);
          break;
          
        case 'setFilter':
          const filterEl = document.getElementById('pos-filter-config');
          if (filterEl) {
            filterEl.value = payload.filter;
            applyFilter();
          }
          break;
          
        case 'setTrimRange':
          if (DATA) {
            DATA.timelineStart = payload.start;
            DATA.timelineEnd = payload.end;
            recalculateWithTrim();
          }
          break;
          
        case 'setAnalysisRange':
          // Receive absolute timestamps directly from parent
          analysisRangeStartMs = payload.startMs;
          analysisRangeEndMs = payload.endMs;
          console.log('[IframeMode] Analysis range set to:', new Date(analysisRangeStartMs).toISOString(), '-', new Date(analysisRangeEndMs).toISOString());
          console.log('[IframeMode] DATA exists:', !!DATA, 'legs:', DATA?.legs?.length, 'startTimestampMs:', DATA?.startTimestampMs);
          
          if (DATA) {
            // Debug: check visible legs before and after
            const visibleLegsBefore = DATA.legs ? DATA.legs.length : 0;
            const visibleLegsAfter = getVisibleLegs(DATA.legs, 'all').length;
            console.log('[IframeMode] Legs: total', visibleLegsBefore, 'visible after filter:', visibleLegsAfter);
            
            // Recalculate statistics based on visible legs
            recalculateFilteredStatistics();
            
            // Update all visualizations
            fitMapToVisibleTrack();
            renderMap();
            renderLegsTable();
            updateSideLegsTable();
            renderScatterCharts();
            renderPOSBreakdown();
            
            // Re-check leg selection
            preselectFirstVisibleLeg();
            
            // Report new height after content changes
            setTimeout(() => {
              const height = document.body.scrollHeight;
              sendToParent('reportHeight', { height: height });
            }, 100);
          }
          break;
          
        case 'scrollSync':
          // Sync scroll position from other iframe
          syncScrollFromParent(payload);
          break;
          
        case 'selectLeg':
          if (DATA && DATA.legs) {
            const leg = DATA.legs.find(l => l.id === payload.legId);
            if (leg) selectLeg(leg);
          }
          break;
          
        case 'navigateLeg':
          // Navigate to next/prev leg in this iframe's session
          navigateLegs(payload.direction);
          break;
          
        case 'finishInit':
          // All initialization messages received - fit map to visible track
          console.log('[IframeMode] Initialization complete, fitting map to visible track');
          setTimeout(() => {
            fitMapToVisibleTrack();
            // Also trigger a height report after map is fitted
            setTimeout(() => {
              const height = document.body.scrollHeight;
              sendToParent('reportHeight', { height: height });
            }, 100);
          }, 200);
          break;
      }
    }
    
    // Send message to parent window
    function sendToParent(type, payload) {
      if (!isIframeMode || !window.parent) return;
      window.parent.postMessage({ type, payload, sessionIndex: iframeSessionIndex }, '*');
    }
    
    // Setup height reporting for iframe auto-resize (no scrolling within iframes)
    function setupScrollSync() {
      if (!isIframeMode) return;
      
      // Report content height to parent for auto-resize
      function reportHeight() {
        const height = document.body.scrollHeight;
        sendToParent('reportHeight', { height: height });
      }
      
      // Report height after initial render and on any resize
      setTimeout(reportHeight, 500);
      setTimeout(reportHeight, 1000);
      setTimeout(reportHeight, 2000);
      
      // Also report on window resize
      window.addEventListener('resize', reportHeight);
      
      // Observe DOM changes to report height updates
      const observer = new MutationObserver(() => {
        setTimeout(reportHeight, 100);
      });
      observer.observe(document.body, { childList: true, subtree: true, attributes: true });
    }
    
    // No longer needed - iframes don't scroll
    function syncScrollFromParent(payload) {
      // Intentionally empty - no scrolling in iframes
    }
    
    // Pre-select first visible leg
    function preselectFirstVisibleLeg() {
      if (!DATA || !DATA.legs || DATA.legs.length === 0) return;
      
      const posFilter = document.getElementById('pos-filter-config')?.value || 'all';
      const filteredLegs = getVisibleLegs(DATA.legs, posFilter);
      
      if (filteredLegs.length > 0) {
        // Check if current selection is still visible
        if (selectedLeg && filteredLegs.some(l => l.id === selectedLeg.id)) {
          return; // Current selection is still valid
        }
        // Select first visible leg
        selectLeg(filteredLegs[0]);
      }
    }
    
    // Recalculate all statistics based on trim
    function recalculateWithTrim() {
      if (!DATA || !DATA.track) return;
      
      console.log('[recalculateWithTrim] Recalculating with trim:', DATA.timelineStart, '-', DATA.timelineEnd);
      
      // Recalculate statistics based on visible legs
      recalculateFilteredStatistics();
      
      // Update all visualizations
      renderMap();
      renderLegsTable();
      if (viewMode === 'legs') {
        updateSideLegsTable();
      }
      renderScatterCharts();
      renderPOSBreakdown();
      renderComparison();
      renderTimeline();
      
      // Re-check leg selection
      preselectFirstVisibleLeg();
    }
    
    // Apply analysis range changes
    /**
     * Calculate and store absolute analysis range from percentages.
     * Call this whenever replayTimelineStartPct or replayTimelineEndPct changes.
     */
    function updateAnalysisRangeFromPct() {
      if (ALL_SESSIONS.length === 0) {
        analysisRangeStartMs = null;
        analysisRangeEndMs = null;
        return;
      }
      
      // Calculate global timeline bounds
      const globalStartMs = Math.min(...ALL_SESSIONS.map(s => s.startTimestampMs || 0));
      const globalEndMs = Math.max(...ALL_SESSIONS.map(s => (s.startTimestampMs || 0) + (s.fullDuration || s.s?.dur || 60) * 60000));
      const totalDurationMs = globalEndMs - globalStartMs;
      
      // Convert percentages to absolute timestamps
      analysisRangeStartMs = globalStartMs + (replayTimelineStartPct / 100) * totalDurationMs;
      analysisRangeEndMs = globalStartMs + (replayTimelineEndPct / 100) * totalDurationMs;
      
      console.log('[updateAnalysisRangeFromPct] Range:', new Date(analysisRangeStartMs).toISOString(), '-', new Date(analysisRangeEndMs).toISOString());
    }
    
    function applyAnalysisRange() {
      if (!DATA) return;
      
      console.log('[applyAnalysisRange] Applying range:', replayTimelineStartPct, '-', replayTimelineEndPct);
      
      // Update absolute timestamps from percentages (skip in iframe mode - timestamps already set)
      if (!isIframeMode) {
        updateAnalysisRangeFromPct();
      }
      
      // Broadcast to iframes with absolute timestamps
      if (!isIframeMode && ALL_SESSIONS.length > 1) {
        broadcastToIframes('setAnalysisRange', {
          startMs: analysisRangeStartMs,
          endMs: analysisRangeEndMs
        });
      }
      
      // Recalculate statistics based on visible legs
      recalculateFilteredStatistics();
      
      // Update all visualizations
      fitMapToVisibleTrack();
      renderMap();
      renderLegsTable();
      if (viewMode === 'legs') {
        updateSideLegsTable();
      }
      renderScatterCharts();
      renderPOSBreakdown();
      renderComparison();
      
      // Re-check leg selection
      preselectFirstVisibleLeg();
    }
    
    // Recalculate statistics based on currently visible legs (filtered by trim and analysis range)
    function recalculateFilteredStatistics() {
      if (!DATA || !DATA.legs) return;
      
      // Get all visible legs (filtered by trim + analysis range)
      const allVisibleLegs = getVisibleLegs(DATA.legs, 'all');
      
      // Separate by point of sail
      const upwindLegs = allVisibleLegs.filter(l => l.pos === 'upwind');
      const downwindLegs = allVisibleLegs.filter(l => l.pos === 'downwind');
      const reachingLegs = allVisibleLegs.filter(l => l.pos === 'reaching');
      
      // Filter out stopped legs for speed/vmg calculations
      const upwindLegsMoving = upwindLegs.filter(l => parseFloat(l.speed) > 1);
      const downwindLegsMoving = downwindLegs.filter(l => parseFloat(l.speed) > 1);
      const reachingLegsMoving = reachingLegs.filter(l => parseFloat(l.speed) > 1);
      
      // Calculate statistics
      const calcMedian = (arr) => {
        if (arr.length === 0) return '-';
        const sorted = arr.slice().sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        const val = sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
        return typeof val === 'number' ? val.toFixed(1) : val;
      };
      
      const weightedAvg = (legs, prop) => {
        if (legs.length === 0) return 0;
        const totalDur = legs.reduce((s, l) => s + l.dur, 0);
        if (totalDur === 0) return 0;
        return legs.reduce((s, l) => s + (typeof l[prop] === 'string' ? parseFloat(l[prop]) : l[prop]) * l.dur, 0) / totalDur;
      };
      
      // Update statistics object
      if (upwindLegsMoving.length > 0) {
        DATA.o.speed_upwind = weightedAvg(upwindLegsMoving, 'speed').toFixed(1);
        DATA.o.vmg_upwind = weightedAvg(upwindLegsMoving, 'vmg').toFixed(1);
        DATA.o.heel_upwind = weightedAvg(upwindLegsMoving, 'heel').toFixed(0);
        DATA.o.corridor_upwind = weightedAvg(upwindLegsMoving, 'corridor').toFixed(1);
        DATA.o.mag_corridor_upwind = weightedAvg(upwindLegsMoving, 'mag_corridor').toFixed(1);
        DATA.o.mag70_upwind = weightedAvg(upwindLegsMoving, 'mag70').toFixed(1);
        DATA.o.rate_upwind = weightedAvg(upwindLegsMoving, 'rate').toFixed(2);
        DATA.o.linedev_upwind = (weightedAvg(upwindLegsMoving, 'lineDeviation') * 100).toFixed(1);
        DATA.o.lostm_upwind = Math.round(upwindLegsMoving.reduce((s, l) => s + l.lostMeters, 0));
      } else {
        DATA.o.speed_upwind = '-';
        DATA.o.vmg_upwind = '-';
        DATA.o.heel_upwind = '-';
        DATA.o.corridor_upwind = '-';
        DATA.o.mag_corridor_upwind = '-';
        DATA.o.mag70_upwind = '-';
        DATA.o.rate_upwind = '-';
        DATA.o.linedev_upwind = '-';
        DATA.o.lostm_upwind = '-';
      }
      
      if (downwindLegsMoving.length > 0) {
        DATA.o.speed_downwind = weightedAvg(downwindLegsMoving, 'speed').toFixed(1);
        DATA.o.vmg_downwind = weightedAvg(downwindLegsMoving, 'vmg').toFixed(1);
        DATA.o.heel_downwind = weightedAvg(downwindLegsMoving, 'heel').toFixed(0);
        DATA.o.corridor_downwind = weightedAvg(downwindLegsMoving, 'corridor').toFixed(1);
        DATA.o.mag_corridor_downwind = weightedAvg(downwindLegsMoving, 'mag_corridor').toFixed(1);
        DATA.o.mag70_downwind = weightedAvg(downwindLegsMoving, 'mag70').toFixed(1);
        DATA.o.rate_downwind = weightedAvg(downwindLegsMoving, 'rate').toFixed(2);
        DATA.o.linedev_downwind = (weightedAvg(downwindLegsMoving, 'lineDeviation') * 100).toFixed(1);
        DATA.o.lostm_downwind = Math.round(downwindLegsMoving.reduce((s, l) => s + l.lostMeters, 0));
      } else {
        DATA.o.speed_downwind = '-';
        DATA.o.vmg_downwind = '-';
        DATA.o.heel_downwind = '-';
        DATA.o.corridor_downwind = '-';
        DATA.o.mag_corridor_downwind = '-';
        DATA.o.mag70_downwind = '-';
        DATA.o.rate_downwind = '-';
        DATA.o.linedev_downwind = '-';
        DATA.o.lostm_downwind = '-';
      }
      
      // Recalculate POS breakdown data
      const totalDur = allVisibleLegs.reduce((s, l) => s + l.dur, 0) || 1;
      
      DATA.pos = {
        upwind: {
          time: upwindLegs.reduce((s, l) => s + l.dur, 0),
          pct: ((upwindLegs.reduce((s, l) => s + l.dur, 0) / totalDur) * 100).toFixed(0),
          speed: DATA.o.speed_upwind,
          vmg: DATA.o.vmg_upwind,
          corridor: DATA.o.corridor_upwind,
          rate: DATA.o.rate_upwind,
          heel: DATA.o.heel_upwind,
          linedev: DATA.o.linedev_upwind,
          lostm: DATA.o.lostm_upwind
        },
        reaching: {
          time: reachingLegs.reduce((s, l) => s + l.dur, 0),
          pct: ((reachingLegs.reduce((s, l) => s + l.dur, 0) / totalDur) * 100).toFixed(0),
          speed: reachingLegsMoving.length ? weightedAvg(reachingLegsMoving, 'speed').toFixed(1) : '-',
          vmg: reachingLegsMoving.length ? weightedAvg(reachingLegsMoving, 'vmg').toFixed(1) : '-',
          corridor: reachingLegsMoving.length ? weightedAvg(reachingLegsMoving, 'corridor').toFixed(1) : '-',
          rate: reachingLegsMoving.length ? weightedAvg(reachingLegsMoving, 'rate').toFixed(2) : '-',
          heel: reachingLegsMoving.length ? weightedAvg(reachingLegsMoving, 'heel').toFixed(0) : '-',
          linedev: reachingLegsMoving.length ? (weightedAvg(reachingLegsMoving, 'lineDeviation') * 100).toFixed(1) : '-',
          lostm: reachingLegsMoving.length ? Math.round(reachingLegsMoving.reduce((s, l) => s + l.lostMeters, 0)) : '-'
        },
        downwind: {
          time: downwindLegs.reduce((s, l) => s + l.dur, 0),
          pct: ((downwindLegs.reduce((s, l) => s + l.dur, 0) / totalDur) * 100).toFixed(0),
          speed: DATA.o.speed_downwind,
          vmg: DATA.o.vmg_downwind,
          corridor: DATA.o.corridor_downwind,
          rate: DATA.o.rate_downwind,
          heel: DATA.o.heel_downwind,
          linedev: DATA.o.linedev_downwind,
          lostm: DATA.o.lostm_downwind
        }
      };
      
      // Update stats display
      updateStatsDisplay();
    }
    
    // Update the stats display elements
    function updateStatsDisplay() {
      if (!DATA || !DATA.o) return;
      
      const speedUp = document.getElementById('speed-up');
      const speedDown = document.getElementById('speed-down');
      const heelUp = document.getElementById('heel-up');
      const heelDown = document.getElementById('heel-down');
      const corrUp = document.getElementById('corr-up');
      const corrDown = document.getElementById('corr-down');
      const magUp = document.getElementById('mag-up');
      const magDown = document.getElementById('mag-down');
      const mag70Up = document.getElementById('mag70-up');
      const mag70Down = document.getElementById('mag70-down');
      const linedevUp = document.getElementById('linedev-up');
      const linedevDown = document.getElementById('linedev-down');
      const rateUp = document.getElementById('rate-up');
      const rateDown = document.getElementById('rate-down');
      
      if (speedUp) speedUp.textContent = `${DATA.o.speed_upwind}/${DATA.o.vmg_upwind}`;
      if (speedDown) speedDown.textContent = `${DATA.o.speed_downwind}/${DATA.o.vmg_downwind}`;
      if (heelUp) heelUp.textContent = DATA.o.heel_upwind + '¬∞';
      if (heelDown) heelDown.textContent = DATA.o.heel_downwind + '¬∞';
      if (corrUp) corrUp.textContent = '¬±' + DATA.o.corridor_upwind + '¬∞';
      if (corrDown) corrDown.textContent = '¬±' + DATA.o.corridor_downwind + '¬∞';
      if (magUp) magUp.textContent = DATA.o.mag_corridor_upwind + '¬∞';
      if (magDown) magDown.textContent = DATA.o.mag_corridor_downwind + '¬∞';
      if (mag70Up) mag70Up.textContent = DATA.o.mag70_upwind + '¬∞';
      if (mag70Down) mag70Down.textContent = DATA.o.mag70_downwind + '¬∞';
      if (linedevUp) linedevUp.textContent = DATA.o.linedev_upwind !== '-' ? `${DATA.o.linedev_upwind}% (${DATA.o.lostm_upwind}m)` : '-';
      if (linedevDown) linedevDown.textContent = DATA.o.linedev_downwind !== '-' ? `${DATA.o.linedev_downwind}% (${DATA.o.lostm_downwind}m)` : '-';
      if (rateUp) rateUp.textContent = DATA.o.rate_upwind + '¬∞/s';
      if (rateDown) rateDown.textContent = DATA.o.rate_downwind + '¬∞/s';
    }
    
    function updateMultiSessionToggleVisibility() {
      const toggle = document.getElementById('multi-session-toggle');
      if (!toggle) return;
      
      // Show toggle only in aligned timeline mode (2+ sessions, not race replay)
      const hasMultipleSessions = ALL_SESSIONS.length > 1;
      const inAlignedMode = hasMultipleSessions && !raceReplayMode;
      
      console.log('[updateMultiSessionToggleVisibility]', {
        hasMultipleSessions,
        raceReplayMode,
        inAlignedMode,
        willShow: inAlignedMode
      });
      
      if (inAlignedMode) {
        toggle.classList.remove('hidden');
        toggle.style.display = 'flex';
      } else {
        toggle.classList.add('hidden');
        toggle.style.display = 'none';
        
        // If leaving aligned mode, disable multi-session view
        if (multiSessionView) {
          multiSessionView = false;
          const checkbox = document.getElementById('multi-session-view-checkbox');
          if (checkbox) checkbox.checked = false;
          const configCheckbox = document.getElementById('multi-session-view-checkbox-config');
          if (configCheckbox) configCheckbox.checked = false;
        }
      }
      
      // Update view config card visibility
      updateViewConfigCard();
    }
    
    function toggleMultiSessionView() {
      // Prevent enabling multi-session view during race replay
      if (raceReplayMode) {
        console.log('[toggleMultiSessionView] Blocked - race replay mode is active');
        const checkbox = document.getElementById('multi-session-view-checkbox');
        if (checkbox) checkbox.checked = false;
        return;
      }
      
      const checkbox = document.getElementById('multi-session-view-checkbox');
      multiSessionView = checkbox ? checkbox.checked : false;
      
      // Sync with config card checkbox
      const configCheckbox = document.getElementById('multi-session-view-checkbox-config');
      if (configCheckbox) configCheckbox.checked = multiSessionView;
      
      console.log('Multi-session view toggled:', multiSessionView);
      console.log('ALL_SESSIONS.length:', ALL_SESSIONS.length);
      console.log('raceReplayMode:', raceReplayMode);
      
      if (multiSessionView && ALL_SESSIONS.length > 1) {
        // Enable split-screen mode
        enableSplitScreenMode();
      } else {
        // Disable split-screen mode, return to normal
        disableSplitScreenMode();
      }
    }
    
    function toggleMultiSessionViewConfig() {
      // Prevent enabling multi-session view during race replay
      if (raceReplayMode) {
        console.log('[toggleMultiSessionViewConfig] Blocked - race replay mode is active');
        const configCheckbox = document.getElementById('multi-session-view-checkbox-config');
        if (configCheckbox) configCheckbox.checked = false;
        return;
      }
      
      const configCheckbox = document.getElementById('multi-session-view-checkbox-config');
      multiSessionView = configCheckbox ? configCheckbox.checked : false;
      
      // Sync with header checkbox
      const checkbox = document.getElementById('multi-session-view-checkbox');
      if (checkbox) checkbox.checked = multiSessionView;
      
      console.log('Multi-session view toggled (config):', multiSessionView);
      
      if (multiSessionView && ALL_SESSIONS.length > 1) {
        enableSplitScreenMode();
      } else {
        disableSplitScreenMode();
      }
    }
    
    function applyFilterConfig() {
      // Call the existing applyFilter function which now uses pos-filter-config
      applyFilter();
    }
    
    function startRaceReplayFromConfig() {
      // Call the main startRaceReplay function
      if (typeof startRaceReplay === 'function') {
        startRaceReplay();
      }
    }
    
    function updateViewConfigCard() {
      const hasMultipleSessions = ALL_SESSIONS.length > 1;
      const multiToggle = document.getElementById('multi-session-toggle-config');
      const raceReplayBtn = document.getElementById('start-race-replay-btn-config');
      
      // Show multi-session toggle if multiple sessions and not in race replay mode
      if (multiToggle) {
        const showMultiToggle = hasMultipleSessions && !raceReplayMode;
        multiToggle.classList.toggle('hidden', !showMultiToggle);
        multiToggle.style.display = showMultiToggle ? 'flex' : 'none';
      }
      
      // Show race replay button if multiple sessions selected and not in race replay mode
      if (raceReplayBtn) {
        const showReplayBtn = hasMultipleSessions && !raceReplayMode && selectedSessionsForReplay.size >= 2;
        raceReplayBtn.classList.toggle('hidden', !showReplayBtn);
        raceReplayBtn.textContent = `üèÅ Start Race Replay (${selectedSessionsForReplay.size})`;
      }
      
      // Show/hide the hide gray toggle based on race replay mode
      const hideGrayContainer = document.getElementById('hide-gray-toggle-container');
      if (hideGrayContainer) {
        hideGrayContainer.style.display = raceReplayMode ? 'flex' : 'none';
      }
    }
    
    function enableSplitScreenMode() {
      console.log('[enableSplitScreenMode] Creating iframe-based split-screen layout');
      console.log('[enableSplitScreenMode] ALL_SESSIONS:', ALL_SESSIONS.length);
      
      // Hide normal dashboard elements
      document.getElementById('map-and-content-card').style.display = 'none';
      document.getElementById('stats-and-tabs-section').style.display = 'none';
      
      // Hide selected leg badge in multi-session mode
      const selectedLegBadge = document.getElementById('selected-leg-badge-config');
      if (selectedLegBadge) selectedLegBadge.style.display = 'none';
      
      // Get or create split-screen container
      let splitScreen = document.getElementById('multi-session-split-screen');
      
      if (!splitScreen) {
        console.error('[enableSplitScreenMode] Split screen element not found!');
        return;
      }
      
      // Store session order for drag reordering
      window.iframeSessionOrder = [0, 1];
      
      // Track which iframes are ready
      window.iframeReadyState = [false, false];
      window.pendingSessionData = [];
      
      // Store sessions for later use
      const sessions = ALL_SESSIONS.slice(0, 2);
      window.pendingSessionData = sessions.map((session, idx) => ({
        session: session,
        idx: idx
      }));
      
      // Create iframe-based split screen HTML
      splitScreen.innerHTML = `
        <div id="iframe-comparison-container" style="display:grid;grid-template-columns:1fr 1fr;gap:16px;width:100%;">
          <!-- Session List Headers (draggable) -->
          <div id="session-header-0" class="session-header-draggable" draggable="true" ondragstart="handleSessionDragStart(event, 0)" ondragover="handleSessionDragOver(event)" ondrop="handleSessionDrop(event, 0)" style="cursor:grab;padding:12px;background:#f3f4f6;border-radius:8px;border-left:4px solid #3b82f6;margin-bottom:8px;">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <h3 id="session-title-iframe-0" style="margin:0;color:#3b82f6;font-size:14px;">Loading...</h3>
              <span style="font-size:20px;cursor:grab;">‚†ø</span>
            </div>
            <p id="session-subtitle-iframe-0" class="text-xs" style="color:#6b7280;margin:4px 0 0 0;"></p>
          </div>
          <div id="session-header-1" class="session-header-draggable" draggable="true" ondragstart="handleSessionDragStart(event, 1)" ondragover="handleSessionDragOver(event)" ondrop="handleSessionDrop(event, 1)" style="cursor:grab;padding:12px;background:#f3f4f6;border-radius:8px;border-left:4px solid #f59e0b;margin-bottom:8px;">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <h3 id="session-title-iframe-1" style="margin:0;color:#f59e0b;font-size:14px;">Loading...</h3>
              <span style="font-size:20px;cursor:grab;">‚†ø</span>
            </div>
            <p id="session-subtitle-iframe-1" class="text-xs" style="color:#6b7280;margin:4px 0 0 0;"></p>
          </div>
          <!-- Iframes - no scrolling, height auto-resizes to content -->
          <iframe id="session-iframe-0" scrolling="no" style="width:100%;border:1px solid #e5e7eb;border-radius:8px;background:#f9fafb;overflow:hidden;"></iframe>
          <iframe id="session-iframe-1" scrolling="no" style="width:100%;border:1px solid #e5e7eb;border-radius:8px;background:#f9fafb;overflow:hidden;"></iframe>
        </div>
      `;
      
      splitScreen.classList.remove('hidden');
      splitScreen.style.display = 'block';
      
      const colors = ['#3b82f6', '#f59e0b'];
      
      sessions.forEach((session, idx) => {
        console.log(`[enableSplitScreenMode] Initializing iframe for session ${idx}:`, session.filename);
        
        // Update header
        const titleEl = document.getElementById(`session-title-iframe-${idx}`);
        const subtitleEl = document.getElementById(`session-subtitle-iframe-${idx}`);
        
        if (titleEl) {
          const shortName = session.filename.replace(/\.(vkx|fit|gpx|csv|gz)$/gi, '').replace(/[_-]/g, ' ');
          titleEl.textContent = shortName;
        }
        if (subtitleEl) {
          subtitleEl.textContent = `${session.s.d} | ${session.s.dur} min | Wind ${session.s.twd}¬∞`;
        }
        
        // Load iframe with current page in iframe mode
        const iframe = document.getElementById(`session-iframe-${idx}`);
        if (iframe) {
          // Set src to current page with iframe mode params
          const currentUrl = new URL(window.location.href);
          currentUrl.searchParams.set('iframe', 'true');
          currentUrl.searchParams.set('sessionIndex', idx.toString());
          iframe.src = currentUrl.toString();
        }
      });
      
      // Setup message listener for iframe communication
      setupIframeMessageListener();
      
      console.log('[enableSplitScreenMode] Iframe split-screen setup complete');
    }
    
    // Initialize iframe with session data via postMessage
    function initializeIframeSession(idx, session) {
      const iframe = document.getElementById(`session-iframe-${idx}`);
      if (!iframe || !iframe.contentWindow) return;
      
      console.log(`[initializeIframeSession] Sending data to iframe ${idx}`);
      
      // Create a serializable copy of session data (exclude functions)
      function serializeSessionData(obj, depth = 0) {
        if (depth > 50) return null; // Prevent stack overflow
        if (obj === null || obj === undefined) return obj;
        if (typeof obj === 'function') return undefined;
        if (typeof obj !== 'object') return obj;
        if (Array.isArray(obj)) {
          return obj.map(item => serializeSessionData(item, depth + 1)).filter(item => item !== undefined);
        }
        const result = {};
        for (const key in obj) {
          if (obj.hasOwnProperty(key)) {
            const value = serializeSessionData(obj[key], depth + 1);
            if (value !== undefined) {
              result[key] = value;
            }
          }
        }
        return result;
      }
      
      const serializedSession = serializeSessionData(session);
      
      // Send session data to iframe immediately (iframe already signaled ready)
      try {
        iframe.contentWindow.postMessage({
          type: 'loadSession',
          payload: {
            sessionData: serializedSession,
            sessionIndex: idx
          }
        }, '*');
        
        // Send current view mode
        iframe.contentWindow.postMessage({
          type: 'setViewMode',
          payload: { mode: viewMode }
        }, '*');
        
        // Send current filter
        const filterEl = document.getElementById('pos-filter-config');
        if (filterEl) {
          iframe.contentWindow.postMessage({
            type: 'setFilter',
            payload: { filter: filterEl.value }
          }, '*');
        }
        
        // Send trim range if set
        if (session.timelineStart !== undefined || session.timelineEnd !== undefined) {
          iframe.contentWindow.postMessage({
            type: 'setTrimRange',
            payload: {
              start: session.timelineStart || 0,
              end: session.timelineEnd || (session.fullDuration || session.s.dur)
            }
          }, '*');
        }
        
        // Send analysis range as absolute timestamps
        // Calculate if not already set
        if (analysisRangeStartMs === null || analysisRangeEndMs === null) {
          updateAnalysisRangeFromPct();
        }
        
        if (analysisRangeStartMs !== null && analysisRangeEndMs !== null) {
          iframe.contentWindow.postMessage({
            type: 'setAnalysisRange',
            payload: {
              startMs: analysisRangeStartMs,
              endMs: analysisRangeEndMs
            }
          }, '*');
        }
        
        // Signal that all initialization is done - now fit map to visible track
        iframe.contentWindow.postMessage({
          type: 'finishInit'
        }, '*');
        
        console.log(`[initializeIframeSession] Data sent to iframe ${idx}`);
      } catch (e) {
        console.error(`[initializeIframeSession] Error sending data to iframe ${idx}:`, e);
      }
    }
    
    // Setup listener for messages from iframes
    function setupIframeMessageListener() {
      if (window.iframeMessageListenerSetup) return;
      window.iframeMessageListenerSetup = true;
      
      // Track iframe heights
      window.iframeHeights = [0, 0];
      
      window.addEventListener('message', (event) => {
        if (isIframeMode) return; // Don't process if we're in an iframe ourselves
        
        const { type, payload, sessionIndex } = event.data || {};
        
        if (type === 'iframeReady') {
          console.log(`[Parent] Iframe ${sessionIndex} is ready`);
          
          // Mark this iframe as ready
          if (window.iframeReadyState) {
            window.iframeReadyState[sessionIndex] = true;
          }
          
          // Send session data to this iframe
          if (window.pendingSessionData && window.pendingSessionData[sessionIndex]) {
            const { session, idx } = window.pendingSessionData[sessionIndex];
            initializeIframeSession(idx, session);
          }
        }
        
        if (type === 'reportHeight') {
          // Resize iframe to fit content
          const iframe = document.getElementById(`session-iframe-${sessionIndex}`);
          if (iframe && payload.height) {
            // Store height - cap at reasonable maximum to prevent unlimited scrolling
            const maxAllowedHeight = 3000;
            window.iframeHeights[sessionIndex] = Math.min(payload.height, maxAllowedHeight);
            
            // Use the maximum height of both iframes so they stay aligned
            const maxHeight = Math.max(...window.iframeHeights);
            
            // Set both iframes to the same height
            [0, 1].forEach(idx => {
              const iframeEl = document.getElementById(`session-iframe-${idx}`);
              if (iframeEl) {
                iframeEl.style.height = `${maxHeight + 20}px`;
              }
            });
          }
        }
        
        if (type === 'syncNavigation') {
          // Forward navigation to the OTHER iframe (not the one that sent it)
          const otherIdx = sessionIndex === 0 ? 1 : 0;
          const otherIframe = document.getElementById(`session-iframe-${otherIdx}`);
          if (otherIframe && otherIframe.contentWindow) {
            otherIframe.contentWindow.postMessage({ 
              type: 'navigateLeg', 
              payload: { direction: payload.direction } 
            }, '*');
          }
        }
      });
    }
    
    // Broadcast message to all iframes
    function broadcastToIframes(type, payload) {
      [0, 1].forEach(idx => {
        const iframe = document.getElementById(`session-iframe-${idx}`);
        if (iframe && iframe.contentWindow) {
          iframe.contentWindow.postMessage({ type, payload }, '*');
        }
      });
    }
    
    // Handle drag start for session reordering
    function handleSessionDragStart(event, headerIdx) {
      event.dataTransfer.setData('text/plain', headerIdx.toString());
      event.dataTransfer.effectAllowed = 'move';
      event.target.style.opacity = '0.5';
    }
    
    // Handle drag over
    function handleSessionDragOver(event) {
      event.preventDefault();
      event.dataTransfer.dropEffect = 'move';
    }
    
    // Handle drop for session reordering
    function handleSessionDrop(event, targetIdx) {
      event.preventDefault();
      const sourceIdx = parseInt(event.dataTransfer.getData('text/plain'), 10);
      
      // Reset opacity
      document.querySelectorAll('.session-header-draggable').forEach(el => {
        el.style.opacity = '1';
      });
      
      if (sourceIdx === targetIdx) return;
      
      console.log(`[handleSessionDrop] Swapping sessions ${sourceIdx} and ${targetIdx}`);
      
      // Swap sessions in order array
      const temp = window.iframeSessionOrder[sourceIdx];
      window.iframeSessionOrder[sourceIdx] = window.iframeSessionOrder[targetIdx];
      window.iframeSessionOrder[targetIdx] = temp;
      
      // Swap iframes
      const container = document.getElementById('iframe-comparison-container');
      const iframe0 = document.getElementById('session-iframe-0');
      const iframe1 = document.getElementById('session-iframe-1');
      const header0 = document.getElementById('session-header-0');
      const header1 = document.getElementById('session-header-1');
      
      // Swap by reordering in DOM
      if (sourceIdx === 0 && targetIdx === 1) {
        container.insertBefore(header1, header0);
        container.insertBefore(iframe1, iframe0);
      } else {
        container.insertBefore(header0, header1);
        container.insertBefore(iframe0, iframe1);
      }
    }
    
    function switchTabSession(sessionIdx, tabName) {
      const context = window.sessionContexts[sessionIdx];
      if (!context) return;
      
      context.activeTab = tabName;
      
      // Update tab buttons
      const tabs = document.querySelectorAll(`.tab[data-session="${sessionIdx}"]`);
      tabs.forEach(tab => {
        if (tab.getAttribute('data-tab') === `${tabName}-${sessionIdx}`) {
          tab.classList.add('active');
        } else {
          tab.classList.remove('active');
        }
      });
      
      // Show/hide tab content
      ['legs', 'steering', 'pos'].forEach(t => {
        const el = document.getElementById(`tab-${t}-${sessionIdx}`);
        if (el) {
          el.classList.toggle('hidden', t !== tabName);
        }
      });
    }
    
    function zoomMapSession(sessionIdx, factor) {
      const context = window.sessionContexts[sessionIdx];
      if (!context) return;
      
      context.mapZoom = Math.max(0.5, Math.min(30, context.mapZoom * factor));
      renderSessionMap(sessionIdx);
    }
    
    function resetMapZoomSession(sessionIdx) {
      const context = window.sessionContexts[sessionIdx];
      if (!context) return;
      
      context.mapZoom = 1;
      context.mapPanX = 0;
      context.mapPanY = 0;
      renderSessionMap(sessionIdx);
    }
    
    function toggleSessionProjection(sessionIdx) {
      const context = window.sessionContexts[sessionIdx];
      if (!context) return;
      
      const checkbox = document.getElementById(`proj-toggle-${sessionIdx}`);
      const label = document.getElementById(`proj-label-${sessionIdx}`);
      const slider = document.getElementById(`proj-slider-${sessionIdx}`);
      
      context.mapProjection = checkbox.checked ? 'geo' : 'compass';
      label.textContent = checkbox.checked ? 'Geo' : 'Compass';
      
      // Update slider position
      if (checkbox.checked) {
        slider.style.transform = 'translateX(14px)';
        slider.parentElement.previousElementSibling.style.backgroundColor = '#3b82f6';
      } else {
        slider.style.transform = 'translateX(0)';
        slider.parentElement.previousElementSibling.style.backgroundColor = '#ccc';
      }
      
      renderSessionMap(sessionIdx);
    }
    
    function toggleHideGraySession(sessionIdx) {
      const context = window.sessionContexts[sessionIdx];
      if (!context) return;
      
      const checkbox = document.getElementById(`hide-gray-tracks-${sessionIdx}`);
      const slider = document.getElementById(`hide-gray-slider-${sessionIdx}`);
      
      context.hideGrayTracks = checkbox.checked;
      
      // Update slider position
      if (checkbox.checked) {
        slider.style.transform = 'translateX(14px)';
        slider.parentElement.previousElementSibling.style.backgroundColor = '#3b82f6';
      } else {
        slider.style.transform = 'translateX(0)';
        slider.parentElement.previousElementSibling.style.backgroundColor = '#ccc';
      }
      
      renderSessionMap(sessionIdx);
    }
    
    function disableSplitScreenMode() {
      console.log('[disableSplitScreenMode] Returning to normal dashboard');
      
      // Clean up iframe message listener flag
      window.iframeMessageListenerSetup = false;
      window.iframeSessionOrder = null;
      
      // Destroy session charts (if any legacy contexts exist)
      if (window.sessionContexts) {
        window.sessionContexts.forEach((ctx, idx) => {
          if (ctx && ctx.charts) {
            Object.values(ctx.charts).forEach(chart => {
              if (chart && chart.destroy) chart.destroy();
            });
          }
        });
        window.sessionContexts = [];
      }
      
      // Show normal dashboard elements
      document.getElementById('map-and-content-card').style.display = '';
      document.getElementById('stats-and-tabs-section').style.display = '';
      
      // Show selected leg badge again
      const selectedLegBadge = document.getElementById('selected-leg-badge-config');
      if (selectedLegBadge) selectedLegBadge.style.display = '';
      
      // Hide split-screen container and clear iframes
      const splitScreen = document.getElementById('multi-session-split-screen');
      if (splitScreen) {
        // Remove iframes to stop any running processes
        const iframe0 = document.getElementById('session-iframe-0');
        const iframe1 = document.getElementById('session-iframe-1');
        if (iframe0) iframe0.src = 'about:blank';
        if (iframe1) iframe1.src = 'about:blank';
        
        splitScreen.classList.add('hidden');
        splitScreen.style.display = 'none';
      }
      
      // Re-render normal dashboard
      renderDashboard();
    }
    
    // ===== SESSION DASHBOARD RENDERING FUNCTIONS =====
    
    function renderSessionDashboard(sessionIdx) {
      console.log(`[renderSessionDashboard] Starting for session ${sessionIdx}`);
      
      const ctx = window.sessionContexts[sessionIdx];
      if (!ctx) {
        console.error(`[renderSessionDashboard] No context for session ${sessionIdx}`);
        return;
      }
      
      const session = ctx.DATA;
      console.log(`[renderSessionDashboard] Session data:`, session.filename);
      
      // Update header
      const titleEl = document.getElementById(`session-title-${sessionIdx}`);
      const subtitleEl = document.getElementById(`session-subtitle-${sessionIdx}`);
      
      console.log(`[renderSessionDashboard] Title element:`, !!titleEl);
      console.log(`[renderSessionDashboard] Subtitle element:`, !!subtitleEl);
      
      if (titleEl && subtitleEl) {
        const shortName = session.filename.replace(/\.(vkx|fit|gpx|csv|gz)$/gi, '').replace(/[_-]/g, ' ');
        const legs = session.legs;
        const bestCorr = legs.length > 0 ? Math.min(...legs.map(l => l.corridor)) : 0;
        
        titleEl.textContent = shortName;
        subtitleEl.innerHTML = `
          ${session.s.d} | ${session.s.dur} min | Wind ${session.s.twd}¬∞ (${session.s.twdSource}) | 
          Best COG: <span style="color:${getCorridorColor(bestCorr)};font-weight:bold;">¬±${bestCorr.toFixed(1)}¬∞</span>
        `;
      }
      
      // Update session stats
      const statsLegs = document.getElementById(`stat-legs-${sessionIdx}`);
      const statsSpeed = document.getElementById(`stat-speed-${sessionIdx}`);
      const statsVmg = document.getElementById(`stat-vmg-${sessionIdx}`);
      
      if (statsLegs && statsSpeed && statsVmg) {
        const legs = session.legs;
        const totalLegs = legs.length;
        
        // Calculate avg speed (weighted by leg duration)
        const totalDuration = legs.reduce((sum, leg) => sum + leg.dur, 0);
        const weightedSpeedSum = legs.reduce((sum, leg) => sum + parseFloat(leg.speed) * leg.dur, 0);
        const avgSpeed = totalDuration > 0 ? (weightedSpeedSum / totalDuration).toFixed(1) : '0.0';
        
        // Find best VMG across all legs
        const bestVmg = legs.length > 0 ? Math.max(...legs.map(l => parseFloat(l.vmg))).toFixed(1) : '0.0';
        
        statsLegs.textContent = totalLegs;
        statsSpeed.textContent = avgSpeed + ' kts';
        statsVmg.textContent = bestVmg + ' kts';
      }
      
      // Render all components
      console.log(`[renderSessionDashboard] Calling renderSessionMap(${sessionIdx})`);
      renderSessionMap(sessionIdx);
      
      console.log(`[renderSessionDashboard] Calling renderSessionLegsTable(${sessionIdx})`);
      renderSessionLegsTable(sessionIdx);
      
      console.log(`[renderSessionDashboard] Calling renderSessionCharts(${sessionIdx})`);
      renderSessionCharts(sessionIdx);
      
      console.log(`[renderSessionDashboard] Calling renderSessionPOSBreakdown(${sessionIdx})`);
      renderSessionPOSBreakdown(sessionIdx);
      
      console.log(`[renderSessionDashboard] Complete for session ${sessionIdx}`);
    }
    
    function selectSessionLeg(sessionIdx, leg) {
      const ctx = window.sessionContexts[sessionIdx];
      if (!ctx) return;
      
      // Toggle selection
      if (ctx.selectedLeg?.id === leg?.id) {
        ctx.selectedLeg = null;
        ctx.selectedInterval = null;
      } else {
        ctx.selectedLeg = leg;
      }
      
      // Update interval help text
      const helpEl = document.getElementById(`interval-help-${sessionIdx}`);
      if (helpEl) {
        if (ctx.selectedLeg) {
          helpEl.innerHTML = `<span class="text-purple" style="font-weight:500;">Leg #${ctx.selectedLeg.id} selected</span> - <button onclick="switchTabSession(${sessionIdx}, 'legs')" style="color:#7c3aed;text-decoration:underline;background:none;border:none;cursor:pointer;font-size:11px;">view details ‚Üí</button>`;
        } else {
          helpEl.textContent = 'Click dots to select leg on map.';
        }
      }
      
      // Re-render affected components
      renderSessionMap(sessionIdx);
      renderSessionLegsTable(sessionIdx);
      renderSessionCharts(sessionIdx); // Re-render to update highlighting
      if (ctx.selectedLeg) {
        renderSessionLegDetail(sessionIdx, ctx.selectedLeg);
      } else {
        document.getElementById(`leg-detail-${sessionIdx}`).innerHTML = '<div style="color:#6b7280;text-align:center;padding:40px;">Select a leg to view details</div>';
      }
    }
    
    function renderSessionMap(sessionIdx) {
      console.log(`[renderSessionMap] Starting for session ${sessionIdx}`);
      
      const ctx = window.sessionContexts[sessionIdx];
      if (!ctx) {
        console.error(`[renderSessionMap] No context for session ${sessionIdx}`);
        return;
      }
      
      const session = ctx.DATA;
      const svg = document.getElementById(`map-${sessionIdx}`);
      
      console.log(`[renderSessionMap] SVG element found:`, !!svg);
      
      if (!svg) {
        console.error(`[renderSessionMap] SVG element map-${sessionIdx} not found`);
        return;
      }
      
      const container = svg.parentElement;
      const width = container.clientWidth || 500;
      const height = 400;
      const padding = 20;
      
      console.log(`[renderSessionMap] Map dimensions: ${width}x${height}`);
      
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      
      // Calculate bounds
      const track = session.track;
      if (!track || track.length === 0) {
        console.error(`[renderSessionMap] No track data for session ${sessionIdx}`);
        return;
      }
      
      console.log(`[renderSessionMap] Track has ${track.length} points`);
      console.log(`[renderSessionMap] Legs count: ${session.legs.length}`);
      
      const lats = track.map(p => p.lat);
      const lons = track.map(p => p.lon);
      const minLat = Math.min(...lats);
      const maxLat = Math.max(...lats);
      const minLon = Math.min(...lons);
      const maxLon = Math.max(...lons);
      
      const latRange = maxLat - minLat || 0.001;
      const lonRange = maxLon - minLon || 0.001;
      
      const centerLat = (minLat + maxLat) / 2;
      
      // Apply projection (lat correction)
      const latCorrection = ctx.mapProjection === 'geo' ? Math.cos(centerLat * Math.PI / 180) : 1;
      const lonRangeCorrected = lonRange * latCorrection;
      
      const scale = Math.min((width - 2*padding) / lonRangeCorrected, (height - 2*padding) / latRange) * 0.9;
      
      const lonToX = lon => padding + (lon - minLon) * latCorrection * scale + (width - 2*padding - lonRangeCorrected * scale) / 2;
      const latToY = lat => height - padding - (lat - minLat) * scale - (height - 2*padding - latRange * scale) / 2;
      
      // Apply zoom and pan
      const zoom = ctx.mapZoom;
      const panX = ctx.mapPanX;
      const panY = ctx.mapPanY;
      
      const vbWidth = width / zoom;
      const vbHeight = height / zoom;
      const vbX = (width - vbWidth) / 2 + panX;
      const vbY = (height - vbHeight) / 2 + panY;
      svg.setAttribute('viewBox', `${vbX} ${vbY} ${vbWidth} ${vbHeight}`);
      
      const markerScale = 1 / zoom;
      
      // Build SVG
      let html = `<rect width="${width}" height="${height}" fill="#f9fafb"/>`;
      
      // Grid
      [0.25, 0.5, 0.75].forEach(f => {
        const y = padding + (height - 2*padding) * f;
        const x = padding + (width - 2*padding) * f;
        html += `<line x1="${padding}" y1="${y}" x2="${width-padding}" y2="${y}" stroke="#e5e7eb" stroke-dasharray="4" vector-effect="non-scaling-stroke"/>`;
        html += `<line x1="${x}" y1="${padding}" x2="${x}" y2="${height-padding}" stroke="#e5e7eb" stroke-dasharray="4" vector-effect="non-scaling-stroke"/>`;
      });
      
      // Base track (gray) - only if hideGrayTracks is false
      if (!ctx.hideGrayTracks) {
        for (let i = 1; i < track.length; i++) {
          const p0 = track[i - 1], p1 = track[i];
          html += `<line x1="${lonToX(p0.lon)}" y1="${latToY(p0.lat)}" x2="${lonToX(p1.lon)}" y2="${latToY(p1.lat)}" stroke="#d1d5db" stroke-width="2" stroke-linecap="round" vector-effect="non-scaling-stroke"/>`;
        }
      }
      
      // Draw legs
      const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };
      
      session.legs.forEach(leg => {
        const legPoints = track.filter(p => p.t >= leg.start && p.t <= leg.end);
        if (legPoints.length < 2) return;
        
        const color = posColors[leg.pos] || '#6b7280';
        const isSelected = ctx.selectedLeg?.id === leg.id;
        const strokeWidth = isSelected ? 4 : 2;
        
        const pathD = 'M' + legPoints.map(p => `${lonToX(p.lon)} ${latToY(p.lat)}`).join('L');
        
        if (isSelected) {
          html += `<path d="${pathD}" stroke="#a855f7" stroke-width="8" fill="none" opacity="0.4" stroke-linecap="round"/>`;
        }
        html += `<path d="${pathD}" stroke="${color}" stroke-width="${strokeWidth}" fill="none" stroke-linecap="round" class="leg-path-${sessionIdx}" data-leg="${leg.id}" style="cursor:pointer"/>`;
      });
      
      // Start/end markers
      if (ctx.selectedLeg) {
        // Selected leg: show S and E markers
        html += `<circle cx="${lonToX(ctx.selectedLeg.startLon)}" cy="${latToY(ctx.selectedLeg.startLat)}" r="${8*markerScale}" fill="#22c55e" stroke="white" stroke-width="${3*markerScale}"/>`;
        html += `<text x="${lonToX(ctx.selectedLeg.startLon)}" y="${latToY(ctx.selectedLeg.startLat) + 4*markerScale}" text-anchor="middle" font-size="${10*markerScale}" fill="white" font-weight="bold">S</text>`;
        html += `<circle cx="${lonToX(ctx.selectedLeg.endLon)}" cy="${latToY(ctx.selectedLeg.endLat)}" r="${8*markerScale}" fill="#ef4444" stroke="white" stroke-width="${3*markerScale}"/>`;
        html += `<text x="${lonToX(ctx.selectedLeg.endLon)}" y="${latToY(ctx.selectedLeg.endLat) + 4*markerScale}" text-anchor="middle" font-size="${10*markerScale}" fill="white" font-weight="bold">E</text>`;
      } else {
        // No selected leg: show simple start/end circles
        html += `<circle cx="${lonToX(track[0].lon)}" cy="${latToY(track[0].lat)}" r="${5*markerScale}" fill="#22c55e" stroke="white" stroke-width="${2*markerScale}"/>`;
        html += `<circle cx="${lonToX(track[track.length-1].lon)}" cy="${latToY(track[track.length-1].lat)}" r="${5*markerScale}" fill="#ef4444" stroke="white" stroke-width="${2*markerScale}"/>`;
      }
      
      svg.innerHTML = html;
      
      // Add click handlers
      svg.querySelectorAll(`.leg-path-${sessionIdx}`).forEach(path => {
        path.addEventListener('click', (e) => {
          e.stopPropagation();
          const legId = parseInt(path.dataset.leg);
          const leg = session.legs.find(l => l.id === legId);
          selectSessionLeg(sessionIdx, leg);
        });
      });
      
      // Update legend
      const legend = document.getElementById(`map-legend-${sessionIdx}`);
      if (legend) {
        let legendHtml = `
          <div style="display:flex;align-items:center;gap:4px;margin-bottom:4px;"><div style="width:10px;height:10px;background:#22c55e;border-radius:2px;"></div><span>Up</span></div>
          <div style="display:flex;align-items:center;gap:4px;margin-bottom:4px;"><div style="width:10px;height:10px;background:#3b82f6;border-radius:2px;"></div><span>Reach</span></div>
          <div style="display:flex;align-items:center;gap:4px;margin-bottom:4px;"><div style="width:10px;height:10px;background:#f59e0b;border-radius:2px;"></div><span>Down</span></div>
        `;
        if (ctx.selectedLeg) {
          legendHtml += `<div style="display:flex;align-items:center;gap:4px;margin-top:4px;"><div style="width:10px;height:10px;background:#a855f7;border-radius:2px;"></div><span>Leg #${ctx.selectedLeg.id}</span></div>`;
        }
        legend.innerHTML = legendHtml;
      }
      
      // Update wind indicator with arrow
      const wind = document.getElementById(`map-wind-${sessionIdx}`);
      if (wind) {
        const windDeg = session.s.twd;
        wind.innerHTML = `
          <div style="font-size:9px;color:#666;margin-bottom:2px;">Wind ${session.s.twd}¬∞</div>
          <svg width="40" height="40" viewBox="0 0 40 40">
            <g transform="rotate(${windDeg}, 20, 20)">
              <line x1="20" y1="8" x2="20" y2="32" stroke="#666" stroke-width="2"/>
              <polygon points="20,32 15,24 25,24" fill="#666"/>
            </g>
          </svg>
        `;
      }
      
      // Update zoom indicator
      const zoomInd = document.getElementById(`map-zoom-indicator-${sessionIdx}`);
      if (zoomInd) {
        zoomInd.textContent = zoom !== 1 ? `${zoom.toFixed(1)}x` : '';
      }
      
      // Add mouse wheel zoom
      svg.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        zoomMapSession(sessionIdx, delta);
      }, { passive: false });
      
      // Add drag to pan
      let isDragging = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let dragStartPanX = 0;
      let dragStartPanY = 0;
      
      svg.addEventListener('mousedown', (e) => {
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        dragStartPanX = ctx.mapPanX;
        dragStartPanY = ctx.mapPanY;
        svg.style.cursor = 'grabbing';
      });
      
      svg.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        ctx.mapPanX = dragStartPanX + dx * (1 / zoom);
        ctx.mapPanY = dragStartPanY + dy * (1 / zoom);
        renderSessionMap(sessionIdx);
      });
      
      svg.addEventListener('mouseup', () => {
        isDragging = false;
        svg.style.cursor = 'grab';
      });
      
      svg.addEventListener('mouseleave', () => {
        isDragging = false;
        svg.style.cursor = 'default';
      });
      
      svg.style.cursor = 'grab';
    }
    
    function renderSessionLegsTable(sessionIdx) {
      console.log(`[renderSessionLegsTable] Starting for session ${sessionIdx}`);
      
      const ctx = window.sessionContexts[sessionIdx];
      if (!ctx) {
        console.error(`[renderSessionLegsTable] No context for session ${sessionIdx}`);
        return;
      }
      
      const session = ctx.DATA;
      const legs = session.legs;
      
      console.log(`[renderSessionLegsTable] Session has ${legs.length} legs`);
      
      const isGarmin = session.dataSource === 'garmin';
      const posNames = { upwind: 'Up', reaching: 'Reach', downwind: 'Down' };
      
      // Update summary
      const tacks = legs.filter(l => l.next_maneuver?.type === 'tack').length;
      const gybes = legs.filter(l => l.next_maneuver?.type === 'gybe').length;
      
      const summaryEl = document.getElementById(`legs-summary-${sessionIdx}`);
      if (summaryEl) {
        summaryEl.textContent = `${legs.length} legs | ${tacks} tacks | ${gybes} gybes`;
      }
      
      // Hide/show MAG and Heel headers based on data source
      const magHeader = document.getElementById(`mag-header-${sessionIdx}`);
      const heelHeader = document.getElementById(`heel-header-${sessionIdx}`);
      if (magHeader) magHeader.style.display = isGarmin ? 'none' : '';
      if (heelHeader) heelHeader.style.display = isGarmin ? 'none' : '';
      
      // Render table
      const tbody = document.getElementById(`legs-tbody-${sessionIdx}`);
      if (!tbody) {
        console.error(`[renderSessionLegsTable] Table body legs-tbody-${sessionIdx} not found`);
        return;
      }
      
      tbody.innerHTML = legs.map(leg => {
        const isSelected = ctx.selectedLeg?.id === leg.id;
        const badgeClass = `badge badge-${leg.pos === 'upwind' ? 'up' : leg.pos === 'reaching' ? 'reach' : 'down'}`;
        
        let nextHtml = '';
        if (leg.next_maneuver) {
          const mc = leg.next_maneuver.type === 'tack' ? 'badge-tack' : 'badge-gybe';
          nextHtml = `<span class="badge ${mc}">${leg.next_maneuver.type === 'tack' ? 'T' : 'G'}${leg.next_maneuver.angle}¬∞</span>`;
        }
        
        const devPct = (leg.lineDeviation * 100).toFixed(1);
        const lostM = Math.round(leg.lostMeters);
        const legHdg = leg.hdg != null ? `${Math.round(leg.hdg)}¬∞` : '-';
        
        return `<tr class="${isSelected ? 'selected' : ''}" data-leg="${leg.id}" style="cursor:pointer;">
          <td>${leg.id}</td>
          <td><span class="${badgeClass}">${posNames[leg.pos]}</span></td>
          <td style="text-align:right">${leg.dur}s</td>
          <td style="text-align:right;color:${getRateColor(leg.rate)}">${leg.rate.toFixed(2)}</td>
          <td style="text-align:right;color:${getCorridorColor(leg.corridor)}">¬±${leg.corridor.toFixed(1)}¬∞</td>
          <td style="text-align:right;color:${getLineDeviationColor(devPct)}">${devPct}% (${lostM}m)</td>
          ${!isGarmin ? `<td style="text-align:right;color:${getCorridorColor(leg.mag70)}">${leg.mag70.toFixed(1)}¬∞/${leg.mag_corridor.toFixed(1)}¬∞</td>` : ''}
          ${!isGarmin ? `<td style="text-align:right">${leg.heel}¬∞</td>` : ''}
          <td style="text-align:right">${leg.speed}/${leg.vmg}</td>
          <td style="text-align:right">${legHdg}</td>
          <td>${nextHtml}</td>
        </tr>`;
      }).join('');
      
      // Add click handlers
      tbody.querySelectorAll('tr').forEach(row => {
        row.addEventListener('click', () => {
          const legId = parseInt(row.dataset.leg);
          const leg = legs.find(l => l.id === legId);
          selectSessionLeg(sessionIdx, leg);
        });
      });
      
      console.log(`[renderSessionLegsTable] Table rendered for session ${sessionIdx}`);
    }
    
    function renderSessionLegDetail(sessionIdx, leg) {
      const container = document.getElementById(`leg-detail-${sessionIdx}`);
      if (!container) return;
      
      const ctx = window.sessionContexts[sessionIdx];
      const session = ctx.DATA;
      
      // Destroy old charts
      if (ctx.charts.legRate) { ctx.charts.legRate.destroy(); ctx.charts.legRate = null; }
      if (ctx.charts.legCog) { ctx.charts.legCog.destroy(); ctx.charts.legCog = null; }
      if (ctx.charts.legMag) { ctx.charts.legMag.destroy(); ctx.charts.legMag = null; }
      if (ctx.charts.legHeel) { ctx.charts.legHeel.destroy(); ctx.charts.legHeel = null; }
      if (ctx.charts.legSpeedVmg) { ctx.charts.legSpeedVmg.destroy(); ctx.charts.legSpeedVmg = null; }
      
      if (!leg) {
        container.innerHTML = '<div style="color:#6b7280;text-align:center;padding:40px;">Select a leg to view details</div>';
        return;
      }
      
      const isGarmin = session.dataSource === 'garmin';
      const posNames = { upwind: 'Upwind', reaching: 'Reaching', downwind: 'Downwind' };
      
      let maneuverHtml = '';
      if (leg.next_maneuver) {
        const mc = leg.next_maneuver.type === 'tack' ? 'maneuver-tack' : 'maneuver-gybe';
        maneuverHtml = `<div class="maneuver-banner ${mc}">Next: ${leg.next_maneuver.type.toUpperCase()} ${leg.next_maneuver.angle}¬∞</div>`;
      } else {
        maneuverHtml = `<div class="maneuver-banner" style="background:#e5e7eb;color:#6b7280;">Next: --</div>`;
      }
      
      // Build stats grid
      const statsRow2 = isGarmin ? `
          <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-top:8px;">
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">COG Corridor</div>
              <div style="font-weight:bold;color:${getCorridorColor(leg.corridor)}">¬±${leg.corridor.toFixed(1)}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Line Deviation</div>
              <div style="font-weight:bold;color:${getLineDeviationColor(leg.lineDeviation * 100)}">${(leg.lineDeviation * 100).toFixed(1)}% (${Math.round(leg.lostMeters)}m)</div>
            </div>
          </div>
      ` : `
          <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:8px;">
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Heel</div>
              <div style="font-weight:bold;">${leg.heel}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">COG Corridor</div>
              <div style="font-weight:bold;color:${getCorridorColor(leg.corridor)}">¬±${leg.corridor.toFixed(1)}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Line Deviation</div>
              <div style="font-weight:bold;color:${getLineDeviationColor(leg.lineDeviation * 100)}">${(leg.lineDeviation * 100).toFixed(1)}% (${Math.round(leg.lostMeters)}m)</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">MAG 70/90</div>
              <div style="font-weight:bold;color:${getCorridorColor(leg.mag70)}">${leg.mag70.toFixed(1)}¬∞ / ${leg.mag_corridor.toFixed(1)}¬∞</div>
            </div>
          </div>
      `;
      
      // Build charts section
      const chartsHtml = isGarmin ? `
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Steering Rate</span>
            <span class="text-xs" style="color:#9ca3af;">0-10 ¬∞/s | <span style="color:#22c55e;">‚îÅ</span> 1.5 <span style="color:#3b82f6;">‚îÅ</span> 3</span>
          </div>
          <div style="height:100px;"><canvas id="leg-rate-chart-${sessionIdx}"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">COG Deviation from ${leg.hdg}¬∞</span>
            <span class="text-xs" style="color:#9ca3af;">‚Ü∂ Port | Stbd ‚Ü∑ | <span style="color:#22c55e;">‚îÅ</span> ¬±5¬∞ <span style="color:#f59e0b;">‚îÅ</span> ¬±10¬∞</span>
          </div>
          <div style="height:100px;"><canvas id="leg-cog-chart-${sessionIdx}"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Speed / VMG</span>
            <span class="text-xs" style="color:#9ca3af;"><span style="color:#3b82f6;">‚îÅ</span> Spd <span style="color:#22c55e;">‚îÅ</span> VMG</span>
          </div>
          <div style="height:100px;"><canvas id="leg-speed-vmg-chart-${sessionIdx}"></canvas></div>
        </div>
      ` : `
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Steering Rate</span>
            <span class="text-xs" style="color:#9ca3af;">0-10 ¬∞/s | <span style="color:#22c55e;">‚îÅ</span> 1.5 <span style="color:#3b82f6;">‚îÅ</span> 3</span>
          </div>
          <div style="height:100px;"><canvas id="leg-rate-chart-${sessionIdx}"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">COG Deviation from ${leg.hdg}¬∞</span>
            <span class="text-xs" style="color:#9ca3af;">‚Ü∂ Port | Stbd ‚Ü∑ | <span style="color:#22c55e;">‚îÅ</span> ¬±5¬∞ <span style="color:#f59e0b;">‚îÅ</span> ¬±10¬∞</span>
          </div>
          <div style="height:100px;"><canvas id="leg-cog-chart-${sessionIdx}"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Mag Heading Deviation from ${leg.hdg}¬∞</span>
            <span class="text-xs" style="color:#9ca3af;">‚Ü∂ Port | Stbd ‚Ü∑ | <span style="color:#22c55e;">‚îÅ</span> ¬±5¬∞ <span style="color:#f59e0b;">‚îÅ</span> ¬±10¬∞</span>
          </div>
          <div style="height:100px;"><canvas id="leg-mag-chart-${sessionIdx}"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Heel Angle</span>
            <span class="text-xs" style="color:#9ca3af;">‚Ü∂ Port | Stbd ‚Ü∑ | <span style="color:#22c55e;">‚îÅ</span> ¬±10¬∞ <span style="color:#f59e0b;">‚îÅ</span> ¬±15¬∞</span>
          </div>
          <div style="height:100px;"><canvas id="leg-heel-chart-${sessionIdx}"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Speed / VMG</span>
            <span class="text-xs" style="color:#9ca3af;"><span style="color:#3b82f6;">‚îÅ</span> Spd <span style="color:#22c55e;">‚îÅ</span> VMG</span>
          </div>
          <div style="height:100px;"><canvas id="leg-speed-vmg-chart-${sessionIdx}"></canvas></div>
        </div>
      `;
      
      container.innerHTML = `
        <div class="detail-box">
          <div class="detail-header">
            <span class="detail-title">Leg #${leg.id}: ${posNames[leg.pos]}</span>
            <span class="text-sm text-purple">${leg.start.toFixed(1)} - ${leg.end.toFixed(1)} min (${leg.dur}s)</span>
          </div>
          
          <!-- Leg Timeline Widget -->
          <div style="margin-top:12px;background:white;border-radius:6px;padding:12px;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
              <span class="text-xs" style="color:#6b7280;font-weight:500;">Leg Timeline</span>
              <span class="text-xs" style="color:#9ca3af;">Position in session</span>
            </div>
            <div id="leg-timeline-bar-${sessionIdx}" style="position:relative;height:32px;background:#f3f4f6;border-radius:4px;">
              <!-- Timeline will be rendered here -->
            </div>
          </div>
          
          <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:12px;">
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Wind</div>
              <div style="font-weight:bold;">${leg.localWind || session.s.twd}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">TWA</div>
              <div style="font-weight:bold;">${leg.twa}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Leg Hdg</div>
              <div style="font-weight:bold;">${leg.hdg}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Spd/VMG</div>
              <div style="font-weight:bold;">${leg.speed}/${leg.vmg}</div>
            </div>
          </div>
          ${statsRow2}
          ${maneuverHtml}
        </div>
        ${chartsHtml}
      `;
      
      // Render leg timeline widget
      renderSessionLegTimelineWidget(sessionIdx, leg);
      
      // Render charts if we have timeseries data
      if (leg.ts && leg.ts.length > 0) {
        const labels = leg.ts.map(p => p.t.toFixed(1));
        
        // Steering Rate Chart
        const rateCanvas = document.getElementById(`leg-rate-chart-${sessionIdx}`);
        if (rateCanvas) {
          ctx.charts.legRate = new Chart(rateCanvas.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: leg.ts.map(p => p.rate),
                borderColor: '#ef4444',
                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                borderWidth: 2,
                pointRadius: 0,
                tension: 0.3,
                fill: true
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: { 
                legend: { display: false },
                annotation: {
                  annotations: {
                    line1: { type: 'line', yMin: 1.5, yMax: 1.5, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                    line2: { type: 'line', yMin: 3, yMax: 3, borderColor: '#3b82f6', borderDash: [5,5], borderWidth: 1 }
                  }
                }
              },
              scales: {
                x: { 
                  display: true,
                  ticks: { font: { size: 9 }, maxTicksLimit: 6, callback: v => labels[v] + 'm' }
                },
                y: { 
                  display: false,
                  min: 0, 
                  max: 10
                }
              }
            }
          });
        }
        
        // Calculate deviation range
        const allDevs = [...leg.ts.map(p => p.dev), ...leg.ts.map(p => p.mdev || 0)];
        const rawMax = Math.max(Math.abs(Math.min(...allDevs)), Math.abs(Math.max(...allDevs)), 15);
        const maxDev = Math.ceil(rawMax / 5) * 5;
        
        // COG Deviation Chart
        const cogCanvas = document.getElementById(`leg-cog-chart-${sessionIdx}`);
        if (cogCanvas) {
          ctx.charts.legCog = new Chart(cogCanvas.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: leg.ts.map(p => p.dev),
                borderColor: '#3b82f6',
                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                borderWidth: 2,
                pointRadius: 0,
                tension: 0.3,
                fill: true
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: { 
                legend: { display: false },
                annotation: {
                  annotations: {
                    zero: { type: 'line', yMin: 0, yMax: 0, borderColor: '#666', borderWidth: 2 },
                    plus5: { type: 'line', yMin: 5, yMax: 5, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                    minus5: { type: 'line', yMin: -5, yMax: -5, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                    plus10: { type: 'line', yMin: 10, yMax: 10, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 },
                    minus10: { type: 'line', yMin: -10, yMax: -10, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 }
                  }
                }
              },
              scales: {
                x: { 
                  display: true,
                  ticks: { font: { size: 9 }, maxTicksLimit: 6, callback: v => labels[v] + 'm' }
                },
                y: { 
                  display: false,
                  min: -maxDev, 
                  max: maxDev
                }
              }
            }
          });
        }
        
        // Mag and Heel charts - only for VKX
        if (!isGarmin) {
          const magCanvas = document.getElementById(`leg-mag-chart-${sessionIdx}`);
          if (magCanvas) {
            ctx.charts.legMag = new Chart(magCanvas.getContext('2d'), {
              type: 'line',
              data: {
                labels,
                datasets: [{
                  data: leg.ts.map(p => p.mdev),
                  borderColor: '#8b5cf6',
                  backgroundColor: 'rgba(139, 92, 246, 0.1)',
                  borderWidth: 2,
                  pointRadius: 0,
                  tension: 0.3,
                  fill: true
                }]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { 
                  legend: { display: false },
                  annotation: {
                    annotations: {
                      zero: { type: 'line', yMin: 0, yMax: 0, borderColor: '#666', borderWidth: 2 },
                      plus5: { type: 'line', yMin: 5, yMax: 5, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                      minus5: { type: 'line', yMin: -5, yMax: -5, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                      plus10: { type: 'line', yMin: 10, yMax: 10, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 },
                      minus10: { type: 'line', yMin: -10, yMax: -10, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 }
                    }
                  }
                },
                scales: {
                  x: { 
                    display: true,
                    ticks: { font: { size: 9 }, maxTicksLimit: 6, callback: v => labels[v] + 'm' }
                  },
                  y: { 
                    display: false,
                    min: -maxDev, 
                    max: maxDev
                  }
                }
              }
            });
          }
          
          // Heel Chart
          const heelData = leg.ts.map(p => p.heel || 0);
          const maxHeel = Math.max(Math.abs(Math.min(...heelData)), Math.abs(Math.max(...heelData)), 15);
          const heelMax = Math.ceil(maxHeel / 5) * 5;
          
          const heelCanvas = document.getElementById(`leg-heel-chart-${sessionIdx}`);
          if (heelCanvas) {
            ctx.charts.legHeel = new Chart(heelCanvas.getContext('2d'), {
              type: 'line',
              data: {
                labels,
                datasets: [{
                  data: heelData,
                  borderColor: '#f59e0b',
                  backgroundColor: 'rgba(245, 158, 11, 0.1)',
                  borderWidth: 2,
                  pointRadius: 0,
                  tension: 0.3,
                  fill: true
                }]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { 
                  legend: { display: false },
                  annotation: {
                    annotations: {
                      zero: { type: 'line', yMin: 0, yMax: 0, borderColor: '#666', borderWidth: 2 },
                      plus10: { type: 'line', yMin: 10, yMax: 10, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                      minus10: { type: 'line', yMin: -10, yMax: -10, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                      plus15: { type: 'line', yMin: 15, yMax: 15, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 },
                      minus15: { type: 'line', yMin: -15, yMax: -15, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 }
                    }
                  }
                },
                scales: {
                  x: { 
                    display: true,
                    ticks: { font: { size: 9 }, maxTicksLimit: 6, callback: v => labels[v] + 'm' }
                  },
                  y: { 
                    display: false,
                    min: -heelMax, 
                    max: heelMax
                  }
                }
              }
            });
          }
        }
        
        // Speed/VMG Chart
        const speedVmgCanvas = document.getElementById(`leg-speed-vmg-chart-${sessionIdx}`);
        if (speedVmgCanvas) {
          ctx.charts.legSpeedVmg = new Chart(speedVmgCanvas.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  label: 'Speed',
                  data: leg.ts.map(p => p.speed),
                  borderColor: '#3b82f6',
                  backgroundColor: 'rgba(59, 130, 246, 0.1)',
                  borderWidth: 2,
                  pointRadius: 0,
                  tension: 0.3,
                  fill: false
                },
                {
                  label: 'VMG',
                  data: leg.ts.map(p => p.vmg),
                  borderColor: '#22c55e',
                  backgroundColor: 'rgba(34, 197, 94, 0.1)',
                  borderWidth: 2,
                  pointRadius: 0,
                  tension: 0.3,
                  fill: false
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: { legend: { display: false } },
              scales: {
                x: { 
                  display: true,
                  ticks: { font: { size: 9 }, maxTicksLimit: 6, callback: v => labels[v] + 'm' }
                },
                y: { 
                  display: false,
                  min: 0
                }
              }
            }
          });
        }
      }
    }
    
    function renderSessionLegTimelineWidget(sessionIdx, leg) {
      const ctx = window.sessionContexts[sessionIdx];
      if (!ctx || !leg) return;
      
      const container = document.getElementById(`leg-timeline-bar-${sessionIdx}`);
      if (!container) return;
      
      const session = ctx.DATA;
      const fullDuration = session.s.dur;
      
      // Calculate leg position within full session duration
      const legStartPct = (leg.start / fullDuration) * 100;
      const legEndPct = (leg.end / fullDuration) * 100;
      const legWidthPct = legEndPct - legStartPct;
      
      // Position of sail colors
      const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };
      const legColor = posColors[leg.pos] || '#7c3aed';
      
      let html = '';
      
      // Background - full session duration
      html += `<div style="position:absolute;left:0;right:0;top:6px;height:20px;background:#e5e7eb;border-radius:3px;"></div>`;
      
      // Leg segment - highlighted
      html += `<div style="position:absolute;left:${legStartPct}%;width:${legWidthPct}%;top:6px;height:20px;background:${legColor};opacity:0.8;border-radius:3px;"></div>`;
      
      // Time labels
      const legStartTime = `${leg.start.toFixed(1)}m`;
      const legEndTime = `${leg.end.toFixed(1)}m`;
      html += `<div style="position:absolute;left:${legStartPct}%;bottom:0;font-size:9px;color:#6b7280;transform:translateX(-50%);">${legStartTime}</div>`;
      html += `<div style="position:absolute;left:${legEndPct}%;bottom:0;font-size:9px;color:#6b7280;transform:translateX(-50%);">${legEndTime}</div>`;
      
      container.innerHTML = html;
    }
    
    function renderSessionCharts(sessionIdx) {
      const ctx = window.sessionContexts[sessionIdx];
      if (!ctx) return;
      
      const session = ctx.DATA;
      const intervals = session.intervals;
      
      console.log(`[renderSessionCharts] Session ${sessionIdx}, intervals: ${intervals.length}`);
      
      // Destroy existing charts
      if (ctx.charts.rate) {
        ctx.charts.rate.destroy();
        ctx.charts.rate = null;
      }
      if (ctx.charts.corridor) {
        ctx.charts.corridor.destroy();
        ctx.charts.corridor = null;
      }
      
      // Rate chart
      const rateCtx = document.getElementById(`rate-chart-${sessionIdx}`);
      if (rateCtx) {
        const rateData = intervals.map(i => ({ x: i.minute, y: i.rate, legId: i.leg_id }));
        const rateColors = intervals.map(i => {
          // Highlight selected interval
          if (ctx.selectedInterval === i.minute) {
            return '#a855f7'; // Purple for selected
          }
          return getRateColor(i.rate);
        });
        const rateRadii = intervals.map(i => ctx.selectedInterval === i.minute ? 6 : 3);
        
        ctx.charts.rate = new Chart(rateCtx.getContext('2d'), {
          type: 'scatter',
          data: {
            datasets: [{
              data: rateData,
              backgroundColor: rateColors,
              pointRadius: rateRadii,
              pointHoverRadius: 8
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { 
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: ctx => {
                    const d = ctx.dataset.data[ctx.dataIndex];
                    return `Min ${d.x} (Leg ${d.legId}): ${d.y.toFixed(2)}¬∞/s`;
                  }
                }
              }
            },
            scales: {
              x: { title: { display: true, text: 'Minute' } },
              y: { min: 0, max: 10, title: { display: true, text: '¬∞/s' } }
            },
            onClick: (e, elements) => {
              if (elements.length > 0) {
                const idx = elements[0].index;
                const d = rateData[idx];
                const leg = session.legs.find(l => l.id === d.legId);
                
                // Toggle interval selection
                if (ctx.selectedInterval === d.x) {
                  ctx.selectedInterval = null;
                  selectSessionLeg(sessionIdx, null);
                } else {
                  ctx.selectedInterval = d.x;
                  selectSessionLeg(sessionIdx, leg);
                }
              }
            }
          }
        });
      }
      
      // Corridor chart
      const corridorCtx = document.getElementById(`corridor-chart-${sessionIdx}`);
      if (corridorCtx) {
        const corridorData = intervals.map(i => ({ x: i.minute, y: i.corridor_pm, legId: i.leg_id }));
        const corridorColors = intervals.map(i => {
          // Highlight selected interval
          if (ctx.selectedInterval === i.minute) {
            return '#a855f7'; // Purple for selected
          }
          return getCorridorColor(i.corridor_pm);
        });
        const corridorRadii = intervals.map(i => ctx.selectedInterval === i.minute ? 6 : 3);
        
        ctx.charts.corridor = new Chart(corridorCtx.getContext('2d'), {
          type: 'scatter',
          data: {
            datasets: [{
              data: corridorData,
              backgroundColor: corridorColors,
              pointRadius: corridorRadii,
              pointHoverRadius: 8
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { 
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: ctx => {
                    const d = ctx.dataset.data[ctx.dataIndex];
                    return `Min ${d.x} (Leg ${d.legId}): ¬±${d.y.toFixed(1)}¬∞`;
                  }
                }
              }
            },
            scales: {
              x: { title: { display: true, text: 'Minute' } },
              y: { min: 0, max: 30, title: { display: true, text: '¬±¬∞' } }
            },
            onClick: (e, elements) => {
              if (elements.length > 0) {
                const idx = elements[0].index;
                const d = corridorData[idx];
                const leg = session.legs.find(l => l.id === d.legId);
                
                // Toggle interval selection
                if (ctx.selectedInterval === d.x) {
                  ctx.selectedInterval = null;
                  selectSessionLeg(sessionIdx, null);
                } else {
                  ctx.selectedInterval = d.x;
                  selectSessionLeg(sessionIdx, leg);
                }
              }
            }
          }
        });
      }
      
      console.log(`[renderSessionCharts] Charts created for session ${sessionIdx}`);
    }
    
    function renderSessionPOSBreakdown(sessionIdx) {
      console.log(`[renderSessionPOSBreakdown] Starting for session ${sessionIdx}`);
      
      const ctx = window.sessionContexts[sessionIdx];
      if (!ctx) {
        console.error(`[renderSessionPOSBreakdown] No context for session ${sessionIdx}`);
        return;
      }
      
      const session = ctx.DATA;
      const container = document.getElementById(`pos-breakdown-${sessionIdx}`);
      
      if (!container) {
        console.error(`[renderSessionPOSBreakdown] Container pos-breakdown-${sessionIdx} not found`);
        return;
      }
      
      const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };
      const posNames = { upwind: 'Upwind', reaching: 'Reaching', downwind: 'Downwind' };
      
      container.innerHTML = ['upwind', 'reaching', 'downwind'].map(pos => {
        const d = session.pos[pos];
        return `
          <div style="border-left:3px solid ${posColors[pos]};padding:12px;background:#f9fafb;border-radius:4px;">
            <div style="font-weight:600;font-size:12px;color:${posColors[pos]};margin-bottom:8px;">${posNames[pos]}</div>
            <div class="pos-stat"><span>Time</span><span>${Math.round(d.time/60)} min (${d.pct}%)</span></div>
            <div class="pos-stat"><span>Spd/VMG</span><span>${d.speed}/${d.vmg} kts</span></div>
            <div class="pos-stat"><span>COG Corridor</span><span>¬±${d.corridor}¬∞</span></div>
            <div class="pos-stat"><span>Steer Rate</span><span>${d.rate}¬∞/s</span></div>
          </div>
        `;
      }).join('');
      
      console.log(`[renderSessionPOSBreakdown] POS breakdown rendered for session ${sessionIdx}`);
    }
    
    function setViewMode(mode) {
      viewMode = mode;
      
      // Broadcast to iframes if in multi-session mode
      if (multiSessionView && !isIframeMode) {
        broadcastToIframes('setViewMode', { mode });
      }
      
      // Update toggle buttons (both in header and view config card)
      const legsBtn = document.getElementById('view-mode-legs');
      const statsBtn = document.getElementById('view-mode-stats');
      const legsBtnConfig = document.getElementById('view-mode-legs-config');
      const statsBtnConfig = document.getElementById('view-mode-stats-config');
      
      const updateBtns = (legsB, statsB) => {
        if (legsB && statsB) {
          if (mode === 'legs') {
            legsB.style.background = '#3b82f6';
            legsB.style.color = 'white';
            statsB.style.background = '#f3f4f6';
            statsB.style.color = '#374151';
          } else {
            statsB.style.background = '#3b82f6';
            statsB.style.color = 'white';
            legsB.style.background = '#f3f4f6';
            legsB.style.color = '#374151';
          }
        }
      };
      
      updateBtns(legsBtn, statsBtn);
      updateBtns(legsBtnConfig, statsBtnConfig);
      
      // Update panel visibility
      const statsPanel = document.getElementById('stats-panel');
      const legsPanel = document.getElementById('legs-panel');
      if (statsPanel && legsPanel) {
        if (mode === 'legs') {
          statsPanel.style.display = 'none';
          legsPanel.style.display = 'block';
        } else {
          statsPanel.style.display = 'block';
          legsPanel.style.display = 'none';
        }
      }
      
      // Move leg-detail element between containers based on view mode
      const legDetail = document.getElementById('leg-detail');
      const mainContainer = document.getElementById('leg-detail-container-main');
      const sideContainer = document.getElementById('leg-detail-container-side');
      if (legDetail && mainContainer && sideContainer) {
        if (mode === 'legs') {
          // Move to side container (in leg-details tab)
          sideContainer.appendChild(legDetail);
        } else {
          // Move back to main container (in legs tab)
          mainContainer.appendChild(legDetail);
        }
      }
      
      // Update tabs visibility
      const legDetailsTab = document.getElementById('tab-btn-leg-details');
      const legsTab = document.getElementById('tab-btn-legs');
      if (legDetailsTab && legsTab) {
        if (mode === 'legs') {
          legDetailsTab.style.display = 'inline-block';
          legsTab.style.display = 'none';
          // Switch to leg-details tab if currently on legs tab
          const activeTab = document.querySelector('.tab.active');
          if (activeTab && activeTab.dataset.tab === 'legs') {
            switchTab('leg-details');
          } else if (!activeTab || activeTab.dataset.tab === 'legs') {
            switchTab('leg-details');
          }
        } else {
          legDetailsTab.style.display = 'none';
          legsTab.style.display = 'inline-block';
          // Switch to legs tab if currently on leg-details tab
          const activeTab = document.querySelector('.tab.active');
          if (activeTab && activeTab.dataset.tab === 'leg-details') {
            switchTab('legs');
          }
        }
      }
      
      // Update the side legs table if in legs mode
      if (mode === 'legs') {
        updateSideLegsTable();
        
        // Switch to leg-details tab
        switchTab('leg-details');
      }
    }
    
    function updateSideLegsTable() {
      if (!DATA || !DATA.legs) return;
      
      const tbody = document.getElementById('legs-tbody-side');
      const summaryEl = document.getElementById('legs-summary-side');
      const bestCorridorEl = document.getElementById('best-corridor-side');
      
      if (!tbody) return;
      
      const posFilter = document.getElementById('pos-filter-config')?.value || 'all';
      
      // Get visible legs using unified helper
      const legs = getVisibleLegs(DATA.legs, posFilter);
      
      const isGarmin = DATA.dataSource === 'garmin';
      
      // Update summary
      if (summaryEl) {
        const upCount = legs.filter(l => l.pos === 'upwind').length;
        const downCount = legs.filter(l => l.pos === 'downwind').length;
        const reachCount = legs.filter(l => l.pos === 'reaching').length;
        summaryEl.innerHTML = `<span class="text-green">${upCount} Up</span> / <span class="text-amber">${downCount} Dn</span> / <span class="text-blue">${reachCount} Reach</span>`;
      }
      
      // Find best corridor
      if (bestCorridorEl) {
        const bestCorr = legs.length > 0 ? Math.min(...legs.map(l => l.corridor)) : Infinity;
        bestCorridorEl.textContent = bestCorr < Infinity ? `¬±${bestCorr.toFixed(1)}¬∞` : '-';
        bestCorridorEl.style.color = getCorridorColor(bestCorr);
      }
      
      // Build table rows - match the format used in main legs table
      // New order: #, POS, Dur, SPD/VMG, MAG70/90, Rate, COG, Dev, Heel, Wind, TWA, Leg Hdg, Next
      const posNames = { upwind: 'Up', reaching: 'Reach', downwind: 'Down' };
      let html = '';
      legs.forEach(leg => {
        const isSelected = selectedLeg?.id === leg.id;
        const badgeClass = `badge badge-${leg.pos === 'upwind' ? 'up' : leg.pos === 'reaching' ? 'reach' : 'down'}`;
        
        let nextHtml = '';
        if (leg.next_maneuver) {
          const mc = leg.next_maneuver.type === 'tack' ? 'badge-tack' : 'badge-gybe';
          nextHtml = `<span class="badge ${mc}">${leg.next_maneuver.type === 'tack' ? 'T' : 'G'}${leg.next_maneuver.angle}¬∞</span>`;
        }
        
        const devPct = (leg.lineDeviation * 100).toFixed(1);
        const legHdg = leg.hdg != null ? `${Math.round(leg.hdg)}¬∞` : '-';
        const legWind = leg.localWind || DATA.s.twd;
        const legTwa = leg.twa || '-';
        
        html += `<tr class="${isSelected ? 'selected' : ''}" onclick="selectLegFromSideTable(${leg.id})" style="cursor:pointer;">
          <td>${leg.id}</td>
          <td><span class="${badgeClass}">${posNames[leg.pos]}</span></td>
          <td style="text-align:right;">${leg.dur}s</td>
          <td style="text-align:right;">${leg.speed}/${leg.vmg}</td>
          ${!isGarmin ? `<td style="text-align:right;color:${getMagCorridorColor(leg.mag70)};">${leg.mag70.toFixed(1)}/${leg.mag_corridor.toFixed(1)}</td>` : ''}
          <td style="text-align:right;color:${getRateColor(leg.rate)};">${leg.rate.toFixed(2)}</td>
          <td style="text-align:right;color:${getCorridorColor(leg.corridor)};">¬±${leg.corridor.toFixed(1)}¬∞</td>
          <td style="text-align:right;color:${getLineDeviationColor(devPct)};">${devPct}%</td>
          ${!isGarmin ? `<td style="text-align:right;">${leg.heel}¬∞</td>` : ''}
          <td style="text-align:right;">${legWind}¬∞</td>
          <td style="text-align:right;">${legTwa}¬∞</td>
          <td style="text-align:right;">${legHdg}</td>
          <td>${nextHtml}</td>
        </tr>`;
      });
      
      tbody.innerHTML = html;
      
      // Update table header to match data source
      const thead = document.querySelector('#legs-table-side thead tr');
      if (thead) {
        thead.innerHTML = `
          <th>#</th>
          <th>POS</th>
          <th style="text-align:right;">Dur</th>
          <th style="text-align:right;">Spd/VMG</th>
          ${!isGarmin ? '<th style="text-align:right;">MAG70/90</th>' : ''}
          <th style="text-align:right;">Rate</th>
          <th style="text-align:right;">COG</th>
          <th style="text-align:right;">Dev</th>
          ${!isGarmin ? '<th style="text-align:right;">Heel</th>' : ''}
          <th style="text-align:right;">Wind</th>
          <th style="text-align:right;">TWA</th>
          <th style="text-align:right;">Hdg</th>
          <th>Next</th>
        `;
      }
    }
    
    function selectLegFromSideTable(legId) {
      if (!DATA || !DATA.legs) return;
      const leg = DATA.legs.find(l => l.id === legId);
      if (leg) {
        selectLeg(leg);
      }
    }

    // Get boat symbol from filename (first word before space, dash, or underscore)
    function getBoatSymbol(filename) {
      const cleaned = filename.replace(/\.(vkx|fit|gpx|gz)$/gi, '');
      const match = cleaned.match(/^([^\s_-]+)/);
      return match ? match[1] : cleaned.substring(0, 10);
    }

    function angleDiff(a, b) {
      let d = ((a - b + 180) % 360) - 180;
      if (d < -180) d += 360;
      return d;
    }

    function analyzeSession(records, startMinutes = null, endMinutes = null) {
      if (records.length < 100) throw new Error('Not enough telemetry data');

      console.log(`Analyzing ${records.length} telemetry records`);
      console.log('Sample records:', records.slice(0, 5));
      
      // Check for valid heading values
      const validHeadings = records.filter(r => r.heading_deg >= 0 && r.heading_deg < 360);
      console.log(`Valid heading records: ${validHeadings.length}/${records.length}`);
      
      // Apply time filtering if specified
      const originalFirstTs = records[0].timestamp_ms;
      let filteredRecords = records;
      
      if (startMinutes !== null && endMinutes !== null) {
        const startMs = originalFirstTs + startMinutes * 60000;
        const endMs = originalFirstTs + endMinutes * 60000;
        filteredRecords = records.filter(r => r.timestamp_ms >= startMs && r.timestamp_ms <= endMs);
        console.log(`Time filter applied: ${startMinutes.toFixed(1)}-${endMinutes.toFixed(1)} min, ${filteredRecords.length} records remaining`);
        
        if (filteredRecords.length < 100) throw new Error('Not enough data in selected time range');
      }
      
      // Downsample to ~4Hz if needed (but don't upsample sparse data)
      const targetHz = 4;
      const firstTs = filteredRecords[0].timestamp_ms;
      const lastTs = filteredRecords[filteredRecords.length - 1].timestamp_ms;
      const duration = (lastTs - firstTs) / 1000;
      const actualHz = filteredRecords.length / duration;
      const step = Math.max(1, Math.floor(actualHz / targetHz));
      const sampled = filteredRecords.filter((_, i) => i % step === 0);
      
      const sampledHz = sampled.length / duration;
      const isSparseData = sampledHz < 1; // Less than 1 Hz is considered sparse
      
      console.log(`Sampled to ${sampled.length} records (${actualHz.toFixed(1)}Hz ‚Üí ${sampledHz.toFixed(2)}Hz)${isSparseData ? ' [SPARSE DATA MODE]' : ''}`);

      // PHASE 1: Detect legs based on HEADING changes over a rolling window
      // Tacks/gybes show up as gradual heading changes, not instant jumps
      const prelimLegs = [];
      
      // Time-based parameters - for sparse data, use sample counts instead
      let windowSize, excludeBeforeSamples, excludeAfterSamples, mergeWindowSamples, minLegDur;
      
      if (isSparseData) {
        // For sparse GPS data (< 1 Hz), use fixed sample counts
        // This ensures meaningful rolling averages
        windowSize = Math.max(3, Math.round(sampled.length / 100)); // ~1% of data
        excludeBeforeSamples = Math.max(1, Math.round(windowSize * 0.3)); // Smaller exclusion for sparse data
        excludeAfterSamples = Math.max(2, Math.round(windowSize * 0.5));
        mergeWindowSamples = Math.max(3, windowSize); // Smaller merge window to keep maneuvers separate
        minLegDur = 15; // Allow shorter legs for sparse data (15 sec vs 30 sec)
        console.log(`Sparse data: window=${windowSize} samples, exclude ${excludeBeforeSamples}/${excludeAfterSamples}, merge=${mergeWindowSamples}, minLeg=${minLegDur}s`);
      } else {
        // Normal high-frequency data - time-based windows
        const windowTimeSec = 5;
        const excludeBeforeSec = 5;
        const excludeAfterSec = 10;
        const mergeWindowSec = 20;
        
        windowSize = Math.max(1, Math.round(windowTimeSec * sampledHz));
        excludeBeforeSamples = Math.round(excludeBeforeSec * sampledHz);
        excludeAfterSamples = Math.round(excludeAfterSec * sampledHz);
        mergeWindowSamples = Math.round(mergeWindowSec * sampledHz);
        minLegDur = 30; // seconds
      }
      
      // Lower threshold to catch gybes (which have smaller heading changes than tacks)
      // For sparse data, use slightly lower threshold to catch all maneuvers
      const maneuverThreshold = isSparseData ? 25 : 25;
      
      console.log(`Maneuver detection: window=${windowSize} samples, threshold=${maneuverThreshold}¬∞`);

      // Calculate rolling average heading
      const rollingHdg = [];
      for (let i = 0; i < sampled.length; i++) {
        if (i < windowSize) {
          rollingHdg.push(sampled[i].heading_deg);
        } else {
          // Circular mean over window
          let sinSum = 0, cosSum = 0;
          for (let j = i - windowSize; j < i; j++) {
            sinSum += Math.sin(sampled[j].heading_deg * Math.PI / 180);
            cosSum += Math.cos(sampled[j].heading_deg * Math.PI / 180);
          }
          let avgHdg = Math.atan2(sinSum, cosSum) * 180 / Math.PI;
          if (avgHdg < 0) avgHdg += 360;
          rollingHdg.push(avgHdg);
        }
      }

      // PASS 1: Detect ALL maneuvers (no duplicate prevention)
      const rawManeuvers = [];
      for (let i = windowSize * 2; i < sampled.length; i++) {
        const timeDiff = (sampled[i].timestamp_ms - sampled[i-1].timestamp_ms) / 1000;
        const hdgChange = Math.abs(angleDiff(rollingHdg[i], rollingHdg[i - windowSize]));
        
        // For sparse data, don't treat time gaps as maneuvers (irregular sampling is normal)
        // Only use heading change threshold
        const isManeuver = isSparseData 
          ? (hdgChange > maneuverThreshold)
          : (hdgChange > maneuverThreshold || timeDiff > 5);
        
        if (isManeuver) {
          rawManeuvers.push({
            idx: i - Math.floor(windowSize / 2), // Center of maneuver
            hdgChange
          });
        }
      }
      
      // PASS 2: Merge nearby maneuvers into exclusion zones
      const exclusionZones = [];
      let currentZone = null;
      
      rawManeuvers.forEach(m => {
        if (!currentZone) {
          currentZone = { start: m.idx, end: m.idx };
        } else if (m.idx - currentZone.end <= mergeWindowSamples) {
          // Extend current zone
          currentZone.end = m.idx;
        } else {
          // Save current zone and start new one
          exclusionZones.push(currentZone);
          currentZone = { start: m.idx, end: m.idx };
        }
      });
      if (currentZone) {
        exclusionZones.push(currentZone);
      }
      
      console.log(`Detected ${rawManeuvers.length} raw maneuvers, merged into ${exclusionZones.length} exclusion zones`);
      
      // Build legs between exclusion zones
      let prevEnd = 0;
      exclusionZones.forEach((zone) => {
        // Previous leg ends excludeBeforeSec before zone START
        const legEndIdx = Math.max(prevEnd, zone.start - excludeBeforeSamples);
        
        // Check if leg is long enough
        if (legEndIdx > prevEnd) {
          const legDur = (sampled[legEndIdx].timestamp_ms - sampled[prevEnd].timestamp_ms) / 1000;
          if (legDur >= minLegDur) {
            prelimLegs.push({ startIdx: prevEnd, endIdx: legEndIdx });
          }
        }
        
        // Next leg starts excludeAfterSec after zone END
        prevEnd = Math.min(sampled.length - 1, zone.end + excludeAfterSamples);
      });
      
      // Add final leg after last zone
      if (prevEnd < sampled.length - 1) {
        const finalDur = (sampled[sampled.length-1].timestamp_ms - sampled[prevEnd].timestamp_ms) / 1000;
        if (finalDur >= minLegDur) {
          prelimLegs.push({ startIdx: prevEnd, endIdx: sampled.length - 1 });
        }
      }
      
      // PASS 3: Filter out legs with excessive heading range (gradual turns)
      // and split legs with sudden heading changes
      // Use higher thresholds for sparse GPS data (COG-derived heading is noisier)
      const maxLegHdgChange = isSparseData ? 55 : 40; // Max sudden heading change allowed
      const maxLegHdgRange = isSparseData ? 50 : 35; // Max total heading range allowed in a leg
      const splitLegs = [];
      
      prelimLegs.forEach(leg => {
        const pts = sampled.slice(leg.startIdx, leg.endIdx + 1);
        if (pts.length < windowSize * 2) {
          splitLegs.push(leg);
          return;
        }
        
        // Check total heading range (to catch gradual turns)
        const headings = pts.map(p => p.heading_deg);
        let minDiff = 0, maxDiff = 0;
        headings.forEach(h => {
          const d = angleDiff(h, headings[0]);
          if (d < minDiff) minDiff = d;
          if (d > maxDiff) maxDiff = d;
        });
        const hdgRange = maxDiff - minDiff;
        
        // Also check average speed (exclude legs where boat is barely moving)
        const avgSpeed = pts.reduce((s, p) => s + p.sog_knots, 0) / pts.length;
        
        // Skip legs with excessive heading range or very low speed
        if (hdgRange > maxLegHdgRange || avgSpeed < 1.5) {
          // Don't include this leg at all
          return;
        }
        
        // Find max sudden heading change within this leg
        let maxChange = 0;
        let maxChangeIdx = -1;
        for (let i = windowSize; i < pts.length - windowSize; i++) {
          // Heading at position i vs i - windowSize
          let s0 = 0, c0 = 0, s1 = 0, c1 = 0;
          for (let j = 0; j < windowSize; j++) {
            s0 += Math.sin(pts[i - windowSize + j].heading_deg * Math.PI / 180);
            c0 += Math.cos(pts[i - windowSize + j].heading_deg * Math.PI / 180);
            s1 += Math.sin(pts[i + j].heading_deg * Math.PI / 180);
            c1 += Math.cos(pts[i + j].heading_deg * Math.PI / 180);
          }
          let h0 = Math.atan2(s0, c0) * 180 / Math.PI;
          let h1 = Math.atan2(s1, c1) * 180 / Math.PI;
          const change = Math.abs(angleDiff(h1, h0));
          if (change > maxChange) {
            maxChange = change;
            maxChangeIdx = i;
          }
        }
        
        if (maxChange > maxLegHdgChange && maxChangeIdx > 0) {
          // Split at the point of maximum change
          const splitPoint = leg.startIdx + maxChangeIdx;
          const beforeEnd = Math.max(leg.startIdx, splitPoint - excludeBeforeSamples);
          const afterStart = Math.min(leg.endIdx, splitPoint + excludeAfterSamples);
          
          const dur1 = (sampled[beforeEnd].timestamp_ms - sampled[leg.startIdx].timestamp_ms) / 1000;
          const dur2 = (sampled[leg.endIdx].timestamp_ms - sampled[afterStart].timestamp_ms) / 1000;
          
          if (dur1 >= minLegDur) {
            splitLegs.push({ startIdx: leg.startIdx, endIdx: beforeEnd });
          }
          if (dur2 >= minLegDur) {
            splitLegs.push({ startIdx: afterStart, endIdx: leg.endIdx });
          }
        } else {
          splitLegs.push(leg);
        }
      });
      
      // Replace prelimLegs with filtered version
      const originalCount = prelimLegs.length;
      prelimLegs.length = 0;
      splitLegs.forEach(l => prelimLegs.push(l));
      
      console.log(`Final leg count after filtering: ${prelimLegs.length} (removed ${originalCount - prelimLegs.length} with excessive heading range or low speed)`);

      // Calculate average heading and speed for each preliminary leg
      prelimLegs.forEach(leg => {
        const points = sampled.slice(leg.startIdx, leg.endIdx + 1);
        
        let avgHdg;
        if (isSparseData && points.length >= 2) {
          // For sparse GPS data: calculate bearing from start to end coordinates
          const startPt = points[0];
          const endPt = points[points.length - 1];
          const dLon = (endPt.lon - startPt.lon) * Math.PI / 180;
          const lat1 = startPt.lat * Math.PI / 180;
          const lat2 = endPt.lat * Math.PI / 180;
          const x = Math.sin(dLon) * Math.cos(lat2);
          const y = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
          avgHdg = Math.atan2(x, y) * 180 / Math.PI;
          if (avgHdg < 0) avgHdg += 360;
        } else {
          const sinSum = points.reduce((s, p) => s + Math.sin(p.heading_deg * Math.PI / 180), 0);
          const cosSum = points.reduce((s, p) => s + Math.cos(p.heading_deg * Math.PI / 180), 0);
          avgHdg = Math.atan2(sinSum, cosSum) * 180 / Math.PI;
          if (avgHdg < 0) avgHdg += 360;
        }
        
        leg.hdg = avgHdg;
        leg.speed = points.reduce((s, p) => s + p.sog_knots, 0) / points.length;
        leg.dur = (points[points.length-1].timestamp_ms - points[0].timestamp_ms) / 1000;
      });

      // PHASE 2: Detect tacks and gybes from heading changes between consecutive legs
      const maneuvers = [];
      console.log('Preliminary legs:', prelimLegs.length);
      
      for (let i = 0; i < prelimLegs.length - 1; i++) {
        const curr = prelimLegs[i];
        const next = prelimLegs[i + 1];
        const hdgChange = Math.abs(angleDiff(next.hdg, curr.hdg));
        
        console.log(`Leg ${i+1}‚Üí${i+2}: hdg ${curr.hdg.toFixed(0)}¬∞‚Üí${next.hdg.toFixed(0)}¬∞, change=${hdgChange.toFixed(0)}¬∞, speeds=${curr.speed.toFixed(1)}/${next.speed.toFixed(1)} kts`);
        
        // Tack: 60-130¬∞ heading change (relaxed from 70-120)
        if (hdgChange >= 60 && hdgChange <= 130 && curr.speed > 1.5 && next.speed > 1.5) {
          maneuvers.push({
            type: 'tack',
            hdg1: curr.hdg,
            hdg2: next.hdg,
            angle: hdgChange,
            avgSpeed: (curr.speed + next.speed) / 2
          });
          console.log(`  ‚Üí Detected TACK`);
        }
        // Gybe: 25-70¬∞ heading change (relaxed)
        else if (hdgChange >= 25 && hdgChange < 60 && curr.speed > 2 && next.speed > 2) {
          maneuvers.push({
            type: 'gybe',
            hdg1: curr.hdg,
            hdg2: next.hdg,
            angle: hdgChange,
            avgSpeed: (curr.speed + next.speed) / 2
          });
          console.log(`  ‚Üí Detected GYBE`);
        }
      }

      // PHASE 3: Calculate TWD from heading distribution
      // Find the two upwind tack headings (opposite heel signs, high heel magnitude)
      // Their bisector points directly at the wind source (TWD)
      let twd = 0;
      
      // Group headings into 10¬∞ bins (only when moving)
      const hdgHist = new Array(36).fill(0);
      const hdgHeelSum = new Array(36).fill(0);
      const hdgAbsHeelSum = new Array(36).fill(0);
      
      sampled.filter(r => r.sog_knots > 2).forEach(r => {
        const bin = Math.floor(r.heading_deg / 10) % 36;
        hdgHist[bin]++;
        hdgHeelSum[bin] += r.roll_deg;
        hdgAbsHeelSum[bin] += Math.abs(r.roll_deg);
      });
      
      // Get all bins sorted by count, with heel data
      const sortedBins = hdgHist
        .map((count, i) => ({
          bin: i * 10 + 5,
          count,
          avgHeel: count > 0 ? hdgHeelSum[i] / count : 0,
          avgAbsHeel: count > 0 ? hdgAbsHeelSum[i] / count : 0
        }))
        .filter(b => b.count > 100)
        .sort((a, b) => b.count - a.count);
      
      console.log('Top heading bins:', sortedBins.slice(0, 8).map(b => 
        `${b.bin}¬∞(${b.count}, heel=${b.avgHeel.toFixed(1)}¬∞)`).join(', '));
      
      if (sortedBins.length >= 2) {
        // Strategy: Find pairs with OPPOSITE heel signs first (true tack pairs)
        // Among opposite-heel pairs, pick one with highest combined heel magnitude
        // Fall back to highest count pair if no opposite-heel pairs exist
        
        let bestOppositeHeelPair = null;
        let bestOppositeHeelScore = 0;
        let bestCountPair = null;
        let bestCountScore = 0;
        
        for (let i = 0; i < Math.min(sortedBins.length, 15); i++) {
          for (let j = i + 1; j < Math.min(sortedBins.length, 15); j++) {
            const diff = Math.abs(angleDiff(sortedBins[i].bin, sortedBins[j].bin));
            if (diff >= 60 && diff <= 120) {
              const heel1 = sortedBins[i].avgHeel;
              const heel2 = sortedBins[j].avgHeel;
              const heelSignsOpposite = (heel1 * heel2) < 0;
              const combinedAbsHeel = sortedBins[i].avgAbsHeel + sortedBins[j].avgAbsHeel;
              const combinedCount = sortedBins[i].count + sortedBins[j].count;
              
              if (heelSignsOpposite) {
                // Prioritize by combined heel magnitude (higher heel = more likely upwind)
                if (combinedAbsHeel > bestOppositeHeelScore) {
                  bestOppositeHeelScore = combinedAbsHeel;
                  bestOppositeHeelPair = [sortedBins[i], sortedBins[j]];
                }
              }
              
              // Track best count pair as fallback
              if (combinedCount > bestCountScore) {
                bestCountScore = combinedCount;
                bestCountPair = [sortedBins[i], sortedBins[j]];
              }
            }
          }
        }
        
        // Use opposite-heel pair if found, otherwise fall back to count-based
        const bestPair = bestOppositeHeelPair || bestCountPair;
        
        if (bestPair) {
          const hdg1 = bestPair[0].bin;
          const hdg2 = bestPair[1].bin;
          const tackAngle = Math.abs(angleDiff(hdg1, hdg2));
          const heel1 = bestPair[0].avgHeel;
          const heel2 = bestPair[1].avgHeel;
          const absHeel1 = bestPair[0].avgAbsHeel;
          const absHeel2 = bestPair[1].avgAbsHeel;
          
          console.log(`Two main tacks: ${hdg1}¬∞ (heel ${heel1.toFixed(1)}¬∞) and ${hdg2}¬∞ (heel ${heel2.toFixed(1)}¬∞)`);
          console.log(`Selection method: ${bestOppositeHeelPair ? 'opposite-heel pair' : 'count-based fallback'}`);
          
          // Calculate bisector using circular mean
          const sin1 = Math.sin(hdg1 * Math.PI / 180);
          const cos1 = Math.cos(hdg1 * Math.PI / 180);
          const sin2 = Math.sin(hdg2 * Math.PI / 180);
          const cos2 = Math.cos(hdg2 * Math.PI / 180);
          let bisector = Math.atan2(sin1 + sin2, cos1 + cos2) * 180 / Math.PI;
          if (bisector < 0) bisector += 360;
          
          // Use heel data to determine if this pair is upwind or downwind
          const heelSignsOpposite = (heel1 * heel2) < 0;
          const pairAvgAbsHeel = (absHeel1 + absHeel2) / 2;
          
          // Find the opposite direction's heel (roughly 180¬∞ from bisector)
          const oppositeBin = sortedBins.find(b => {
            const diff = Math.abs(angleDiff(b.bin, (bisector + 180) % 360));
            return diff < 30;
          });
          const oppositeAbsHeel = oppositeBin ? oppositeBin.avgAbsHeel : 0;
          
          console.log(`Bisector: ${bisector.toFixed(0)}¬∞`);
          console.log(`Heel signs opposite: ${heelSignsOpposite}, pair avg heel: ${pairAvgAbsHeel.toFixed(1)}¬∞, opposite: ${oppositeAbsHeel.toFixed(1)}¬∞`);
          
          // Determine if this pair is upwind based on heel
          const isUpwindPair = heelSignsOpposite && (pairAvgAbsHeel > oppositeAbsHeel + 3);
          
          if (isUpwindPair) {
            // These are upwind headings, bisector = TWD
            twd = bisector;
            console.log(`TWD from upwind headings (heel confirmed): ${twd.toFixed(0)}¬∞`);
          } else if (heelSignsOpposite) {
            // Heel signs opposite but not clearly higher - check TWA
            const twa1 = Math.abs(angleDiff(hdg1, bisector));
            const twa2 = Math.abs(angleDiff(hdg2, bisector));
            if (twa1 < 90 && twa2 < 90) {
              twd = bisector;
              console.log(`TWD from upwind headings (TWA confirmed): ${twd.toFixed(0)}¬∞`);
            } else {
              twd = (bisector + 180) % 360;
              console.log(`TWD inverted based on TWA: ${twd.toFixed(0)}¬∞`);
            }
          } else {
            // Heel signs same - these are likely downwind, TWD is opposite
            twd = (bisector + 180) % 360;
            console.log(`TWD from downwind headings (same heel sign): ${twd.toFixed(0)}¬∞`);
          }
        } else {
          // No valid pair found, use top bin + 45¬∞
          twd = (sortedBins[0].bin + 45) % 360;
          console.log(`TWD from single heading: ${twd.toFixed(0)}¬∞`);
        }
      } else if (maneuvers.length >= 2) {
        // Fallback: use maneuver bisectors
        console.log('Using maneuver bisectors as fallback');
        const bisectors = maneuvers.filter(m => m.hdgChange >= 60 && m.hdgChange <= 130).map(m => {
          const sin1 = Math.sin(m.hdg1 * Math.PI / 180);
          const cos1 = Math.cos(m.hdg1 * Math.PI / 180);
          const sin2 = Math.sin(m.hdg2 * Math.PI / 180);
          const cos2 = Math.cos(m.hdg2 * Math.PI / 180);
          let bisector = Math.atan2(sin1 + sin2, cos1 + cos2) * 180 / Math.PI;
          if (bisector < 0) bisector += 360;
          return bisector;
        });
        
        if (bisectors.length > 0) {
          const sinSum = bisectors.reduce((s, b) => s + Math.sin(b * Math.PI / 180), 0);
          const cosSum = bisectors.reduce((s, b) => s + Math.cos(b * Math.PI / 180), 0);
          twd = Math.atan2(sinSum, cosSum) * 180 / Math.PI;
          if (twd < 0) twd += 360;
          console.log(`TWD from maneuver bisectors: ${twd.toFixed(0)}¬∞`);
        }
      }

      console.log(`TWD calculated: ${twd.toFixed(0)}¬∞`);

      // PHASE 4: Calculate TWA for each point with refined TWD
      sampled.forEach(r => {
        const rawTwa = angleDiff(r.cog_deg, twd);
        r.twa = Math.abs(rawTwa);
        r.twa_signed = rawTwa;
      });

      // PHASE 5: Re-detect legs using TWA-based rolling window
      // This gives us proper upwind/reaching/downwind classification
      const legs = [];
      legStart = 0;
      
      // Calculate rolling average TWA
      const rollingTwa = [];
      for (let i = 0; i < sampled.length; i++) {
        if (i < windowSize) {
          rollingTwa.push(sampled[i].twa);
        } else {
          let sum = 0;
          for (let j = i - windowSize; j < i; j++) {
            sum += sampled[j].twa;
          }
          rollingTwa.push(sum / windowSize);
        }
      }

      // Detect legs by TWA changes (tack = TWA stays similar but heading flips)
      // and heading changes (gybe = heading changes, TWA stays high)
      const twaChangeThreshold = 30;
      // For sparse GPS data, also check instantaneous heading changes (gybes get smoothed by rolling avg)
      const instantHdgThreshold = isSparseData ? 40 : 999; // Only for sparse data
      // Cooldown: after detecting a maneuver, wait before detecting another (rolling avg needs to stabilize)
      const cooldownSamples = isSparseData ? windowSize * 2 : 0;
      let cooldown = 0;
      
      for (let i = windowSize * 2; i < sampled.length; i++) {
        // Skip if in cooldown period
        if (cooldown > 0) {
          cooldown--;
          continue;
        }
        
        const timeDiff = (sampled[i].timestamp_ms - sampled[i-1].timestamp_ms) / 1000;
        const hdgChange = Math.abs(angleDiff(rollingHdg[i], rollingHdg[i - windowSize]));
        const twaChange = Math.abs(rollingTwa[i] - rollingTwa[i - windowSize]);
        // Instantaneous heading change (for catching gybes in sparse data)
        const instantHdgChange = Math.abs(angleDiff(sampled[i].heading_deg, sampled[i-1].heading_deg));
        
        // Detect maneuver: significant heading change OR significant TWA change
        // For sparse data: also check instantaneous heading change to catch gybes
        // For sparse data, don't use time gap detection (irregular sampling is normal)
        const isManeuver = isSparseData
          ? (hdgChange > maneuverThreshold || twaChange > twaChangeThreshold || instantHdgChange > instantHdgThreshold)
          : (hdgChange > maneuverThreshold || twaChange > twaChangeThreshold || timeDiff > 5);
        
        if (isManeuver) {
          const legDur = (sampled[i-1].timestamp_ms - sampled[legStart].timestamp_ms) / 1000;
          if (legDur >= minLegDur) {
            legs.push({ startIdx: legStart, endIdx: i - windowSize });
          }
          legStart = i;
          cooldown = cooldownSamples; // Start cooldown
        }
      }
      // Add final leg
      const finalLegDur = (sampled[sampled.length-1].timestamp_ms - sampled[legStart].timestamp_ms) / 1000;
      if (finalLegDur >= minLegDur) {
        legs.push({ startIdx: legStart, endIdx: sampled.length - 1 });
      }
      
      console.log(`PHASE 5: Re-detected ${legs.length} legs using TWA`);

      // PHASE 6: Process each leg with proper TWA-based classification
      const processedLegs = legs.map((leg, idx) => {
        const points = sampled.slice(leg.startIdx, leg.endIdx + 1);
        if (points.length === 0) return null;
        
        const dur = (points[points.length-1].timestamp_ms - points[0].timestamp_ms) / 1000;
        const startMin = (points[0].timestamp_ms - firstTs) / 60000;
        const endMin = (points[points.length-1].timestamp_ms - firstTs) / 60000;

        // Average values
        const avgTwa = points.reduce((s, p) => s + p.twa, 0) / points.length;
        const avgSpeed = points.reduce((s, p) => s + p.sog_knots, 0) / points.length;
        const avgHeel = points.reduce((s, p) => s + Math.abs(p.roll_deg), 0) / points.length;

        // POS classification based on TWA
        let pos;
        if (avgTwa < 75) pos = 'upwind';
        else if (avgTwa <= 112) pos = 'reaching';
        else pos = 'downwind';

        // Leg heading
        let legHdg;
        
        if (isSparseData && points.length >= 2) {
          // For sparse GPS data: calculate bearing from start to end coordinates
          // This gives the actual direction traveled from start to end of leg
          const startPt = points[0];
          const endPt = points[points.length - 1];
          const dLon = (endPt.lon - startPt.lon) * Math.PI / 180;
          const lat1 = startPt.lat * Math.PI / 180;
          const lat2 = endPt.lat * Math.PI / 180;
          const x = Math.sin(dLon) * Math.cos(lat2);
          const y = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
          legHdg = Math.atan2(x, y) * 180 / Math.PI;
          if (legHdg < 0) legHdg += 360;
          
          console.log(`  Leg ${idx+1} heading: ${legHdg.toFixed(0)}¬∞`);
        } else {
          // For high-frequency data: use circular mean of headings
          const sinSum = points.reduce((s, p) => s + Math.sin(p.heading_deg * Math.PI / 180), 0);
          const cosSum = points.reduce((s, p) => s + Math.cos(p.heading_deg * Math.PI / 180), 0);
          legHdg = Math.atan2(sinSum, cosSum) * 180 / Math.PI;
          if (legHdg < 0) legHdg += 360;
        }
        
        // Store endpoint headings (COG at start/end of leg)
        const hdgStart = points[0].heading_deg;
        const hdgEnd = points[points.length - 1].heading_deg;

        // Steering rate (¬∞/s)
        let totalHdgChange = 0;
        for (let i = 1; i < points.length; i++) {
          totalHdgChange += Math.abs(angleDiff(points[i].heading_deg, points[i-1].heading_deg));
        }
        const rate = totalHdgChange / dur;

        // COG corridor (5-95 percentile deviation)
        const cogDevs = points.map(p => angleDiff(p.cog_deg, legHdg));
        cogDevs.sort((a, b) => a - b);
        const p5 = cogDevs[Math.floor(cogDevs.length * 0.05)];
        const p95 = cogDevs[Math.floor(cogDevs.length * 0.95)];
        const corridor = Math.max(Math.abs(p5), Math.abs(p95));

        // Mag heading corridor (90% envelope: 5-95 percentile)
        const magDevs = points.map(p => angleDiff(p.heading_deg, legHdg));
        magDevs.sort((a, b) => a - b);
        const mp5 = magDevs[Math.floor(magDevs.length * 0.05)];
        const mp95 = magDevs[Math.floor(magDevs.length * 0.95)];
        const magCorridor = Math.max(Math.abs(mp5), Math.abs(mp95));
        
        // MAG70 (70% envelope: 15-85 percentile)
        const mp15 = magDevs[Math.floor(magDevs.length * 0.15)];
        const mp85 = magDevs[Math.floor(magDevs.length * 0.85)];
        const mag70 = Math.max(Math.abs(mp15), Math.abs(mp85));

        // Line Deviation (100% - straightness) and lost meters
        // Uses Haversine formula for accurate distance calculation
        const haversine = (lat1, lon1, lat2, lon2) => {
          const R = 6371000; // Earth radius in meters
          const dLat = (lat2 - lat1) * Math.PI / 180;
          const dLon = (lon2 - lon1) * Math.PI / 180;
          const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
          return R * c;
        };
        
        // Straight-line distance from start to end
        const straightDist = haversine(points[0].lat, points[0].lon, 
                                        points[points.length-1].lat, points[points.length-1].lon);
        
        // Total path length (sum of all segment distances)
        let totalPathLen = 0;
        for (let i = 1; i < points.length; i++) {
          totalPathLen += haversine(points[i-1].lat, points[i-1].lon, 
                                     points[i].lat, points[i].lon);
        }
        
        // Line deviation (how much extra distance was sailed)
        const lineDeviation = totalPathLen > 0 ? (totalPathLen - straightDist) / straightDist : 0;
        const lostMeters = totalPathLen - straightDist;

        // Timeseries for detail view (downsample)
        const tsStep = Math.max(1, Math.floor(points.length / 100));
        const ts = points.filter((_, i) => i % tsStep === 0).map(p => {
          // Calculate instantaneous TWA and VMG
          const instTwa = Math.abs(angleDiff(p.heading_deg, twd));
          const instVmg = Math.abs(p.sog_knots * Math.cos(instTwa * Math.PI / 180));
          return {
            t: (p.timestamp_ms - points[0].timestamp_ms) / 60000 + startMin,
            cog: p.cog_deg,
            hdg: p.heading_deg,
            dev: angleDiff(p.cog_deg, legHdg),
            mdev: angleDiff(p.heading_deg, legHdg),
            heel: p.roll_deg,
            spd: p.sog_knots,
            vmg: instVmg,
            rate: 0 // Will compute below
          };
        });

        // Compute instant rate for timeseries
        for (let i = 1; i < ts.length - 1; i++) {
          const dt = (ts[i+1].t - ts[i-1].t) * 60; // seconds
          const dh = Math.abs(angleDiff(ts[i+1].hdg, ts[i-1].hdg));
          ts[i].rate = dt > 0 ? dh / dt : 0;
        }
        if (ts.length > 0) ts[0].rate = ts.length > 1 ? ts[1].rate : 0;
        if (ts.length > 1) ts[ts.length-1].rate = ts[ts.length-2].rate;

        return {
          id: idx + 1,
          start: startMin,
          end: endMin,
          dur: Math.round(dur),
          pos,
          twa: Math.round(avgTwa),
          hdg: Math.round(legHdg),
          hdgStart: hdgStart,  // Heading at start of leg
          hdgEnd: hdgEnd,  // Heading at end of leg
          speed: avgSpeed.toFixed(1),
          heel: avgHeel.toFixed(1),
          rate,
          corridor,
          mag_corridor: magCorridor,
          mag70,
          lineDeviation,
          lostMeters,
          startLat: points[0].lat,
          startLon: points[0].lon,
          endLat: points[points.length-1].lat,
          endLon: points[points.length-1].lon,
          ts,
          next_maneuver: null
        };
      }).filter(leg => leg !== null);
      
      // Re-number legs after filtering
      processedLegs.forEach((leg, i) => leg.id = i + 1);
      
      console.log(`PHASE 6: Processed ${processedLegs.length} legs`);
      processedLegs.forEach(leg => {
        console.log(`  Leg ${leg.id}: ${leg.pos}, TWA=${leg.twa}¬∞, hdg=${leg.hdg}¬∞, ${leg.dur}s`);
      });

      // PHASE 7: Detect tacks and gybes based on heading changes
      // Use clustering to find consistent wind direction from maneuvers
      let finalTacks = 0, finalGybes = 0;
      
      // First pass: collect ALL potential maneuvers and their implied wind
      const potentialManeuvers = [];
      
      for (let i = 0; i < processedLegs.length - 1; i++) {
        const curr = processedLegs[i];
        const next = processedLegs[i + 1];
        
        // Use trimmed average headings for tack/gybe angle calculation
        const currHdg = curr.hdg;
        const nextHdg = next.hdg;
        const hdgChange = Math.abs(angleDiff(nextHdg, currHdg));
        
        if (isSparseData) {
          console.log(`  Maneuver check ${curr.id}->${next.id}: hdg ${currHdg}¬∞->${nextHdg}¬∞, change=${hdgChange.toFixed(0)}¬∞`);
        }
        
        // Skip if heading change is too small or too large
        if (hdgChange < 50 || hdgChange > 150) continue;
        
        // Calculate bisector
        const sin1 = Math.sin(currHdg * Math.PI / 180);
        const cos1 = Math.cos(currHdg * Math.PI / 180);
        const sin2 = Math.sin(nextHdg * Math.PI / 180);
        const cos2 = Math.cos(nextHdg * Math.PI / 180);
        let bisector = Math.atan2(sin1 + sin2, cos1 + cos2) * 180 / Math.PI;
        if (bisector < 0) bisector += 360;
        
        // For a tack, wind comes FROM bisector direction
        // For a gybe, wind comes FROM opposite of bisector
        potentialManeuvers.push({
          idx: i,
          curr, next,
          hdgChange,
          tackWind: bisector,  // If this is a tack, wind is from here
          gybeWind: (bisector + 180) % 360  // If this is a gybe, wind is from here
        });
      }
      
      console.log(`Found ${potentialManeuvers.length} potential maneuvers`);
      
      // Cluster the implied wind directions to find the dominant wind
      // Use 30¬∞ bins
      function findDominantWind(maneuvers, windKey) {
        const bins = {};
        maneuvers.forEach(m => {
          const bin = Math.round(m[windKey] / 30) * 30 % 360;
          if (!bins[bin]) bins[bin] = [];
          bins[bin].push(m);
        });
        
        // Find the bin with most maneuvers
        let maxBin = null, maxCount = 0;
        Object.entries(bins).forEach(([bin, list]) => {
          if (list.length > maxCount) {
            maxCount = list.length;
            maxBin = parseInt(bin);
          }
        });
        
        return { dominantBin: maxBin, count: maxCount, bins };
      }
      
      // Check if tacks or gybes give more consistent wind
      const tackAnalysis = findDominantWind(potentialManeuvers, 'tackWind');
      const gybeAnalysis = findDominantWind(potentialManeuvers, 'gybeWind');
      
      console.log(`Tack wind clusters: dominant bin ${tackAnalysis.dominantBin}¬∞ with ${tackAnalysis.count} maneuvers`);
      console.log(`Gybe wind clusters: dominant bin ${gybeAnalysis.dominantBin}¬∞ with ${gybeAnalysis.count} maneuvers`);
      
      // Build wind timeline from consistent maneuvers only
      const windTimeline = [];
      const windTolerance = 45; // Only accept maneuvers within 45¬∞ of dominant wind
      
      // Determine dominant wind direction from the most consistent cluster
      // BUT validate against heel-confirmed TWD from Phase 3
      let dominantWind;
      const tackDominant = tackAnalysis.dominantBin;
      const gybeDominant = gybeAnalysis.dominantBin;
      
      // Check which candidate is closer to our heel-validated TWD
      const tackDiff = Math.abs(angleDiff(tackDominant, twd));
      const gybeDiff = Math.abs(angleDiff(gybeDominant, twd));
      
      console.log(`Phase 3 TWD (heel-validated): ${twd}¬∞`);
      console.log(`Tack dominant: ${tackDominant}¬∞ (diff from TWD: ${tackDiff.toFixed(0)}¬∞)`);
      console.log(`Gybe dominant: ${gybeDominant}¬∞ (diff from TWD: ${gybeDiff.toFixed(0)}¬∞)`);
      
      // Use the cluster that's closest to heel-validated TWD, or fall back to Phase 3 TWD
      if (tackAnalysis.count >= 3 && tackDiff < 60) {
        dominantWind = tackDominant;
        console.log(`Using tack cluster (consistent with heel-validated TWD)`);
      } else if (gybeAnalysis.count >= 3 && gybeDiff < 60) {
        dominantWind = gybeDominant;
        console.log(`Using gybe cluster (consistent with heel-validated TWD)`);
      } else {
        dominantWind = twd; // Keep heel-validated TWD from Phase 3
        console.log(`Keeping heel-validated TWD from Phase 3`);
      }
      
      console.log(`Using dominant wind direction: ${dominantWind}¬∞`);
      
      for (const m of potentialManeuvers) {
        const tackWindDiff = Math.abs(angleDiff(m.tackWind, dominantWind));
        const gybeWindDiff = Math.abs(angleDiff(m.gybeWind, dominantWind));
        
        // Additional validation: tacks should be between upwind legs, gybes between downwind legs
        const bothUpwind = m.curr.pos === 'upwind' && m.next.pos === 'upwind';
        const bothDownwind = m.curr.pos === 'downwind' && m.next.pos === 'downwind';
        
        if (isSparseData) {
          // For sparse GPS data, use relaxed position validation and angle validation
          // (GPS-derived positions may be less accurate due to COG noise)
          const oneUpwind = m.curr.pos === 'upwind' || m.next.pos === 'upwind';
          const oneDownwind = m.curr.pos === 'downwind' || m.next.pos === 'downwind';
          const neitherReaching = m.curr.pos !== 'reaching' && m.next.pos !== 'reaching';
          
          // Angle validation: typical tack angles are 70-120¬∞, typical gybe angles are 40-110¬∞
          const validTackAngle = m.hdgChange >= 70 && m.hdgChange <= 120;
          const validGybeAngle = m.hdgChange >= 40 && m.hdgChange <= 110;
          
          // For tacks: allow if at least one leg is upwind AND neither is downwind
          const tackPosValid = oneUpwind && !bothDownwind;
          // For gybes: allow if at least one leg is downwind AND neither is reaching
          const gybePosValid = oneDownwind && neitherReaching;
          
          // Debug logging for sparse data
          console.log(`  Leg ${m.curr.id} (${m.curr.pos}) -> Leg ${m.next.id} (${m.next.pos}): hdgChange=${m.hdgChange.toFixed(0)}¬∞`);
          console.log(`    tackWindDiff=${tackWindDiff.toFixed(0)}¬∞, gybeWindDiff=${gybeWindDiff.toFixed(0)}¬∞`);
          console.log(`    tackPosValid=${tackPosValid}, gybePosValid=${gybePosValid}, validTack=${validTackAngle}, validGybe=${validGybeAngle}`);
          
          if (tackWindDiff <= windTolerance && tackWindDiff < gybeWindDiff && tackPosValid && validTackAngle) {
            m.curr.next_maneuver = { type: 'tack', angle: Math.round(m.hdgChange) };
            finalTacks++;
            windTimeline.push({ time: m.curr.end, wind: m.tackWind, type: 'tack' });
            console.log(`    => TACK ASSIGNED: ${Math.round(m.hdgChange)}¬∞`);
          } else if (gybeWindDiff <= windTolerance && gybePosValid && validGybeAngle) {
            m.curr.next_maneuver = { type: 'gybe', angle: Math.round(m.hdgChange) };
            finalGybes++;
            windTimeline.push({ time: m.curr.end, wind: m.gybeWind, type: 'gybe' });
            console.log(`    => GYBE ASSIGNED: ${Math.round(m.hdgChange)}¬∞`);
          } else {
            console.log(`    => NOT ASSIGNED`);
          }
        } else {
          // Original VKX logic - simpler validation based on wind direction only
          if (tackWindDiff <= windTolerance && tackWindDiff < gybeWindDiff) {
            m.curr.next_maneuver = { type: 'tack', angle: Math.round(m.hdgChange) };
            finalTacks++;
            windTimeline.push({ time: m.curr.end, wind: m.tackWind, type: 'tack' });
            console.log(`  TACK after Leg ${m.curr.id}: ${m.curr.hdg.toFixed(0)}¬∞‚Üí${m.next.hdg.toFixed(0)}¬∞ (${Math.round(m.hdgChange)}¬∞), wind=${m.tackWind.toFixed(0)}¬∞`);
          } else if (gybeWindDiff <= windTolerance) {
            m.curr.next_maneuver = { type: 'gybe', angle: Math.round(m.hdgChange) };
            finalGybes++;
            windTimeline.push({ time: m.curr.end, wind: m.gybeWind, type: 'gybe' });
            console.log(`  GYBE after Leg ${m.curr.id}: ${m.curr.hdg.toFixed(0)}¬∞‚Üí${m.next.hdg.toFixed(0)}¬∞ (${Math.round(m.hdgChange)}¬∞), wind=${m.gybeWind.toFixed(0)}¬∞`);
          }
        }
      }
      
      console.log(`PHASE 7: Final maneuvers - ${finalTacks} tacks, ${finalGybes} gybes`);
      console.log(`Wind timeline has ${windTimeline.length} points`);
      
      // Debug: Log which legs have next_maneuver set
      const legsWithManeuvers = processedLegs.filter(l => l.next_maneuver !== null);
      console.log(`Legs with next_maneuver after Phase 7: ${legsWithManeuvers.length}`);
      legsWithManeuvers.forEach(l => console.log(`  Leg ${l.id}: ${l.next_maneuver.type} ${l.next_maneuver.angle}¬∞`));
      
      // Update twd to dominantWind if we found valid clusters
      if (windTimeline.length >= 3) {
        twd = dominantWind;
        console.log(`Updated TWD to dominant wind: ${twd}¬∞`);
      }

      // PHASE 8: Recalculate TWA and VMG using time-varying wind
      // Sort wind timeline by time
      windTimeline.sort((a, b) => a.time - b.time);
      
      // Helper: interpolate wind at a given time
      function getWindAtTime(t) {
        if (windTimeline.length === 0) return twd; // Fallback to original TWD
        if (windTimeline.length === 1) return windTimeline[0].wind;
        
        // Find surrounding wind measurements
        let before = null, after = null;
        for (let i = 0; i < windTimeline.length; i++) {
          if (windTimeline[i].time <= t) before = windTimeline[i];
          if (windTimeline[i].time >= t && !after) after = windTimeline[i];
        }
        
        if (!before) return after.wind;
        if (!after) return before.wind;
        if (before.time === after.time) return before.wind;
        
        // Linear interpolation with circular handling
        const ratio = (t - before.time) / (after.time - before.time);
        let diff = angleDiff(after.wind, before.wind);
        let interpolated = before.wind + diff * ratio;
        if (interpolated < 0) interpolated += 360;
        if (interpolated >= 360) interpolated -= 360;
        return interpolated;
      }
      
      // Recalculate TWA and add VMG for each leg
      processedLegs.forEach(leg => {
        const midTime = (leg.start + leg.end) / 2;
        const localWind = getWindAtTime(midTime);
        leg.localWind = Math.round(localWind);
        
        // Recalculate TWA with local wind
        const newTwa = Math.abs(angleDiff(leg.hdg, localWind));
        leg.twa = Math.round(newTwa);
        
        // Recalculate POS based on new TWA
        if (newTwa < 75) {
          leg.pos = 'upwind';
        } else if (newTwa > 112) {
          leg.pos = 'downwind';
        } else {
          leg.pos = 'reaching';
        }
        
        // Calculate VMG (Velocity Made Good towards/away from wind)
        // VMG = Speed √ó cos(TWA)
        const speed = parseFloat(leg.speed);
        const vmg = Math.abs(speed * Math.cos(newTwa * Math.PI / 180));
        leg.vmg = vmg.toFixed(1);
        
        console.log(`  Leg ${leg.id}: wind=${leg.localWind}¬∞, TWA=${leg.twa}¬∞, VMG=${leg.vmg} kts`);
      });
      
      // Calculate typical (median) wind direction from time-varying data
      // Only use median if it's consistent with heel-validated TWD
      if (windTimeline.length > 0) {
        // Use circular median for angles
        const windAngles = windTimeline.map(w => w.wind);
        // Sort by angle (handling circular nature by finding cluster)
        const sorted = [...windAngles].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        const medianWind = sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
        
        // Only update TWD if median is within 60¬∞ of current (heel-validated) TWD
        const medianDiff = Math.abs(angleDiff(medianWind, twd));
        if (medianDiff < 60) {
          twd = Math.round(medianWind);
          console.log(`Typical wind (median of ${windTimeline.length} measurements): ${twd}¬∞ (consistent with heel validation)`);
        } else {
          console.log(`Median wind ${Math.round(medianWind)}¬∞ differs too much from heel-validated ${twd}¬∞, keeping original`);
        }
      }
      
      console.log(`PHASE 8: Recalculated TWA and VMG with time-varying wind`);

      // Calculate 1-minute intervals
      const intervals = [];
      processedLegs.forEach(leg => {
        const legPoints = sampled.filter(p => {
          const t = (p.timestamp_ms - firstTs) / 60000;
          return t >= leg.start && t <= leg.end;
        });

        // Group by minute
        const byMinute = {};
        legPoints.forEach(p => {
          const min = Math.floor((p.timestamp_ms - firstTs) / 60000);
          if (!byMinute[min]) byMinute[min] = [];
          byMinute[min].push(p);
        });

        Object.entries(byMinute).forEach(([min, pts]) => {
          if (pts.length < 10) return;

          // Calc steering rate for this minute
          let hdgChange = 0;
          for (let i = 1; i < pts.length; i++) {
            hdgChange += Math.abs(angleDiff(pts[i].heading_deg, pts[i-1].heading_deg));
          }
          const dur = (pts[pts.length-1].timestamp_ms - pts[0].timestamp_ms) / 1000;
          const rate = dur > 0 ? hdgChange / dur : 0;

          // Minute heading
          const sinSum = pts.reduce((s, p) => s + Math.sin(p.heading_deg * Math.PI / 180), 0);
          const cosSum = pts.reduce((s, p) => s + Math.cos(p.heading_deg * Math.PI / 180), 0);
          let minHdg = Math.atan2(sinSum, cosSum) * 180 / Math.PI;
          if (minHdg < 0) minHdg += 360;

          // COG corridor
          const devs = pts.map(p => angleDiff(p.cog_deg, minHdg));
          devs.sort((a, b) => a - b);
          const p5 = devs[Math.floor(devs.length * 0.05)] || devs[0];
          const p95 = devs[Math.floor(devs.length * 0.95)] || devs[devs.length-1];
          const corridor = Math.max(Math.abs(p5), Math.abs(p95));

          // MAG corridor (heading deviation from mean heading)
          const magDevs = pts.map(p => angleDiff(p.heading_deg, minHdg));
          magDevs.sort((a, b) => a - b);
          const mp5 = magDevs[Math.floor(magDevs.length * 0.05)] || magDevs[0];
          const mp95 = magDevs[Math.floor(magDevs.length * 0.95)] || magDevs[magDevs.length-1];
          const magCorridor = Math.max(Math.abs(mp5), Math.abs(mp95));

          intervals.push({
            minute: parseInt(min),
            leg_id: leg.id,
            pos: leg.pos,
            rate,
            corridor_pm: corridor,
            mag_corridor_pm: magCorridor
          });
        });
      });

      // Calculate overall stats
      // Filter out slow legs (< 2 kts) for speed/VMG stats - these are maneuvering/drifting
      const minSpeedForStats = 2.0;
      const upwindLegs = processedLegs.filter(l => l.pos === 'upwind');
      const downwindLegs = processedLegs.filter(l => l.pos === 'downwind');
      const reachingLegs = processedLegs.filter(l => l.pos === 'reaching');
      
      // For speed/VMG, exclude slow maneuvering legs
      const upwindLegsMoving = upwindLegs.filter(l => parseFloat(l.speed) >= minSpeedForStats);
      const downwindLegsMoving = downwindLegs.filter(l => parseFloat(l.speed) >= minSpeedForStats);
      const reachingLegsMoving = reachingLegs.filter(l => parseFloat(l.speed) >= minSpeedForStats);

      const weightedAvg = (legs, prop) => {
        const total = legs.reduce((s, l) => s + l.dur, 0);
        if (total === 0) return 0;
        return legs.reduce((s, l) => s + parseFloat(l[prop]) * l.dur, 0) / total;
      };

      const totalDur = processedLegs.reduce((s, l) => s + l.dur, 0);
      
      // Determine TWD source description
      let twdSource;
      if (finalTacks + finalGybes > 0) {
        twdSource = `time-varying from ${finalTacks + finalGybes} maneuvers`;
      } else if (finalTacks >= 1) {
        twdSource = `from ${finalTacks} tack${finalTacks > 1 ? 's' : ''}`;
      } else if (finalGybes >= 1) {
        twdSource = `from ${finalGybes} gybe${finalGybes > 1 ? 's' : ''}`;
      } else {
        twdSource = 'from heading analysis';
      }

      const stats = {
        d: new Date(firstTs).toLocaleDateString(),
        timestamp: firstTs, // Raw timestamp for sorting
        dur: Math.round(totalDur / 60),
        twd: Math.round(twd),
        twdSource,
        finalTacks,
        finalGybes,
        // Use moving legs (>2 kts) for all performance stats to exclude maneuvering
        speed_upwind: upwindLegsMoving.length ? weightedAvg(upwindLegsMoving, 'speed').toFixed(1) : '-',
        speed_downwind: downwindLegsMoving.length ? weightedAvg(downwindLegsMoving, 'speed').toFixed(1) : '-',
        vmg_upwind: upwindLegsMoving.length ? weightedAvg(upwindLegsMoving, 'vmg').toFixed(1) : '-',
        vmg_downwind: downwindLegsMoving.length ? weightedAvg(downwindLegsMoving, 'vmg').toFixed(1) : '-',
        heel_upwind: upwindLegsMoving.length ? weightedAvg(upwindLegsMoving, 'heel').toFixed(0) : '-',
        heel_downwind: downwindLegsMoving.length ? weightedAvg(downwindLegsMoving, 'heel').toFixed(0) : '-',
        corridor_upwind: upwindLegsMoving.length ? weightedAvg(upwindLegsMoving, 'corridor').toFixed(1) : '-',
        corridor_downwind: downwindLegsMoving.length ? weightedAvg(downwindLegsMoving, 'corridor').toFixed(1) : '-',
        mag_corridor_upwind: upwindLegsMoving.length ? weightedAvg(upwindLegsMoving, 'mag_corridor').toFixed(1) : '-',
        mag_corridor_downwind: downwindLegsMoving.length ? weightedAvg(downwindLegsMoving, 'mag_corridor').toFixed(1) : '-',
        mag70_upwind: upwindLegsMoving.length ? weightedAvg(upwindLegsMoving, 'mag70').toFixed(1) : '-',
        mag70_downwind: downwindLegsMoving.length ? weightedAvg(downwindLegsMoving, 'mag70').toFixed(1) : '-',
        rate_upwind: upwindLegsMoving.length ? weightedAvg(upwindLegsMoving, 'rate').toFixed(2) : '-',
        rate_downwind: downwindLegsMoving.length ? weightedAvg(downwindLegsMoving, 'rate').toFixed(2) : '-',
        linedev_upwind: upwindLegsMoving.length ? (weightedAvg(upwindLegsMoving, 'lineDeviation') * 100).toFixed(1) : '-',
        linedev_downwind: downwindLegsMoving.length ? (weightedAvg(downwindLegsMoving, 'lineDeviation') * 100).toFixed(1) : '-',
        lostm_upwind: upwindLegsMoving.length ? Math.round(upwindLegsMoving.reduce((s, l) => s + l.lostMeters, 0)) : '-',
        lostm_downwind: downwindLegsMoving.length ? Math.round(downwindLegsMoving.reduce((s, l) => s + l.lostMeters, 0)) : '-',
      };

      // POS breakdown
      const posBreakdown = {
        upwind: {
          time: upwindLegs.reduce((s, l) => s + l.dur, 0),
          pct: ((upwindLegs.reduce((s, l) => s + l.dur, 0) / totalDur) * 100).toFixed(0),
          speed: stats.speed_upwind,
          vmg: stats.vmg_upwind,
          corridor: stats.corridor_upwind,
          rate: stats.rate_upwind,
          heel: stats.heel_upwind,
          linedev: stats.linedev_upwind,
          lostm: stats.lostm_upwind
        },
        reaching: {
          time: reachingLegs.reduce((s, l) => s + l.dur, 0),
          pct: ((reachingLegs.reduce((s, l) => s + l.dur, 0) / totalDur) * 100).toFixed(0),
          speed: reachingLegsMoving.length ? weightedAvg(reachingLegsMoving, 'speed').toFixed(1) : '-',
          vmg: reachingLegsMoving.length ? weightedAvg(reachingLegsMoving, 'vmg').toFixed(1) : '-',
          corridor: reachingLegsMoving.length ? weightedAvg(reachingLegsMoving, 'corridor').toFixed(1) : '-',
          rate: reachingLegsMoving.length ? weightedAvg(reachingLegsMoving, 'rate').toFixed(2) : '-',
          heel: reachingLegsMoving.length ? weightedAvg(reachingLegsMoving, 'heel').toFixed(0) : '-',
          linedev: reachingLegsMoving.length ? (weightedAvg(reachingLegsMoving, 'lineDeviation') * 100).toFixed(1) : '-',
          lostm: reachingLegsMoving.length ? Math.round(reachingLegsMoving.reduce((s, l) => s + l.lostMeters, 0)) : '-'
        },
        downwind: {
          time: downwindLegs.reduce((s, l) => s + l.dur, 0),
          pct: ((downwindLegs.reduce((s, l) => s + l.dur, 0) / totalDur) * 100).toFixed(0),
          speed: stats.speed_downwind,
          vmg: stats.vmg_downwind,
          corridor: stats.corridor_downwind,
          rate: stats.rate_downwind,
          heel: stats.heel_downwind,
          linedev: stats.linedev_downwind,
          lostm: stats.lostm_downwind
        }
      };

      // Track points for map (store full resolution for adaptive rendering)
      // Include hdg, sog, cog, roll for race replay mode
      const track = sampled.map(p => ({
        lat: p.lat,
        lon: p.lon,
        t: (p.timestamp_ms - firstTs) / 60000,
        hdg: p.heading_deg || p.cog_deg || 0,
        sog: p.sog_knots || 0,
        cog: p.cog_deg || 0,
        roll_deg: p.roll_deg || 0
      }));

      return {
        s: stats,
        o: stats,
        legs: processedLegs,
        intervals,
        pos: posBreakdown,
        track
      };
    }

    // ===== UI FUNCTIONS =====
    function getRateColor(rate) {
      if (rate <= 1.5) return '#22c55e';
      if (rate <= 3) return '#3b82f6';
      if (rate <= 5) return '#f59e0b';
      return '#ef4444';
    }

    function getCorridorColor(c) {
      if (c <= 8) return '#22c55e';
      if (c <= 12) return '#3b82f6';
      if (c <= 18) return '#f59e0b';
      return '#ef4444';
    }

    function getMagCorridorColor(c) {
      if (c <= 5) return '#22c55e';   // Excellent: ‚â§¬±5¬∞
      if (c <= 8) return '#3b82f6';   // Good: ¬±5-8¬∞
      if (c <= 12) return '#f59e0b';  // Fair: ¬±8-12¬∞
      return '#ef4444';                // Needs work: >¬±12¬∞
    }

    function getLineDeviationColor(pct) {
      if (pct <= 1) return '#22c55e';   // Excellent: <= 1%
      if (pct <= 2) return '#3b82f6';   // Good: 1-2%
      if (pct <= 4) return '#f59e0b';   // Fair: 2-4%
      return '#ef4444';                  // Needs work: > 4%
    }

    function renderDashboard() {
      const filename = DATA.filename || 'Session';
      const shortName = filename.replace('.vkx', '').replace('.fit', '').replace('.gpx', '').replace('.csv', '').replace('.gz', '').replace(/[_-]/g, ' ');
      document.getElementById('session-title').textContent = `${shortName} - Steering Analysis`;
      
      // Build subtitle with optional timeline info
      let subtitle = `${DATA.s.d} | ${DATA.s.dur} min | Wind ${DATA.s.twd}¬∞ (${DATA.s.twdSource})`;
      if (DATA.dataSource === 'garmin') {
        subtitle += ' | üìç GPS (smoothed COG)';
      }
      if (DATA.fullDuration && DATA.timelineStart !== undefined && DATA.timelineEnd !== undefined) {
        const isFiltered = DATA.timelineStart > 0.1 || DATA.timelineEnd < DATA.fullDuration - 0.1;
        if (isFiltered) {
          subtitle += ` | ‚è± ${DATA.timelineStart.toFixed(1)}-${DATA.timelineEnd.toFixed(1)} min`;
        }
      }
      document.getElementById('session-subtitle').textContent = subtitle;
      
      // Update add files button text
      const addBtn = document.getElementById('add-files-btn');
      if (addBtn) {
        addBtn.textContent = ALL_SESSIONS.length > 1 ? 'Add More Files' : 'Load More Files';
      }

      // Stats
      document.getElementById('speed-up').textContent = `${DATA.o.speed_upwind}/${DATA.o.vmg_upwind}`;
      document.getElementById('speed-down').textContent = `${DATA.o.speed_downwind}/${DATA.o.vmg_downwind}`;
      document.getElementById('heel-up').textContent = DATA.o.heel_upwind + '¬∞';
      document.getElementById('heel-down').textContent = DATA.o.heel_downwind + '¬∞';
      document.getElementById('corr-up').textContent = '¬±' + DATA.o.corridor_upwind + '¬∞';
      document.getElementById('corr-down').textContent = '¬±' + DATA.o.corridor_downwind + '¬∞';
      document.getElementById('mag-up').textContent = DATA.o.mag_corridor_upwind + '¬∞';
      document.getElementById('mag-down').textContent = DATA.o.mag_corridor_downwind + '¬∞';
      document.getElementById('mag70-up').textContent = DATA.o.mag70_upwind + '¬∞';
      document.getElementById('mag70-down').textContent = DATA.o.mag70_downwind + '¬∞';
      document.getElementById('linedev-up').textContent = DATA.o.linedev_upwind !== '-' ? `${DATA.o.linedev_upwind}% (${DATA.o.lostm_upwind}m)` : '-';
      document.getElementById('linedev-down').textContent = DATA.o.linedev_downwind !== '-' ? `${DATA.o.linedev_downwind}% (${DATA.o.lostm_downwind}m)` : '-';
      document.getElementById('rate-up').textContent = DATA.o.rate_upwind + '¬∞/s';
      document.getElementById('rate-down').textContent = DATA.o.rate_downwind + '¬∞/s';
      
      // Hide heel and MAG boxes for Garmin data (no independent heading or heel sensor)
      const isGarmin = DATA.dataSource === 'garmin';
      document.getElementById('heel-box').style.display = isGarmin ? 'none' : '';
      document.getElementById('mag-box').style.display = isGarmin ? 'none' : '';
      
      // Tacks/Gybes stats
      const tacks = DATA.legs.filter(l => l.next_maneuver?.type === 'tack');
      const gybes = DATA.legs.filter(l => l.next_maneuver?.type === 'gybe');
      const tackAngles = tacks.map(l => l.next_maneuver.angle).filter(a => a);
      const gybeAngles = gybes.map(l => l.next_maneuver.angle).filter(a => a);
      const medianTackAngle = tackAngles.length ? Math.round(tackAngles.sort((a,b) => a-b)[Math.floor(tackAngles.length/2)]) : null;
      const medianGybeAngle = gybeAngles.length ? Math.round(gybeAngles.sort((a,b) => a-b)[Math.floor(gybeAngles.length/2)]) : null;
      
      document.getElementById('tack-count').textContent = tacks.length;
      document.getElementById('tack-angle').textContent = medianTackAngle !== null ? medianTackAngle + '¬∞' : '-';
      document.getElementById('gybe-count').textContent = gybes.length;
      document.getElementById('gybe-angle').textContent = medianGybeAngle !== null ? medianGybeAngle + '¬∞' : '-';

      renderMap();
      renderLegsTable();
      renderScatterCharts();
      renderPOSBreakdown();
      renderTimeline();
      
      // Show/hide multi-session toggle based on mode
      updateMultiSessionToggleVisibility();
      
      // Initialize view mode (legs mode by default)
      setViewMode(viewMode);
      
      // Setup scroll sync if in iframe mode
      if (isIframeMode) {
        setupScrollSync();
      }
    }

    // Map zoom/pan state
    let mapZoom = 1;
    let mapPanX = 0;
    let mapPanY = 0;
    let mapProjection = 'compass'; // 'compass' (no lat correction) or 'geo' (lat corrected)
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let mapFullscreen = false;  // Fullscreen mode for map (race replay only)

    function zoomMap(factor) {
      mapZoom = Math.max(0.5, Math.min(30, mapZoom * factor));
      renderMap();
    }
    
    function toggleMapFullscreen() {
      mapFullscreen = !mapFullscreen;
      
      const mapContainer = document.getElementById('map-container');
      const mapEl = document.getElementById('map');
      const fullscreenBtn = document.getElementById('map-fullscreen-btn');
      const fsHeader = document.getElementById('map-fullscreen-header');
      const fsFooter = document.getElementById('map-fullscreen-footer');
      const fsDetailsPanel = document.getElementById('fs-details-panel');
      
      if (mapFullscreen) {
        // Enter fullscreen
        mapContainer.classList.add('map-fullscreen');
        document.body.style.overflow = 'hidden';
        
        // Header not used in new layout
        fsHeader.innerHTML = '';
        
        // Footer not used in new layout
        fsFooter.innerHTML = '';
        
        // Show telemetry toggle button
        const telemetryBtn = document.getElementById('fs-telemetry-toggle-btn');
        if (telemetryBtn) telemetryBtn.style.display = 'flex';
        
        // Right panel: Exit button + Timeline (without timeslot) + Leg comparison
        let rightPanelHtml = '';
        
        // Exit button at top (light theme)
        rightPanelHtml += `
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
            <span style="color:#1f2937;font-weight:600;font-size:14px;">üó∫Ô∏è Fullscreen View</span>
            <button onclick="toggleMapFullscreen()" style="background:#e5e7eb;border:1px solid #d1d5db;color:#1f2937;padding:6px 12px;border-radius:6px;cursor:pointer;font-size:12px;display:flex;align-items:center;gap:4px;" onmouseover="this.style.background='#d1d5db'" onmouseout="this.style.background='#e5e7eb'">
              <span>‚úï</span> Exit Fullscreen
            </button>
          </div>
        `;
        
        // Timeline with legs (without timeslot/analysis range line)
        const timelinesContainer = document.getElementById('all-timelines-container');
        if (timelinesContainer && timelinesContainer.innerHTML) {
          // Clone timeline but remove the "Analysis Range" row
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = timelinesContainer.innerHTML;
          // Remove the analysis range selector row (yellow background)
          const analysisRangeRow = tempDiv.querySelector('[style*="background:#fef3c7"]');
          if (analysisRangeRow) {
            analysisRangeRow.parentElement?.removeChild(analysisRangeRow);
          }
          // Also remove global time labels at bottom
          const lastRow = tempDiv.querySelector('[style*="margin-top:4px"]');
          if (lastRow && lastRow.textContent.includes(':')) {
            lastRow.parentElement?.removeChild(lastRow);
          }
          rightPanelHtml += `<div class="card" style="padding:12px;">${tempDiv.innerHTML}</div>`;
        }
        
        // Force update legs panel first to ensure it has current data
        if (raceReplayMode && typeof updateCurrentLegsPanel === 'function') {
          currentLegIds = []; // Reset to force rebuild
          updateCurrentLegsPanel();
        }
        
        // Leg comparison content - in race replay mode, always show it
        const legsComparison = document.getElementById('legs-comparison-section');
        if (raceReplayMode && legsComparison) {
          // In race replay mode, always clone legs comparison even if "hidden" class exists
          rightPanelHtml += `<div class="card" style="flex:1;overflow-y:auto;min-height:0;">${legsComparison.innerHTML}</div>`;
        } else if (legsComparison && !legsComparison.classList.contains('hidden')) {
          rightPanelHtml += `<div class="card" style="flex:1;overflow-y:auto;min-height:0;">${legsComparison.innerHTML}</div>`;
        } else if (selectedLeg) {
          // Show selected leg details in single-session mode
          rightPanelHtml += getFsSelectedLegDetailsHtml();
        } else {
          rightPanelHtml += `
            <div class="card" style="color:#9ca3af;text-align:center;padding:24px;flex:1;">
              Select a leg on the map or table to see details
            </div>
          `;
        }
        
        fsDetailsPanel.innerHTML = rightPanelHtml;
        
        // Get viewport size for fullscreen map
        updateFullscreenMapSize();
        
        // Fit map to visible track after a short delay for layout
        setTimeout(() => {
          fitMapToVisibleTrackFullscreen();
          // Initialize charts in the fullscreen panel (after DOM is ready)
          if (raceReplayMode) {
            initFsLegComparisonCharts();
            // Initialize trim handles in the cloned timeline
            initFsTrimHandles();
          }
        }, 100);
        
        if (fullscreenBtn) {
          fullscreenBtn.textContent = '‚äó';
          fullscreenBtn.title = 'Exit Fullscreen (Esc)';
        }
        
        // Add escape key listener and resize handler
        document.addEventListener('keydown', handleFullscreenEscape);
        window.addEventListener('resize', handleFullscreenResize);
      } else {
        // Exit fullscreen
        mapContainer.classList.remove('map-fullscreen');
        document.body.style.overflow = '';
        
        // Destroy fullscreen leg comparison charts
        destroyFsRaceReplayCharts();
        
        // Clear cloned content
        fsHeader.innerHTML = '';
        fsFooter.innerHTML = '';
        fsDetailsPanel.innerHTML = '';
        
        // Hide telemetry toggle button and overlays
        const telemetryBtn = document.getElementById('fs-telemetry-toggle-btn');
        if (telemetryBtn) telemetryBtn.style.display = 'none';
        const telemetryOverlay = document.getElementById('fs-map-telemetry-overlay');
        if (telemetryOverlay) telemetryOverlay.classList.add('hidden');
        const legOverlay = document.getElementById('fs-map-leg-overlay');
        if (legOverlay) legOverlay.classList.add('hidden');
        
        // Restore map legend visibility
        const legend = document.getElementById('map-legend');
        if (legend) legend.style.display = 'block';
        
        // Restore normal map size
        mapEl.setAttribute('width', '500');
        mapEl.setAttribute('height', '500');
        
        if (fullscreenBtn) {
          fullscreenBtn.textContent = '‚õ∂';
          fullscreenBtn.title = 'Fullscreen Map';
        }
        
        // Remove escape key listener and resize handler
        document.removeEventListener('keydown', handleFullscreenEscape);
        window.removeEventListener('resize', handleFullscreenResize);
      }
      
      // Re-render map with new size
      renderMap();
    }
    
    function updateFullscreenMapSize() {
      if (!mapFullscreen) return;
      
      const mapEl = document.getElementById('map');
      const wrapper = document.getElementById('fs-map-wrapper');
      const panel = document.getElementById('fs-details-panel');
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      
      // Get actual panel width (flex-based, between 400-600px)
      const panelWidth = panel ? Math.min(600, Math.max(400, vw * 0.35)) : 400;
      
      // Calculate available space for map
      const availableHeight = vh - 32; // 16px padding top and bottom
      const availableWidth = vw - panelWidth - 48; // padding on sides
      
      // Make map square, fitting the available space
      const mapSize = Math.min(availableWidth, availableHeight);
      const finalSize = Math.max(400, Math.floor(mapSize));
      
      mapEl.setAttribute('width', finalSize);
      mapEl.setAttribute('height', finalSize);
      
      // Size wrapper to fit map (plus padding for overlays)
      if (wrapper) {
        wrapper.style.width = (finalSize + 32) + 'px';
        wrapper.style.minWidth = (finalSize + 32) + 'px';
      }
    }
    
    // Toggle telemetry overlay on fullscreen map
    let fsMapTelemetryVisible = false;
    let fsMapTelemetryMinimized = false;
    let fsMapTelemetryDragging = false;
    let fsMapTelemetryDragOffset = { x: 0, y: 0 };
    
    function toggleFsMapTelemetry() {
      fsMapTelemetryVisible = !fsMapTelemetryVisible;
      const overlay = document.getElementById('fs-map-telemetry-overlay');
      const legOverlay = document.getElementById('fs-map-leg-overlay');
      const legend = document.getElementById('map-legend');
      const btn = document.getElementById('fs-telemetry-toggle-btn');
      
      if (overlay) {
        overlay.classList.toggle('hidden', !fsMapTelemetryVisible);
      }
      if (legOverlay) {
        legOverlay.classList.toggle('hidden', !fsMapTelemetryVisible);
      }
      // Also toggle map legend (boat details in upper left)
      if (legend && mapFullscreen) {
        legend.style.display = fsMapTelemetryVisible ? 'block' : 'none';
      }
      if (btn) {
        btn.style.background = fsMapTelemetryVisible ? '#3b82f6' : 'rgba(255, 255, 255, 0.95)';
        btn.style.color = fsMapTelemetryVisible ? 'white' : '#1f2937';
      }
      
      if (fsMapTelemetryVisible) {
        updateFsMapTelemetry();
        updateFsMapLegTelemetry();
      }
    }
    
    function toggleFsMapTelemetryMinimize(e) {
      e.stopPropagation();
      fsMapTelemetryMinimized = !fsMapTelemetryMinimized;
      const overlay = document.getElementById('fs-map-telemetry-overlay');
      const minBtn = overlay?.querySelector('.fs-minimize-btn');
      if (overlay) {
        overlay.classList.toggle('minimized', fsMapTelemetryMinimized);
      }
      if (minBtn) {
        minBtn.textContent = fsMapTelemetryMinimized ? '‚ñ≤' : '‚ñº';
      }
    }
    
    function startDragFsMapTelemetry(e) {
      if (e.target.classList.contains('fs-minimize-btn')) return;
      const overlay = document.getElementById('fs-map-telemetry-overlay');
      if (!overlay) return;
      
      fsMapTelemetryDragging = true;
      const rect = overlay.getBoundingClientRect();
      fsMapTelemetryDragOffset.x = e.clientX - rect.left;
      fsMapTelemetryDragOffset.y = e.clientY - rect.top;
      
      document.addEventListener('mousemove', dragFsMapTelemetry);
      document.addEventListener('mouseup', stopDragFsMapTelemetry);
      e.preventDefault();
    }
    
    function dragFsMapTelemetry(e) {
      if (!fsMapTelemetryDragging) return;
      const overlay = document.getElementById('fs-map-telemetry-overlay');
      const wrapper = document.getElementById('fs-map-wrapper');
      if (!overlay || !wrapper) return;
      
      const wrapperRect = wrapper.getBoundingClientRect();
      let x = e.clientX - wrapperRect.left - fsMapTelemetryDragOffset.x;
      let y = e.clientY - wrapperRect.top - fsMapTelemetryDragOffset.y;
      
      // Constrain to wrapper bounds
      x = Math.max(0, Math.min(x, wrapperRect.width - overlay.offsetWidth));
      y = Math.max(0, Math.min(y, wrapperRect.height - overlay.offsetHeight));
      
      overlay.style.left = x + 'px';
      overlay.style.top = y + 'px';
      overlay.style.bottom = 'auto';
    }
    
    function stopDragFsMapTelemetry() {
      fsMapTelemetryDragging = false;
      document.removeEventListener('mousemove', dragFsMapTelemetry);
      document.removeEventListener('mouseup', stopDragFsMapTelemetry);
    }
    
    // Update telemetry overlay content - same format as video overlay
    function updateFsMapTelemetry() {
      if (!fsMapTelemetryVisible || !mapFullscreen) return;
      
      // Get current telemetry data based on playback time
      const sessions = typeof getReplaySessions === 'function' ? getReplaySessions() : (DATA ? [DATA] : []);
      if (!sessions || sessions.length === 0) return;
      
      // Use first session for telemetry display (like video overlay)
      const session = sessions[0];
      if (!session || !session.track) return;
      
      // Find track point closest to current playback time
      const currentTimeMs = getFullStartTimeMs() + playbackTime * 60000;
      const sessionStartMs = session.startTimestampMs || 0;
      const sessionTimeMin = (currentTimeMs - sessionStartMs) / 60000;
      
      // Find closest track point
      let closestPoint = null;
      let minDiff = Infinity;
      session.track.forEach(p => {
        const diff = Math.abs(p.t - sessionTimeMin);
        if (diff < minDiff) {
          minDiff = diff;
          closestPoint = p;
        }
      });
      
      if (!closestPoint) return;
      
      // Update individual elements (same as video overlay)
      const spdEl = document.getElementById('fs-telem-spd');
      const vmgEl = document.getElementById('fs-telem-vmg');
      const hdgEl = document.getElementById('fs-telem-hdg');
      const heelEl = document.getElementById('fs-telem-heel');
      const strEl = document.getElementById('fs-telem-str');
      
      if (spdEl) spdEl.textContent = closestPoint.spd != null ? closestPoint.spd.toFixed(1) : '-.-';
      if (vmgEl) vmgEl.textContent = closestPoint.vmg != null ? closestPoint.vmg.toFixed(1) : '-.-';
      if (hdgEl) hdgEl.textContent = closestPoint.hdg != null ? Math.round(closestPoint.hdg) + '¬∞' : '---';
      if (heelEl) heelEl.textContent = closestPoint.heel != null ? Math.round(closestPoint.heel) + '¬∞' : '--';
      if (strEl) strEl.textContent = closestPoint.rate != null ? closestPoint.rate.toFixed(1) : '-.-';
    }
    
    // Leg overlay drag/minimize/resize
    let fsMapLegMinimized = false;
    let fsMapLegDragging = false;
    let fsMapLegDragOffset = { x: 0, y: 0 };
    
    function toggleFsMapLegMinimize(e) {
      e.stopPropagation();
      fsMapLegMinimized = !fsMapLegMinimized;
      const overlay = document.getElementById('fs-map-leg-overlay');
      const minBtn = overlay?.querySelector('.fs-minimize-btn');
      if (overlay) {
        overlay.classList.toggle('minimized', fsMapLegMinimized);
      }
      if (minBtn) {
        minBtn.textContent = fsMapLegMinimized ? '‚ñ≤' : '‚ñº';
      }
    }
    
    function startDragFsMapLegOverlay(e) {
      if (e.target.classList.contains('fs-minimize-btn')) return;
      const overlay = document.getElementById('fs-map-leg-overlay');
      if (!overlay) return;
      
      fsMapLegDragging = true;
      const rect = overlay.getBoundingClientRect();
      fsMapLegDragOffset.x = e.clientX - rect.left;
      fsMapLegDragOffset.y = e.clientY - rect.top;
      
      document.addEventListener('mousemove', dragFsMapLegOverlay);
      document.addEventListener('mouseup', stopDragFsMapLegOverlay);
      e.preventDefault();
    }
    
    function dragFsMapLegOverlay(e) {
      if (!fsMapLegDragging) return;
      const overlay = document.getElementById('fs-map-leg-overlay');
      const wrapper = document.getElementById('fs-map-wrapper');
      if (!overlay || !wrapper) return;
      
      const wrapperRect = wrapper.getBoundingClientRect();
      let x = e.clientX - wrapperRect.left - fsMapLegDragOffset.x;
      let y = e.clientY - wrapperRect.top - fsMapLegDragOffset.y;
      
      // Constrain to wrapper bounds
      x = Math.max(0, Math.min(x, wrapperRect.width - overlay.offsetWidth));
      y = Math.max(0, Math.min(y, wrapperRect.height - overlay.offsetHeight));
      
      overlay.style.left = x + 'px';
      overlay.style.top = y + 'px';
      overlay.style.bottom = 'auto';
    }
    
    function stopDragFsMapLegOverlay() {
      fsMapLegDragging = false;
      document.removeEventListener('mousemove', dragFsMapLegOverlay);
      document.removeEventListener('mouseup', stopDragFsMapLegOverlay);
    }
    
    // Resize function for widgets
    let fsWidgetResizing = null;
    let fsWidgetResizeStart = { width: 0, height: 0, x: 0, y: 0 };
    
    function startResizeFsWidget(e, widgetId) {
      e.preventDefault();
      e.stopPropagation();
      const widget = document.getElementById(widgetId);
      if (!widget) return;
      
      fsWidgetResizing = widgetId;
      const rect = widget.getBoundingClientRect();
      fsWidgetResizeStart = {
        width: rect.width,
        height: rect.height,
        x: e.clientX,
        y: e.clientY
      };
      
      document.addEventListener('mousemove', resizeFsWidget);
      document.addEventListener('mouseup', stopResizeFsWidget);
    }
    
    function resizeFsWidget(e) {
      if (!fsWidgetResizing) return;
      const widget = document.getElementById(fsWidgetResizing);
      if (!widget) return;
      
      const dx = e.clientX - fsWidgetResizeStart.x;
      const dy = e.clientY - fsWidgetResizeStart.y;
      
      const newWidth = Math.max(120, fsWidgetResizeStart.width + dx);
      const newHeight = Math.max(80, fsWidgetResizeStart.height + dy);
      
      widget.style.width = newWidth + 'px';
      widget.style.minWidth = newWidth + 'px';
    }
    
    function stopResizeFsWidget() {
      fsWidgetResizing = null;
      document.removeEventListener('mousemove', resizeFsWidget);
      document.removeEventListener('mouseup', stopResizeFsWidget);
    }
    
    // Update leg overlay content
    function updateFsMapLegTelemetry() {
      if (!fsMapTelemetryVisible || !mapFullscreen) return;
      
      const sessions = typeof getReplaySessions === 'function' ? getReplaySessions() : (DATA ? [DATA] : []);
      if (!sessions || sessions.length === 0) return;
      
      const session = sessions[0];
      if (!session) return;
      
      // Get current leg
      const leg = getCurrentLegAtTime(session, playbackTime);
      
      const labelEl = document.getElementById('fs-leg-label');
      const spdEl = document.getElementById('fs-leg-spd');
      const vmgEl = document.getElementById('fs-leg-vmg');
      const hdgEl = document.getElementById('fs-leg-hdg');
      const nextEl = document.getElementById('fs-leg-next');
      
      if (!leg) {
        if (labelEl) labelEl.textContent = 'Leg --';
        if (spdEl) spdEl.textContent = '-.-';
        if (vmgEl) vmgEl.textContent = '-.-';
        if (hdgEl) hdgEl.textContent = '---';
        if (nextEl) nextEl.textContent = '--';
        return;
      }
      
      const posNames = { upwind: 'UP', reaching: 'RCH', downwind: 'DN' };
      const posName = posNames[leg.pos] || '';
      
      if (labelEl) labelEl.textContent = `#${leg.id} ${posName}`;
      if (spdEl) spdEl.textContent = leg.speed != null ? leg.speed.toFixed(1) : '-.-';
      if (vmgEl) vmgEl.textContent = leg.vmg != null ? leg.vmg.toFixed(1) : '-.-';
      if (hdgEl) hdgEl.textContent = leg.hdg != null ? Math.round(leg.hdg) + '¬∞' : '---';
      
      if (nextEl) {
        if (leg.next_maneuver) {
          const typeChar = leg.next_maneuver.type === 'tack' ? 'T' : 'G';
          nextEl.textContent = `${typeChar}${leg.next_maneuver.angle}¬∞`;
        } else {
          nextEl.textContent = '--';
        }
      }
    }
    
    // Get selected leg details HTML for fullscreen right panel (light theme)
    function getFsSelectedLegDetailsHtml() {
      if (!selectedLeg || !DATA) {
        return `<div class="card" style="color:#6b7280;text-align:center;padding:24px;flex:1;">Select a leg to see details</div>`;
      }
      
      const leg = selectedLeg;
      const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };
      const posNames = { upwind: 'Upwind', reaching: 'Reaching', downwind: 'Downwind' };
      
      const rateColor = leg.rate <= 2 ? '#22c55e' : leg.rate <= 4 ? '#84cc16' : leg.rate <= 6 ? '#eab308' : '#ef4444';
      const corrColor = leg.corridor <= 8 ? '#22c55e' : leg.corridor <= 12 ? '#84cc16' : leg.corridor <= 18 ? '#eab308' : '#ef4444';
      
      let nextBadge = '<span style="color:#6b7280;">‚Äî</span>';
      if (leg.next_maneuver) {
        const bgColor = leg.next_maneuver.type === 'tack' ? '#dbeafe' : '#fef3c7';
        const textColor = leg.next_maneuver.type === 'tack' ? '#1d4ed8' : '#b45309';
        nextBadge = `<span style="background:${bgColor};color:${textColor};padding:2px 8px;border-radius:4px;font-weight:600;">${leg.next_maneuver.type === 'tack' ? 'T' : 'G'}${leg.next_maneuver.angle}¬∞</span>`;
      }
      
      // Get nearby legs for quick navigation
      const nearbyLegsHtml = getFsNearbyLegsHtml();
      
      return `
        <div class="card" style="flex:1;overflow-y:auto;min-height:0;">
          <div style="border-left:4px solid ${posColors[leg.pos]};padding-left:12px;margin-bottom:16px;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
              <span style="font-weight:700;font-size:16px;">Leg #${leg.id}</span>
              <span style="background:${posColors[leg.pos]};color:white;padding:4px 10px;border-radius:6px;font-weight:600;font-size:12px;">${posNames[leg.pos]}</span>
            </div>
            
            <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px;">
              <div style="text-align:center;background:#f3f4f6;border-radius:8px;padding:10px;">
                <div style="font-size:10px;color:#6b7280;margin-bottom:2px;">Duration</div>
                <div style="font-weight:700;font-size:14px;">${leg.dur}s</div>
              </div>
              <div style="text-align:center;background:#f3f4f6;border-radius:8px;padding:10px;">
                <div style="font-size:10px;color:#6b7280;margin-bottom:2px;">Speed/VMG</div>
                <div style="font-weight:700;font-size:14px;">${leg.speed}/${leg.vmg}</div>
              </div>
              <div style="text-align:center;background:#f3f4f6;border-radius:8px;padding:10px;">
                <div style="font-size:10px;color:#6b7280;margin-bottom:2px;">Rate</div>
                <div style="font-weight:700;font-size:14px;color:${rateColor};">${leg.rate.toFixed(2)}</div>
              </div>
              <div style="text-align:center;background:#f3f4f6;border-radius:8px;padding:10px;">
                <div style="font-size:10px;color:#6b7280;margin-bottom:2px;">COG ¬±</div>
                <div style="font-weight:700;font-size:14px;color:${corrColor};">¬±${leg.corridor.toFixed(1)}¬∞</div>
              </div>
            </div>
            
            <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:6px;">
              <div style="text-align:center;background:#f3f4f6;border-radius:6px;padding:8px;">
                <div style="font-size:9px;color:#6b7280;">Wind</div>
                <div style="font-weight:600;font-size:12px;">${leg.localWind || DATA.s.twd}¬∞</div>
              </div>
              <div style="text-align:center;background:#f3f4f6;border-radius:6px;padding:8px;">
                <div style="font-size:9px;color:#6b7280;">Hdg</div>
                <div style="font-weight:600;font-size:12px;">${leg.hdg != null ? leg.hdg + '¬∞' : '-'}</div>
              </div>
              <div style="text-align:center;background:#f3f4f6;border-radius:6px;padding:8px;">
                <div style="font-size:9px;color:#6b7280;">TWA</div>
                <div style="font-weight:600;font-size:12px;">${leg.twa || '-'}¬∞</div>
              </div>
              <div style="text-align:center;background:#f3f4f6;border-radius:6px;padding:8px;">
                <div style="font-size:9px;color:#6b7280;">Next</div>
                <div style="font-weight:600;font-size:11px;">${nextBadge}</div>
              </div>
            </div>
          </div>
          
          ${nearbyLegsHtml ? `
            <div style="color:#6b7280;font-size:11px;margin-bottom:8px;">Nearby Legs</div>
            <div style="display:flex;flex-direction:column;gap:6px;">${nearbyLegsHtml}</div>
          ` : ''}
        </div>
      `;
    }
    
    // Fit map to visible track specifically for fullscreen mode
    function fitMapToVisibleTrackFullscreen() {
      if (!mapFullscreen) return;
      
      // Get all visible track points from all sessions in race replay mode
      let allVisiblePoints = [];
      
      if (raceReplayMode && ALL_SESSIONS.length > 1) {
        // Collect visible points from all replay sessions
        ALL_SESSIONS.forEach((session, idx) => {
          if (!selectedSessionsForReplay.has(idx)) return;
          if (!session.track || session.track.length < 2) return;
          
          session.track.forEach(p => {
            if (isTrackPointVisible(p, session)) {
              allVisiblePoints.push(p);
            }
          });
        });
      } else if (DATA && DATA.track) {
        // Single session - use filtered track
        allVisiblePoints = DATA.track.filter(p => isTrackPointVisible(p));
      }
      
      if (allVisiblePoints.length < 2) {
        // Fallback to all track points
        if (DATA && DATA.track) {
          allVisiblePoints = DATA.track;
        }
        if (allVisiblePoints.length < 2) return;
      }
      
      const mapEl = document.getElementById('map');
      const width = parseInt(mapEl.getAttribute('width')) || 500;
      const height = parseInt(mapEl.getAttribute('height')) || 500;
      const padding = 30;
      
      // Calculate bounds from visible points
      const lats = allVisiblePoints.map(p => p.lat);
      const lons = allVisiblePoints.map(p => p.lon);
      const minLat = Math.min(...lats), maxLat = Math.max(...lats);
      const minLon = Math.min(...lons), maxLon = Math.max(...lons);
      const latRange = maxLat - minLat || 0.001;
      const lonRange = maxLon - minLon || 0.001;
      
      // Apply latitude correction in geo mode
      const centerLat = (minLat + maxLat) / 2;
      const latCorrection = mapProjection === 'geo' ? Math.cos(centerLat * Math.PI / 180) : 1;
      const lonRangeCorrected = lonRange * latCorrection;
      
      // Calculate scale to fit visible points
      const scale = Math.min((width - 2*padding) / lonRangeCorrected, (height - 2*padding) / latRange) * 0.95;
      
      // Transform functions
      const lonToX = lon => padding + (lon - minLon) * latCorrection * scale + (width - 2*padding - lonRangeCorrected * scale) / 2;
      const latToY = lat => height - padding - (lat - minLat) * scale - (height - 2*padding - latRange * scale) / 2;
      
      // Calculate center in SVG coords
      const centerX = (lonToX(minLon) + lonToX(maxLon)) / 2;
      const centerY = (latToY(minLat) + latToY(maxLat)) / 2;
      
      // Reset zoom and pan to center the visible track
      mapZoom = 1;
      mapPanX = centerX - width / 2;
      mapPanY = centerY - height / 2;
      
      renderMap();
    }
    
    function updateFsSelectedLegDetails() {
      const fsDetailsPanel = document.getElementById('fs-details-panel');
      if (!fsDetailsPanel || !mapFullscreen) return;
      
      // Update only the leg details portion (keep header with exit button and timeline)
      const legDetailsHtml = getFsSelectedLegDetailsHtml();
      
      // Find and update just the leg section, or rebuild the whole panel
      const existingContent = fsDetailsPanel.innerHTML;
      if (existingContent.includes('Exit Fullscreen')) {
        // Panel has header, update just the leg section
        const timelinesContainer = document.getElementById('all-timelines-container');
        let rightPanelHtml = '';
        
        // Exit button at top (light theme)
        rightPanelHtml += `
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
            <span style="color:#1f2937;font-weight:600;font-size:14px;">üó∫Ô∏è Fullscreen View</span>
            <button onclick="toggleMapFullscreen()" style="background:#e5e7eb;border:1px solid #d1d5db;color:#1f2937;padding:6px 12px;border-radius:6px;cursor:pointer;font-size:12px;display:flex;align-items:center;gap:4px;" onmouseover="this.style.background='#d1d5db'" onmouseout="this.style.background='#e5e7eb'">
              <span>‚úï</span> Exit Fullscreen
            </button>
          </div>
        `;
        
        // Timeline (without timeslot)
        if (timelinesContainer && timelinesContainer.innerHTML) {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = timelinesContainer.innerHTML;
          const analysisRangeRow = tempDiv.querySelector('[style*="background:#fef3c7"]');
          if (analysisRangeRow) {
            analysisRangeRow.parentElement?.removeChild(analysisRangeRow);
          }
          const lastRow = tempDiv.querySelector('[style*="margin-top:4px"]');
          if (lastRow && lastRow.textContent.includes(':')) {
            lastRow.parentElement?.removeChild(lastRow);
          }
          rightPanelHtml += `<div class="card" style="padding:12px;">${tempDiv.innerHTML}</div>`;
        }
        
        rightPanelHtml += legDetailsHtml;
        fsDetailsPanel.innerHTML = rightPanelHtml;
      } else {
        fsDetailsPanel.innerHTML = legDetailsHtml;
      }
    }
    
    function getFsNearbyLegsHtml(currentLeg) {
      if (!DATA || !DATA.legs) return '';
      
      const leg = currentLeg || selectedLeg;
      if (!leg) return '';
      
      const currentIdx = DATA.legs.findIndex(l => l.id === leg.id);
      const nearbyLegs = [];
      
      // Get 2 legs before and 2 legs after
      for (let i = Math.max(0, currentIdx - 2); i <= Math.min(DATA.legs.length - 1, currentIdx + 2); i++) {
        if (i !== currentIdx) {
          nearbyLegs.push(DATA.legs[i]);
        }
      }
      
      if (nearbyLegs.length === 0) return '';
      
      const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };
      
      return nearbyLegs.map(leg => `
        <div style="background:#f3f4f6;border-radius:8px;padding:10px;display:flex;align-items:center;gap:12px;cursor:pointer;transition:background 0.15s;" onclick="selectLeg(DATA.legs.find(l=>l.id===${leg.id}));updateFsSelectedLegDetails();" onmouseover="this.style.background='#e5e7eb'" onmouseout="this.style.background='#f3f4f6'">
          <div style="width:4px;height:36px;background:${posColors[leg.pos]};border-radius:2px;"></div>
          <div style="flex:1;">
            <div style="font-weight:600;font-size:12px;color:#1f2937;">Leg #${leg.id}</div>
            <div style="font-size:10px;color:#6b7280;">${leg.dur}s ¬∑ ${leg.speed}/${leg.vmg} kt</div>
          </div>
          <div style="text-align:right;">
            <div style="font-size:11px;color:#1f2937;">¬±${leg.corridor.toFixed(1)}¬∞</div>
            <div style="font-size:10px;color:#6b7280;">${leg.rate.toFixed(2)} rate</div>
          </div>
        </div>
      `).join('');
    }
    
    function handleFullscreenResize() {
      if (mapFullscreen) {
        updateFullscreenMapSize();
        renderMap();
        fitMapToVisibleTrackFullscreen();
      }
    }
    
    function handleFullscreenEscape(e) {
      if (e.key === 'Escape' && mapFullscreen) {
        toggleMapFullscreen();
      }
    }
    
    function exitMapFullscreen() {
      if (mapFullscreen) {
        toggleMapFullscreen();
      }
    }

    function resetMapZoom() {
      // Fit map to the visible (colored) portion of the track
      if (mapFullscreen) {
        fitMapToVisibleTrackFullscreen();
      } else {
        fitMapToVisibleTrack();
      }
    }
    
    // Fit map to show only the visible (non-grey) portion of the track
    function fitMapToVisibleTrack() {
      // Get actual map dimensions
      const mapEl = document.getElementById('map');
      const width = mapEl.clientWidth || parseInt(mapEl.getAttribute('width')) || 350;
      const height = mapEl.clientHeight || parseInt(mapEl.getAttribute('height')) || 350;
      const padding = 25;
      
      // Collect all visible points from all relevant sessions
      let allVisiblePoints = [];
      let allTrackPoints = [];  // For bounds calculation
      
      if (raceReplayMode && ALL_SESSIONS.length > 0) {
        // Race replay mode - collect from all selected sessions
        ALL_SESSIONS.forEach((session, idx) => {
          if (!selectedSessionsForReplay.has(idx)) return;
          if (!session.track || session.track.length < 2) return;
          
          // Add all track points for bounds
          session.track.forEach(p => allTrackPoints.push(p));
          
          // Add visible points
          session.track.forEach(p => {
            if (isTrackPointVisible(p, session)) {
              allVisiblePoints.push(p);
            }
          });
        });
      } else if (DATA && DATA.track && DATA.track.length >= 2) {
        // Single session mode
        allTrackPoints = DATA.originalTrack || DATA.track;
        allVisiblePoints = DATA.track.filter(p => isTrackPointVisible(p));
      }
      
      // Fallback to all track points if no visible points
      if (allVisiblePoints.length < 2) {
        allVisiblePoints = allTrackPoints;
      }
      
      if (allVisiblePoints.length < 2 || allTrackPoints.length < 2) return;
      
      // Get bounds from ALL track points (for consistent coordinate system)
      const allLats = allTrackPoints.map(p => p.lat);
      const allLons = allTrackPoints.map(p => p.lon);
      const minLat = Math.min(...allLats), maxLat = Math.max(...allLats);
      const minLon = Math.min(...allLons), maxLon = Math.max(...allLons);
      const latRange = maxLat - minLat || 0.001;
      const lonRange = maxLon - minLon || 0.001;
      
      // Apply latitude correction in geo mode
      const centerLat = (minLat + maxLat) / 2;
      const latCorrection = mapProjection === 'geo' ? Math.cos(centerLat * Math.PI / 180) : 1;
      const lonRangeCorrected = lonRange * latCorrection;
      
      const scale = Math.min((width - 2*padding) / lonRangeCorrected, (height - 2*padding) / latRange) * 0.9;
      
      const lonToX = lon => padding + (lon - minLon) * latCorrection * scale + (width - 2*padding - lonRangeCorrected * scale) / 2;
      const latToY = lat => height - padding - (lat - minLat) * scale - (height - 2*padding - latRange * scale) / 2;
      
      // Get VISIBLE track bounds in SVG coordinates
      const visLats = allVisiblePoints.map(p => p.lat);
      const visLons = allVisiblePoints.map(p => p.lon);
      const visMinLat = Math.min(...visLats), visMaxLat = Math.max(...visLats);
      const visMinLon = Math.min(...visLons), visMaxLon = Math.max(...visLons);
      
      const visMinX = lonToX(visMinLon), visMaxX = lonToX(visMaxLon);
      const visMinY = latToY(visMaxLat), visMaxY = latToY(visMinLat);  // Note: Y is inverted
      
      const visCenterX = (visMinX + visMaxX) / 2;
      const visCenterY = (visMinY + visMaxY) / 2;
      const visWidth = Math.max(visMaxX - visMinX + 40, 50);
      const visHeight = Math.max(visMaxY - visMinY + 40, 50);
      
      // Calculate zoom to fit visible track with some padding
      mapZoom = Math.min(width / visWidth, height / visHeight, 8);
      mapZoom = Math.max(mapZoom, 0.8); // Allow slight zoom out
      mapPanX = visCenterX - width / 2;
      mapPanY = visCenterY - height / 2;
      
      renderMap();
    }
    
    function saveMapScreenshot() {
      // Show video export dialog
      showVideoExportDialog();
    }
    
    function showVideoExportDialog() {
      videoExportDialogOpen = true;
      lastExportMarkerChanged = 'start'; // Default to start marker
      
      const sessions = getReplaySessions();
      const globalStartMs = getFullStartTimeMs();
      const globalEndMs = getFullEndTimeMs();
      const totalDurationMs = globalEndMs - globalStartMs;
      const totalDurationMin = totalDurationMs / 60000;
      
      // Store for use in other functions
      window.exportGlobalStartMs = globalStartMs;
      window.exportTotalDurationMs = totalDurationMs;
      
      // Use current timeslot selection as default export range
      const { startMs: timeslotStartMs, endMs: timeslotEndMs } = getTimeslotRangeMs();
      const defaultStartPct = ((timeslotStartMs - globalStartMs) / totalDurationMs) * 100;
      const defaultEndPct = ((timeslotEndMs - globalStartMs) / totalDurationMs) * 100;
      
      // Calculate default start/end clock times from timeslot
      const defaultStartMs = timeslotStartMs;
      const defaultEndMs = timeslotEndMs;
      const formatClockTime = (ms) => new Date(ms).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit', hour12: false});
      
      // Create modal overlay - centered on screen
      const modal = document.createElement('div');
      modal.id = 'video-export-modal';
      modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.2);display:flex;align-items:center;justify-content:center;z-index:10000;';
      
      modal.innerHTML = `
        <div id="export-dialog-content" style="background:white;border-radius:12px;padding:20px;max-width:500px;width:90%;box-shadow:0 4px 20px rgba(0,0,0,0.3);max-height:90vh;overflow-y:auto;cursor:default;">
          <div id="export-dialog-header" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;cursor:move;user-select:none;">
            <h3 style="margin:0;font-size:16px;">Export Interactive Replay</h3>
            <span style="font-size:10px;color:#9ca3af;">‚ãÆ‚ãÆ drag to move</span>
          </div>
          
          <div style="margin-bottom:12px;">
            <label style="display:block;font-size:11px;color:#6b7280;margin-bottom:6px;">Select Timeline Range</label>
            <div id="export-timelines-container" style="background:#f9fafb;border-radius:8px;padding:10px;border:1px solid #e5e7eb;">
              <!-- Timelines will be rendered here -->
            </div>
          </div>
          
          <div style="display:flex;gap:12px;margin-bottom:12px;">
            <div style="flex:1;">
              <label style="display:block;font-size:11px;color:#6b7280;margin-bottom:4px;">Start Time <span id="start-time-hint" style="color:#2563eb;font-weight:500;">(‚Üê‚Üí active)</span></label>
              <input type="text" id="export-start-time" value="${formatClockTime(defaultStartMs)}" style="width:100%;padding:6px;border:2px solid #2563eb;border-radius:6px;font-size:13px;box-sizing:border-box;outline:none;">
            </div>
            <div style="flex:1;">
              <label style="display:block;font-size:11px;color:#6b7280;margin-bottom:4px;">End Time <span id="end-time-hint" style="color:#9ca3af;"></span></label>
              <input type="text" id="export-end-time" value="${formatClockTime(defaultEndMs)}" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:6px;font-size:13px;box-sizing:border-box;">
            </div>
          </div>
          
          <div style="margin-bottom:12px;">
            <label style="display:block;font-size:11px;color:#6b7280;margin-bottom:4px;">Export Format</label>
            <select id="export-format" onchange="updateExportFormatUI()" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:6px;font-size:13px;box-sizing:border-box;">
              <option value="html">üì¶ Interactive HTML Player</option>
              <option value="webm" selected>üé¨ Video (MP4 or WebM)</option>
            </select>
          </div>
          
          <div style="margin-bottom:12px;">
            <label style="display:block;font-size:11px;color:#6b7280;margin-bottom:4px;">Default Playback Speed</label>
            <select id="export-speed" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:6px;font-size:13px;box-sizing:border-box;">
              <option value="1">1√ó (Real time)</option>
              <option value="2">2√ó</option>
              <option value="4">4√ó</option>
              <option value="8" selected>8√ó</option>
              <option value="16">16√ó</option>
            </select>
          </div>
          
          <div id="fps-container" style="display:none;margin-bottom:12px;">
            <label style="display:block;font-size:11px;color:#6b7280;margin-bottom:4px;">Frame Rate</label>
            <select id="export-fps" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:6px;font-size:13px;box-sizing:border-box;">
              <option value="10">10 FPS (smaller file)</option>
              <option value="15" selected>15 FPS (balanced)</option>
              <option value="24">24 FPS (smooth)</option>
              <option value="30">30 FPS (very smooth)</option>
            </select>
          </div>
          
          <div id="export-hint" style="font-size:10px;color:#9ca3af;margin-bottom:12px;">üì¶ Exports a self-contained HTML file with interactive playback. Works offline, small file size (~50-200 KB).</div>
          
          <div id="export-progress" style="display:none;margin-bottom:12px;">
            <div style="font-size:11px;color:#6b7280;margin-bottom:4px;"><span id="export-progress-text">Preparing...</span></div>
            <div style="background:#e5e7eb;border-radius:4px;height:6px;overflow:hidden;">
              <div id="export-progress-bar" style="background:#3b82f6;height:100%;width:0%;transition:width 0.2s;"></div>
            </div>
          </div>
          
          <div style="display:flex;gap:8px;justify-content:flex-end;">
            <button onclick="closeVideoExportDialog()" style="padding:6px 14px;border:1px solid #d1d5db;border-radius:6px;background:white;cursor:pointer;font-size:13px;">Cancel</button>
            <button id="export-start-btn" onclick="startVideoExport()" style="padding:6px 14px;border:none;border-radius:6px;background:#3b82f6;color:white;cursor:pointer;font-size:13px;">üì• Export</button>
          </div>
        </div>
      `;
      
      getModalContainer().appendChild(modal);
      
      // Initialize format UI based on default selection
      updateExportFormatUI();
      
      // Render detailed timelines with timeslot range
      renderExportTimelines(sessions, globalStartMs, totalDurationMs, defaultStartPct, defaultEndPct);
      
      // Initialize timeline selector interaction
      initExportTimelineSelector(globalStartMs, totalDurationMs);
      
      // Make dialog draggable
      const dialogContent = document.getElementById('export-dialog-content');
      const dialogHeader = document.getElementById('export-dialog-header');
      let isDragging = false;
      let dragOffsetX = 0, dragOffsetY = 0;
      
      dialogHeader.addEventListener('mousedown', (e) => {
        if (e.target.tagName === 'BUTTON') return;
        isDragging = true;
        const rect = dialogContent.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;
        dialogContent.style.position = 'fixed';
        dialogContent.style.margin = '0';
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', function dragMove(e) {
        if (!isDragging) return;
        const newX = e.clientX - dragOffsetX;
        const newY = e.clientY - dragOffsetY;
        dialogContent.style.left = `${Math.max(0, Math.min(window.innerWidth - dialogContent.offsetWidth, newX))}px`;
        dialogContent.style.top = `${Math.max(0, Math.min(window.innerHeight - dialogContent.offsetHeight, newY))}px`;
      });
      
      document.addEventListener('mouseup', function dragEnd() {
        isDragging = false;
      });
      
      // Close on backdrop click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) closeVideoExportDialog();
      });
      
      // Close on Escape key
      const escHandler = (e) => {
        if (e.code === 'Escape') {
          closeVideoExportDialog();
          document.removeEventListener('keydown', escHandler);
        }
      };
      document.addEventListener('keydown', escHandler);
    }
    
    function renderExportTimelines(sessions, globalStartMs, totalDurationMs, defaultStartPct, defaultEndPct) {
      const container = document.getElementById('export-timelines-container');
      if (!container) return;
      
      // Store default end percentage for selector initialization
      window.exportDefaultEndPct = defaultEndPct !== undefined ? defaultEndPct : 100;
      
      const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };
      const totalDurationMin = totalDurationMs / 60000;
      
      // Helper: convert absolute ms timestamp to percentage on global timeline
      const msToGlobalPct = (ms) => ((ms - globalStartMs) / totalDurationMs) * 100;
      
      let html = '';
      
      // Render each session timeline - showing ONLY the trimmed portion, aligned to global time
      sessions.forEach((session, idx) => {
        const color = BOAT_COLORS[idx % BOAT_COLORS.length];
        const boatSymbol = getBoatSymbol(session.filename);
        const startTimestampMs = session.startTimestampMs || 0;
        const fullDuration = session.fullDuration || session.s.dur;
        
        // Get trimmed range in minutes from original session start
        const trimStartMin = session.timelineStart || 0;
        const trimEndMin = session.timelineEnd || fullDuration;
        
        // Calculate the actual trimmed start/end in absolute ms
        // This matches how analyzeSession filters data
        const trimmedStartMs = startTimestampMs + trimStartMin * 60000;
        const trimmedEndMs = startTimestampMs + trimEndMin * 60000;
        
        // Position on global timeline
        const sessionLeftPct = msToGlobalPct(trimmedStartMs);
        const sessionRightPct = msToGlobalPct(trimmedEndMs);
        const sessionWidthPct = Math.max(1, sessionRightPct - sessionLeftPct);
        
        // Use session.legs - times are in minutes relative to trimmed data start
        // leg.start = 0 means the start of the trimmed range
        const legs = session.legs || [];
        
        html += `
          <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
            <div style="display:flex;align-items:center;width:50px;flex-shrink:0;">
              <span style="display:inline-flex;align-items:center;justify-content:center;width:14px;height:14px;border-radius:50%;background:${color};color:white;font-size:8px;font-weight:bold;margin-right:4px;">${idx + 1}</span>
              <span style="font-size:10px;color:${color};font-weight:600;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${boatSymbol}</span>
            </div>
            <div class="export-timeline-bar" data-session="${idx}" style="flex:1;position:relative;height:20px;">
              <!-- Session trimmed range background -->
              <div style="position:absolute;left:${sessionLeftPct}%;width:${sessionWidthPct}%;top:2px;height:16px;background:${color};opacity:0.2;border-radius:3px;"></div>`;
        
        // Render leg segments
        // leg.start/end are in minutes from the first point of trimmed data
        legs.forEach((leg) => {
          // Convert to absolute ms, then to global percentage
          const legStartMs = trimmedStartMs + leg.start * 60000;
          const legEndMs = trimmedStartMs + leg.end * 60000;
          
          const leftPct = msToGlobalPct(legStartMs);
          const rightPct = msToGlobalPct(legEndMs);
          const widthPct = Math.max(0.3, rightPct - leftPct);
          const legColor = posColors[leg.pos] || '#9ca3af';
          
          html += `<div style="position:absolute;left:${leftPct}%;top:4px;width:${widthPct}%;height:12px;background:${legColor};opacity:0.85;border-radius:2px;"></div>`;
        });
        
        // Export selection marker lines
        const markerEndPct = window.exportDefaultEndPct || 100;
        html += `
              <div class="export-marker-start" style="position:absolute;left:${defaultStartPct}%;top:0;width:2px;height:20px;background:#2563eb;pointer-events:none;z-index:15;box-shadow:0 0 3px #2563eb;"></div>
              <div class="export-marker-end" style="position:absolute;left:${markerEndPct}%;top:0;width:2px;height:20px;background:#2563eb;pointer-events:none;z-index:15;box-shadow:0 0 3px #2563eb;"></div>
            </div>
          </div>`;
      });
      
      // Add export selection timeline
      const endPctRight = 100 - (window.exportDefaultEndPct || 100);
      html += `
        <div style="display:flex;align-items:center;gap:6px;margin-top:6px;padding-top:6px;border-top:1px solid #e5e7eb;">
          <div style="width:50px;flex-shrink:0;font-size:10px;color:#2563eb;font-weight:600;">üìπ Export</div>
          <div style="flex:1;position:relative;height:20px;" id="export-timeline-selector">
            <div style="position:absolute;left:0;right:0;top:2px;height:16px;background:#dbeafe;border-radius:3px;"></div>
            <div id="export-selection-range" style="position:absolute;top:2px;height:16px;background:#3b82f6;opacity:0.4;border-radius:3px;left:${defaultStartPct}%;right:${endPctRight}%;"></div>
            <div id="export-handle-start" style="position:absolute;top:0;width:6px;height:20px;background:#2563eb;border-radius:2px;cursor:ew-resize;left:${defaultStartPct}%;transform:translateX(-50%);z-index:2;box-shadow:0 1px 3px rgba(0,0,0,0.3);"></div>
            <div id="export-handle-end" style="position:absolute;top:0;width:6px;height:20px;background:#2563eb;border-radius:2px;cursor:ew-resize;right:${endPctRight}%;transform:translateX(50%);z-index:2;box-shadow:0 1px 3px rgba(0,0,0,0.3);"></div>
          </div>
        </div>`;
      
      // Add global time labels
      const globalStartDate = new Date(globalStartMs);
      const globalEndDate = new Date(globalStartMs + totalDurationMs);
      const startTimeStr = globalStartDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
      const endTimeStr = globalEndDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
      
      html += `
        <div style="display:flex;align-items:center;gap:6px;margin-top:2px;">
          <div style="width:50px;flex-shrink:0;"></div>
          <div style="flex:1;position:relative;display:flex;justify-content:space-between;font-size:8px;color:#6b7280;">
            <span>${startTimeStr}</span>`;
      
      // Add half-hour interval labels
      const startMinOfDay = globalStartDate.getHours() * 60 + globalStartDate.getMinutes();
      const firstHalfHour = Math.ceil(startMinOfDay / 30) * 30;
      const offsetMin = firstHalfHour - startMinOfDay;
      
      for (let min = offsetMin; min <= totalDurationMin; min += 30) {
        const pct = (min / totalDurationMin) * 100;
        if (pct < 10 || pct > 90) continue;
        
        const labelDate = new Date(globalStartMs + min * 60000);
        const timeStr = labelDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
        html += `<span style="position:absolute;left:${pct}%;transform:translateX(-50%);">${timeStr}</span>`;
      }
      
      html += `
            <span>${endTimeStr}</span>
          </div>
        </div>`;
      
      container.innerHTML = html;
    }
    
    function initExportTimelineSelector(globalStartMs, totalDurationMs) {
      const selector = document.getElementById('export-timeline-selector');
      const handleStart = document.getElementById('export-handle-start');
      const handleEnd = document.getElementById('export-handle-end');
      const selectionRange = document.getElementById('export-selection-range');
      const startInput = document.getElementById('export-start-time');
      const endInput = document.getElementById('export-end-time');
      
      if (!selector || !handleStart || !handleEnd) return;
      
      let dragging = null;
      // Use totalDurationMs for export timeline (based on absolute timestamps)
      const globalDurationMin = totalDurationMs / 60000;
      
      const formatClockTime = (ms) => new Date(ms).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit', hour12: false});
      
      const parseClockTime = (str) => {
        // Parse HH:MM:SS or HH:MM format
        const parts = str.split(':');
        if (parts.length >= 2) {
          const hours = parseInt(parts[0]) || 0;
          const mins = parseInt(parts[1]) || 0;
          const secs = parseInt(parts[2]) || 0;
          
          // Get the date part from globalStartMs
          const baseDate = new Date(globalStartMs);
          const endDate = new Date(globalStartMs + totalDurationMs);
          
          // Create candidate date on same day as start
          const candidate1 = new Date(baseDate);
          candidate1.setHours(hours, mins, secs, 0);
          
          // Create candidate date on next day (for times that cross midnight)
          const candidate2 = new Date(baseDate);
          candidate2.setDate(candidate2.getDate() + 1);
          candidate2.setHours(hours, mins, secs, 0);
          
          // Return the candidate that falls within our timeline range
          if (candidate1.getTime() >= globalStartMs && candidate1.getTime() <= globalStartMs + totalDurationMs) {
            return candidate1.getTime();
          } else if (candidate2.getTime() >= globalStartMs && candidate2.getTime() <= globalStartMs + totalDurationMs) {
            return candidate2.getTime();
          }
          
          // Fallback: return whichever is closer to our range
          const dist1 = Math.min(Math.abs(candidate1.getTime() - globalStartMs), Math.abs(candidate1.getTime() - (globalStartMs + totalDurationMs)));
          const dist2 = Math.min(Math.abs(candidate2.getTime() - globalStartMs), Math.abs(candidate2.getTime() - (globalStartMs + totalDurationMs)));
          return dist1 <= dist2 ? candidate1.getTime() : candidate2.getTime();
        }
        return globalStartMs;
      };
      
      // Function to update visual state of active marker (uses global function)
      const updateActiveMarkerUI = () => updateExportActiveMarkerUI();
      
      const updateMarkerLines = (startPct, endPct) => {
        // Update all marker lines on boat tracks
        document.querySelectorAll('.export-marker-start').forEach(m => {
          m.style.left = startPct + '%';
        });
        document.querySelectorAll('.export-marker-end').forEach(m => {
          m.style.left = endPct + '%';
          m.style.right = 'auto';
        });
      };
      
      const jumpMapToPosition = (pct) => {
        // Convert percentage to playbackTime and update map
        // pct is 0-100 representing position in global timeline (based on absolute timestamps)
        // playbackTime is in minutes from globalStartMs
        playbackTime = (pct / 100) * globalDurationMin;
        renderMap();
        updateBoatInfoPanel();
        updateCurrentLegsPanel();
        updatePlaybackUI();
        updateTimelinePlaybackPointer();
        syncVideosToPlayback(true);  // Sync video to new position
      };
      
      const updateFromHandles = () => {
        const startPct = parseFloat(handleStart.style.left) || 0;
        const endPct = 100 - (parseFloat(handleEnd.style.right) || 0);
        
        selectionRange.style.left = startPct + '%';
        selectionRange.style.right = (100 - endPct) + '%';
        
        const startMs = globalStartMs + (startPct / 100) * totalDurationMs;
        const endMs = globalStartMs + (endPct / 100) * totalDurationMs;
        
        startInput.value = formatClockTime(startMs);
        endInput.value = formatClockTime(endMs);
        
        // Update marker lines on boat tracks
        updateMarkerLines(startPct, endPct);
        
        // Jump map to the position being dragged
        if (dragging === 'start') {
          jumpMapToPosition(startPct);
        } else if (dragging === 'end') {
          jumpMapToPosition(endPct);
        }
      };
      
      const onMouseMove = (e) => {
        if (!dragging) return;
        
        const rect = selector.getBoundingClientRect();
        let pct = ((e.clientX - rect.left) / rect.width) * 100;
        pct = Math.max(0, Math.min(100, pct));
        
        if (dragging === 'start') {
          const endPct = 100 - (parseFloat(handleEnd.style.right) || 0);
          if (pct < endPct - 2) {
            handleStart.style.left = pct + '%';
            updateFromHandles();
          }
        } else if (dragging === 'end') {
          const startPct = parseFloat(handleStart.style.left) || 0;
          if (pct > startPct + 2) {
            handleEnd.style.right = (100 - pct) + '%';
            updateFromHandles();
          }
        }
      };
      
      const onMouseUp = () => {
        dragging = null;
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
      };
      
      handleStart.addEventListener('mousedown', (e) => {
        e.preventDefault();
        dragging = 'start';
        lastExportMarkerChanged = 'start';
        updateActiveMarkerUI();
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      });
      
      handleEnd.addEventListener('mousedown', (e) => {
        e.preventDefault();
        dragging = 'end';
        lastExportMarkerChanged = 'end';
        updateActiveMarkerUI();
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      });
      
      // No action when clicking on timeline (outside handles)
      // Timeline click is intentionally disabled per user request
      
      // Focus handlers for input fields - also set active marker
      startInput.addEventListener('focus', () => {
        lastExportMarkerChanged = 'start';
        updateActiveMarkerUI();
      });
      
      endInput.addEventListener('focus', () => {
        lastExportMarkerChanged = 'end';
        updateActiveMarkerUI();
      });
      
      // Blur handlers to update hints when focus leaves
      startInput.addEventListener('blur', () => {
        updateActiveMarkerUI();
      });
      
      endInput.addEventListener('blur', () => {
        updateActiveMarkerUI();
      });
      
      // Arrow key handlers for input fields (up/down to adjust by 1 second, left/right blocked)
      const handleInputArrowKeys = (e, isStart) => {
        if (e.code === 'ArrowUp' || e.code === 'ArrowDown') {
          e.preventDefault();
          e.stopPropagation();
          
          // Work directly with percentages - 1 second as percentage of total duration
          const stepMs = 1000; // 1 second
          const stepPct = (stepMs / totalDurationMs) * 100;
          const delta = e.code === 'ArrowUp' ? stepPct : -stepPct;
          
          if (isStart) {
            const currentPct = parseFloat(handleStart.style.left) || 0;
            const endPct = 100 - (parseFloat(handleEnd.style.right) || 0);
            // Clamp to valid range
            const newPct = Math.max(0, Math.min(endPct - 2, currentPct + delta));
            handleStart.style.left = newPct + '%';
            dragging = 'start';
            updateFromHandles();
            dragging = null;
          } else {
            const currentPct = 100 - (parseFloat(handleEnd.style.right) || 0);
            const startPct = parseFloat(handleStart.style.left) || 0;
            // Clamp to valid range
            const newPct = Math.max(startPct + 2, Math.min(100, currentPct + delta));
            handleEnd.style.right = (100 - newPct) + '%';
            dragging = 'end';
            updateFromHandles();
            dragging = null;
          }
        } else if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
          // Block left/right arrows when input is focused - they should move cursor in input
          // Don't prevent default so cursor can move in text field
        }
      };
      
      startInput.addEventListener('keydown', (e) => handleInputArrowKeys(e, true));
      endInput.addEventListener('keydown', (e) => handleInputArrowKeys(e, false));
      
      // Sync input fields to handles and jump map (on manual text change)
      startInput.addEventListener('change', () => {
        const ms = parseClockTime(startInput.value);
        const pct = ((ms - globalStartMs) / totalDurationMs) * 100;
        const endPct = 100 - (parseFloat(handleEnd.style.right) || 0);
        if (pct >= 0 && pct < endPct - 2 && pct <= 100) {
          handleStart.style.left = pct + '%';
          dragging = 'start';
          lastExportMarkerChanged = 'start';
          updateActiveMarkerUI();
          updateFromHandles();
          dragging = null;
        }
      });
      
      endInput.addEventListener('change', () => {
        const ms = parseClockTime(endInput.value);
        const pct = ((ms - globalStartMs) / totalDurationMs) * 100;
        const startPct = parseFloat(handleStart.style.left) || 0;
        if (pct <= 100 && pct > startPct + 2 && pct >= 0) {
          handleEnd.style.right = (100 - pct) + '%';
          dragging = 'end';
          lastExportMarkerChanged = 'end';
          updateActiveMarkerUI();
          updateFromHandles();
          dragging = null;
        }
      });
      
      // Initialize marker lines at current position
      const initialStartPct = parseFloat(handleStart.style.left) || 0;
      const initialEndPct = 100 - (parseFloat(handleEnd.style.right) || 0);
      updateMarkerLines(initialStartPct, initialEndPct);
      
      // Initialize active marker UI
      updateActiveMarkerUI();
    }
    
    function updateExportFormatUI() {
      const format = document.getElementById('export-format').value;
      const fpsContainer = document.getElementById('fps-container');
      const hint = document.getElementById('export-hint');
      const btn = document.getElementById('export-start-btn');
      
      if (format === 'webm') {
        fpsContainer.style.display = 'block';
        hint.textContent = 'üé¨ Exports MP4 if your browser supports H.264 encoding, otherwise WebM. Check console for details.';
        btn.textContent = 'üé¨ Export Video';
      } else {
        fpsContainer.style.display = 'none';
        hint.textContent = 'üì¶ Exports a self-contained HTML file with interactive playback. Works offline, small file size (~50-200 KB).';
        btn.textContent = 'üì• Export HTML';
      }
    }
    
    function closeVideoExportDialog() {
      videoExportDialogOpen = false;
      const modal = document.getElementById('video-export-modal');
      if (modal) modal.remove();
      
      // Clean up export timeslot variables
      delete window.exportTimeslotStartMs;
      delete window.exportTimeslotEndMs;
    }
    
    function parseTimeInput(str) {
      // Parse mm:ss or m:ss format to minutes
      const parts = str.split(':');
      if (parts.length === 2) {
        const mins = parseInt(parts[0]) || 0;
        const secs = parseInt(parts[1]) || 0;
        return mins + secs / 60;
      }
      return parseFloat(str) || 0;
    }
    
    async function startVideoExport() {
      const format = document.getElementById('export-format').value;
      const startTimeStr = document.getElementById('export-start-time').value;
      const endTimeStr = document.getElementById('export-end-time').value;
      const speed = parseInt(document.getElementById('export-speed').value);
      
      // Parse clock time (HH:MM:SS) to ms
      const parseClockTime = (str) => {
        const parts = str.split(':');
        if (parts.length >= 2) {
          const hours = parseInt(parts[0]) || 0;
          const mins = parseInt(parts[1]) || 0;
          const secs = parseInt(parts[2]) || 0;
          const globalStartMs = window.exportGlobalStartMs;
          const totalDurationMs = window.exportTotalDurationMs;
          
          // Get the date part from globalStartMs
          const baseDate = new Date(globalStartMs);
          
          // Create candidate date on same day as start
          const candidate1 = new Date(baseDate);
          candidate1.setHours(hours, mins, secs, 0);
          
          // Create candidate date on next day (for times that cross midnight)
          const candidate2 = new Date(baseDate);
          candidate2.setDate(candidate2.getDate() + 1);
          candidate2.setHours(hours, mins, secs, 0);
          
          // Return the candidate that falls within our timeline range
          if (candidate1.getTime() >= globalStartMs && candidate1.getTime() <= globalStartMs + totalDurationMs) {
            return candidate1.getTime();
          } else if (candidate2.getTime() >= globalStartMs && candidate2.getTime() <= globalStartMs + totalDurationMs) {
            return candidate2.getTime();
          }
          
          // Fallback: return whichever is closer to our range
          const dist1 = Math.min(Math.abs(candidate1.getTime() - globalStartMs), Math.abs(candidate1.getTime() - (globalStartMs + totalDurationMs)));
          const dist2 = Math.min(Math.abs(candidate2.getTime() - globalStartMs), Math.abs(candidate2.getTime() - (globalStartMs + totalDurationMs)));
          return dist1 <= dist2 ? candidate1.getTime() : candidate2.getTime();
        }
        return window.exportGlobalStartMs;
      };
      
      const exportStartMs = parseClockTime(startTimeStr);
      const exportEndMs = parseClockTime(endTimeStr);
      
      if (exportEndMs <= exportStartMs) {
        alert('End time must be after start time');
        return;
      }
      
      if (format === 'webm') {
        await exportAsWebM(exportStartMs, exportEndMs, speed);
      } else {
        await exportAsHTML(exportStartMs, exportEndMs, speed);
      }
    }
    
    // Direct canvas video export using WebCodecs + mp4-muxer
    async function exportAsWebM(exportStartMs, exportEndMs, speed) {
      const fps = parseInt(document.getElementById('export-fps').value);
      const globalStartMs = window.exportGlobalStartMs;
      
      // Reset stale leg tracking for fresh export
      window.exportLastValidLegs = {};
      
      // Store export time range for renderMapToCanvas to use
      window.exportTimeslotStartMs = exportStartMs;
      window.exportTimeslotEndMs = exportEndMs;
      
      // Convert to playback time (minutes from global start)
      const exportStartMin = (exportStartMs - globalStartMs) / 60000;
      const exportEndMin = (exportEndMs - globalStartMs) / 60000;
      
      // Calculate frames
      const durationMin = exportEndMin - exportStartMin;
      const realDurationSec = (durationMin * 60) / speed;
      const totalFrames = Math.max(1, Math.ceil(realDurationSec * fps));
      const timeStepMin = durationMin / totalFrames;
      
      // Show progress
      document.getElementById('export-progress').style.display = 'block';
      document.getElementById('export-progress-text').textContent = `0/${totalFrames} frames`;
      document.getElementById('export-progress-bar').style.width = '0%';
      document.getElementById('export-start-btn').disabled = true;
      document.getElementById('export-start-btn').textContent = 'Capturing...';
      
      // Stop current playback
      const wasPlaying = isPlaying;
      const savedPlaybackTime = playbackTime;
      if (isPlaying) stopPlayback();
      
      // Canvas size (must be even for H.264)
      const width = 700;
      const height = 700;
      const renderCanvas = document.createElement('canvas');
      renderCanvas.width = width;
      renderCanvas.height = height;
      const ctx = renderCanvas.getContext('2d', { willReadFrequently: true });
      
      // Pre-calculate frame timestamps
      const frameTimestamps = [];
      for (let i = 0; i < totalFrames; i++) {
        frameTimestamps.push(exportStartMin + i * timeStepMin);
      }
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
      
      // Check for WebCodecs and mp4-muxer support
      const hasWebCodecs = typeof VideoEncoder !== 'undefined' && typeof VideoFrame !== 'undefined';
      const hasMp4Muxer = typeof Mp4Muxer !== 'undefined';
      
      console.log('Export capabilities:', { hasWebCodecs, hasMp4Muxer });
      
      if (hasWebCodecs && hasMp4Muxer) {
        try {
          await exportWithWebCodecs(ctx, renderCanvas, width, height, frameTimestamps, fps, totalFrames, timestamp, savedPlaybackTime, wasPlaying, speed);
          return;
        } catch (err) {
          console.error('WebCodecs export failed:', err);
          document.getElementById('export-progress-text').textContent = `MP4 failed: ${err.message}. Using WebM...`;
          await new Promise(r => setTimeout(r, 1500));
        }
      } else {
        console.log('WebCodecs or Mp4Muxer not available, using MediaRecorder');
        document.getElementById('export-progress-text').textContent = 'MP4 not supported, using WebM...';
        await new Promise(r => setTimeout(r, 1000));
      }
      
      // Fallback to MediaRecorder (WebM)
      await exportWithMediaRecorder(ctx, renderCanvas, width, height, frameTimestamps, fps, totalFrames, timestamp, savedPlaybackTime, wasPlaying, speed);
    }
    
    // Export using WebCodecs + mp4-muxer (native MP4)
    async function exportWithWebCodecs(ctx, canvas, width, height, frameTimestamps, fps, totalFrames, timestamp, savedPlaybackTime, wasPlaying, speed) {
      const frameDurationMicros = Math.round(1000000 / fps);
      
      // Check encoder support first
      let testConfig = {
        codec: 'avc1.42001f',
        width: width,
        height: height,
        bitrate: 4000000,
        framerate: fps
      };
      
      console.log('Testing H.264 support with config:', testConfig);
      
      let support;
      try {
        support = await VideoEncoder.isConfigSupported(testConfig);
        console.log('H.264 support result:', support);
      } catch (e) {
        console.error('isConfigSupported error:', e);
        throw new Error('Cannot check H.264 support: ' + e.message);
      }
      
      if (!support.supported) {
        throw new Error('H.264 encoding not supported by this browser');
      }
      
      // Setup mp4-muxer
      console.log('Creating Mp4Muxer...');
      let muxer;
      try {
        muxer = new Mp4Muxer.Muxer({
          target: new Mp4Muxer.ArrayBufferTarget(),
          video: {
            codec: 'avc',
            width: width,
            height: height
          },
          fastStart: 'in-memory'
        });
      } catch (e) {
        console.error('Mp4Muxer creation error:', e);
        throw new Error('Cannot create MP4 muxer: ' + e.message);
      }
      
      // Setup VideoEncoder with error tracking
      console.log('Creating VideoEncoder...');
      let encoderError = null;
      let encoder;
      try {
        encoder = new VideoEncoder({
          output: (chunk, meta) => {
            try {
              muxer.addVideoChunk(chunk, meta);
            } catch (e) {
              console.error('Muxer addVideoChunk error:', e);
              encoderError = e;
            }
          },
          error: (err) => {
            console.error('VideoEncoder error callback:', err);
            encoderError = err;
          }
        });
      } catch (e) {
        console.error('VideoEncoder creation error:', e);
        throw new Error('Cannot create video encoder: ' + e.message);
      }
      
      console.log('Configuring encoder...');
      try {
        encoder.configure({
          codec: 'avc1.42001f',
          width: width,
          height: height,
          bitrate: 4000000,
          framerate: fps,
          avc: { format: 'avc' }
        });
      } catch (e) {
        console.error('Encoder configure error:', e);
        throw new Error('Cannot configure encoder: ' + e.message);
      }
      
      // Encode frames
      console.log('Starting frame encoding...');
      for (let i = 0; i < frameTimestamps.length; i++) {
        if (encoderError) {
          throw new Error('Encoder error during encoding: ' + encoderError.message);
        }
        
        // Check encoder state before encoding
        if (encoder.state === 'closed') {
          throw new Error('Encoder was closed unexpectedly');
        }
        
        // Set global playbackTime so calculateSailingRoute and other functions work correctly
        playbackTime = frameTimestamps[i];
        
        // Render frame
        renderMapToCanvas(ctx, width, height, frameTimestamps[i], speed);
        
        // Create VideoFrame from canvas
        let frame;
        try {
          frame = new VideoFrame(canvas, {
            timestamp: i * frameDurationMicros,
            duration: frameDurationMicros
          });
        } catch (e) {
          console.error('VideoFrame creation error:', e);
          throw new Error('Cannot create video frame: ' + e.message);
        }
        
        // Encode (keyframe every 2 seconds)
        try {
          // Wait if encoder queue is getting full
          while (encoder.encodeQueueSize > 5) {
            await new Promise(r => setTimeout(r, 10));
            if (encoder.state === 'closed' || encoderError) {
              frame.close();
              throw new Error(encoderError ? encoderError.message : 'Encoder closed while waiting for queue');
            }
          }
          
          const keyFrame = i % (fps * 2) === 0;
          encoder.encode(frame, { keyFrame });
        } catch (e) {
          frame.close();
          console.error('Encode error:', e);
          throw new Error('Cannot encode frame: ' + e.message);
        }
        frame.close();
        
        // Update progress
        document.getElementById('export-progress-text').textContent = `${i + 1}/${totalFrames} frames`;
        document.getElementById('export-progress-bar').style.width = `${Math.round(((i + 1) / totalFrames) * 100)}%`;
        
        // Yield to UI every few frames
        if (i % 5 === 0) {
          await new Promise(r => setTimeout(r, 0));
        }
      }
      
      if (encoderError) {
        throw new Error('Encoder error after encoding: ' + encoderError.message);
      }
      
      // Flush encoder
      console.log('Flushing encoder...');
      document.getElementById('export-progress-text').textContent = 'Finalizing...';
      document.getElementById('export-start-btn').textContent = 'Saving...';
      
      try {
        if (encoder.state === 'configured') {
          await encoder.flush();
        }
      } catch (e) {
        console.error('Encoder flush error:', e);
        throw new Error('Cannot flush encoder: ' + e.message);
      }
      
      if (encoder.state !== 'closed') {
        encoder.close();
      }
      
      console.log('Finalizing muxer...');
      try {
        muxer.finalize();
      } catch (e) {
        console.error('Muxer finalize error:', e);
        throw new Error('Cannot finalize MP4: ' + e.message);
      }
      
      // Get MP4 data
      const mp4Data = muxer.target.buffer;
      console.log('MP4 size:', mp4Data.byteLength, 'bytes');
      
      const blob = new Blob([mp4Data], { type: 'video/mp4' });
      
      // Download
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.download = `sailing-replay-${timestamp}.mp4`;
      a.href = url;
      a.click();
      URL.revokeObjectURL(url);
      
      // Restore state
      closeVideoExportDialog();
      playbackTime = savedPlaybackTime;
      renderMap();
      updateBoatInfoPanel();
      updatePlaybackUI();
      updateTimelinePlaybackPointer();
      if (wasPlaying) startPlayback();
    }
    
    // Fallback export using MediaRecorder (WebM)
    async function exportWithMediaRecorder(ctx, canvas, width, height, frameTimestamps, fps, totalFrames, timestamp, savedPlaybackTime, wasPlaying, speed) {
      const frameDelayMs = Math.round(1000 / fps);
      
      // Setup MediaRecorder
      const stream = canvas.captureStream(fps);
      let mediaRecorder;
      try {
        mediaRecorder = new MediaRecorder(stream, {
          mimeType: 'video/webm;codecs=vp9',
          videoBitsPerSecond: 8000000
        });
      } catch (e) {
        mediaRecorder = new MediaRecorder(stream, {
          mimeType: 'video/webm',
          videoBitsPerSecond: 8000000
        });
      }
      
      const chunks = [];
      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) chunks.push(e.data);
      };
      
      return new Promise((resolve) => {
        mediaRecorder.onstop = () => {
          const blob = new Blob(chunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.download = `sailing-replay-${timestamp}.webm`;
          a.href = url;
          a.click();
          URL.revokeObjectURL(url);
          
          closeVideoExportDialog();
          playbackTime = savedPlaybackTime;
          renderMap();
          updateBoatInfoPanel();
          updatePlaybackUI();
          updateTimelinePlaybackPointer();
          if (wasPlaying) startPlayback();
          resolve();
        };
        
        mediaRecorder.start();
        
        let frameCount = 0;
        const renderNextFrame = async () => {
          if (frameCount >= frameTimestamps.length) {
            document.getElementById('export-progress-text').textContent = `${totalFrames}/${totalFrames} frames - Saving...`;
            document.getElementById('export-start-btn').textContent = 'Saving...';
            await new Promise(r => setTimeout(r, frameDelayMs));
            mediaRecorder.stop();
            return;
          }
          
          // Set global playbackTime so calculateSailingRoute and other functions work correctly
          playbackTime = frameTimestamps[frameCount];
          
          renderMapToCanvas(ctx, width, height, frameTimestamps[frameCount], speed);
          
          frameCount++;
          document.getElementById('export-progress-text').textContent = `${frameCount}/${totalFrames} frames`;
          document.getElementById('export-progress-bar').style.width = `${Math.round((frameCount / totalFrames) * 100)}%`;
          
          await new Promise(r => setTimeout(r, frameDelayMs));
          requestAnimationFrame(renderNextFrame);
        };
        
        requestAnimationFrame(renderNextFrame);
      });
    }
    
    // Direct canvas renderer for video export
    function renderMapToCanvas(ctx, width, height, currentPlaybackTime, exportSpeed) {
      const padding = 5;
      const sessions = getReplaySessions();
      if (sessions.length === 0) return;
      
      // Apply telemetry offset for export
      const exportTelemetryTime = currentPlaybackTime + telemetryOffsetSec / 60;
      
      // Clear canvas
      ctx.fillStyle = '#eff6ff';
      ctx.fillRect(0, 0, width, height);
      
      // Get timeslot range for filtering
      let timeslotStartMs, timeslotEndMs;
      if (window.exportTimeslotStartMs !== undefined && window.exportTimeslotEndMs !== undefined) {
        timeslotStartMs = window.exportTimeslotStartMs;
        timeslotEndMs = window.exportTimeslotEndMs;
      } else {
        const timeslotRange = getTimeslotRangeMs();
        timeslotStartMs = timeslotRange.startMs;
        timeslotEndMs = timeslotRange.endMs;
      }
      
      // Calculate bounds from track points within timeslot only
      let allLats = [], allLons = [];
      sessions.forEach(session => {
        const sessionStartMs = session.startTimestampMs || 0;
        const trimStartMin = session.timelineStart || 0;
        const trimEndMin = session.timelineEnd || session.s.dur;
        const trimDuration = trimEndMin - trimStartMin;
        
        session.track.forEach(p => {
          if (p.t < 0 || p.t > trimDuration) return;
          const ptAbsMs = sessionStartMs + (trimStartMin + p.t) * 60000;
          if (ptAbsMs >= timeslotStartMs && ptAbsMs <= timeslotEndMs) {
            allLats.push(p.lat);
            allLons.push(p.lon);
          }
        });
      });
      
      if (allLats.length === 0) {
        sessions.forEach(session => {
          allLats.push(...session.track.map(p => p.lat));
          allLons.push(...session.track.map(p => p.lon));
        });
      }
      
      const minLat = Math.min(...allLats), maxLat = Math.max(...allLats);
      const minLon = Math.min(...allLons), maxLon = Math.max(...allLons);
      const latRange = maxLat - minLat || 0.001;
      const lonRange = maxLon - minLon || 0.001;
      
      const centerLat = (minLat + maxLat) / 2;
      const latCorrection = mapProjection === 'geo' ? Math.cos(centerLat * Math.PI / 180) : 1;
      const lonRangeCorrected = lonRange * latCorrection;
      
      const scale = Math.min((width - 2*padding) / lonRangeCorrected, (height - 2*padding) / latRange);
      
      const lonToX = lon => padding + (lon - minLon) * latCorrection * scale + (width - 2*padding - lonRangeCorrected * scale) / 2;
      const latToY = lat => height - padding - (lat - minLat) * scale - (height - 2*padding - latRange * scale) / 2;
      
      // Draw grid
      ctx.strokeStyle = '#d1d5db';
      ctx.setLineDash([6, 6]);
      ctx.lineWidth = 1;
      [0.25, 0.5, 0.75].forEach(f => {
        const y = padding + (height - 2*padding) * f;
        const x = padding + (width - 2*padding) * f;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(width - padding, y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, height - padding);
        ctx.stroke();
      });
      ctx.setLineDash([]);
      
      // Draw VMG highlights (before tracks) - use telemetry-adjusted time
      sessions.forEach((session, boatIdx) => {
        if (!isSessionVisibleAtTime(session, exportTelemetryTime)) return;
        
        const track = session.track;
        const legs = session.legs;
        if (!track || !legs || track.length < 10) return;
        
        const sessionStart = session.timelineStart || 0;
        const sessionEnd = session.timelineEnd || session.s.dur;
        const trimDuration = sessionEnd - sessionStart;
        const sessionLocalTime = getSessionLocalTime(session, exportTelemetryTime);
        const trackPlaybackTime = sessionLocalTime - sessionStart;
        const sessionStartMs = session.startTimestampMs || 0;
        
        let currentLegIdx = -1;
        for (let i = 0; i < legs.length; i++) {
          if (trackPlaybackTime >= legs[i].start && trackPlaybackTime <= legs[i].end) {
            currentLegIdx = i;
            break;
          }
        }
        if (currentLegIdx === -1) {
          for (let i = legs.length - 1; i >= 0; i--) {
            if (trackPlaybackTime > legs[i].end) {
              currentLegIdx = i;
              break;
            }
          }
        }
        
        const legsToHighlight = new Set();
        if (currentLegIdx >= 0) {
          for (let i = currentLegIdx; i >= Math.max(0, currentLegIdx - 3); i--) {
            legsToHighlight.add(i);
          }
        }
        
        legs.forEach((leg, legIdx) => {
          if (!legsToHighlight.has(legIdx)) return;
          
          const legVmg = parseFloat(leg.vmg);
          if (isNaN(legVmg) || legVmg <= 0) return;
          
          const legTwd = leg.localWind || session.s.twd || 0;
          const legStart = leg.start;
          const legEnd = leg.end;
          
          // Find track point indices for this leg and calculate VMG for each
          // Use ALL points for accurate segment calculation (match main map)
          const legPoints = [];
          for (let i = 0; i < track.length; i++) {
            const pt = track[i];
            if (pt.t >= legStart && pt.t <= legEnd) {
              const hdg = pt.hdg || pt.cog || 0;
              const sog = pt.sog || 0;
              const twa = Math.abs(angleDiff(hdg, legTwd));
              const instVmg = Math.abs(sog * Math.cos(twa * Math.PI / 180));
              
              legPoints.push({
                t: pt.t,
                lat: pt.lat,
                lon: pt.lon,
                vmg: instVmg,
                deviation: instVmg - legVmg
              });
            }
          }
          
          if (legPoints.length < 2) return;
          
          // Group into contiguous segments above/below average (match main map)
          const segments = [];
          let currentSeg = null;
          
          for (let i = 0; i < legPoints.length; i++) {
            const pt = legPoints[i];
            const isAbove = pt.deviation > 0;
            
            if (!currentSeg || currentSeg.isAbove !== isAbove) {
              if (currentSeg && currentSeg.points.length > 0) segments.push(currentSeg);
              currentSeg = { isAbove, points: [pt], totalDeviation: pt.deviation };
            } else {
              currentSeg.points.push(pt);
              currentSeg.totalDeviation += pt.deviation;
            }
          }
          if (currentSeg && currentSeg.points.length > 0) segments.push(currentSeg);
          
          // Calculate duration and avg deviation for each segment
          segments.forEach(seg => {
            if (seg.points.length >= 2) {
              seg.duration = seg.points[seg.points.length - 1].t - seg.points[0].t;
            } else {
              seg.duration = 0;
            }
            seg.avgDeviation = seg.totalDeviation / seg.points.length;
          });
          
          // Separate and sort
          const aboveSegs = segments.filter(s => s.isAbove && s.duration > 0);
          const belowSegs = segments.filter(s => !s.isAbove && s.duration > 0);
          
          // Calculate total leg duration from actual points
          const totalLegDur = legPoints.length >= 2 ? legPoints[legPoints.length - 1].t - legPoints[0].t : 0;
          const maxHighlightDur = totalLegDur * 0.2;
          
          // Function to find best/worst portion of a segment within a duration limit
          const trimSegment = (seg, maxDur, findWorst) => {
            if (seg.duration <= maxDur) return seg;
            
            const pts = seg.points;
            if (pts.length < 2) return seg;
            
            let bestStart = 0;
            let bestEnd = 1;
            let bestAvg = findWorst ? Infinity : -Infinity;
            
            for (let i = 0; i < pts.length; i++) {
              let sum = 0;
              let count = 0;
              let j = i;
              
              while (j < pts.length && (pts[j].t - pts[i].t) <= maxDur) {
                sum += pts[j].deviation;
                count++;
                j++;
              }
              
              if (count >= 2) {
                const avg = sum / count;
                if (findWorst ? avg < bestAvg : avg > bestAvg) {
                  bestAvg = avg;
                  bestStart = i;
                  bestEnd = j;
                }
              }
            }
            
            const trimmedPts = pts.slice(bestStart, bestEnd);
            return {
              isAbove: seg.isAbove,
              points: trimmedPts,
              duration: trimmedPts.length >= 2 ? trimmedPts[trimmedPts.length - 1].t - trimmedPts[0].t : 0,
              avgDeviation: bestAvg
            };
          };
          
          // Best 20% of leg duration
          aboveSegs.sort((a, b) => b.avgDeviation - a.avgDeviation);
          const bestSegs = [];
          let bestDur = 0;
          for (const seg of aboveSegs) {
            if (bestDur >= maxHighlightDur) break;
            const remainingBudget = maxHighlightDur - bestDur;
            if (seg.duration <= remainingBudget) {
              bestSegs.push(seg);
              bestDur += seg.duration;
            } else if (remainingBudget > 0) {
              const trimmed = trimSegment(seg, remainingBudget, false);
              if (trimmed.duration > 0) {
                bestSegs.push(trimmed);
                bestDur += trimmed.duration;
              }
            }
          }
          
          // Worst 20% of leg duration
          belowSegs.sort((a, b) => a.avgDeviation - b.avgDeviation);
          const worstSegs = [];
          let worstDur = 0;
          for (const seg of belowSegs) {
            if (worstDur >= maxHighlightDur) break;
            const remainingBudget = maxHighlightDur - worstDur;
            if (seg.duration <= remainingBudget) {
              worstSegs.push(seg);
              worstDur += seg.duration;
            } else if (remainingBudget > 0) {
              const trimmed = trimSegment(seg, remainingBudget, true);
              if (trimmed.duration > 0) {
                worstSegs.push(trimmed);
                worstDur += trimmed.duration;
              }
            }
          }
          
          const highlightLookahead = 10 / 60;
          const drawStep = Math.max(1, Math.floor(track.length / 400));
          
          const drawHighlightSegs = (segs, color) => {
            ctx.strokeStyle = color;
            ctx.lineWidth = 10;
            ctx.lineCap = 'butt';
            ctx.globalAlpha = 0.3;
            
            segs.forEach(seg => {
              for (let i = drawStep; i < seg.points.length; i += drawStep) {
                const p0 = seg.points[i - drawStep];
                const p1 = seg.points[i];
                
                if (p1.t > trackPlaybackTime + highlightLookahead) continue;
                if (p1.t < 0 || p1.t > trimDuration) continue;
                
                const p1AbsMs = sessionStartMs + (sessionStart + p1.t) * 60000;
                if (p1AbsMs < timeslotStartMs || p1AbsMs > timeslotEndMs) continue;
                
                ctx.beginPath();
                ctx.moveTo(lonToX(p0.lon), latToY(p0.lat));
                ctx.lineTo(lonToX(p1.lon), latToY(p1.lat));
                ctx.stroke();
              }
            });
            ctx.globalAlpha = 1;
          };
          
          drawHighlightSegs(worstSegs, '#ef4444');
          drawHighlightSegs(bestSegs, '#22c55e');
        });
      });
      
      // Draw tracks - use telemetry-adjusted time
      sessions.forEach((session, boatIdx) => {
        if (!isSessionVisibleAtTime(session, exportTelemetryTime)) return;
        
        const color = BOAT_COLORS[boatIdx % BOAT_COLORS.length];
        const track = session.track;
        const step = Math.max(1, Math.floor(track.length / 800));
        
        const sessionLocalTime = getSessionLocalTime(session, exportTelemetryTime);
        const sessionStart = session.timelineStart || 0;
        const sessionEnd = session.timelineEnd || session.s.dur;
        const trimDuration = sessionEnd - sessionStart;
        const trackPlaybackTime = sessionLocalTime - sessionStart;
        const sessionStartMs = session.startTimestampMs || 0;
        
        ctx.lineCap = 'round';
        ctx.lineWidth = 4;
        
        for (let i = step; i < track.length; i += step) {
          const p0 = track[i - step], p1 = track[i];
          
          if (p1.t < 0 || p1.t > trimDuration) continue;
          
          const p1AbsMs = sessionStartMs + (sessionStart + p1.t) * 60000;
          if (p1AbsMs < timeslotStartMs || p1AbsMs > timeslotEndMs) continue;
          
          let opacity = 0.9;
          let strokeColor = color;
          const recentWindow = trackRecentWindow;
          const fadeWindow = trackFadeWindow;
          
          if (sessionLocalTime >= sessionStart && trackPlaybackTime >= 0) {
            const age = trackPlaybackTime - p1.t;
            if (p1.t > trackPlaybackTime) {
              opacity = 0.15;
              strokeColor = '#9ca3af';
            } else if (age <= recentWindow) {
              opacity = 0.9;
            } else if (age <= fadeWindow) {
              opacity = 0.9 - (age - recentWindow) / (fadeWindow - recentWindow) * 0.5;
            } else {
              opacity = 0.2;
              strokeColor = '#9ca3af';
            }
          } else if (sessionLocalTime < sessionStart) {
            opacity = 0.15;
            strokeColor = '#9ca3af';
          }
          
          if (hideGrayTracks && opacity < 0.2) continue;
          
          ctx.globalAlpha = opacity;
          ctx.strokeStyle = strokeColor;
          ctx.beginPath();
          ctx.moveTo(lonToX(p0.lon), latToY(p0.lat));
          ctx.lineTo(lonToX(p1.lon), latToY(p1.lat));
          ctx.stroke();
        }
      });
      
      ctx.globalAlpha = 1;
      
      // Draw racing marks
      if (!cachedRacingMarks) {
        cachedRacingMarks = detectRacingMarks(sessions);
      }
      const marks = cachedRacingMarks;
      
      // Upmarks - text below
      marks.upmarks.forEach(mark => {
        const x = lonToX(mark.lon);
        const y = latToY(mark.lat);
        ctx.fillStyle = '#f97316';
        ctx.strokeStyle = '#c2410c';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = '#c2410c';
        ctx.font = 'bold 12px -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('UP', x, y + 12);
      });
      
      // Downmarks - text above
      marks.downmarks.forEach(mark => {
        const x = lonToX(mark.lon);
        const y = latToY(mark.lat);
        ctx.fillStyle = '#14b8a6';
        ctx.strokeStyle = '#0f766e';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = '#0f766e';
        ctx.font = 'bold 12px -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText('DN', x, y - 12);
      });
      
      // Draw boat markers - use telemetry-adjusted time
      if (currentPlaybackTime > 0) {
        sessions.forEach((session, boatIdx) => {
          if (!isSessionVisibleAtTime(session, exportTelemetryTime)) return;
          
          const pos = getBoatPositionAtTime(session, exportTelemetryTime);
          if (!pos) return;
          
          const x = lonToX(pos.lon);
          const y = latToY(pos.lat);
          const color = BOAT_COLORS[boatIdx % BOAT_COLORS.length];
          const size = 20;
          
          const hdgRad = pos.hdg * Math.PI / 180;
          const cosH = Math.cos(hdgRad);
          const sinH = Math.sin(hdgRad);
          
          const rot = (dx, dy) => ({
            x: x + dx * cosH + dy * sinH,
            y: y + dx * sinH - dy * cosH
          });
          
          const bow = rot(0, size * 0.9);
          const sternL = rot(-size * 0.4, -size * 0.5);
          const sternR = rot(size * 0.4, -size * 0.5);
          const midL = rot(-size * 0.45, size * 0.1);
          const midR = rot(size * 0.45, size * 0.1);
          
          ctx.fillStyle = color;
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(bow.x, bow.y);
          ctx.quadraticCurveTo(midR.x, midR.y, sternR.x, sternR.y);
          ctx.lineTo(sternL.x, sternL.y);
          ctx.quadraticCurveTo(midL.x, midL.y, bow.x, bow.y);
          ctx.fill();
          ctx.stroke();
          
          const badgePos = rot(0, -size * 0.9);
          ctx.fillStyle = 'white';
          ctx.strokeStyle = color;
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          ctx.arc(badgePos.x, badgePos.y, 12, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          ctx.fillStyle = color;
          ctx.font = 'bold 14px -apple-system, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(String(boatIdx + 1), badgePos.x, badgePos.y);
        });
      }
      
      // Get visible boat positions - use telemetry-adjusted time
      const boatPositions = sessions.map((session, i) => ({
        pos: isSessionVisibleAtTime(session, exportTelemetryTime) ? getBoatPositionAtTime(session, exportTelemetryTime) : null,
        color: BOAT_COLORS[i % BOAT_COLORS.length],
        idx: i,
        session: session
      })).filter(b => b.pos);
      
      // Calculate time to mark for each boat - use telemetry-adjusted time
      const timeToMarkData = [];
      if (cachedRacingMarks && currentPlaybackTime > 0) {
        const upmark = cachedRacingMarks.upmarks[0];
        const downmark = cachedRacingMarks.downmarks[0];
        
        sessions.forEach((session, boatIdx) => {
          if (!isSessionVisibleAtTime(session, exportTelemetryTime)) {
            timeToMarkData.push({ timeToUp: null, timeToDn: null, isUpwind: null });
            return;
          }
          
          const leg = getCurrentLegAtTime(session, exportTelemetryTime);
          const track = session.track;
          const sessionStart = session.timelineStart || 0;
          
          if (!track || track.length === 0) {
            timeToMarkData.push({ timeToUp: null, timeToDn: null, isUpwind: null });
            return;
          }
          
          let isUpwind = null;
          if (leg) {
            isUpwind = leg.pos === 'upwind' || (leg.twa != null && leg.twa < 90);
          }
          
          const sessionLocalTime = getSessionLocalTime(session, exportTelemetryTime);
          const currentTrackTime = sessionLocalTime - sessionStart;
          
          let timeToUp = null, timeToDn = null;
          
          // Find time to upmark
          if (upmark) {
            let minDist = Infinity, minDistTrackTime = null, passedMin = false;
            for (let i = 0; i < track.length; i++) {
              const pt = track[i];
              if (pt.t <= currentTrackTime) continue;
              const dist = haversineDistance(pt.lat, pt.lon, upmark.lat, upmark.lon);
              if (dist < minDist) {
                minDist = dist;
                minDistTrackTime = pt.t;
              } else if (minDist < 40 && !passedMin) {
                passedMin = true;
                break;
              }
            }
            if (minDist <= 50 && minDistTrackTime != null) {
              timeToUp = (minDistTrackTime - currentTrackTime) * 60;
            }
          }
          
          // Find time to downmark
          if (downmark) {
            let minDist = Infinity, minDistTrackTime = null, passedMin = false;
            for (let i = 0; i < track.length; i++) {
              const pt = track[i];
              if (pt.t <= currentTrackTime) continue;
              const dist = haversineDistance(pt.lat, pt.lon, downmark.lat, downmark.lon);
              if (dist < minDist) {
                minDist = dist;
                minDistTrackTime = pt.t;
              } else if (minDist < 40 && !passedMin) {
                passedMin = true;
                break;
              }
            }
            if (minDist <= 50 && minDistTrackTime != null) {
              timeToDn = (minDistTrackTime - currentTrackTime) * 60;
            }
          }
          
          timeToMarkData.push({ timeToUp, timeToDn, isUpwind });
        });
      }
      
      // Draw sailing routes between boats
      if (boatPositions.length >= 2 && currentPlaybackTime > 0) {
        const b1 = boatPositions[0];
        const b2 = boatPositions[1];
        
        const route1to2 = calculateSailingRoute(b1.pos, b2.pos, sessions, 0);
        const route2to1 = calculateSailingRoute(b1.pos, b2.pos, sessions, 1);
        
        // Draw route 1‚Üí2 (blue)
        if (route1to2 && route1to2.waypoints.length >= 2) {
          ctx.strokeStyle = '#3b82f6';
          ctx.lineWidth = 3;
          ctx.setLineDash([8, 5]);
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          route1to2.waypoints.forEach((wp, i) => {
            const px = lonToX(wp.lon);
            const py = latToY(wp.lat);
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          });
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.globalAlpha = 1;
          
          if (route1to2.waypoints.length === 3) {
            const tackPt = route1to2.waypoints[1];
            const tx = lonToX(tackPt.lon);
            const ty = latToY(tackPt.lat);
            const sz = 6;
            ctx.fillStyle = '#3b82f6';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(tx, ty - sz);
            ctx.lineTo(tx + sz, ty);
            ctx.lineTo(tx, ty + sz);
            ctx.lineTo(tx - sz, ty);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
          }
        }
        
        // Draw route 2‚Üí1 (green)
        if (route2to1 && route2to1.waypoints.length >= 2) {
          ctx.strokeStyle = '#22c55e';
          ctx.lineWidth = 3;
          ctx.setLineDash([8, 5]);
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          route2to1.waypoints.forEach((wp, i) => {
            const px = lonToX(wp.lon);
            const py = latToY(wp.lat);
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          });
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.globalAlpha = 1;
          
          if (route2to1.waypoints.length === 3) {
            const tackPt = route2to1.waypoints[1];
            const tx = lonToX(tackPt.lon);
            const ty = latToY(tackPt.lat);
            const sz = 6;
            ctx.fillStyle = '#22c55e';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(tx, ty - sz);
            ctx.lineTo(tx + sz, ty);
            ctx.lineTo(tx, ty + sz);
            ctx.lineTo(tx - sz, ty);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
          }
        }
        
        // Distance label with catching time
        const route = route1to2;
        if (route && route.waypoints.length >= 2) {
          const x1 = lonToX(route.waypoints[0].lon);
          const y1 = latToY(route.waypoints[0].lat);
          const x2 = lonToX(route.waypoints[route.waypoints.length - 1].lon);
          const y2 = latToY(route.waypoints[route.waypoints.length - 1].lat);
          
          const midX = (x1 + x2) / 2;
          const midY = (y1 + y2) / 2;
          
          const dx = x2 - x1;
          const dy = y2 - y1;
          const len = Math.sqrt(dx * dx + dy * dy);
          const perpX = len > 0 ? -dy / len : 0;
          const perpY = len > 0 ? dx / len : -1;
          const labelX = midX + perpX * 55;
          const labelY = midY + perpY * 55;
          
          const formatDist = (m) => m >= 1000 ? `${(m/1000).toFixed(1)}km` : `${Math.round(m)}m`;
          const formatTime = (sec) => {
            if (sec > 3600) return '>1h';
            if (sec > 600) return `${Math.round(sec/60)}m`;
            if (sec >= 60) return `${Math.floor(sec/60)}:${String(Math.round(sec%60)).padStart(2,'0')}`;
            return `${Math.round(sec)}s`;
          };
          
          const smoothedTime = getSmoothedSailingTime(route.time, '1to2');
          const smoothedTime2to1 = route2to1 ? getSmoothedSailingTime(route2to1.time, '2to1') : 0;
          
          // Determine leader based on time-to-mark when boats on same course
          let catchingTime = 0;
          let leadingBoatIdx = -1;
          const ttm0 = timeToMarkData[0];
          const ttm1 = timeToMarkData[1];
          
          if (smoothedTime > 0 && smoothedTime2to1 > 0) {
            // Check if both boats are on same course
            if (ttm0 && ttm1 && ttm0.isUpwind !== null && ttm1.isUpwind !== null && ttm0.isUpwind === ttm1.isUpwind) {
              // Same course - use time-to-mark to determine leader
              const time0 = ttm0.isUpwind ? ttm0.timeToUp : ttm0.timeToDn;
              const time1 = ttm1.isUpwind ? ttm1.timeToUp : ttm1.timeToDn;
              
              if (time0 != null && time1 != null && time0 > 0 && time1 > 0) {
                if (time0 < time1) {
                  // Boat 0 reaches mark first - it's leading, boat 1 catching up
                  leadingBoatIdx = 0;
                  catchingTime = smoothedTime2to1;
                } else {
                  // Boat 1 reaches mark first - it's leading, boat 0 catching up
                  leadingBoatIdx = 1;
                  catchingTime = smoothedTime;
                }
              }
            }
            
            // If different courses or no mark data, use sailing time comparison
            if (catchingTime === 0) {
              if (leadingBoatIdx === 0) {
                catchingTime = smoothedTime2to1;
              } else if (leadingBoatIdx === 1) {
                catchingTime = smoothedTime;
              } else {
                // No previous leader - use sailing time comparison
                catchingTime = Math.min(smoothedTime, smoothedTime2to1);
                leadingBoatIdx = smoothedTime < smoothedTime2to1 ? 1 : 0;
              }
            }
          }
          
          const labelText = catchingTime > 0 
            ? `Distance: ${formatDist(route.directDist)}, ${formatTime(catchingTime)}`
            : `Distance: ${formatDist(route.directDist)}`;
          
          ctx.fillStyle = 'rgba(0,0,0,0.85)';
          ctx.beginPath();
          ctx.roundRect(labelX - 85, labelY - 14, 170, 28, 5);
          ctx.fill();
          
          ctx.fillStyle = '#f59e0b';
          ctx.font = 'bold 14px -apple-system, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(labelText, labelX, labelY);
        }
      }
      
      // Wind indicator
      const windDeg = sessions[0].s.twd;
      const windX = width - 50;
      const windY = 50;
      
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.beginPath();
      ctx.roundRect(windX - 40, windY - 38, 80, 80, 6);
      ctx.fill();
      
      ctx.fillStyle = '#374151';
      ctx.font = 'bold 15px -apple-system, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText(`Wind ${windDeg}¬∞`, windX, windY - 20);
      
      ctx.save();
      ctx.translate(windX, windY + 8);
      ctx.rotate(windDeg * Math.PI / 180);
      ctx.strokeStyle = '#374151';
      ctx.lineWidth = 3.5;
      ctx.beginPath();
      ctx.moveTo(0, -18);
      ctx.lineTo(0, 18);
      ctx.stroke();
      ctx.fillStyle = '#374151';
      ctx.beginPath();
      ctx.moveTo(0, 18);
      ctx.lineTo(-8, 6);
      ctx.lineTo(8, 6);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      
      // Date/Time
      const globalStartMsValue = window.exportGlobalStartMs || getFullStartTimeMs();
      const currentMs = globalStartMsValue + currentPlaybackTime * 60000;
      const currentDate = new Date(currentMs);
      const dateStr = currentDate.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
      const timeStr = currentDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
      const speedStr = `Race Replay  √ó${exportSpeed || 1}`;
      
      const timeBoxWidth = 180;
      const timeBoxHeight = 75;
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.beginPath();
      ctx.roundRect(width - timeBoxWidth - 15, height - timeBoxHeight - 15, timeBoxWidth, timeBoxHeight, 6);
      ctx.fill();
      
      ctx.fillStyle = 'white';
      ctx.font = 'bold 26px -apple-system, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(timeStr, width - timeBoxWidth/2 - 15, height - timeBoxHeight/2 - 15 - 12);
      
      ctx.fillStyle = '#9ca3af';
      ctx.font = '14px -apple-system, sans-serif';
      ctx.fillText(dateStr, width - timeBoxWidth/2 - 15, height - timeBoxHeight/2 - 15 + 10);
      
      ctx.fillStyle = '#60a5fa';
      ctx.font = 'bold 13px -apple-system, sans-serif';
      ctx.fillText(speedStr, width - timeBoxWidth/2 - 15, height - timeBoxHeight/2 - 15 + 28);
      
      // Boat legend with telemetry and time-to-mark
      if (!window.exportLastValidLegs) window.exportLastValidLegs = {};
      
      const formatMarkTime = (sec) => {
        if (sec > 3600) return '>1h';
        if (sec > 600) return `${Math.round(sec/60)}m`;
        if (sec >= 60) return `${Math.floor(sec/60)}:${String(Math.round(sec%60)).padStart(2,'0')}`;
        return `${Math.round(sec)}s`;
      };
      
      let legendY = 15;
      sessions.forEach((session, boatIdx) => {
        // Skip boats not visible - use telemetry-adjusted time
        if (!isSessionVisibleAtTime(session, exportTelemetryTime)) return;
        
        const color = BOAT_COLORS[boatIdx % BOAT_COLORS.length];
        const boatSymbol = getBoatSymbol(session.filename);
        const smoothed = getSmoothedTelemetry(session, exportTelemetryTime, 2);
        let leg = getCurrentLegAtTime(session, exportTelemetryTime);
        let isStale = false;
        
        if (!leg && window.exportLastValidLegs[boatIdx]) {
          leg = window.exportLastValidLegs[boatIdx];
          isStale = true;
        }
        
        if (leg && !isStale) {
          window.exportLastValidLegs[boatIdx] = leg;
        }
        
        const boxHeight = 85;
        const boxWidth = 210;
        
        ctx.fillStyle = 'rgba(255,255,255,0.92)';
        ctx.beginPath();
        ctx.roundRect(15, legendY, boxWidth, boxHeight, 6);
        ctx.fill();
        
        // Boat number circle
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(38, legendY + 24, 16, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.font = 'bold 16px -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(String(boatIdx + 1), 38, legendY + 24);
        
        // Boat name
        ctx.fillStyle = '#1f2937';
        ctx.font = 'bold 16px -apple-system, sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText(boatSymbol, 62, legendY + 8);
        
        // Current telemetry
        if (smoothed) {
          const dataStr = `${(smoothed.sog || 0).toFixed(1)}/${(smoothed.vmg || 0).toFixed(1)} kts  ${Math.round(smoothed.hdg || 0)}¬∞`;
          ctx.fillStyle = '#374151';
          ctx.font = '14px -apple-system, sans-serif';
          ctx.fillText(dataStr, 62, legendY + 28);
        } else {
          ctx.fillStyle = '#9ca3af';
          ctx.font = '14px -apple-system, sans-serif';
          ctx.fillText('‚Äî', 62, legendY + 28);
        }
        
        // Leg info
        if (leg) {
          const legSpd = leg.speed != null ? (typeof leg.speed === 'number' ? leg.speed.toFixed(1) : leg.speed) : '-';
          const legVmg = leg.vmg != null ? (typeof leg.vmg === 'number' ? leg.vmg.toFixed(1) : leg.vmg) : '-';
          const legHdg = leg.hdg != null ? leg.hdg + '¬∞' : '-';
          
          let legStr = `Leg: ${legSpd}/${legVmg} ${legHdg}`;
          
          if (leg.next_maneuver) {
            const type = leg.next_maneuver.type === 'tack' ? 'T' : 'G';
            const angle = leg.next_maneuver.angle ? Math.round(leg.next_maneuver.angle) + '¬∞' : '';
            legStr += ` ${type}${angle}`;
          }
          
          ctx.fillStyle = isStale ? '#b0b0b0' : '#6b7280';
          ctx.font = '13px -apple-system, sans-serif';
          ctx.fillText(legStr, 62, legendY + 46);
        } else {
          ctx.fillStyle = '#9ca3af';
          ctx.font = '13px -apple-system, sans-serif';
          ctx.fillText('Leg: ‚Äî', 62, legendY + 46);
        }
        
        // Time to mark
        const ttmData = timeToMarkData[boatIdx];
        if (ttmData) {
          let showUpmark = ttmData.isUpwind;
          if (ttmData.isUpwind === null) {
            if (ttmData.timeToUp != null && ttmData.timeToDn != null) {
              showUpmark = ttmData.timeToUp <= ttmData.timeToDn;
            } else if (ttmData.timeToUp != null) {
              showUpmark = true;
            } else if (ttmData.timeToDn != null) {
              showUpmark = false;
            }
          }
          
          const time = showUpmark ? ttmData.timeToUp : ttmData.timeToDn;
          if (time != null && time > 0) {
            const markLabel = showUpmark ? 'Up mark in:' : 'Down mark in:';
            ctx.fillStyle = '#9ca3af';
            ctx.font = '12px -apple-system, sans-serif';
            ctx.fillText(`${markLabel} ${formatMarkTime(time)}`, 62, legendY + 64);
          }
        }
        
        legendY += boxHeight + 10;
      });
    }
    
    // ===== VIDEO WITH OVERLAYS EXPORT =====
    
    let videoExportInProgress = false;
    
    function showVideoWithOverlaysExportDialog() {
      if (!currentActiveVideo) {
        alert('No video is currently loaded. Please load a video first.');
        return;
      }
      
      // Calculate video time range
      const referenceStartMs = getFullStartTimeMs();
      const videoStartMs = currentActiveVideo.startTimestampMs;
      const videoDurationSec = currentActiveVideo.durationSec || 
        (currentActiveVideo.is360Video && current360Player ? current360Player.duration : 60);
      const videoEndMs = videoStartMs + videoDurationSec * 1000;
      
      // Current playback position within video
      const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
      const currentVideoTimeSec = Math.max(0, (currentAbsoluteMs - videoStartMs) / 1000);
      
      // Format time helper
      const formatTime = (sec) => {
        const m = Math.floor(sec / 60);
        const s = Math.floor(sec % 60);
        return `${m}:${s.toString().padStart(2, '0')}`;
      };
      
      // Default export range: from current position to end, or full video if at start
      const defaultStartSec = currentVideoTimeSec < 5 ? 0 : currentVideoTimeSec;
      const defaultEndSec = Math.min(defaultStartSec + 60, videoDurationSec); // Default 60 sec or to end
      
      // Detect video type
      const is360 = currentActiveVideo.is360Video;
      const isINSV = is360 && current360Player && current360Player.combinedCanvas;
      
      // Create modal
      const modal = document.createElement('div');
      modal.id = 'video-overlay-export-modal';
      modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:10000;';
      
      modal.innerHTML = `
        <div id="video-export-dialog" style="background:white;border-radius:12px;padding:20px;max-width:480px;width:90%;box-shadow:0 4px 20px rgba(0,0,0,0.3);max-height:90vh;overflow-y:auto;">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
            <h3 style="margin:0;font-size:16px;">üé¨ Export Video with Overlays</h3>
            <button onclick="closeVideoOverlayExportDialog()" style="background:none;border:none;font-size:20px;cursor:pointer;color:#6b7280;">√ó</button>
          </div>
          
          <div style="background:#f0f9ff;border:1px solid #bae6fd;border-radius:8px;padding:10px;margin-bottom:16px;font-size:12px;">
            <div style="font-weight:600;color:#0369a1;margin-bottom:4px;">üìπ ${currentActiveVideo.filename}</div>
            <div style="color:#0284c7;">
              ${is360 ? (isINSV ? '360¬∞ INSV (current FOV will be used)' : '360¬∞ LRV') : 'Standard video'}
              ‚Ä¢ Duration: ${formatTime(videoDurationSec)}
            </div>
          </div>
          
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:16px;">
            <div>
              <label style="display:block;font-size:11px;color:#6b7280;margin-bottom:4px;">Start Time</label>
              <input type="text" id="vexp-start" value="${formatTime(defaultStartSec)}" 
                style="width:100%;padding:8px;border:1px solid #d1d5db;border-radius:6px;font-size:13px;box-sizing:border-box;">
              <div style="font-size:10px;color:#9ca3af;margin-top:2px;">Format: M:SS</div>
            </div>
            <div>
              <label style="display:block;font-size:11px;color:#6b7280;margin-bottom:4px;">End Time</label>
              <input type="text" id="vexp-end" value="${formatTime(defaultEndSec)}" 
                style="width:100%;padding:8px;border:1px solid #d1d5db;border-radius:6px;font-size:13px;box-sizing:border-box;">
              <div style="font-size:10px;color:#9ca3af;margin-top:2px;">Max: ${formatTime(videoDurationSec)}</div>
            </div>
          </div>
          
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:16px;">
            <div>
              <label style="display:block;font-size:11px;color:#6b7280;margin-bottom:4px;">Resolution</label>
              <select id="vexp-resolution" style="width:100%;padding:8px;border:1px solid #d1d5db;border-radius:6px;font-size:13px;">
                <option value="720">720p (1280√ó720)</option>
                <option value="1080" selected>1080p (1920√ó1080)</option>
                <option value="1440">1440p (2560√ó1440)</option>
              </select>
            </div>
            <div>
              <label style="display:block;font-size:11px;color:#6b7280;margin-bottom:4px;">Frame Rate</label>
              <select id="vexp-fps" style="width:100%;padding:8px;border:1px solid #d1d5db;border-radius:6px;font-size:13px;">
                <option value="15">15 FPS</option>
                <option value="24">24 FPS</option>
                <option value="30" selected>30 FPS</option>
              </select>
            </div>
          </div>
          
          <div style="margin-bottom:16px;">
            <label style="display:block;font-size:11px;color:#6b7280;margin-bottom:8px;">Include Overlays</label>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
              <label style="display:flex;align-items:center;gap:6px;font-size:12px;cursor:pointer;">
                <input type="checkbox" id="vexp-telemetry" checked> Telemetry (SPD/VMG/HDG)
              </label>
              <label style="display:flex;align-items:center;gap:6px;font-size:12px;cursor:pointer;">
                <input type="checkbox" id="vexp-leg" checked> Leg Info
              </label>
              <label style="display:flex;align-items:center;gap:6px;font-size:12px;cursor:pointer;">
                <input type="checkbox" id="vexp-minimap" checked> GPS Map
              </label>
              <label style="display:flex;align-items:center;gap:6px;font-size:12px;cursor:pointer;">
                <input type="checkbox" id="vexp-time" checked> Timestamp
              </label>
            </div>
          </div>
          
          <div id="vexp-estimate" style="background:#f9fafb;border-radius:6px;padding:10px;margin-bottom:16px;font-size:11px;color:#6b7280;">
            Estimated: calculating...
          </div>
          
          <div style="background:#fef3c7;border:1px solid #f59e0b;border-radius:6px;padding:8px 10px;margin-bottom:16px;font-size:11px;color:#92400e;">
            ‚ö†Ô∏è Note: Audio is not included in 360¬∞ video exports. Video only.
          </div>
          
          <div id="vexp-progress" style="display:none;margin-bottom:16px;">
            <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
              <span id="vexp-progress-text" style="font-size:11px;color:#6b7280;">Preparing...</span>
              <span id="vexp-progress-pct" style="font-size:11px;color:#3b82f6;font-weight:600;">0%</span>
            </div>
            <div style="background:#e5e7eb;border-radius:4px;height:8px;overflow:hidden;">
              <div id="vexp-progress-bar" style="background:linear-gradient(90deg,#3b82f6,#8b5cf6);height:100%;width:0%;transition:width 0.3s;"></div>
            </div>
          </div>
          
          <div style="display:flex;gap:8px;justify-content:flex-end;">
            <button onclick="closeVideoOverlayExportDialog()" style="padding:8px 16px;border:1px solid #d1d5db;border-radius:6px;background:white;cursor:pointer;font-size:13px;">Cancel</button>
            <button id="vexp-start-btn" onclick="startVideoOverlayExport()" style="padding:8px 16px;border:none;border-radius:6px;background:#3b82f6;color:white;cursor:pointer;font-size:13px;font-weight:500;">
              üé¨ Export MP4
            </button>
          </div>
        </div>
      `;
      
      getModalContainer().appendChild(modal);
      
      // Close on backdrop click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) closeVideoOverlayExportDialog();
      });
      
      // Close on Escape
      const escHandler = (e) => {
        if (e.code === 'Escape') {
          closeVideoOverlayExportDialog();
          document.removeEventListener('keydown', escHandler);
        }
      };
      document.addEventListener('keydown', escHandler);
      
      // Update estimate when inputs change
      const updateEstimate = () => {
        const startSec = parseTimeInput(document.getElementById('vexp-start').value);
        const endSec = parseTimeInput(document.getElementById('vexp-end').value);
        const fps = parseInt(document.getElementById('vexp-fps').value);
        const res = document.getElementById('vexp-resolution').value;
        
        const duration = Math.max(0, endSec - startSec);
        const frames = Math.ceil(duration * fps);
        
        // Rough estimate: ~50KB per frame at 1080p
        const sizeMultiplier = res === '720' ? 0.5 : (res === '1440' ? 2 : 1);
        const estimatedMB = Math.round(frames * 0.05 * sizeMultiplier);
        
        // Time estimate: ~0.1-0.3 sec per frame for 360, ~0.05 sec for regular
        const is360 = currentActiveVideo && currentActiveVideo.is360Video;
        const secPerFrame = is360 ? 0.2 : 0.05;
        const estimatedMin = Math.ceil((frames * secPerFrame) / 60);
        
        document.getElementById('vexp-estimate').innerHTML = `
          <div style="display:flex;justify-content:space-between;">
            <span>Duration: <b>${formatTime(duration)}</b> (${frames} frames)</span>
            <span>Est. size: <b>~${estimatedMB}MB</b></span>
          </div>
          <div style="margin-top:4px;color:#9ca3af;">Export time: ~${estimatedMin} min${is360 ? ' (360¬∞ video - may take longer)' : ''}</div>
        `;
      };
      
      ['vexp-start', 'vexp-end', 'vexp-fps', 'vexp-resolution'].forEach(id => {
        document.getElementById(id).addEventListener('change', updateEstimate);
        document.getElementById(id).addEventListener('input', updateEstimate);
      });
      
      updateEstimate();
    }
    
    function closeVideoOverlayExportDialog() {
      const modal = document.getElementById('video-overlay-export-modal');
      if (modal) modal.remove();
      videoExportInProgress = false;
    }
    
    function parseTimeInput(str) {
      const parts = str.split(':').map(s => parseFloat(s.trim()) || 0);
      if (parts.length === 1) return parts[0];
      if (parts.length === 2) return parts[0] * 60 + parts[1];
      if (parts.length >= 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
      return 0;
    }
    
    async function startVideoOverlayExport() {
      if (videoExportInProgress) return;
      videoExportInProgress = true;
      
      const startBtn = document.getElementById('vexp-start-btn');
      startBtn.disabled = true;
      startBtn.textContent = '‚è≥ Preparing...';
      
      // Store original 360 player state for restoration
      let was360Playing = false;
      let was360Active = is360VideoActive;
      
      try {
        // Parse inputs
        const startSec = parseTimeInput(document.getElementById('vexp-start').value);
        const endSec = parseTimeInput(document.getElementById('vexp-end').value);
        const fps = parseInt(document.getElementById('vexp-fps').value);
        const resOption = document.getElementById('vexp-resolution').value;
        
        const width = resOption === '720' ? 1280 : (resOption === '1440' ? 2560 : 1920);
        const height = resOption === '720' ? 720 : (resOption === '1440' ? 1440 : 1080);
        
        const includeTelemetry = document.getElementById('vexp-telemetry').checked;
        const includeLeg = document.getElementById('vexp-leg').checked;
        const includeMinimap = document.getElementById('vexp-minimap').checked;
        const includeTime = document.getElementById('vexp-time').checked;
        
        // Validate
        const videoDuration = currentActiveVideo.durationSec || 
          (current360Player ? current360Player.duration : 60);
        
        if (startSec < 0 || endSec > videoDuration || startSec >= endSec) {
          alert(`Invalid time range. Video duration is ${Math.floor(videoDuration / 60)}:${Math.floor(videoDuration % 60).toString().padStart(2, '0')}`);
          startBtn.disabled = false;
          startBtn.textContent = 'üé¨ Export MP4';
          videoExportInProgress = false;
          return;
        }
        
        // Show progress
        document.getElementById('vexp-progress').style.display = 'block';
        
        // Calculate playback time offset
        const referenceStartMs = getFullStartTimeMs();
        const videoStartMs = currentActiveVideo.startTimestampMs;
        
        // Pause current playback
        const wasPlaying = isPlaying;
        if (isPlaying) stopPlayback();
        
        // Pause 360 player if active
        if (current360Player) {
          was360Playing = current360Player.playing || false;
          if (current360Player.pause) {
            current360Player.pause();
          }
          // Stop the animation loop during export
          is360VideoActive = false;
        }
        
        // Save current state
        const savedPlaybackTime = playbackTime;
        const savedLon360 = lon360;
        const savedLat360 = lat360;
        const savedFov360 = threeCamera ? threeCamera.fov : 100;
        
        // Create render canvas
        const renderCanvas = document.createElement('canvas');
        renderCanvas.width = width;
        renderCanvas.height = height;
        const ctx = renderCanvas.getContext('2d');
        
        // Check WebCodecs support
        if (typeof VideoEncoder === 'undefined') {
          throw new Error('WebCodecs API not supported. Please use Chrome or Edge.');
        }
        
        // Check Mp4Muxer support
        if (typeof Mp4Muxer === 'undefined') {
          throw new Error('MP4 muxer not available.');
        }
        
        // Setup encoder first to determine codec
        const frameDurationMicros = Math.round(1000000 / fps);
        let encoderError = null;
        let encoder = null;
        let useVP9 = false;
        
        console.log('Export resolution:', width, 'x', height, 'fps:', fps);
        
        // Try multiple codec configurations in order of preference
        const codecConfigs = [
          // H.264 Baseline profile (most compatible)
          {
            codec: 'avc1.42001f',
            width: width,
            height: height,
            bitrate: resOption === '1440' ? 12000000 : (resOption === '1080' ? 8000000 : 4000000)
          },
          // H.264 Constrained Baseline
          {
            codec: 'avc1.42e01f',
            width: width,
            height: height,
            bitrate: resOption === '1440' ? 12000000 : (resOption === '1080' ? 8000000 : 4000000)
          },
          // H.264 Main profile
          {
            codec: 'avc1.4d001f',
            width: width,
            height: height,
            bitrate: resOption === '1440' ? 12000000 : (resOption === '1080' ? 8000000 : 4000000)
          },
          // VP9 (good fallback, widely supported)
          {
            codec: 'vp09.00.10.08',
            width: width,
            height: height,
            bitrate: resOption === '1440' ? 12000000 : (resOption === '1080' ? 8000000 : 4000000)
          },
          // VP8
          {
            codec: 'vp8',
            width: width,
            height: height,
            bitrate: resOption === '1440' ? 12000000 : (resOption === '1080' ? 8000000 : 4000000)
          }
        ];
        
        let encoderConfig = null;
        for (const config of codecConfigs) {
          console.log('Checking encoder support for:', config.codec, config.width + 'x' + config.height);
          try {
            const support = await VideoEncoder.isConfigSupported(config);
            console.log('  Result:', support.supported ? 'SUPPORTED' : 'not supported');
            if (support.supported) {
              encoderConfig = support.config || config;
              useVP9 = config.codec.startsWith('vp');
              console.log('Using codec:', config.codec);
              break;
            }
          } catch (e) {
            console.warn('  Config check error:', e.message);
          }
        }
        
        if (!encoderConfig) {
          // Last resort: try 720p
          console.log('Trying 720p fallback...');
          const fallbackConfig = {
            codec: 'avc1.42001f',
            width: 1280,
            height: 720,
            bitrate: 4000000
          };
          try {
            const support = await VideoEncoder.isConfigSupported(fallbackConfig);
            if (support.supported) {
              encoderConfig = fallbackConfig;
              console.log('Using 720p fallback');
              // Note: we'll still render at requested res but encode at 720p
            }
          } catch (e) {
            console.warn('720p fallback failed:', e);
          }
        }
        
        if (!encoderConfig) {
          throw new Error('No supported video encoder found. Your browser may not support WebCodecs video encoding.');
        }
        
        // Update muxer codec if using VP9
        const muxerCodec = useVP9 ? 'vp9' : 'avc';
        
        // Note: Audio export from 360 video is not yet supported
        // LRV audio would require extracting and re-encoding audio samples
        // which adds significant complexity. For now, export video only.
        console.log('Note: Audio export not yet supported for 360 video');
        
        // Create muxer with correct codec (video only for now)
        const muxer = new Mp4Muxer.Muxer({
          target: new Mp4Muxer.ArrayBufferTarget(),
          video: {
            codec: muxerCodec,
            width: encoderConfig.width,
            height: encoderConfig.height
          },
          fastStart: 'in-memory'
        });
        
        encoder = new VideoEncoder({
          output: (chunk, meta) => {
            try {
              muxer.addVideoChunk(chunk, meta);
            } catch (e) {
              console.error('Muxer error:', e);
              encoderError = e;
            }
          },
          error: (err) => {
            console.error('VideoEncoder error callback:', err);
            encoderError = err;
          }
        });
        
        console.log('Encoder created, state:', encoder.state);
        
        encoder.configure(encoderConfig);
        
        console.log('Encoder configured, state:', encoder.state);
        
        // Wait a moment for encoder to be fully ready
        await new Promise(r => setTimeout(r, 100));
        
        if (encoder.state !== 'configured') {
          throw new Error(`Encoder not in configured state: ${encoder.state}`);
        }
        
        // Calculate frames
        const duration = endSec - startSec;
        const totalFrames = Math.ceil(duration * fps);
        
        startBtn.textContent = '‚è≥ Exporting...';
        
        // Export each frame
        for (let i = 0; i < totalFrames; i++) {
          if (encoderError) throw encoderError;
          
          // Check encoder state before encoding
          if (encoder.state === 'closed') {
            throw new Error('Encoder was closed unexpectedly');
          }
          
          const videoTimeSec = startSec + (i / fps);
          const absoluteMs = videoStartMs + videoTimeSec * 1000;
          const newPlaybackTime = (absoluteMs - referenceStartMs) / 60000;
          
          // Update global playback time for telemetry functions
          playbackTime = newPlaybackTime;
          
          // Render video frame to canvas
          try {
            await renderVideoFrameToCanvas(ctx, width, height, videoTimeSec);
          } catch (renderErr) {
            console.error('renderVideoFrameToCanvas error:', renderErr);
            throw new Error('Failed to render frame: ' + renderErr.message);
          }
          
          // Check encoder state after async render
          if (encoder.state === 'closed') {
            throw new Error('Encoder closed during frame render');
          }
          
          // Render overlays
          try {
            renderOverlaysToCanvas(ctx, width, height, {
              telemetry: includeTelemetry,
              leg: includeLeg,
              minimap: includeMinimap,
              time: includeTime,
              videoTimeSec: videoTimeSec
            });
          } catch (overlayErr) {
            console.error('renderOverlaysToCanvas error:', overlayErr);
            // Non-fatal, continue without overlays
          }
          
          // Validate canvas before creating frame
          if (renderCanvas.width === 0 || renderCanvas.height === 0) {
            throw new Error(`Invalid canvas dimensions: ${renderCanvas.width}x${renderCanvas.height}`);
          }
          
          // Log every 30 frames
          if (i % 30 === 0) {
            console.log(`Frame ${i}/${totalFrames}, encoder state: ${encoder.state}, queue: ${encoder.encodeQueueSize}`);
          }
          
          // Create VideoFrame and encode
          let frame = null;
          try {
            frame = new VideoFrame(renderCanvas, {
              timestamp: i * frameDurationMicros,
              duration: frameDurationMicros
            });
          } catch (frameErr) {
            console.error('VideoFrame creation failed:', frameErr, 'canvas:', renderCanvas.width, 'x', renderCanvas.height);
            throw new Error('Failed to create VideoFrame: ' + frameErr.message);
          }
          
          try {
            // Wait if encoder queue is getting full
            let queueWaitCount = 0;
            while (encoder.encodeQueueSize > 5) {
              await new Promise(r => setTimeout(r, 10));
              queueWaitCount++;
              if (queueWaitCount > 500) { // 5 second timeout
                frame.close();
                throw new Error('Encoder queue timeout');
              }
              if (encoder.state === 'closed' || encoderError) {
                frame.close();
                console.error('Encoder closed during queue wait. State:', encoder.state, 'Error:', encoderError);
                throw encoderError || new Error('Encoder closed while waiting for queue');
              }
            }
            
            // Final state check right before encode
            if (encoder.state === 'closed') {
              frame.close();
              console.error('Encoder closed before encode. encoderError:', encoderError);
              throw new Error('Encoder closed before encode call');
            }
            
            if (encoder.state !== 'configured') {
              frame.close();
              console.error('Encoder in unexpected state:', encoder.state);
              throw new Error('Encoder in unexpected state: ' + encoder.state);
            }
            
            if (encoderError) {
              frame.close();
              console.error('Encoder error detected:', encoderError);
              throw encoderError;
            }
            
            const keyFrame = i % (fps * 2) === 0;
            encoder.encode(frame, { keyFrame });
            frame.close();
            frame = null;
          } catch (encodeErr) {
            if (frame) {
              try { frame.close(); } catch(e) {}
            }
            console.error('Encode failed at frame', i, ':', encodeErr);
            throw encodeErr;
          }
          
          // Update progress
          const pct = Math.round(((i + 1) / totalFrames) * 100);
          document.getElementById('vexp-progress-text').textContent = `Frame ${i + 1}/${totalFrames}`;
          document.getElementById('vexp-progress-pct').textContent = `${pct}%`;
          document.getElementById('vexp-progress-bar').style.width = `${pct}%`;
          
          // Yield to UI every few frames
          if (i % 3 === 0) {
            await new Promise(r => setTimeout(r, 0));
          }
        }
        
        // Finalize
        document.getElementById('vexp-progress-text').textContent = 'Finalizing...';
        
        // Only flush and close if encoder is still usable
        if (encoder.state === 'configured') {
          await encoder.flush();
          encoder.close();
        } else if (encoder.state !== 'closed') {
          encoder.close();
        }
        
        muxer.finalize();
        
        // Download
        const mp4Data = muxer.target.buffer;
        const blob = new Blob([mp4Data], { type: 'video/mp4' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        a.download = `sailing-video-${timestamp}.mp4`;
        a.href = url;
        a.click();
        URL.revokeObjectURL(url);
        
        // Restore state
        playbackTime = savedPlaybackTime;
        lon360 = savedLon360;
        lat360 = savedLat360;
        if (threeCamera) {
          threeCamera.fov = savedFov360;
          threeCamera.updateProjectionMatrix();
        }
        
        // Seek 360 player back to original position
        if (current360Player && current360Player.seek) {
          const originalVideoTimeSec = Math.max(0, (savedPlaybackTime * 60000 + referenceStartMs - videoStartMs) / 1000);
          await current360Player.seek(originalVideoTimeSec);
        }
        
        // Restore animation loop if it was active
        if (was360Active && current360Player) {
          is360VideoActive = true;
          animate360();
        }
        
        // Restore playback if it was playing
        if (wasPlaying) {
          startPlayback();
        }
        
        // Update UI
        renderMap();
        updateVideoOverlays();
        updatePlaybackUI();
        
        closeVideoOverlayExportDialog();
        
      } catch (err) {
        console.error('Video export error:', err);
        
        // Clean up encoder if it exists and is not closed
        if (typeof encoder !== 'undefined' && encoder && encoder.state !== 'closed') {
          try {
            encoder.close();
          } catch (e) {
            console.warn('Error closing encoder:', e);
          }
        }
        
        alert('Export failed: ' + err.message);
        
        // Restore animation loop on error too
        if (was360Active && current360Player) {
          is360VideoActive = true;
          animate360();
        }
        
        // Restore state on error too
        if (startBtn) {
          startBtn.disabled = false;
          startBtn.textContent = 'üé¨ Export MP4';
        }
        videoExportInProgress = false;
      }
    }
    
    async function renderVideoFrameToCanvas(ctx, width, height, videoTimeSec) {
      const is360 = currentActiveVideo && currentActiveVideo.is360Video;
      
      if (is360 && current360Player) {
        // 360 video - render from Three.js
        await render360FrameToCanvas(ctx, width, height, videoTimeSec);
      } else if (currentActiveVideo && currentActiveVideo.element) {
        // Regular video - draw from video element
        await renderRegularVideoFrame(ctx, width, height, videoTimeSec);
      } else {
        // No video - black frame
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, height);
      }
    }
    
    async function render360FrameToCanvas(ctx, width, height, videoTimeSec) {
      // Determine player type
      const isINSV = current360Player && current360Player.combinedCanvas;
      const isLRV = current360Player && current360Player.video && !current360Player.combinedCanvas;
      
      if (isINSV) {
        // INSV player - seek and wait for frame to be rendered
        // The seek() method calls renderFastKeyframePreview which draws to combinedCanvas
        await current360Player.seek(videoTimeSec);
        
        // Give a moment for the frame to be fully rendered
        await new Promise(r => setTimeout(r, 100));
        
        // Ensure the frame is drawn to combinedCanvas
        // The seek should have done this, but call forceRedraw as a fallback
        if (current360Player.decodedFrameBuffer && current360Player.decodedFrameBuffer.length > 0) {
          if (current360Player.forceRedrawToAllCanvases) {
            current360Player.forceRedrawToAllCanvases('combined');
          }
        }
        
        // Update texture from combinedCanvas
        if (threeTexture) {
          threeTexture.needsUpdate = true;
        }
        
      } else if (isLRV) {
        // LRV player - seek video element and wait
        const video = current360Player.video;
        
        // Set the current time
        video.currentTime = videoTimeSec;
        
        // Wait for seek to complete
        await new Promise((resolve) => {
          const timeoutId = setTimeout(resolve, 500); // Timeout fallback
          const onSeeked = () => {
            clearTimeout(timeoutId);
            video.removeEventListener('seeked', onSeeked);
            resolve();
          };
          video.addEventListener('seeked', onSeeked);
        });
        
        // Wait a moment for the frame to be ready
        await new Promise(r => setTimeout(r, 50));
        
        // The texture auto-updates from video element via VideoTexture
        if (threeTexture) {
          threeTexture.needsUpdate = true;
        }
      } else {
        // No valid 360 player - fill black
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, height);
        return;
      }
      
      // Now render the Three.js scene
      if (!threeRenderer || !threeScene || !threeCamera) {
        // No renderer available - draw black
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, height);
        return;
      }
      
      // Save current renderer size
      const originalSize = new THREE.Vector2();
      threeRenderer.getSize(originalSize);
      const originalPixelRatio = threeRenderer.getPixelRatio();
      
      // Temporarily resize renderer to export resolution
      threeRenderer.setPixelRatio(1);
      threeRenderer.setSize(width, height);
      
      // Update camera aspect ratio for export resolution
      const originalAspect = threeCamera.aspect;
      threeCamera.aspect = width / height;
      threeCamera.updateProjectionMatrix();
      
      // Update camera orientation with current lon/lat
      const phi = THREE.MathUtils.degToRad(90 - lat360);
      const theta = THREE.MathUtils.degToRad(lon360);
      
      threeCamera.target.x = 500 * Math.sin(phi) * Math.cos(theta);
      threeCamera.target.y = 500 * Math.cos(phi);
      threeCamera.target.z = 500 * Math.sin(phi) * Math.sin(theta);
      threeCamera.lookAt(threeCamera.target);
      threeCamera.position.set(0, 0, 0);
      
      // Handle different view modes
      if (viewMode360 === 'megaview' && megaViewMesh && megaViewMaterial) {
        if (threeSphere) threeSphere.visible = false;
        megaViewMesh.visible = true;
        
        // LRV UV flip mirrors the view, needs 180¬∞ offset
        // INSV also needs 180¬∞ offset, Equirect needs 0¬∞
        const yawOffset = current360Format === 'equirectangular' ? 0 : 180;
        const yawRad = THREE.MathUtils.degToRad(lon360 + yawOffset);
        const pitchRad = THREE.MathUtils.degToRad(-lat360);
        megaViewMaterial.uniforms.yaw.value = yawRad;
        megaViewMaterial.uniforms.pitch.value = pitchRad;
        megaViewMaterial.uniforms.hFov.value = THREE.MathUtils.degToRad(megaHFov);
        megaViewMaterial.uniforms.panniniD.value = 0.8 + (megaHFov - 160) * 0.0067;
        megaViewMaterial.uniforms.aspect.value = width / height;
        
        threeRenderer.render(threeScene, orthoCamera);
      } else {
        if (threeSphere) threeSphere.visible = true;
        if (megaViewMesh) megaViewMesh.visible = false;
        threeRenderer.render(threeScene, threeCamera);
      }
      
      // Draw the rendered frame to export canvas
      ctx.drawImage(threeRenderer.domElement, 0, 0, width, height);
      
      // Restore original renderer settings
      threeRenderer.setPixelRatio(originalPixelRatio);
      threeRenderer.setSize(originalSize.x, originalSize.y);
      threeCamera.aspect = originalAspect;
      threeCamera.updateProjectionMatrix();
    }
    
    async function renderRegularVideoFrame(ctx, width, height, videoTimeSec) {
      const video = currentActiveVideo.element;
      
      // Seek to target time
      video.currentTime = videoTimeSec;
      
      // Wait for seek to complete
      await new Promise((resolve) => {
        const onSeeked = () => {
          video.removeEventListener('seeked', onSeeked);
          resolve();
        };
        video.addEventListener('seeked', onSeeked);
        
        // Timeout fallback
        setTimeout(resolve, 200);
      });
      
      // Draw video frame
      ctx.drawImage(video, 0, 0, width, height);
    }
    
    function renderOverlaysToCanvas(ctx, width, height, options) {
      const scale = width / 1920; // Scale factor based on 1080p reference
      // Use larger sizes to match fullscreen overlay appearance
      const fsScale = scale * 1.5; // Fullscreen-like scaling
      const sessions = getReplaySessions();
      
      // Get current telemetry data (using telemetry-adjusted time for export)
      const exportOverlayTime = getTelemetryDisplayTime();
      const session = sessions[0];
      const telemetry = session ? getSmoothedTelemetry(session, exportOverlayTime, 2) : null;
      const leg = session ? getCurrentLegAtTime(session, exportOverlayTime) : null;
      
      // Telemetry overlay (top-right)
      if (options.telemetry && telemetry) {
        const padding = 20 * scale;
        const boxWidth = 180 * scale;
        const boxHeight = 170 * scale;
        const x = width - boxWidth - padding;
        const y = padding;
        
        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        roundRect(ctx, x, y, boxWidth, boxHeight, 8 * scale);
        ctx.fill();
        
        // Text - use larger font
        ctx.font = `bold ${18 * scale}px monospace`;
        ctx.textAlign = 'right';
        
        const lineHeight = 32 * scale;
        let ty = y + 32 * scale;
        
        ctx.fillStyle = '#9ca3af';
        ctx.fillText('SPD', x + boxWidth - 70 * scale, ty);
        ctx.fillStyle = '#fff';
        ctx.fillText(telemetry.sog.toFixed(1), x + boxWidth - 14 * scale, ty);
        
        ty += lineHeight;
        ctx.fillStyle = '#9ca3af';
        ctx.fillText('VMG', x + boxWidth - 70 * scale, ty);
        ctx.fillStyle = '#fff';
        ctx.fillText(telemetry.vmg.toFixed(1), x + boxWidth - 14 * scale, ty);
        
        ty += lineHeight;
        ctx.fillStyle = '#9ca3af';
        ctx.fillText('HDG', x + boxWidth - 70 * scale, ty);
        ctx.fillStyle = '#fff';
        ctx.fillText(Math.round(telemetry.hdg).toString().padStart(3, '0'), x + boxWidth - 14 * scale, ty);
        
        ty += lineHeight;
        ctx.fillStyle = '#9ca3af';
        ctx.fillText('HEEL', x + boxWidth - 70 * scale, ty);
        ctx.fillStyle = '#fff';
        ctx.fillText(Math.round(telemetry.heel).toString(), x + boxWidth - 14 * scale, ty);
        
        ty += lineHeight;
        ctx.fillStyle = '#9ca3af';
        ctx.fillText('STR', x + boxWidth - 70 * scale, ty);
        ctx.fillStyle = '#fff';
        ctx.fillText((telemetry.steeringRate || 0).toFixed(1), x + boxWidth - 14 * scale, ty);
      }
      
      // Leg overlay (bottom-right, above telemetry)
      if (options.leg && leg) {
        const padding = 20 * scale;
        const boxWidth = 180 * scale;
        const boxHeight = 170 * scale;  // Taller to fit "Next" row
        const x = width - boxWidth - padding;
        const y = height - boxHeight - 60 * scale;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        roundRect(ctx, x, y, boxWidth, boxHeight, 8 * scale);
        ctx.fill();
        
        // Format leg label
        const legPos = leg.pos ? leg.pos.charAt(0).toUpperCase() : '?';
        ctx.font = `bold ${14 * scale}px monospace`;
        ctx.textAlign = 'left';
        ctx.fillStyle = '#fff';
        ctx.fillText(`Leg #${leg.id || '?'} (${legPos})`, x + 14 * scale, y + 24 * scale);
        
        // Format speed/vmg values (can be number or string)
        const formatValue = (val) => {
          if (val == null) return '-';
          if (typeof val === 'number') return val.toFixed(1);
          return String(val);
        };
        
        ctx.font = `bold ${16 * scale}px monospace`;
        ctx.textAlign = 'right';
        const lineHeight = 28 * scale;
        let ty = y + 54 * scale;
        
        ctx.fillStyle = '#9ca3af';
        ctx.fillText('SPD', x + boxWidth - 70 * scale, ty);
        ctx.fillStyle = '#fff';
        ctx.fillText(formatValue(leg.speed), x + boxWidth - 14 * scale, ty);
        
        ty += lineHeight;
        ctx.fillStyle = '#9ca3af';
        ctx.fillText('VMG', x + boxWidth - 70 * scale, ty);
        ctx.fillStyle = '#fff';
        ctx.fillText(formatValue(leg.vmg), x + boxWidth - 14 * scale, ty);
        
        ty += lineHeight;
        ctx.fillStyle = '#9ca3af';
        ctx.fillText('HDG', x + boxWidth - 70 * scale, ty);
        ctx.fillStyle = '#fff';
        const hdgVal = leg.hdg != null ? Math.round(leg.hdg).toString().padStart(3, '0') : '---';
        ctx.fillText(hdgVal, x + boxWidth - 14 * scale, ty);
        
        // Add "Next" row with tack angle and time
        ty += lineHeight;
        ctx.fillStyle = '#9ca3af';
        ctx.fillText('Next', x + boxWidth - 70 * scale, ty);
        ctx.fillStyle = '#fff';
        
        // Calculate next info (tack angle + time remaining)
        let nextText = '--';
        if (session) {
          const sessionLocalTime = getSessionLocalTime(session, playbackTime);
          const sessionStart = session.timelineStart || 0;
          const trackTime = sessionLocalTime - sessionStart;
          const timeToEnd = (leg.end - trackTime) * 60; // seconds
          
          const nextLeg = getNextLeg(session, leg);
          let tackAngle = '--';
          if (nextLeg && leg.hdg != null && nextLeg.hdg != null) {
            tackAngle = Math.round(Math.abs(angleDiff(leg.hdg, nextLeg.hdg)));
          }
          
          if (timeToEnd > 0) {
            const mins = Math.floor(timeToEnd / 60);
            const secs = Math.floor(timeToEnd % 60);
            nextText = `${tackAngle}${typeof tackAngle === 'number' ? '¬∞' : ''}, ${mins}:${secs.toString().padStart(2, '0')}`;
          } else {
            nextText = `${tackAngle}${typeof tackAngle === 'number' ? '¬∞' : ''}, 0:00`;
          }
        }
        ctx.fillText(nextText, x + boxWidth - 14 * scale, ty);
      }
      
      // Minimap overlay (bottom-left)
      if (options.minimap && sessions.length > 0) {
        const padding = 20 * scale;
        const mapSize = 260 * scale;  // Larger minimap
        const x = padding;
        const y = height - mapSize - 60 * scale;
        
        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        roundRect(ctx, x, y, mapSize, mapSize, 8 * scale);
        ctx.fill();
        
        // Render minimap content
        renderMinimapToCanvas(ctx, x + 10 * scale, y + 10 * scale, mapSize - 20 * scale, mapSize - 20 * scale, sessions);
      }
      
      // Timestamp overlay (bottom-right corner)
      if (options.time) {
        const videoTimeSec = options.videoTimeSec || 0;
        const m = Math.floor(videoTimeSec / 60);
        const s = Math.floor(videoTimeSec % 60);
        const timeStr = `${m}:${s.toString().padStart(2, '0')}`;
        
        ctx.font = `bold ${18 * scale}px monospace`;  // Larger font
        ctx.textAlign = 'right';
        
        const textWidth = ctx.measureText(timeStr).width;
        const padding = 20 * scale;
        const boxWidth = textWidth + 32 * scale;
        const boxHeight = 36 * scale;
        const x = width - boxWidth - padding;
        const y = height - boxHeight - padding;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        roundRect(ctx, x, y, boxWidth, boxHeight, 6 * scale);
        ctx.fill();
        
        ctx.fillStyle = '#fff';
        ctx.fillText(timeStr, x + boxWidth - 16 * scale, y + 25 * scale);
      }
    }
    
    function renderMinimapToCanvas(ctx, x, y, width, height, sessions) {
      // Calculate bounds
      let minLat = Infinity, maxLat = -Infinity;
      let minLon = Infinity, maxLon = -Infinity;
      
      sessions.forEach(session => {
        if (!session.track) return;
        session.track.forEach(p => {
          if (p.lat < minLat) minLat = p.lat;
          if (p.lat > maxLat) maxLat = p.lat;
          if (p.lon < minLon) minLon = p.lon;
          if (p.lon > maxLon) maxLon = p.lon;
        });
      });
      
      if (minLat === Infinity) return;
      
      const latPad = (maxLat - minLat) * 0.1 || 0.001;
      const lonPad = (maxLon - minLon) * 0.1 || 0.001;
      minLat -= latPad; maxLat += latPad;
      minLon -= lonPad; maxLon += lonPad;
      
      const latRange = maxLat - minLat;
      const lonRange = maxLon - minLon;
      const scale = Math.min(width / lonRange, height / latRange) * 0.9;
      
      const lonToX = lon => x + (lon - minLon) * scale + (width - lonRange * scale) / 2;
      const latToY = lat => y + height - ((lat - minLat) * scale + (height - latRange * scale) / 2);
      
      // Draw tracks
      sessions.forEach((session, i) => {
        if (!session.track) return;
        const color = BOAT_COLORS[i % BOAT_COLORS.length];
        
        // Use telemetry-adjusted time for export
        const exportTelemetryTime = getTelemetryDisplayTime();
        const sessionLocalTime = getSessionLocalTime(session, exportTelemetryTime);
        const sessionStart = session.timelineStart || 0;
        const trackPlaybackTime = sessionLocalTime - sessionStart;
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        
        const step = Math.max(1, Math.floor(session.track.length / 200));
        
        for (let idx = step; idx < session.track.length; idx += step) {
          const p0 = session.track[idx - step];
          const p1 = session.track[idx];
          
          // Time-based opacity
          let opacity = 0.8;
          if (p1.t > trackPlaybackTime) {
            opacity = 0.15;
          } else if (trackPlaybackTime - p1.t > 5) {
            opacity = 0.3;
          }
          
          ctx.globalAlpha = opacity;
          ctx.beginPath();
          ctx.moveTo(lonToX(p0.lon), latToY(p0.lat));
          ctx.lineTo(lonToX(p1.lon), latToY(p1.lat));
          ctx.stroke();
        }
      });
      
      ctx.globalAlpha = 1;
      
      // Draw boat positions (use telemetry-adjusted time)
      const exportBoatTelemetryTime = getTelemetryDisplayTime();
      sessions.forEach((session, i) => {
        const pos = getBoatPositionAtTime(session, exportBoatTelemetryTime);
        if (!pos) return;
        
        const color = BOAT_COLORS[i % BOAT_COLORS.length];
        const bx = lonToX(pos.lon);
        const by = latToY(pos.lat);
        const hdg = pos.hdg || 0;
        const size = 8;
        
        ctx.save();
        ctx.translate(bx, by);
        ctx.rotate(hdg * Math.PI / 180);
        
        ctx.fillStyle = color;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, -size);
        ctx.lineTo(size * 0.6, size * 0.6);
        ctx.lineTo(-size * 0.6, size * 0.6);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.restore();
      });
    }
    
    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }
    
    // HTML export (original functionality)
    async function exportAsHTML(exportStartMs, exportEndMs, speed) {
      // Show progress
      document.getElementById('export-progress').style.display = 'block';
      document.getElementById('export-progress-text').textContent = 'Preparing export...';
      document.getElementById('export-progress-bar').style.width = '50%';
      document.getElementById('export-start-btn').disabled = true;
      
      await new Promise(r => setTimeout(r, 50));
      
      // Collect session data for export
      const sessions = getReplaySessions();
      const globalStartMs = window.exportGlobalStartMs;
      const globalEndMs = window.exportTotalDurationMs + globalStartMs;
      
      // Export range in minutes from global start
      const exportStartMin = (exportStartMs - globalStartMs) / 60000;
      const exportEndMin = (exportEndMs - globalStartMs) / 60000;
      
      // Prepare session data for export
      const exportSessions = sessions.map((session, idx) => {
        const sessionStartMs = session.startTimestampMs || 0;
        const trimStart = session.timelineStart || 0;
        const trimEnd = session.timelineEnd || session.s.dur;
        
        // Filter and simplify track points within export range
        const track = session.track.filter(p => {
          const sessionLocalTime = trimStart + p.t;
          const globalTime = (sessionStartMs + sessionLocalTime * 60000 - globalStartMs) / 60000;
          return globalTime >= exportStartMin && globalTime <= exportEndMin;
        }).map(p => ({
          lat: Math.round(p.lat * 1000000) / 1000000,
          lon: Math.round(p.lon * 1000000) / 1000000,
          t: Math.round(p.t * 1000) / 1000,
          hdg: Math.round(p.hdg || p.cog || 0),
          sog: Math.round((p.sog || 0) * 10) / 10
        }));
        
        // Downsample if too many points (keep ~500 max per session)
        const maxPoints = 500;
        const step = track.length > maxPoints ? Math.ceil(track.length / maxPoints) : 1;
        const sampledTrack = step > 1 ? track.filter((_, i) => i % step === 0) : track;
        
        return {
          name: getBoatSymbol(session.filename),
          color: BOAT_COLORS[idx % BOAT_COLORS.length],
          startMs: sessionStartMs,
          trimStart: trimStart,
          trimEnd: trimEnd,
          twd: session.s.twd || 0,
          track: sampledTrack
        };
      });
      
      // Calculate bounds
      let minLat = Infinity, maxLat = -Infinity, minLon = Infinity, maxLon = -Infinity;
      exportSessions.forEach(s => {
        s.track.forEach(p => {
          minLat = Math.min(minLat, p.lat);
          maxLat = Math.max(maxLat, p.lat);
          minLon = Math.min(minLon, p.lon);
          maxLon = Math.max(maxLon, p.lon);
        });
      });
      
      // Add padding
      const latPad = (maxLat - minLat) * 0.1 || 0.001;
      const lonPad = (maxLon - minLon) * 0.1 || 0.001;
      
      const exportData = {
        sessions: exportSessions,
        globalStartMs: globalStartMs,
        exportStartMin: exportStartMin,
        exportEndMin: exportEndMin,
        bounds: {
          minLat: minLat - latPad,
          maxLat: maxLat + latPad,
          minLon: minLon - lonPad,
          maxLon: maxLon + lonPad
        },
        defaultSpeed: speed,
        exportDate: new Date().toISOString()
      };
      
      // Generate standalone HTML
      const htmlContent = generateStandaloneHTML(exportData);
      
      document.getElementById('export-progress-text').textContent = 'Downloading...';
      document.getElementById('export-progress-bar').style.width = '100%';
      
      // Download
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
      a.download = `sailing-replay-${timestamp}.html`;
      a.href = url;
      a.click();
      URL.revokeObjectURL(url);
      
      closeVideoExportDialog();
    }
    
    function generateStandaloneHTML(data) {
      // Safely stringify the data
      const safeData = JSON.parse(JSON.stringify(data, function(key, value) {
        if (value === Infinity) return 999999;
        if (value === -Infinity) return -999999;
        if (Number.isNaN(value)) return 0;
        return value;
      }));
      
      const dataJSON = JSON.stringify(safeData);
      const dateStr = new Date(data.globalStartMs).toLocaleDateString();
      const boatCount = data.sessions.length;
      const boatText = boatCount + ' boat' + (boatCount > 1 ? 's' : '');

      // Build JS code as array of lines - NO template literals
      const jsLines = [];
      jsLines.push('var DATA = ' + dataJSON + ';');
      jsLines.push('var sessions = DATA.sessions;');
      jsLines.push('var bounds = DATA.bounds;');
      jsLines.push('var globalStartMs = DATA.globalStartMs;');
      jsLines.push('var exportStartMin = DATA.exportStartMin;');
      jsLines.push('var exportEndMin = DATA.exportEndMin;');
      jsLines.push('var duration = exportEndMin - exportStartMin;');
      jsLines.push('var playbackTime = 0;');
      jsLines.push('var isPlaying = false;');
      jsLines.push('var speed = DATA.defaultSpeed;');
      jsLines.push('var animationId = null;');
      jsLines.push('var lastFrameTime = 0;');
      jsLines.push('var width = 800, height = 600, padding = 40;');
      jsLines.push('var latRange = bounds.maxLat - bounds.minLat;');
      jsLines.push('var lonRange = bounds.maxLon - bounds.minLon;');
      jsLines.push('var mapScale = Math.min((width - 2*padding) / lonRange, (height - 2*padding) / latRange);');
      jsLines.push('function lonToX(lon) { return padding + (lon - bounds.minLon) * mapScale; }');
      jsLines.push('function latToY(lat) { return height - padding - (lat - bounds.minLat) * mapScale; }');
      jsLines.push('function getSessionLocalTime(session, globalTime) {');
      jsLines.push('  var currentTimeMs = globalStartMs + (exportStartMin + globalTime) * 60000;');
      jsLines.push('  return (currentTimeMs - session.startMs) / 60000;');
      jsLines.push('}');
      jsLines.push('function getBoatPosition(session, globalTime) {');
      jsLines.push('  if (!session.track.length) return null;');
      jsLines.push('  var sessionLocalTime = getSessionLocalTime(session, globalTime);');
      jsLines.push('  var trackTime = sessionLocalTime - session.trimStart;');
      jsLines.push('  if (trackTime < 0 || sessionLocalTime > session.trimEnd) return null;');
      jsLines.push('  var closest = session.track[0], minDiff = Infinity;');
      jsLines.push('  for (var i = 0; i < session.track.length; i++) {');
      jsLines.push('    var p = session.track[i];');
      jsLines.push('    var diff = Math.abs(p.t - trackTime);');
      jsLines.push('    if (diff < minDiff) { minDiff = diff; closest = p; }');
      jsLines.push('  }');
      jsLines.push('  return minDiff < 3 ? closest : null;');
      jsLines.push('}');
      jsLines.push('function render() {');
      jsLines.push('  var svg = document.getElementById("map-svg");');
      jsLines.push('  var html = "";');
      jsLines.push('  html += "<rect width=\'800\' height=\'600\' fill=\'#eff6ff\'/>";');
      jsLines.push('  [0.25, 0.5, 0.75].forEach(function(f) {');
      jsLines.push('    var y = padding + (height - 2*padding) * f;');
      jsLines.push('    var x = padding + (width - 2*padding) * f;');
      jsLines.push('    html += "<line x1=\'" + padding + "\' y1=\'" + y + "\' x2=\'" + (width-padding) + "\' y2=\'" + y + "\' stroke=\'#e5e7eb\' stroke-dasharray=\'4\'/>";');
      jsLines.push('    html += "<line x1=\'" + x + "\' y1=\'" + padding + "\' x2=\'" + x + "\' y2=\'" + (height-padding) + "\' stroke=\'#e5e7eb\' stroke-dasharray=\'4\'/>";');
      jsLines.push('  });');
      jsLines.push('  sessions.forEach(function(session, idx) {');
      jsLines.push('    var track = session.track;');
      jsLines.push('    var sessionLocalTime = getSessionLocalTime(session, playbackTime);');
      jsLines.push('    var trackPlaybackTime = sessionLocalTime - session.trimStart;');
      jsLines.push('    for (var i = 1; i < track.length; i++) {');
      jsLines.push('      var p0 = track[i-1], p1 = track[i];');
      jsLines.push('      var opacity = 0.9, color = session.color;');
      jsLines.push('      if (sessionLocalTime >= session.trimStart) {');
      jsLines.push('        var age = trackPlaybackTime - p1.t;');
      jsLines.push('        if (p1.t > trackPlaybackTime) { opacity = 0.15; color = "#9ca3af"; }');
      jsLines.push('        else if (age > 30) { opacity = 0.2; color = "#9ca3af"; }');
      jsLines.push('        else if (age > 15) { opacity = 0.9 - (age - 15) / 30; }');
      jsLines.push('      } else { opacity = 0.15; color = "#9ca3af"; }');
      jsLines.push('      html += "<line x1=\'" + lonToX(p0.lon) + "\' y1=\'" + latToY(p0.lat) + "\' x2=\'" + lonToX(p1.lon) + "\' y2=\'" + latToY(p1.lat) + "\' stroke=\'" + color + "\' stroke-width=\'3\' stroke-linecap=\'round\' opacity=\'" + opacity + "\'/>";');
      jsLines.push('    }');
      jsLines.push('  });');
      jsLines.push('  sessions.forEach(function(session, idx) {');
      jsLines.push('    var pos = getBoatPosition(session, playbackTime);');
      jsLines.push('    if (!pos) return;');
      jsLines.push('    var bx = lonToX(pos.lon), by = latToY(pos.lat);');
      jsLines.push('    var color = session.color;');
      jsLines.push('    var size = 16;');
      jsLines.push('    var hdgRad = pos.hdg * Math.PI / 180;');
      jsLines.push('    var cosH = Math.cos(hdgRad), sinH = Math.sin(hdgRad);');
      jsLines.push('    function rot(dx, dy) { return { x: bx + dx * cosH + dy * sinH, y: by + dx * sinH - dy * cosH }; }');
      jsLines.push('    var bow = rot(0, size * 0.9);');
      jsLines.push('    var sternL = rot(-size * 0.4, -size * 0.5);');
      jsLines.push('    var sternR = rot(size * 0.4, -size * 0.5);');
      jsLines.push('    var midL = rot(-size * 0.45, size * 0.1);');
      jsLines.push('    var midR = rot(size * 0.45, size * 0.1);');
      jsLines.push('    html += "<path d=\'M" + bow.x + "," + bow.y + " Q" + midR.x + "," + midR.y + " " + sternR.x + "," + sternR.y + " L" + sternL.x + "," + sternL.y + " Q" + midL.x + "," + midL.y + " " + bow.x + "," + bow.y + "\' fill=\'" + color + "\' stroke=\'white\' stroke-width=\'1.5\'/>";');
      jsLines.push('    var badge = rot(0, -size * 0.85);');
      jsLines.push('    html += "<circle cx=\'" + badge.x + "\' cy=\'" + badge.y + "\' r=\'7\' fill=\'white\' stroke=\'" + color + "\' stroke-width=\'1.5\'/>";');
      jsLines.push('    html += "<text x=\'" + badge.x + "\' y=\'" + (badge.y + 3) + "\' text-anchor=\'middle\' font-size=\'9\' fill=\'" + color + "\' font-weight=\'bold\'>" + (idx + 1) + "</text>";');
      jsLines.push('  });');
      jsLines.push('  svg.innerHTML = html;');
      jsLines.push('  var infoHtml = "";');
      jsLines.push('  sessions.forEach(function(session) {');
      jsLines.push('    var pos = getBoatPosition(session, playbackTime);');
      jsLines.push('    if (pos) { infoHtml += "<div class=\'boat-card\' style=\'border-color:" + session.color + "\'><b>" + session.name + "</b> " + pos.sog.toFixed(1) + " kn</div>"; }');
      jsLines.push('  });');
      jsLines.push('  document.getElementById("boat-info").innerHTML = infoHtml;');
      jsLines.push('  var pct = duration > 0 ? (playbackTime / duration) * 100 : 0;');
      jsLines.push('  document.getElementById("timeline-progress").style.width = pct + "%";');
      jsLines.push('  document.getElementById("timeline-handle").style.left = pct + "%";');
      jsLines.push('  var currentSec = Math.floor(playbackTime * 60);');
      jsLines.push('  var totalSec = Math.floor(duration * 60);');
      jsLines.push('  function fmt(s) { return Math.floor(s/60) + ":" + String(s%60).padStart(2,"0"); }');
      jsLines.push('  document.getElementById("time-display").textContent = fmt(currentSec) + " / " + fmt(totalSec);');
      jsLines.push('}');
      jsLines.push('function togglePlay() {');
      jsLines.push('  isPlaying = !isPlaying;');
      jsLines.push('  document.getElementById("play-btn").textContent = isPlaying ? "‚è∏" : "‚ñ∂";');
      jsLines.push('  if (isPlaying) { lastFrameTime = performance.now(); animationId = requestAnimationFrame(animate); }');
      jsLines.push('  else if (animationId) { cancelAnimationFrame(animationId); }');
      jsLines.push('}');
      jsLines.push('function animate(timestamp) {');
      jsLines.push('  if (!isPlaying) return;');
      jsLines.push('  var elapsed = (timestamp - lastFrameTime) / 1000;');
      jsLines.push('  lastFrameTime = timestamp;');
      jsLines.push('  playbackTime += (elapsed * speed) / 60;');
      jsLines.push('  if (playbackTime >= duration) { playbackTime = duration; isPlaying = false; document.getElementById("play-btn").textContent = "‚ñ∂"; }');
      jsLines.push('  render();');
      jsLines.push('  if (isPlaying) animationId = requestAnimationFrame(animate);');
      jsLines.push('}');
      jsLines.push('function seekTo(e) {');
      jsLines.push('  var rect = e.currentTarget.getBoundingClientRect();');
      jsLines.push('  var pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));');
      jsLines.push('  playbackTime = pct * duration;');
      jsLines.push('  render();');
      jsLines.push('}');
      jsLines.push('function setSpeed(s) {');
      jsLines.push('  speed = s;');
      jsLines.push('  document.querySelectorAll(".speed-btn").forEach(function(btn) {');
      jsLines.push('    btn.classList.toggle("active", parseInt(btn.dataset.speed) === s);');
      jsLines.push('  });');
      jsLines.push('}');
      jsLines.push('document.getElementById("legend").innerHTML = sessions.map(function(s) {');
      jsLines.push('  return "<div class=\'legend-item\'><div class=\'legend-color\' style=\'background:" + s.color + "\'></div>" + s.name + "</div>";');
      jsLines.push('}).join("");');
      jsLines.push('document.addEventListener("keydown", function(e) {');
      jsLines.push('  if (e.code === "Space") { e.preventDefault(); togglePlay(); }');
      jsLines.push('  else if (e.code === "ArrowRight") { playbackTime = Math.min(duration, playbackTime + 10/60); render(); }');
      jsLines.push('  else if (e.code === "ArrowLeft") { playbackTime = Math.max(0, playbackTime - 10/60); render(); }');
      jsLines.push('});');
      jsLines.push('var isDragging = false;');
      jsLines.push('document.getElementById("timeline-handle").addEventListener("mousedown", function() { isDragging = true; });');
      jsLines.push('document.addEventListener("mousemove", function(e) {');
      jsLines.push('  if (!isDragging) return;');
      jsLines.push('  var timeline = document.getElementById("timeline");');
      jsLines.push('  var rect = timeline.getBoundingClientRect();');
      jsLines.push('  var pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));');
      jsLines.push('  playbackTime = pct * duration;');
      jsLines.push('  render();');
      jsLines.push('});');
      jsLines.push('document.addEventListener("mouseup", function() { isDragging = false; });');
      jsLines.push('render();');
      
      const jsCode = jsLines.join('\n');

      // Build HTML as array of lines too
      const htmlLines = [];
      htmlLines.push('<!DOCTYPE html>');
      htmlLines.push('<html lang="en">');
      htmlLines.push('<head>');
      htmlLines.push('  <meta charset="UTF-8">');
      htmlLines.push('  <meta name="viewport" content="width=device-width, initial-scale=1.0">');
      htmlLines.push('  <title>Sailing Replay - ' + dateStr + '</title>');
      htmlLines.push('  <style>');
      htmlLines.push('    * { box-sizing: border-box; margin: 0; padding: 0; }');
      htmlLines.push('    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: #1e293b; color: white; height: 100vh; display: flex; flex-direction: column; }');
      htmlLines.push('    .header { padding: 12px 16px; background: #0f172a; display: flex; justify-content: space-between; align-items: center; }');
      htmlLines.push('    .header h1 { font-size: 16px; font-weight: 600; }');
      htmlLines.push('    .header .info { font-size: 12px; color: #94a3b8; }');
      htmlLines.push('    .map-container { flex: 1; position: relative; overflow: hidden; }');
      htmlLines.push('    .map-container svg { width: 100%; height: 100%; }');
      htmlLines.push('    .controls { padding: 12px 16px; background: #0f172a; display: flex; gap: 12px; align-items: center; }');
      htmlLines.push('    .play-btn { width: 40px; height: 40px; border-radius: 50%; border: none; background: #3b82f6; color: white; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; }');
      htmlLines.push('    .play-btn:hover { background: #2563eb; }');
      htmlLines.push('    .timeline { flex: 1; height: 8px; background: #334155; border-radius: 4px; cursor: pointer; position: relative; }');
      htmlLines.push('    .timeline-progress { height: 100%; background: #3b82f6; border-radius: 4px; pointer-events: none; }');
      htmlLines.push('    .timeline-handle { position: absolute; top: 50%; width: 16px; height: 16px; background: white; border-radius: 50%; transform: translate(-50%, -50%); cursor: grab; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }');
      htmlLines.push('    .time-display { font-size: 13px; color: #94a3b8; min-width: 80px; text-align: right; }');
      htmlLines.push('    .speed-btn { padding: 6px 12px; border: 1px solid #475569; background: transparent; color: #94a3b8; border-radius: 4px; cursor: pointer; font-size: 12px; }');
      htmlLines.push('    .speed-btn.active { background: #3b82f6; border-color: #3b82f6; color: white; }');
      htmlLines.push('    .legend { position: absolute; top: 12px; left: 12px; background: rgba(15,23,42,0.9); padding: 10px; border-radius: 8px; font-size: 11px; }');
      htmlLines.push('    .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }');
      htmlLines.push('    .legend-color { width: 12px; height: 12px; border-radius: 2px; }');
      htmlLines.push('    .boat-info { position: absolute; bottom: 70px; left: 12px; right: 12px; display: flex; gap: 8px; flex-wrap: wrap; }');
      htmlLines.push('    .boat-card { background: rgba(15,23,42,0.9); padding: 8px 12px; border-radius: 6px; font-size: 11px; border-left: 3px solid; }');
      htmlLines.push('  </style>');
      htmlLines.push('</head>');
      htmlLines.push('<body>');
      htmlLines.push('  <div class="header">');
      htmlLines.push('    <h1>‚õµ Sailing Replay</h1>');
      htmlLines.push('    <div class="info">' + dateStr + ' ‚Ä¢ ' + boatText + '</div>');
      htmlLines.push('  </div>');
      htmlLines.push('  <div class="map-container" id="map-container">');
      htmlLines.push('    <svg id="map-svg" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet"></svg>');
      htmlLines.push('    <div class="legend" id="legend"></div>');
      htmlLines.push('    <div class="boat-info" id="boat-info"></div>');
      htmlLines.push('  </div>');
      htmlLines.push('  <div class="controls">');
      htmlLines.push('    <button class="play-btn" id="play-btn" onclick="togglePlay()">‚ñ∂</button>');
      htmlLines.push('    <div class="timeline" id="timeline" onclick="seekTo(event)">');
      htmlLines.push('      <div class="timeline-progress" id="timeline-progress"></div>');
      htmlLines.push('      <div class="timeline-handle" id="timeline-handle"></div>');
      htmlLines.push('    </div>');
      htmlLines.push('    <div class="time-display" id="time-display">0:00 / 0:00</div>');
      htmlLines.push('    <button class="speed-btn" data-speed="1" onclick="setSpeed(1)">1x</button>');
      htmlLines.push('    <button class="speed-btn active" data-speed="8" onclick="setSpeed(8)">8x</button>');
      htmlLines.push('    <button class="speed-btn" data-speed="16" onclick="setSpeed(16)">16x</button>');
      htmlLines.push('  </div>');
      htmlLines.push('<script>');
      htmlLines.push(jsCode);
      htmlLines.push('</' + 'script>');
      htmlLines.push('</body>');
      htmlLines.push('</html>');
      
      return htmlLines.join('\n');
    }

    function toggleProjection() {
      const toggle = document.getElementById('proj-toggle');
      const slider = document.getElementById('proj-slider');
      const label = document.getElementById('proj-label');
      const track = toggle.nextElementSibling; // The track span
      
      if (toggle.checked) {
        mapProjection = 'geo';
        slider.style.transform = 'translateX(14px)';
        track.style.backgroundColor = '#7c3aed';
        label.textContent = 'Geo';
        label.title = 'Geographic projection: true distances, angles vary with wind direction';
      } else {
        mapProjection = 'compass';
        slider.style.transform = 'translateX(0)';
        track.style.backgroundColor = '#ccc';
        label.textContent = 'Compass';
        label.title = 'Compass projection: angles as sailed, consistent regardless of wind';
      }
      renderMap();
    }

    function fitMapToTrimmedTrack() {
      if (!DATA.track || DATA.track.length < 2) return;
      
      // Get actual map dimensions
      const mapEl = document.getElementById('map');
      const width = mapEl.clientWidth || parseInt(mapEl.getAttribute('width')) || 500;
      const height = mapEl.clientHeight || parseInt(mapEl.getAttribute('height')) || 500;
      const padding = 20;
      
      // Get overall map bounds (from original track)
      const trackForBounds = DATA.originalTrack || DATA.track;
      const allLats = trackForBounds.map(p => p.lat);
      const allLons = trackForBounds.map(p => p.lon);
      const minLat = Math.min(...allLats), maxLat = Math.max(...allLats);
      const minLon = Math.min(...allLons), maxLon = Math.max(...allLons);
      const latRange = maxLat - minLat || 0.001;
      const lonRange = maxLon - minLon || 0.001;
      
      // Apply latitude correction only in geo mode
      const centerLat = (minLat + maxLat) / 2;
      const latCorrection = mapProjection === 'geo' ? Math.cos(centerLat * Math.PI / 180) : 1;
      const lonRangeCorrected = lonRange * latCorrection;
      
      const scale = Math.min((width - 2*padding) / lonRangeCorrected, (height - 2*padding) / latRange) * 0.9;
      
      const lonToX = lon => padding + (lon - minLon) * latCorrection * scale + (width - 2*padding - lonRangeCorrected * scale) / 2;
      const latToY = lat => height - padding - (lat - minLat) * scale - (height - 2*padding - latRange * scale) / 2;
      
      // Get trimmed track bounds in SVG coordinates
      const trimXs = DATA.track.map(p => lonToX(p.lon));
      const trimYs = DATA.track.map(p => latToY(p.lat));
      const trimMinX = Math.min(...trimXs), trimMaxX = Math.max(...trimXs);
      const trimMinY = Math.min(...trimYs), trimMaxY = Math.max(...trimYs);
      const trimCenterX = (trimMinX + trimMaxX) / 2;
      const trimCenterY = (trimMinY + trimMaxY) / 2;
      const trimWidth = trimMaxX - trimMinX + 40;
      const trimHeight = trimMaxY - trimMinY + 40;
      
      // Calculate zoom to fit trimmed track with some padding
      mapZoom = Math.min(width / trimWidth, height / trimHeight, 10);
      mapZoom = Math.max(mapZoom, 1); // Don't zoom out beyond 1
      mapPanX = trimCenterX - width / 2;
      mapPanY = trimCenterY - height / 2;
      
      renderMap();
    }

    function zoomToLeg(legId) {
      const leg = DATA.legs.find(l => l.id === legId);
      if (!leg) return;
      
      const points = DATA.track.filter(p => p.t >= leg.start && p.t <= leg.end);
      if (points.length < 2) return;
      
      // Get actual map dimensions
      const mapEl = document.getElementById('map');
      const width = mapEl.clientWidth || parseInt(mapEl.getAttribute('width')) || 500;
      const height = mapEl.clientHeight || parseInt(mapEl.getAttribute('height')) || 500;
      const padding = 20;
      
      // Get overall map bounds - MUST match renderMap bounds calculation
      const trackForBounds = DATA.originalTrack || DATA.track;
      const allLats = trackForBounds.map(p => p.lat);
      const allLons = trackForBounds.map(p => p.lon);
      const minLat = Math.min(...allLats), maxLat = Math.max(...allLats);
      const minLon = Math.min(...allLons), maxLon = Math.max(...allLons);
      const latRange = maxLat - minLat || 0.001;
      const lonRange = maxLon - minLon || 0.001;
      
      // Apply latitude correction only in geo mode
      const centerLat = (minLat + maxLat) / 2;
      const latCorrection = mapProjection === 'geo' ? Math.cos(centerLat * Math.PI / 180) : 1;
      const lonRangeCorrected = lonRange * latCorrection;
      
      const scale = Math.min((width - 2*padding) / lonRangeCorrected, (height - 2*padding) / latRange) * 0.9;
      
      const lonToX = lon => padding + (lon - minLon) * latCorrection * scale + (width - 2*padding - lonRangeCorrected * scale) / 2;
      const latToY = lat => height - padding - (lat - minLat) * scale - (height - 2*padding - latRange * scale) / 2;
      
      // Get leg bounds in SVG coordinates
      const legXs = points.map(p => lonToX(p.lon));
      const legYs = points.map(p => latToY(p.lat));
      const legMinX = Math.min(...legXs), legMaxX = Math.max(...legXs);
      const legMinY = Math.min(...legYs), legMaxY = Math.max(...legYs);
      const legCenterX = (legMinX + legMaxX) / 2;
      const legCenterY = (legMinY + legMaxY) / 2;
      const legWidth = Math.max(legMaxX - legMinX + 60, 60);  // Minimum size with padding
      const legHeight = Math.max(legMaxY - legMinY + 60, 60);
      
      // Calculate zoom to fit leg with some padding
      // Cap zoom between 1 and 8 for reasonable viewing
      mapZoom = Math.min(width / legWidth, height / legHeight);
      mapZoom = Math.max(1, Math.min(mapZoom, 8));
      
      // Calculate pan to center the leg
      // The viewBox formula is: vbX = (width - vbWidth) / 2 + mapPanX
      // We want the center of viewBox to be at legCenterX
      // viewBox center = vbX + vbWidth/2 = (width - vbWidth)/2 + mapPanX + vbWidth/2
      //                = width/2 + mapPanX
      // So: legCenterX = width/2 + mapPanX  =>  mapPanX = legCenterX - width/2
      mapPanX = legCenterX - width / 2;
      mapPanY = legCenterY - height / 2;
      
      console.log('[zoomToLeg] legId:', legId, 'center:', legCenterX, legCenterY, 'zoom:', mapZoom, 'pan:', mapPanX, mapPanY);
      
      renderMap();
    }

    function renderMap() {
      const svg = document.getElementById('map');
      // Get actual map dimensions - use clientWidth for 100% width maps
      const width = svg.clientWidth || parseInt(svg.getAttribute('width')) || 500;
      const height = svg.clientHeight || parseInt(svg.getAttribute('height')) || 500;
      const padding = 20;

      // === RACE REPLAY MODE ===
      if (raceReplayMode) {
        const sessions = getReplaySessions();
        if (sessions.length === 0) return;
        
        // Get timeslot range for filtering
        const { startMs: timeslotStartMs, endMs: timeslotEndMs } = getTimeslotRangeMs();
        
        // Calculate bounds from track points within timeslot and trim range
        let allLats = [], allLons = [];
        sessions.forEach(session => {
          const sessionStartMs = session.startTimestampMs || 0;
          const trimStartMin = session.timelineStart || 0;
          const trimEndMin = session.timelineEnd || (session.fullDuration || session.s.dur);
          // Use originalTrack for consistent time values during trim drag
          const track = session.originalTrack || session.track;
          
          // Filter track points to those within trim range and timeslot
          track.forEach(p => {
            // Skip points outside current trim (t is relative to session start when using originalTrack)
            if (p.t < trimStartMin || p.t > trimEndMin) return;
            
            const pointAbsMs = sessionStartMs + p.t * 60000;
            if (pointAbsMs >= timeslotStartMs && pointAbsMs <= timeslotEndMs) {
              allLats.push(p.lat);
              allLons.push(p.lon);
            }
          });
        });
        
        // Fallback to full track if no points in timeslot
        if (allLats.length === 0) {
          sessions.forEach(session => {
            const track = session.originalTrack || session.track;
            allLats.push(...track.map(p => p.lat));
            allLons.push(...track.map(p => p.lon));
          });
        }
        
        const minLat = Math.min(...allLats), maxLat = Math.max(...allLats);
        const minLon = Math.min(...allLons), maxLon = Math.max(...allLons);
        const latRange = maxLat - minLat || 0.001;
        const lonRange = maxLon - minLon || 0.001;
        
        const centerLat = (minLat + maxLat) / 2;
        const latCorrection = mapProjection === 'geo' ? Math.cos(centerLat * Math.PI / 180) : 1;
        const lonRangeCorrected = lonRange * latCorrection;
        
        const scale = Math.min((width - 2*padding) / lonRangeCorrected, (height - 2*padding) / latRange) * 0.9;
        
        const lonToX = lon => padding + (lon - minLon) * latCorrection * scale + (width - 2*padding - lonRangeCorrected * scale) / 2;
        const latToY = lat => height - padding - (lat - minLat) * scale - (height - 2*padding - latRange * scale) / 2;
        const xToLon = x => minLon + (x - padding - (width - 2*padding - lonRangeCorrected * scale) / 2) / (latCorrection * scale);
        const yToLat = y => minLat + (height - padding - y - (height - 2*padding - latRange * scale) / 2) / scale;
        
        // ViewBox for zoom/pan
        const vbWidth = width / mapZoom;
        const vbHeight = height / mapZoom;
        const vbX = (width - vbWidth) / 2 + mapPanX;
        const vbY = (height - vbHeight) / 2 + mapPanY;
        svg.setAttribute('viewBox', `${vbX} ${vbY} ${vbWidth} ${vbHeight}`);
        
        const margin = 0.15;
        const visMinLon = xToLon(vbX - vbWidth * margin);
        const visMaxLon = xToLon(vbX + vbWidth * (1 + margin));
        const visMaxLat = yToLat(vbY - vbHeight * margin);
        const visMinLat = yToLat(vbY + vbHeight * (1 + margin));
        const isVisible = p => p.lon >= visMinLon && p.lon <= visMaxLon && p.lat >= visMinLat && p.lat <= visMaxLat;
        
        // Scale markers based on zoom level and map size
        // In fullscreen mode, markers should be larger proportional to map size
        const baseSizeScale = mapFullscreen ? (width / 500) : 1;
        const markerScale = baseSizeScale / mapZoom;
        
        // Stroke width for tracks - larger in fullscreen
        const trackStrokeWidth = mapFullscreen ? 5 : 3;
        const highlightStrokeWidth = mapFullscreen ? 16 : 10;
        
        let html = '';
        
        // Grid
        [0.25, 0.5, 0.75].forEach(f => {
          const y = padding + (height - 2*padding) * f;
          const x = padding + (width - 2*padding) * f;
          html += `<line x1="${padding}" y1="${y}" x2="${width-padding}" y2="${y}" stroke="#e5e7eb" stroke-dasharray="4" vector-effect="non-scaling-stroke"/>`;
          html += `<line x1="${x}" y1="${padding}" x2="${x}" y2="${height-padding}" stroke="#e5e7eb" stroke-dasharray="4" vector-effect="non-scaling-stroke"/>`;
        });
        
        // Draw VMG performance highlights for each leg (BEFORE track so highlights appear behind)
        // Red = worst 20% of leg duration, Green = best 20% of leg duration
        // Show for current leg and last 3 legs
        sessions.forEach((session, boatIdx) => {
          const track = session.track;
          const legs = session.legs;
          
          if (!track || !legs || track.length < 10) return;
          
          // Calculate session time offset for track-relative coordinates
          const sessionStart = session.timelineStart || 0;
          const sessionLocalTime = getSessionLocalTime(session, playbackTime);
          const trackPlaybackTime = sessionLocalTime - sessionStart;
          
          // Find current leg index
          let currentLegIdx = -1;
          for (let i = 0; i < legs.length; i++) {
            if (trackPlaybackTime >= legs[i].start && trackPlaybackTime <= legs[i].end) {
              currentLegIdx = i;
              break;
            }
          }
          
          // If not in any leg, find the most recent completed leg
          if (currentLegIdx === -1) {
            for (let i = legs.length - 1; i >= 0; i--) {
              if (trackPlaybackTime > legs[i].end) {
                currentLegIdx = i;
                break;
              }
            }
          }
          
          // Determine which legs to highlight (current and last 3)
          const legsToHighlight = new Set();
          if (currentLegIdx >= 0) {
            for (let i = currentLegIdx; i >= Math.max(0, currentLegIdx - 3); i--) {
              legsToHighlight.add(i);
            }
          }
          
          legs.forEach((leg, legIdx) => {
            // Only highlight selected legs
            if (!legsToHighlight.has(legIdx)) return;
            
            // Skip legs without valid VMG
            const legVmg = parseFloat(leg.vmg);
            if (isNaN(legVmg) || legVmg <= 0) return;
            
            // Use the leg's local wind direction (same as used to calculate leg.vmg)
            const legTwd = leg.localWind || session.s.twd || 0;
            
            // Get track points for this leg
            const legStart = leg.start;  // in minutes from track start
            const legEnd = leg.end;
            
            // Find track point indices for this leg and calculate VMG for each
            // Use ALL points for accurate segment calculation
            const legPoints = [];
            for (let i = 0; i < track.length; i++) {
              const pt = track[i];
              if (pt.t >= legStart && pt.t <= legEnd) {
                const hdg = pt.hdg || pt.cog || 0;
                const sog = pt.sog || 0;
                const twa = Math.abs(angleDiff(hdg, legTwd));
                const instVmg = Math.abs(sog * Math.cos(twa * Math.PI / 180));
                
                legPoints.push({
                  t: pt.t,
                  lat: pt.lat,
                  lon: pt.lon,
                  vmg: instVmg,
                  deviation: instVmg - legVmg
                });
              }
            }
            
            if (legPoints.length < 2) return;
            
            // Group into contiguous segments above/below average
            const segments = [];
            let currentSeg = null;
            
            for (let i = 0; i < legPoints.length; i++) {
              const pt = legPoints[i];
              const isAbove = pt.deviation > 0;
              
              if (!currentSeg || currentSeg.isAbove !== isAbove) {
                if (currentSeg && currentSeg.points.length > 0) segments.push(currentSeg);
                currentSeg = { isAbove, points: [pt], totalDeviation: pt.deviation };
              } else {
                currentSeg.points.push(pt);
                currentSeg.totalDeviation += pt.deviation;
              }
            }
            if (currentSeg && currentSeg.points.length > 0) segments.push(currentSeg);
            
            // Calculate duration and avg deviation for each segment
            segments.forEach(seg => {
              if (seg.points.length >= 2) {
                seg.duration = seg.points[seg.points.length - 1].t - seg.points[0].t;
              } else {
                seg.duration = 0;
              }
              seg.avgDeviation = seg.totalDeviation / seg.points.length;
            });
            
            // Separate and sort
            const aboveSegs = segments.filter(s => s.isAbove && s.duration > 0);
            const belowSegs = segments.filter(s => !s.isAbove && s.duration > 0);
            
            // Calculate total leg duration
            const totalLegDur = legPoints.length >= 2 ? legPoints[legPoints.length - 1].t - legPoints[0].t : 0;
            const maxHighlightDur = totalLegDur * 0.2; // 20% of leg duration for each color
            
            // Function to find best/worst portion of a segment within a duration limit
            const trimSegment = (seg, maxDur, findWorst) => {
              if (seg.duration <= maxDur) return seg;
              
              const pts = seg.points;
              if (pts.length < 2) return seg;
              
              let bestStart = 0;
              let bestEnd = 1;
              let bestAvg = findWorst ? Infinity : -Infinity;
              
              // Sliding window to find best/worst portion
              for (let i = 0; i < pts.length; i++) {
                let sum = 0;
                let count = 0;
                let j = i;
                
                while (j < pts.length && (pts[j].t - pts[i].t) <= maxDur) {
                  sum += pts[j].deviation;
                  count++;
                  j++;
                }
                
                if (count >= 2) {
                  const avg = sum / count;
                  if (findWorst ? avg < bestAvg : avg > bestAvg) {
                    bestAvg = avg;
                    bestStart = i;
                    bestEnd = j;
                  }
                }
              }
              
              const trimmedPts = pts.slice(bestStart, bestEnd);
              return {
                isAbove: seg.isAbove,
                points: trimmedPts,
                duration: trimmedPts.length >= 2 ? trimmedPts[trimmedPts.length - 1].t - trimmedPts[0].t : 0,
                avgDeviation: bestAvg
              };
            };
            
            // Best 20% of leg duration
            aboveSegs.sort((a, b) => b.avgDeviation - a.avgDeviation);
            const bestSegs = [];
            let bestDur = 0;
            for (const seg of aboveSegs) {
              if (bestDur >= maxHighlightDur) break;
              const remainingBudget = maxHighlightDur - bestDur;
              if (seg.duration <= remainingBudget) {
                bestSegs.push(seg);
                bestDur += seg.duration;
              } else if (remainingBudget > 0) {
                // Trim segment to fit remaining budget
                const trimmed = trimSegment(seg, remainingBudget, false);
                if (trimmed.duration > 0) {
                  bestSegs.push(trimmed);
                  bestDur += trimmed.duration;
                }
              }
            }
            
            // Worst 20% of leg duration
            belowSegs.sort((a, b) => a.avgDeviation - b.avgDeviation);
            const worstSegs = [];
            let worstDur = 0;
            for (const seg of belowSegs) {
              if (worstDur >= maxHighlightDur) break;
              const remainingBudget = maxHighlightDur - worstDur;
              if (seg.duration <= remainingBudget) {
                worstSegs.push(seg);
                worstDur += seg.duration;
              } else if (remainingBudget > 0) {
                // Trim segment to fit remaining budget
                const trimmed = trimSegment(seg, remainingBudget, true);
                if (trimmed.duration > 0) {
                  worstSegs.push(trimmed);
                  worstDur += trimmed.duration;
                }
              }
            }
            
            // Draw function with sampling to avoid overdraw
            // Render highlights 10 seconds ahead of boat position
            // Use higher resolution (more points) in fullscreen mode
            const trackPointTarget = mapFullscreen ? 2000 : 400;
            const baseStep = Math.max(1, Math.floor(track.length / trackPointTarget));
            const drawStep = Math.max(1, Math.round(baseStep / mapZoom));
            const highlightLookahead = 10 / 60; // 10 seconds in minutes
            
            // Get trim and timing info for filtering
            const sessionStartMs = session.startTimestampMs || 0;
            const trimStartMin = session.timelineStart || 0;
            const trimEndMin = session.timelineEnd || session.s.dur;
            const trimDuration = trimEndMin - trimStartMin;
            
            const drawSegments = (segs, color) => {
              segs.forEach(seg => {
                // Sample points within segment for drawing
                for (let i = drawStep; i < seg.points.length; i += drawStep) {
                  const p0 = seg.points[i - drawStep];
                  const p1 = seg.points[i];
                  
                  if (p1.t > trackPlaybackTime + highlightLookahead) continue;
                  
                  // Skip points outside trim range
                  if (p1.t < 0 || p1.t > trimDuration) continue;
                  
                  // Skip points outside timeslot
                  const p1AbsMs = sessionStartMs + (trimStartMin + p1.t) * 60000;
                  if (p1AbsMs < timeslotStartMs || p1AbsMs > timeslotEndMs) continue;
                  
                  const x0 = lonToX(p0.lon);
                  const y0 = latToY(p0.lat);
                  const x1 = lonToX(p1.lon);
                  const y1 = latToY(p1.lat);
                  
                  html += `<line x1="${x0}" y1="${y0}" x2="${x1}" y2="${y1}" stroke="${color}" stroke-width="${highlightStrokeWidth}" stroke-linecap="butt" opacity="0.3" vector-effect="non-scaling-stroke"/>`;
                }
              });
            };
            
            drawSegments(worstSegs, '#ef4444');
            drawSegments(bestSegs, '#22c55e');
          });
        });
        
        // Draw tracks for each session
        sessions.forEach((session, boatIdx) => {
          // Skip track if session is not active at current playback time
          if (!isSessionVisibleAtTime(session, playbackTime)) return;
          
          const color = BOAT_COLORS[boatIdx % BOAT_COLORS.length];
          // Use originalTrack (full session) with time filtering for smooth trim drag
          const track = session.originalTrack || session.track;
          // Use higher resolution (more points) in fullscreen mode
          const trackPointTarget = mapFullscreen ? 2000 : 400;
          const baseStep = Math.max(1, Math.floor(track.length / trackPointTarget));
          const adaptiveStep = Math.max(1, Math.round(baseStep / mapZoom));
          
          // Calculate playback time relative to this session's track using synchronized time
          const sessionLocalTime = getSessionLocalTime(session, playbackTime);
          const sessionStart = session.timelineStart || 0;
          const sessionEnd = session.timelineEnd || (session.fullDuration || session.s.dur);
          // When using originalTrack, trackPlaybackTime is relative to session start (not trim start)
          const trackPlaybackTime = sessionLocalTime;
          
          // Get session timing for timeslot filtering
          const sessionStartMs = session.startTimestampMs || 0;
          
          for (let i = adaptiveStep; i < track.length; i += adaptiveStep) {
            const p0 = track[i - adaptiveStep], p1 = track[i];
            if (!isVisible(p0) && !isVisible(p1)) continue;
            
            // Skip points outside current trim range (when using originalTrack, t is relative to session start)
            if (p1.t < sessionStart || p1.t > sessionEnd) continue;
            
            // Check if this segment is within timeslot (p1.t is relative to session start)
            const p1AbsMs = sessionStartMs + p1.t * 60000;
            if (p1AbsMs < timeslotStartMs || p1AbsMs > timeslotEndMs) continue;
            
            // Time-based fading using track-relative time
            // Configurable: recent window at full opacity, then fade to gray
            let opacity = 0.9;
            let strokeColor = color;
            const recentWindow = trackRecentWindow;  // Configurable full opacity period
            const fadeWindow = trackFadeWindow;      // Configurable grey out period
            let isGray = false;
            
            // Only apply fading if we have a valid session local time for this session
            if (sessionLocalTime >= sessionStart && trackPlaybackTime >= sessionStart) {
              const age = trackPlaybackTime - p1.t;
              
              if (p1.t > trackPlaybackTime) {
                // Future track - faded grey
                opacity = 0.15;
                strokeColor = '#9ca3af';
                isGray = true;
              } else if (age <= recentWindow) {
                // Recent track - full opacity
                opacity = 0.9;
              } else if (age <= fadeWindow) {
                // Fading period - gradient fade
                const fadePct = (age - recentWindow) / (fadeWindow - recentWindow);
                opacity = 0.9 - fadePct * 0.5;  // 0.9 to 0.4
              } else {
                // Older than fade window - grey
                opacity = 0.2;
                strokeColor = '#9ca3af';
                isGray = true;
              }
            } else if (sessionLocalTime < sessionStart) {
              // Session hasn't started yet - all future
              opacity = 0.15;
              strokeColor = '#9ca3af';
              isGray = true;
            }
            
            // Skip gray tracks if hide mode is enabled
            if (hideGrayTracks && isGray) continue;
            
            html += `<line x1="${lonToX(p0.lon)}" y1="${latToY(p0.lat)}" x2="${lonToX(p1.lon)}" y2="${latToY(p1.lat)}" stroke="${strokeColor}" stroke-width="${trackStrokeWidth}" stroke-linecap="round" opacity="${opacity}" vector-effect="non-scaling-stroke"/>`;
          }
        });
        
        // Draw racing marks (detected from leg transitions, cached)
        if (!cachedRacingMarks) {
          cachedRacingMarks = detectRacingMarks(sessions);
        }
        const marks = cachedRacingMarks;
        
        // Draw upmarks (windward marks) - orange circle
        marks.upmarks.forEach(mark => {
          const x = lonToX(mark.lon);
          const y = latToY(mark.lat);
          const radius = 5 * markerScale;
          
          html += `<circle cx="${x}" cy="${y}" r="${radius}" fill="#f97316" stroke="#c2410c" stroke-width="${1.5 * markerScale}" opacity="0.9"/>`;
          html += `<text x="${x}" y="${y + radius + 8 * markerScale}" text-anchor="middle" font-size="${7 * markerScale}" fill="#c2410c" font-weight="bold">UP</text>`;
        });
        
        // Draw downmarks (leeward marks) - teal circle
        marks.downmarks.forEach(mark => {
          const x = lonToX(mark.lon);
          const y = latToY(mark.lat);
          const radius = 5 * markerScale;
          
          html += `<circle cx="${x}" cy="${y}" r="${radius}" fill="#14b8a6" stroke="#0f766e" stroke-width="${1.5 * markerScale}" opacity="0.9"/>`;
          html += `<text x="${x}" y="${y - radius - 3 * markerScale}" text-anchor="middle" font-size="${7 * markerScale}" fill="#0f766e" font-weight="bold">DN</text>`;
        });
        
        // Draw boat markers at current playback position
        // Boat points according to magnetic heading (hdg) when available, falls back to COG
        if (playbackTime > 0) {
          sessions.forEach((session, boatIdx) => {
            // Skip boat if session is not active at current playback time (using telemetry-adjusted time)
            const mapTelemetryTime = getTelemetryDisplayTime();
            if (!isSessionVisibleAtTime(session, mapTelemetryTime)) return;
            
            const pos = getBoatPositionAtTime(session, mapTelemetryTime);
            if (!pos) return;
            
            const x = lonToX(pos.lon);
            const y = latToY(pos.lat);
            const color = BOAT_COLORS[boatIdx % BOAT_COLORS.length];
            const size = 16 * markerScale;
            
            // Determine stroke color based on VMG segment proximity (5 seconds window)
            let boatStrokeColor = 'white';
            const vmgProximityWindow = 5 / 60; // 5 seconds in minutes
            const sessionStart = session.timelineStart || 0;
            const sessionLocalTime = getSessionLocalTime(session, mapTelemetryTime);
            const currentTrackTime = sessionLocalTime - sessionStart;
            
            // Check VMG segments for this boat (need to find current and recent legs)
            const legs = session.legs;
            const track = session.track;
            if (legs && track && legs.length > 0) {
              // Find current leg index
              let currentLegIdx = -1;
              for (let li = 0; li < legs.length; li++) {
                if (currentTrackTime >= legs[li].start && currentTrackTime <= legs[li].end) {
                  currentLegIdx = li;
                  break;
                }
              }
              if (currentLegIdx === -1) {
                for (let li = legs.length - 1; li >= 0; li--) {
                  if (currentTrackTime > legs[li].end) {
                    currentLegIdx = li;
                    break;
                  }
                }
              }
              
              // Check current and last 3 legs for VMG segments
              if (currentLegIdx >= 0) {
                let inBestZone = false;
                let inWorstZone = false;
                
                for (let li = currentLegIdx; li >= Math.max(0, currentLegIdx - 3) && !inBestZone; li--) {
                  const leg = legs[li];
                  const legVmg = parseFloat(leg.vmg);
                  if (isNaN(legVmg) || legVmg <= 0) continue;
                  
                  const legTwd = leg.localWind || session.s.twd || 0;
                  
                  // Get leg points with VMG deviations
                  const legPoints = [];
                  for (let ti = 0; ti < track.length; ti++) {
                    const pt = track[ti];
                    if (pt.t >= leg.start && pt.t <= leg.end) {
                      const hdg = pt.hdg || pt.cog || 0;
                      const sog = pt.sog || 0;
                      const twa = Math.abs(angleDiff(hdg, legTwd));
                      const instVmg = Math.abs(sog * Math.cos(twa * Math.PI / 180));
                      legPoints.push({ t: pt.t, deviation: instVmg - legVmg });
                    }
                  }
                  
                  if (legPoints.length < 2) continue;
                  
                  // Build segments
                  const segments = [];
                  let currentSeg = null;
                  for (let pi = 0; pi < legPoints.length; pi++) {
                    const pt = legPoints[pi];
                    const isAbove = pt.deviation > 0;
                    if (!currentSeg || currentSeg.isAbove !== isAbove) {
                      if (currentSeg && currentSeg.points.length >= 2) {
                        currentSeg.duration = currentSeg.points[currentSeg.points.length - 1].t - currentSeg.points[0].t;
                        currentSeg.avgDeviation = currentSeg.points.reduce((s, p) => s + p.deviation, 0) / currentSeg.points.length;
                        segments.push(currentSeg);
                      }
                      currentSeg = { isAbove, points: [] };
                    }
                    currentSeg.points.push(pt);
                  }
                  if (currentSeg && currentSeg.points.length >= 2) {
                    currentSeg.duration = currentSeg.points[currentSeg.points.length - 1].t - currentSeg.points[0].t;
                    currentSeg.avgDeviation = currentSeg.points.reduce((s, p) => s + p.deviation, 0) / currentSeg.points.length;
                    segments.push(currentSeg);
                  }
                  
                  // Select best/worst 20%
                  const totalLegDur = legPoints[legPoints.length - 1].t - legPoints[0].t;
                  const maxHighlightDur = totalLegDur * 0.2;
                  
                  const aboveSegs = segments.filter(s => s.isAbove).sort((a, b) => b.avgDeviation - a.avgDeviation);
                  const belowSegs = segments.filter(s => !s.isAbove).sort((a, b) => a.avgDeviation - b.avgDeviation);
                  
                  let bestDur = 0;
                  for (const seg of aboveSegs) {
                    if (bestDur >= maxHighlightDur) break;
                    const startT = seg.points[0].t;
                    const endT = seg.points[seg.points.length - 1].t;
                    if (currentTrackTime >= (startT - vmgProximityWindow) && currentTrackTime <= (endT + vmgProximityWindow)) {
                      inBestZone = true;
                      break;
                    }
                    bestDur += seg.duration;
                  }
                  
                  if (!inBestZone) {
                    let worstDur = 0;
                    for (const seg of belowSegs) {
                      if (worstDur >= maxHighlightDur) break;
                      const startT = seg.points[0].t;
                      const endT = seg.points[seg.points.length - 1].t;
                      if (currentTrackTime >= (startT - vmgProximityWindow) && currentTrackTime <= (endT + vmgProximityWindow)) {
                        inWorstZone = true;
                        break;
                      }
                      worstDur += seg.duration;
                    }
                  }
                }
                
                if (inBestZone) {
                  boatStrokeColor = '#22c55e'; // Green
                } else if (inWorstZone) {
                  boatStrokeColor = '#ef4444'; // Red
                }
              }
            }
            
            // Draw boat shape - hull silhouette
            // Use magnetic heading (pos.hdg) for boat orientation
            // Heading: 0¬∞=North(up), 90¬∞=East(right), 180¬∞=South(down), 270¬∞=West(left)
            const hdgRad = pos.hdg * Math.PI / 180;
            const cosH = Math.cos(hdgRad);
            const sinH = Math.sin(hdgRad);
            
            // Rotate helper: dx=sideways(+starboard), dy=forward(+bow)
            const rot = (dx, dy) => ({
              x: x + dx * cosH + dy * sinH,
              y: y + dx * sinH - dy * cosH
            });
            
            // Hull shape (wide with pointed bow)
            const bow = rot(0, size * 0.9);           // Front tip
            const sternL = rot(-size * 0.4, -size * 0.5);  // Back left
            const sternR = rot(size * 0.4, -size * 0.5);   // Back right
            const midL = rot(-size * 0.45, size * 0.1);    // Mid left (widest)
            const midR = rot(size * 0.45, size * 0.1);     // Mid right (widest)
            
            // Hull path
            html += `<path d="M${bow.x},${bow.y} Q${midR.x},${midR.y} ${sternR.x},${sternR.y} L${sternL.x},${sternL.y} Q${midL.x},${midL.y} ${bow.x},${bow.y}" fill="${color}" stroke="${boatStrokeColor}" stroke-width="${1.5 * markerScale}" stroke-linejoin="round"/>`;
            
            // Boat number badge
            const badgePos = rot(0, -size * 0.85);
            html += `<circle cx="${badgePos.x}" cy="${badgePos.y}" r="${7 * markerScale}" fill="white" stroke="${color}" stroke-width="${1.5 * markerScale}"/>`;
            html += `<text x="${badgePos.x}" y="${badgePos.y + 3 * markerScale}" text-anchor="middle" font-size="${9 * markerScale}" fill="${color}" font-weight="bold">${boatIdx + 1}</text>`;
          });
        }
        
        svg.innerHTML = html;
        
        // Draw distance line between boats (after svg content is set, using overlay)
        // Calculate distances between boats (using telemetry-adjusted time)
        const distanceTelemetryTime = getTelemetryDisplayTime();
        const boatPositions = sessions.map((session, i) => ({
          pos: getBoatPositionAtTime(session, distanceTelemetryTime),
          color: BOAT_COLORS[i % BOAT_COLORS.length],
          symbol: getBoatSymbol(session.filename),
          idx: i
        })).filter(b => b.pos);
        
        // Track which boat is leading (for legend display)
        let leadingBoatIdx = -1; // -1 means no clear leader
        
        // Calculate time to mark for each boat FIRST (needed for leader determination)
        const timeToMarkData = [];
        if (cachedRacingMarks && playbackTime > 0) {
          const upmark = cachedRacingMarks.upmarks[0];
          const downmark = cachedRacingMarks.downmarks[0];
          
          sessions.forEach((session, boatIdx) => {
            // Skip boats not active at current playback time (using telemetry-adjusted time)
            if (!isSessionVisibleAtTime(session, distanceTelemetryTime)) {
              timeToMarkData.push({ timeToUp: null, timeToDn: null, isUpwind: null });
              return;
            }
            
            const leg = getCurrentLegAtTime(session, distanceTelemetryTime);
            const track = session.track;
            const sessionStart = session.timelineStart || 0;
            
            // Only skip if no track data
            if (!track || track.length === 0) {
              timeToMarkData.push({ timeToUp: null, timeToDn: null, isUpwind: null });
              return;
            }
            
            // Determine if boat is going upwind or downwind (null if no leg data)
            let isUpwind = null;
            if (leg) {
              isUpwind = leg.pos === 'upwind' || (leg.twa != null && leg.twa < 90);
            }
            
            // Convert playback time to session-local time (using telemetry-adjusted time)
            const sessionLocalTime = getSessionLocalTime(session, distanceTelemetryTime);
            // Track time is relative to trimmed start (same as sessionStart)
            const currentTrackTime = sessionLocalTime - sessionStart;
            
            // Find next arrival at upmark (scan forward for closest approach)
            let timeToUp = null;
            if (upmark) {
              let minDist = Infinity;
              let minDistTrackTime = null;
              let passedMin = false;
              
              for (let i = 0; i < track.length; i++) {
                const pt = track[i];
                if (pt.t <= currentTrackTime) continue;
                
                const dist = haversineDistance(pt.lat, pt.lon, upmark.lat, upmark.lon);
                
                if (dist < minDist) {
                  minDist = dist;
                  minDistTrackTime = pt.t;
                  passedMin = false;
                } else if (minDist < 40 && !passedMin) {
                  passedMin = true;
                  break;
                }
              }
              
              if (minDist <= 50 && minDistTrackTime != null) {
                timeToUp = (minDistTrackTime - currentTrackTime) * 60;
              }
            }
            
            // Find next arrival at downmark
            let timeToDn = null;
            if (downmark) {
              let minDist = Infinity;
              let minDistTrackTime = null;
              let passedMin = false;
              
              for (let i = 0; i < track.length; i++) {
                const pt = track[i];
                if (pt.t <= currentTrackTime) continue;
                
                const dist = haversineDistance(pt.lat, pt.lon, downmark.lat, downmark.lon);
                
                if (dist < minDist) {
                  minDist = dist;
                  minDistTrackTime = pt.t;
                  passedMin = false;
                } else if (minDist < 40 && !passedMin) {
                  passedMin = true;
                  break;
                }
              }
              
              if (minDist <= 50 && minDistTrackTime != null) {
                timeToDn = (minDistTrackTime - currentTrackTime) * 60;
              }
            }
            
            timeToMarkData.push({ timeToUp, timeToDn, isUpwind });
          });
        }
        
        // Draw sailing route between first two boats
        if (boatPositions.length >= 2 && playbackTime > 0) {
          const b1 = boatPositions[0];
          const b2 = boatPositions[1];
          
          // Get sailing route calculations for both directions
          const route1to2 = calculateSailingRoute(b1.pos, b2.pos, sessions, 0);
          const route2to1 = calculateSailingRoute(b1.pos, b2.pos, sessions, 1);
          
          // Draw route 1‚Üí2 (blue)
          if (route1to2 && route1to2.waypoints.length >= 2) {
            let pathD = '';
            route1to2.waypoints.forEach((wp, i) => {
              const x = lonToX(wp.lon);
              const y = latToY(wp.lat);
              pathD += (i === 0 ? 'M' : 'L') + `${x},${y}`;
            });
            
            const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            pathEl.setAttribute('d', pathD);
            pathEl.setAttribute('stroke', '#3b82f6'); // Blue
            pathEl.setAttribute('stroke-width', 2 * markerScale);
            pathEl.setAttribute('stroke-dasharray', `${6 * markerScale},${4 * markerScale}`);
            pathEl.setAttribute('fill', 'none');
            pathEl.setAttribute('opacity', '0.8');
            svg.appendChild(pathEl);
          }
          
          // Draw route 2‚Üí1 (green)
          if (route2to1 && route2to1.waypoints.length >= 2) {
            let pathD = '';
            route2to1.waypoints.forEach((wp, i) => {
              const x = lonToX(wp.lon);
              const y = latToY(wp.lat);
              pathD += (i === 0 ? 'M' : 'L') + `${x},${y}`;
            });
            
            const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            pathEl.setAttribute('d', pathD);
            pathEl.setAttribute('stroke', '#22c55e'); // Green
            pathEl.setAttribute('stroke-width', 2 * markerScale);
            pathEl.setAttribute('stroke-dasharray', `${6 * markerScale},${4 * markerScale}`);
            pathEl.setAttribute('fill', 'none');
            pathEl.setAttribute('opacity', '0.8');
            svg.appendChild(pathEl);
          }
          
          // Use route1to2 as reference for label positioning
          const route = route1to2;
          if (route && route.waypoints.length >= 2) {
            // Add distance/time label offset to the side of the route
            // Calculate perpendicular offset from the line between boats
            const x1 = lonToX(route.waypoints[0].lon);
            const y1 = latToY(route.waypoints[0].lat);
            const x2 = lonToX(route.waypoints[route.waypoints.length - 1].lon);
            const y2 = latToY(route.waypoints[route.waypoints.length - 1].lat);
            
            // Midpoint of direct line
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            
            // Perpendicular direction (rotate 90 degrees)
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.sqrt(dx * dx + dy * dy);
            const perpX = len > 0 ? -dy / len : 0;
            const perpY = len > 0 ? dx / len : -1;
            
            // Offset distance (away from boats)
            const offsetDist = 55 * markerScale;
            const labelX = midX + perpX * offsetDist;
            const labelY = midY + perpY * offsetDist;
            
            const formatDist = (m) => m >= 1000 ? `${(m/1000).toFixed(1)}km` : `${Math.round(m)}m`;
            const formatTime = (sec) => {
              if (sec > 3600) return '>1h';
              if (sec > 600) return `${Math.round(sec/60)}m`;
              if (sec >= 60) return `${Math.floor(sec/60)}:${String(Math.round(sec%60)).padStart(2,'0')}`;
              return `${Math.round(sec)}s`;
            };
            
            // Apply 10-second rolling window to sailing times (separate for each route)
            const smoothedTime = getSmoothedSailingTime(route.time, '1to2');
            const smoothedTime2to1 = route2to1 ? getSmoothedSailingTime(route2to1.time, '2to1') : 0;
            
            // Determine leader based on time to mark when boats on same course
            let catchingTime = 0;
            const ttm0 = timeToMarkData[0];
            const ttm1 = timeToMarkData[1];
            
            if (smoothedTime > 0 && smoothedTime2to1 > 0) {
              // Check if both boats are on same course
              if (ttm0 && ttm1 && ttm0.isUpwind !== null && ttm1.isUpwind !== null && ttm0.isUpwind === ttm1.isUpwind) {
                // Same course - use time-to-mark to determine leader
                const time0 = ttm0.isUpwind ? ttm0.timeToUp : ttm0.timeToDn;
                const time1 = ttm1.isUpwind ? ttm1.timeToUp : ttm1.timeToDn;
                
                if (time0 != null && time1 != null && time0 > 0 && time1 > 0) {
                  if (time0 < time1) {
                    // Boat 0 reaches mark first - it's leading, boat 1 catching up
                    leadingBoatIdx = 0;
                    catchingTime = smoothedTime2to1; // Time for boat 1 to catch boat 0
                  } else {
                    // Boat 1 reaches mark first - it's leading, boat 0 catching up
                    leadingBoatIdx = 1;
                    catchingTime = smoothedTime; // Time for boat 0 to catch boat 1
                  }
                }
              }
              
              // If different courses or no mark data, use previous leader or sailing time
              if (catchingTime === 0) {
                if (leadingBoatIdx === 0) {
                  catchingTime = smoothedTime2to1;
                } else if (leadingBoatIdx === 1) {
                  catchingTime = smoothedTime;
                } else {
                  // No previous leader - use sailing time comparison
                  catchingTime = Math.min(smoothedTime, smoothedTime2to1);
                  leadingBoatIdx = smoothedTime < smoothedTime2to1 ? 1 : 0;
                }
              }
            }
            
            // Simplified label: "Distance: 10m, 2:45"
            const labelText = catchingTime > 0 
              ? `Distance: ${formatDist(route.directDist)}, ${formatTime(catchingTime)}`
              : `Distance: ${formatDist(route.directDist)}`;
            
            // Calculate label dimensions
            const lineHeight = 10 * markerScale;
            const labelWidth = 120 * markerScale;
            const labelHeight = (lineHeight + 8) * markerScale;
            const labelPadding = 4 * markerScale;
            
            // Background for label
            const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            labelBg.setAttribute('x', labelX - labelWidth/2);
            labelBg.setAttribute('y', labelY - labelHeight/2);
            labelBg.setAttribute('width', labelWidth);
            labelBg.setAttribute('height', labelHeight);
            labelBg.setAttribute('rx', 3 * markerScale);
            labelBg.setAttribute('fill', 'rgba(0,0,0,0.85)');
            svg.appendChild(labelBg);
            
            // Single line: Distance and time
            const yPos = labelY + 3 * markerScale;
            const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text1.setAttribute('x', labelX);
            text1.setAttribute('y', yPos);
            text1.setAttribute('text-anchor', 'middle');
            text1.setAttribute('font-size', 9 * markerScale);
            text1.setAttribute('fill', '#f59e0b');
            text1.setAttribute('font-weight', 'bold');
            text1.textContent = labelText;
            svg.appendChild(text1);
          }
        }
        
        // Render boat legend with live data (2-sec smoothed) plus leg info
        let legendHtml = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;"><span style="font-size:10px;color:#6b7280;">Boats:</span><button onclick="saveMapScreenshot()" style="font-size:9px;padding:2px 6px;background:#3b82f6;color:white;border:none;border-radius:3px;cursor:pointer;" title="Export map animation">üé¨ Save</button></div>';
        sessions.forEach((session, boatIdx) => {
          // Skip boats not active at current playback time
          if (!isSessionVisibleAtTime(session, playbackTime)) return;
          
          const color = BOAT_COLORS[boatIdx % BOAT_COLORS.length];
          const boatSymbol = getBoatSymbol(session.filename);
          const smoothed = getSmoothedTelemetry(session, playbackTime, 2);
          let leg = getCurrentLegAtTime(session, playbackTime);
          let isStale = false;
          
          // If no current leg, use last valid leg for this boat (grayed out)
          if (!leg && lastValidMapLegs[boatIdx]) {
            leg = lastValidMapLegs[boatIdx];
            isStale = true;
          }
          
          // Update last valid leg if we have a current one
          if (leg && !isStale) {
            lastValidMapLegs[boatIdx] = leg;
          }
          
          let dataHtml = '';
          if (smoothed) {
            const sogVmg = `${(smoothed.sog || 0).toFixed(1)}/${(smoothed.vmg || 0).toFixed(1)}`;
            const hdg = `${Math.round(smoothed.hdg || 0)}¬∞`;
            dataHtml = `<span style="font-size:11px;color:#6b7280;">${sogVmg} ${hdg}</span>`;
          } else {
            dataHtml = `<span style="font-size:11px;color:#9ca3af;">‚Äî</span>`;
          }
          
          // Leg info: SPD/VMG + HDG + next maneuver (same data source as leg comparison widget)
          let legHtml = '';
          if (leg) {
            const legSpd = leg.speed != null ? leg.speed : '-';
            const legVmg = leg.vmg != null ? leg.vmg : '-';
            const legHdg = leg.hdg != null ? leg.hdg + '¬∞' : '-';
            
            let nextManeuver = '';
            if (leg.next_maneuver) {
              const type = leg.next_maneuver.type === 'tack' ? 'T' : 'G';
              const angle = leg.next_maneuver.angle ? Math.round(leg.next_maneuver.angle) + '¬∞' : '-';
              nextManeuver = ` ${type}${angle}`;
            }
            
            const staleStyle = isStale ? 'opacity:0.5;' : '';
            legHtml = `<span style="font-size:10px;color:#9ca3af;${staleStyle}">Leg: ${legSpd}/${legVmg} ${legHdg}${nextManeuver}</span>`;
          }
          
          // Time to mark info - show time to relevant mark based on current direction
          let timeToMarkHtml = '';
          const ttmData = timeToMarkData[boatIdx];
          if (ttmData) {
            const formatTime = (sec) => {
              if (sec > 3600) return '>1h';
              if (sec > 600) return `${Math.round(sec/60)}m`;
              if (sec >= 60) return `${Math.floor(sec/60)}:${String(Math.round(sec%60)).padStart(2,'0')}`;
              return `${Math.round(sec)}s`;
            };
            
            // Determine which mark to show based on direction or nearest
            let showUpmark = ttmData.isUpwind;
            if (ttmData.isUpwind === null) {
              // No leg data - show whichever mark is closer (smaller time)
              if (ttmData.timeToUp != null && ttmData.timeToDn != null) {
                showUpmark = ttmData.timeToUp <= ttmData.timeToDn;
              } else if (ttmData.timeToUp != null) {
                showUpmark = true;
              } else if (ttmData.timeToDn != null) {
                showUpmark = false;
              }
            }
            
            const time = showUpmark ? ttmData.timeToUp : ttmData.timeToDn;
            if (time != null && time > 0) {
              const markLabel = showUpmark ? 'Up mark in' : 'Down mark in';
              timeToMarkHtml = `<span style="font-size:10px;color:#9ca3af;">${markLabel}: ${formatTime(time)}</span>`;
            }
          }
          
          legendHtml += `
            <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
              <div style="width:18px;height:18px;background:${color};border-radius:50%;display:flex;align-items:center;justify-content:center;color:white;font-size:11px;font-weight:bold;">${boatIdx+1}</div>
              <div style="display:flex;flex-direction:column;line-height:1.2;">
                <span style="font-weight:600;font-size:12px;">${boatSymbol}</span>
                ${dataHtml}
                ${legHtml ? `<div style="margin-top:1px;">${legHtml}</div>` : ''}
                ${timeToMarkHtml ? `<div style="margin-top:1px;">${timeToMarkHtml}</div>` : ''}
              </div>
            </div>`;
        });
        
        document.getElementById('map-legend').innerHTML = legendHtml;
        
        // Wind indicator (use first session's wind)
        const windDeg = sessions[0].s.twd;
        document.getElementById('map-wind').innerHTML = `
          <div style="font-size:9px;color:#666;margin-bottom:2px;">Wind ${windDeg}¬∞</div>
          <svg width="40" height="40" viewBox="0 0 40 40">
            <g transform="rotate(${windDeg}, 20, 20)">
              <line x1="20" y1="8" x2="20" y2="32" stroke="#666" stroke-width="2"/>
              <polygon points="20,32 15,24 25,24" fill="#666"/>
            </g>
          </svg>
        `;
        
        document.getElementById('map-zoom-indicator').textContent = mapZoom !== 1 ? `${mapZoom.toFixed(1)}x` : '';
        
        // No leg click handlers in race replay mode
        return;
      }
      
      // === NORMAL MODE ===
      // Use original track for bounds calculation if available
      const trackForBounds = DATA.originalTrack || DATA.track;
      
      // Calculate bounds
      const lats = trackForBounds.map(p => p.lat);
      const lons = trackForBounds.map(p => p.lon);
      const minLat = Math.min(...lats), maxLat = Math.max(...lats);
      const minLon = Math.min(...lons), maxLon = Math.max(...lons);
      const latRange = maxLat - minLat || 0.001;
      const lonRange = maxLon - minLon || 0.001;
      
      // Apply latitude correction only in geo mode
      // Compass mode: angles appear as true compass values (consistent regardless of wind)
      // Geo mode: geographically accurate, but angles vary with wind direction
      const centerLat = (minLat + maxLat) / 2;
      const latCorrection = mapProjection === 'geo' ? Math.cos(centerLat * Math.PI / 180) : 1;
      const lonRangeCorrected = lonRange * latCorrection;
      
      const scale = Math.min((width - 2*padding) / lonRangeCorrected, (height - 2*padding) / latRange) * 0.9;

      const lonToX = lon => padding + (lon - minLon) * latCorrection * scale + (width - 2*padding - lonRangeCorrected * scale) / 2;
      const latToY = lat => height - padding - (lat - minLat) * scale - (height - 2*padding - latRange * scale) / 2;
      const xToLon = x => minLon + (x - padding - (width - 2*padding - lonRangeCorrected * scale) / 2) / (latCorrection * scale);
      const yToLat = y => minLat + (height - padding - y - (height - 2*padding - latRange * scale) / 2) / scale;

      // Store for later use
      DATA._mapTransform = { lonToX, latToY };

      // Calculate viewBox for zoom/pan
      const vbWidth = width / mapZoom;
      const vbHeight = height / mapZoom;
      const vbX = (width - vbWidth) / 2 + mapPanX;
      const vbY = (height - vbHeight) / 2 + mapPanY;
      svg.setAttribute('viewBox', `${vbX} ${vbY} ${vbWidth} ${vbHeight}`);

      // Calculate visible lat/lon bounds (with margin)
      const margin = 0.15;
      const visMinLon = xToLon(vbX - vbWidth * margin);
      const visMaxLon = xToLon(vbX + vbWidth * (1 + margin));
      const visMaxLat = yToLat(vbY - vbHeight * margin);
      const visMinLat = yToLat(vbY + vbHeight * (1 + margin));

      // Helper: check if point is in visible area
      const isVisible = p => p.lon >= visMinLon && p.lon <= visMaxLon && p.lat >= visMinLat && p.lat <= visMaxLat;

      // Adaptive step: show more detail when zoomed in
      // At zoom 1x: step to get ~400 visible lines (or 2000 in fullscreen)
      // At zoom 30x: step=1 (full resolution)
      const trackPointTarget = mapFullscreen ? 2000 : 400;
      const baseStep = Math.max(1, Math.floor(DATA.track.length / trackPointTarget));
      const adaptiveStep = Math.max(1, Math.round(baseStep / mapZoom));

      const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };

      // Build SVG
      let html = '';
      
      // Grid
      [0.25, 0.5, 0.75].forEach(f => {
        const y = padding + (height - 2*padding) * f;
        const x = padding + (width - 2*padding) * f;
        html += `<line x1="${padding}" y1="${y}" x2="${width-padding}" y2="${y}" stroke="#e5e7eb" stroke-dasharray="4" vector-effect="non-scaling-stroke"/>`;
        html += `<line x1="${x}" y1="${padding}" x2="${x}" y2="${height-padding}" stroke="#e5e7eb" stroke-dasharray="4" vector-effect="non-scaling-stroke"/>`;
      });

      // Get timeline filter info
      const fullDuration = DATA.fullDuration || DATA.s.dur;
      const timelineStart = DATA.timelineStart || 0;
      const timelineEnd = DATA.timelineEnd || fullDuration;
      const hasFilter = timelineStart > 0.1 || timelineEnd < fullDuration - 0.1;
      
      // Get visible time range using unified helper
      const visibleRange = getVisibleTimeRangeMs();
      const hasAnalysisFilter = analysisRangeStartMs !== null && analysisRangeEndMs !== null;
      const useTimeslotFilter = (ALL_SESSIONS.length > 1 || isIframeMode) && !raceReplayMode && hasAnalysisFilter;

      // Draw excluded (grey) portions of track if filter is active
      // In aligned mode, completely skip rendering outside timeslot overlap
      if (hasFilter && DATA.originalTrack && !useTimeslotFilter) {
        for (let i = adaptiveStep; i < DATA.originalTrack.length; i += adaptiveStep) {
          const p0 = DATA.originalTrack[i - adaptiveStep], p1 = DATA.originalTrack[i];
          // Skip if neither point visible
          if (!isVisible(p0) && !isVisible(p1)) continue;
          const inExcluded = p0.t < timelineStart || p0.t > timelineEnd || p1.t < timelineStart || p1.t > timelineEnd;
          if (inExcluded) {
            html += `<line x1="${lonToX(p0.lon)}" y1="${latToY(p0.lat)}" x2="${lonToX(p1.lon)}" y2="${latToY(p1.lat)}" stroke="#9ca3af" stroke-width="3" stroke-linecap="round" opacity="0.5" vector-effect="non-scaling-stroke"/>`;
          }
        }
      }

      // Base track (included portion) with viewport culling and adaptive step
      const sessionStartMs = DATA.startTimestampMs || 0;
      const trimStartMin = DATA.timelineStart || 0;
      
      for (let i = adaptiveStep; i < DATA.track.length; i += adaptiveStep) {
        const p0 = DATA.track[i - adaptiveStep], p1 = DATA.track[i];
        if (!isVisible(p0) && !isVisible(p1)) continue;
        
        // In aligned mode, skip lines where both points are outside visible range
        if (useTimeslotFilter && visibleRange) {
          const p0AbsMs = trackPointToAbsoluteMs(p0.t);
          const p1AbsMs = trackPointToAbsoluteMs(p1.t);
          
          // Skip if both points are before or both after the visible range
          const bothBefore = p0AbsMs < visibleRange.startMs && p1AbsMs < visibleRange.startMs;
          const bothAfter = p0AbsMs > visibleRange.endMs && p1AbsMs > visibleRange.endMs;
          if (bothBefore || bothAfter) continue;
        }
        
        html += `<line x1="${lonToX(p0.lon)}" y1="${latToY(p0.lat)}" x2="${lonToX(p1.lon)}" y2="${latToY(p1.lat)}" stroke="#d1d5db" stroke-width="2" stroke-linecap="round" vector-effect="non-scaling-stroke"/>`;
      }

      // Leg segments with viewport culling
      DATA.legs.forEach(leg => {
        const isSelected = selectedLeg?.id === leg.id;
        const color = isSelected ? '#a855f7' : posColors[leg.pos];
        const strokeWidth = isSelected ? 6 : 4;

        // Get points for this leg with adaptive step
        let prevPoint = null;
        let legHasVisiblePoints = false;
        
        for (let i = 0; i < DATA.track.length; i += adaptiveStep) {
          const p = DATA.track[i];
          if (p.t < leg.start || p.t > leg.end) {
            prevPoint = null;
            continue;
          }
          
          // In aligned mode, skip points outside visible range
          if (useTimeslotFilter && visibleRange) {
            const pAbsMs = trackPointToAbsoluteMs(p.t);
            if (pAbsMs < visibleRange.startMs || pAbsMs > visibleRange.endMs) {
              prevPoint = null;
              continue;
            }
          }
          
          if (prevPoint) {
            const visible = isVisible(p) || isVisible(prevPoint);
            if (visible) {
              legHasVisiblePoints = true;
              // Glow for selected
              if (isSelected) {
                html += `<line x1="${lonToX(prevPoint.lon)}" y1="${latToY(prevPoint.lat)}" x2="${lonToX(p.lon)}" y2="${latToY(p.lat)}" stroke="#c084fc" stroke-width="12" stroke-linecap="round" opacity="0.4" vector-effect="non-scaling-stroke"/>`;
              }
              html += `<line x1="${lonToX(prevPoint.lon)}" y1="${latToY(prevPoint.lat)}" x2="${lonToX(p.lon)}" y2="${latToY(p.lat)}" stroke="${color}" stroke-width="${strokeWidth}" stroke-linecap="round" class="leg-segment" data-leg="${leg.id}" style="cursor:pointer" vector-effect="non-scaling-stroke"/>`;
            }
          }
          prevPoint = p;
        }
        
        // Add hit area for leg (one transparent path for click detection)
        if (legHasVisiblePoints) {
          const legPoints = DATA.track.filter(p => p.t >= leg.start && p.t <= leg.end);
          if (legPoints.length >= 2) {
            const pathD = 'M' + legPoints.filter((_, i) => i % adaptiveStep === 0 || i === legPoints.length - 1)
              .map(p => `${lonToX(p.lon)} ${latToY(p.lat)}`).join('L');
            html += `<path d="${pathD}" fill="none" stroke="transparent" stroke-width="15" class="leg-hit" data-leg="${leg.id}" style="cursor:pointer" vector-effect="non-scaling-stroke"/>`;
          }
        }
      });

      // Render outside-trim selected leg from originalTrack
      if (selectedLeg?.isOutsideTrim && DATA.originalTrack) {
        const timeOffset = DATA.timelineStart || 0;
        const legStartTime = selectedLeg.start + timeOffset;
        const legEndTime = selectedLeg.end + timeOffset;
        
        let prevPoint = null;
        for (let i = 0; i < DATA.originalTrack.length; i += adaptiveStep) {
          const p = DATA.originalTrack[i];
          if (p.t < legStartTime || p.t > legEndTime) {
            prevPoint = null;
            continue;
          }
          
          if (prevPoint && (isVisible(p) || isVisible(prevPoint))) {
            // Glow
            html += `<line x1="${lonToX(prevPoint.lon)}" y1="${latToY(prevPoint.lat)}" x2="${lonToX(p.lon)}" y2="${latToY(p.lat)}" stroke="#c084fc" stroke-width="12" stroke-linecap="round" opacity="0.4" vector-effect="non-scaling-stroke"/>`;
            // Line
            html += `<line x1="${lonToX(prevPoint.lon)}" y1="${latToY(prevPoint.lat)}" x2="${lonToX(p.lon)}" y2="${latToY(p.lat)}" stroke="#a855f7" stroke-width="6" stroke-linecap="round" vector-effect="non-scaling-stroke"/>`;
          }
          prevPoint = p;
        }
      }

      // Start/End markers - scale radius inversely with zoom to keep consistent size
      const markerScale = 1 / mapZoom;
      if (selectedLeg) {
        html += `<circle cx="${lonToX(selectedLeg.startLon)}" cy="${latToY(selectedLeg.startLat)}" r="${8 * markerScale}" fill="#22c55e" stroke="white" stroke-width="${3 * markerScale}"/>`;
        html += `<text x="${lonToX(selectedLeg.startLon)}" y="${latToY(selectedLeg.startLat) + 4 * markerScale}" text-anchor="middle" font-size="${10 * markerScale}" fill="white" font-weight="bold">S</text>`;
        html += `<circle cx="${lonToX(selectedLeg.endLon)}" cy="${latToY(selectedLeg.endLat)}" r="${8 * markerScale}" fill="#ef4444" stroke="white" stroke-width="${3 * markerScale}"/>`;
        html += `<text x="${lonToX(selectedLeg.endLon)}" y="${latToY(selectedLeg.endLat) + 4 * markerScale}" text-anchor="middle" font-size="${10 * markerScale}" fill="white" font-weight="bold">E</text>`;
      } else {
        html += `<circle cx="${lonToX(DATA.track[0].lon)}" cy="${latToY(DATA.track[0].lat)}" r="${5 * markerScale}" fill="#22c55e" stroke="white" stroke-width="${2 * markerScale}"/>`;
        html += `<circle cx="${lonToX(DATA.track[DATA.track.length-1].lon)}" cy="${latToY(DATA.track[DATA.track.length-1].lat)}" r="${5 * markerScale}" fill="#ef4444" stroke="white" stroke-width="${2 * markerScale}"/>`;
      }
      
      svg.innerHTML = html;

      // Render legend in HTML overlay (not affected by zoom)
      let legendHtml = `
        <div style="display:flex;align-items:center;gap:4px;margin-bottom:4px;"><div style="width:10px;height:10px;background:#22c55e;border-radius:2px;"></div><span>Up</span></div>
        <div style="display:flex;align-items:center;gap:4px;margin-bottom:4px;"><div style="width:10px;height:10px;background:#3b82f6;border-radius:2px;"></div><span>Reach</span></div>
        <div style="display:flex;align-items:center;gap:4px;margin-bottom:4px;"><div style="width:10px;height:10px;background:#f59e0b;border-radius:2px;"></div><span>Down</span></div>
      `;
      if (selectedLeg) {
        legendHtml += `<div style="display:flex;align-items:center;gap:4px;"><div style="width:10px;height:10px;background:#a855f7;border-radius:2px;"></div><span>Leg #${selectedLeg.id}</span></div>`;
      }
      document.getElementById('map-legend').innerHTML = legendHtml;

      // Render wind indicator in HTML overlay
      const windHtml = `
        <div style="font-size:9px;color:#666;margin-bottom:2px;">Wind ${DATA.s.twd}¬∞</div>
        <svg width="50" height="50" style="display:block;">
          <line x1="25" y1="10" x2="25" y2="40" stroke="#666" stroke-width="2"/>
          <polygon points="25,40 20,32 30,32" fill="#666"/>
          <text x="25" y="48" text-anchor="middle" font-size="8" fill="#666">‚Üì</text>
        </svg>
      `;
      // Create rotated wind arrow - points in direction wind is GOING TO
      // TWD = where wind comes FROM, so wind goes to (TWD + 180)¬∞
      // Base SVG arrow points down (south=180¬∞). SVG rotate is clockwise.
      // To point at compass direction D: rotate = (D + 180) % 360
      // To point where wind goes: rotate = ((TWD+180) + 180) % 360 = TWD
      const windDeg = DATA.s.twd;
      document.getElementById('map-wind').innerHTML = `
        <div style="font-size:9px;color:#666;margin-bottom:2px;">Wind ${DATA.s.twd}¬∞</div>
        <svg width="40" height="40" viewBox="0 0 40 40">
          <g transform="rotate(${windDeg}, 20, 20)">
            <line x1="20" y1="8" x2="20" y2="32" stroke="#666" stroke-width="2"/>
            <polygon points="20,32 15,24 25,24" fill="#666"/>
          </g>
        </svg>
      `;

      // Zoom indicator
      document.getElementById('map-zoom-indicator').textContent = mapZoom !== 1 ? `${mapZoom.toFixed(1)}x` : '';

      // Add event listeners for leg selection (these need to be re-added since elements are recreated)
      svg.querySelectorAll('.leg-hit').forEach(el => {
        el.addEventListener('click', () => {
          const legId = parseInt(el.dataset.leg);
          selectLeg(DATA.legs.find(l => l.id === legId));
        });
      });
    }

    // Set up map zoom/pan listeners once (not inside renderMap)
    let mapListenersInitialized = false;
    let mapRenderPending = false;
    
    function requestMapRender() {
      if (mapRenderPending) return;
      mapRenderPending = true;
      requestAnimationFrame(() => {
        renderMap();
        mapRenderPending = false;
      });
    }
    
    function initMapListeners() {
      if (mapListenersInitialized) return;
      mapListenersInitialized = true;
      
      const svg = document.getElementById('map');
      
      svg.addEventListener('wheel', (e) => {
        if (!DATA) return;
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        mapZoom = Math.max(0.5, Math.min(30, mapZoom * factor));
        requestMapRender();
      }, { passive: false });

      svg.addEventListener('mousedown', (e) => {
        if (!DATA) return;
        if (e.target.classList.contains('leg-hit') || e.target.classList.contains('leg-segment')) return;
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        svg.style.cursor = 'grabbing';
      });

      svg.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const dx = (e.clientX - dragStartX) / mapZoom;
        const dy = (e.clientY - dragStartY) / mapZoom;
        mapPanX -= dx;
        mapPanY -= dy;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        requestMapRender();
      });

      svg.addEventListener('mouseup', () => {
        isDragging = false;
        svg.style.cursor = 'grab';
      });

      svg.addEventListener('mouseleave', () => {
        isDragging = false;
        svg.style.cursor = 'grab';
      });
    }

    // Initialize map listeners on page load
    initMapListeners();

    function renderLegsTable() {
      if (!DATA || !DATA.legs) {
        console.warn('[renderLegsTable] No DATA available');
        return;
      }
      
      // Use the config filter (which is now the main filter)
      const filter = document.getElementById('pos-filter-config')?.value || 'all';
      
      // Get visible legs using unified helper
      const legs = getVisibleLegs(DATA.legs, filter);

      const tacks = legs.filter(l => l.next_maneuver?.type === 'tack').length;
      const gybes = legs.filter(l => l.next_maneuver?.type === 'gybe').length;
      document.getElementById('legs-summary').textContent = `${legs.length} legs | ${tacks} tacks | ${gybes} gybes`;

      const bestCorr = legs.length > 0 ? Math.min(...legs.map(l => l.corridor)) : 0;
      document.getElementById('best-corridor').textContent = `¬±${bestCorr.toFixed(1)}¬∞`;
      document.getElementById('best-corridor').style.color = getCorridorColor(bestCorr);

      const isGarmin = DATA.dataSource === 'garmin';
      const posNames = { upwind: 'Up', reaching: 'Reach', downwind: 'Down' };
      
      // Update table headers based on data source
      // New order: #, POS, Dur, SPD/VMG, MAG70/90, Rate, COG, Dev, Heel, Wind, TWA, Leg Hdg, Next
      const thead = document.querySelector('#legs-table thead tr');
      thead.innerHTML = `
        <th>#</th>
        <th>POS</th>
        <th style="text-align: right;">Dur</th>
        <th style="text-align: right;">Spd/VMG</th>
        ${!isGarmin ? '<th style="text-align: right;">MAG70/90</th>' : ''}
        <th style="text-align: right;">Rate</th>
        <th style="text-align: right;">COG</th>
        <th style="text-align: right;">Dev</th>
        ${!isGarmin ? '<th style="text-align: right;">Heel</th>' : ''}
        <th style="text-align: right;">Wind</th>
        <th style="text-align: right;">TWA</th>
        <th style="text-align: right;">Hdg</th>
        <th>Next</th>
      `;
      
      const tbody = document.getElementById('legs-tbody');
      tbody.innerHTML = legs.map(leg => {
        const isSelected = selectedLeg?.id === leg.id;
        const badgeClass = `badge badge-${leg.pos === 'upwind' ? 'up' : leg.pos === 'reaching' ? 'reach' : 'down'}`;
        let nextHtml = '';
        if (leg.next_maneuver) {
          const mc = leg.next_maneuver.type === 'tack' ? 'badge-tack' : 'badge-gybe';
          nextHtml = `<span class="badge ${mc}">${leg.next_maneuver.type === 'tack' ? 'T' : 'G'}${leg.next_maneuver.angle}¬∞</span>`;
        }
        const devPct = (leg.lineDeviation * 100).toFixed(1);
        const lostM = Math.round(leg.lostMeters);
        const legHdg = leg.hdg != null ? `${Math.round(leg.hdg)}¬∞` : '-';
        const legWind = leg.localWind || DATA.s.twd;
        const legTwa = leg.twa || '-';
        
        return `<tr class="${isSelected ? 'selected' : ''}" data-leg="${leg.id}">
          <td>${leg.id}</td>
          <td><span class="${badgeClass}">${posNames[leg.pos]}</span></td>
          <td style="text-align:right">${leg.dur}s</td>
          <td style="text-align:right">${leg.speed}/${leg.vmg}</td>
          ${!isGarmin ? `<td style="text-align:right;color:${getMagCorridorColor(leg.mag70)}">${leg.mag70.toFixed(1)}¬∞/${leg.mag_corridor.toFixed(1)}¬∞</td>` : ''}
          <td style="text-align:right;color:${getRateColor(leg.rate)}">${leg.rate.toFixed(2)}</td>
          <td style="text-align:right;color:${getCorridorColor(leg.corridor)}">¬±${leg.corridor.toFixed(1)}¬∞</td>
          <td style="text-align:right;color:${getLineDeviationColor(devPct)}">${devPct}%</td>
          ${!isGarmin ? `<td style="text-align:right">${leg.heel}¬∞</td>` : ''}
          <td style="text-align:right">${legWind}¬∞</td>
          <td style="text-align:right">${legTwa}¬∞</td>
          <td style="text-align:right">${legHdg}</td>
          <td>${nextHtml}</td>
        </tr>`;
      }).join('');

      tbody.querySelectorAll('tr').forEach(row => {
        row.addEventListener('click', () => {
          const legId = parseInt(row.dataset.leg);
          selectLeg(DATA.legs.find(l => l.id === legId));
        });
      });
      
      // Also update side legs table if in legs view mode
      if (viewMode === 'legs') {
        updateSideLegsTable();
      }
    }

    let legRateChart = null;
    let legCogChart = null;
    let legMagChart = null;
    let legHeelChart = null;
    let legSpeedVmgChart = null;

    function renderLegDetail(leg) {
      // Save scroll position before updating content
      const detailContainer = document.getElementById('leg-detail');
      const savedScrollTop = detailContainer ? detailContainer.scrollTop : 0;
      
      // Destroy old charts
      if (legRateChart) { legRateChart.destroy(); legRateChart = null; }
      if (legCogChart) { legCogChart.destroy(); legCogChart = null; }
      if (legMagChart) { legMagChart.destroy(); legMagChart = null; }
      if (legHeelChart) { legHeelChart.destroy(); legHeelChart = null; }
      if (legSpeedVmgChart) { legSpeedVmgChart.destroy(); legSpeedVmgChart = null; }

      if (!leg) {
        document.getElementById('leg-detail').innerHTML = '<div style="color:#6b7280;text-align:center;padding:40px;">Select a leg to view details</div>';
        return;
      }

      const isGarmin = DATA.dataSource === 'garmin';
      const posNames = { upwind: 'Upwind', reaching: 'Reaching', downwind: 'Downwind' };
      let maneuverHtml = '';
      if (leg.next_maneuver) {
        const mc = leg.next_maneuver.type === 'tack' ? 'maneuver-tack' : 'maneuver-gybe';
        maneuverHtml = `<div class="maneuver-banner ${mc}">Next: ${leg.next_maneuver.type.toUpperCase()} ${leg.next_maneuver.angle}¬∞</div>`;
      } else {
        maneuverHtml = `<div class="maneuver-banner" style="background:#e5e7eb;color:#6b7280;">Next: --</div>`;
      }

      // Calculate VMG efficiency (VMG / Speed * 100)
      const vmgEfficiency = leg.speed > 0 ? ((parseFloat(leg.vmg) / parseFloat(leg.speed)) * 100).toFixed(0) : '-';

      // Build stats grid - 5 columns x 2 rows
      // Row 1: Spd/VMG, MAG 70/90, Rate, COG Corridor, Line Deviation
      // Row 2: VMG Efficiency, Wind, TWA, Leg Hdg, Heel
      const statsRow1 = isGarmin ? `
          <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px;margin-top:12px;">
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Spd/VMG</div>
              <div style="font-weight:bold;">${leg.speed}/${leg.vmg}</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Rate</div>
              <div style="font-weight:bold;color:${getRateColor(leg.rate)}">${leg.rate.toFixed(2)}¬∞/s</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">COG Corridor</div>
              <div style="font-weight:bold;color:${getCorridorColor(leg.corridor)}">¬±${leg.corridor.toFixed(1)}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Line Deviation</div>
              <div style="font-weight:bold;color:${getLineDeviationColor(leg.lineDeviation * 100)}">${(leg.lineDeviation * 100).toFixed(1)}%</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">VMG Efficiency</div>
              <div style="font-weight:bold;">${vmgEfficiency}%</div>
            </div>
          </div>
      ` : `
          <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px;margin-top:12px;">
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Spd/VMG</div>
              <div style="font-weight:bold;">${leg.speed}/${leg.vmg}</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">MAG 70/90</div>
              <div style="font-weight:bold;color:${getMagCorridorColor(leg.mag70)}">${leg.mag70.toFixed(1)}¬∞ / ${leg.mag_corridor.toFixed(1)}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Rate</div>
              <div style="font-weight:bold;color:${getRateColor(leg.rate)}">${leg.rate.toFixed(2)}¬∞/s</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">COG Corridor</div>
              <div style="font-weight:bold;color:${getCorridorColor(leg.corridor)}">¬±${leg.corridor.toFixed(1)}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Line Deviation</div>
              <div style="font-weight:bold;color:${getLineDeviationColor(leg.lineDeviation * 100)}">${(leg.lineDeviation * 100).toFixed(1)}%</div>
            </div>
          </div>
      `;
      
      const statsRow2 = isGarmin ? `
          <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px;margin-top:8px;">
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Wind</div>
              <div style="font-weight:bold;">${leg.localWind || DATA.s.twd}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">TWA</div>
              <div style="font-weight:bold;">${leg.twa}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Leg Hdg</div>
              <div style="font-weight:bold;">${leg.hdg}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">VMG Efficiency</div>
              <div style="font-weight:bold;">${vmgEfficiency}%</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;visibility:hidden;"></div>
          </div>
      ` : `
          <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px;margin-top:8px;">
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">VMG Efficiency</div>
              <div style="font-weight:bold;">${vmgEfficiency}%</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Wind</div>
              <div style="font-weight:bold;">${leg.localWind || DATA.s.twd}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">TWA</div>
              <div style="font-weight:bold;">${leg.twa}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Leg Hdg</div>
              <div style="font-weight:bold;">${leg.hdg}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Heel</div>
              <div style="font-weight:bold;">${leg.heel}¬∞</div>
            </div>
          </div>
      `;

      // Build charts section - reordered: Speed/VMG, MAG, Rate, COG, Heel
      // Different for Garmin (no MAG chart, no Heel chart)
      const chartsHtml = isGarmin ? `
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Speed / VMG</span>
            <span class="text-xs" style="color:#9ca3af;"><span style="color:#3b82f6;">‚îÅ</span> Spd <span style="color:#22c55e;">‚îÅ</span> VMG | <span style="color:#ef4444;background:#fecaca;padding:0 3px;border-radius:2px;">!</span> Spd‚Üë VMG‚Üì</span>
          </div>
          <div style="height:100px;"><canvas id="leg-speed-vmg-chart"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Steering Rate</span>
            <span class="text-xs" style="color:#9ca3af;">0-10 ¬∞/s | <span style="color:#22c55e;">‚îÅ</span> 1.5 <span style="color:#3b82f6;">‚îÅ</span> 3</span>
          </div>
          <div style="height:100px;"><canvas id="leg-rate-chart"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">COG Deviation from ${leg.hdg}¬∞</span>
            <span class="text-xs" style="color:#9ca3af;">‚Ü∂ Port | Stbd ‚Ü∑ | <span style="color:#22c55e;">‚îÅ</span> ¬±5¬∞ <span style="color:#f59e0b;">‚îÅ</span> ¬±10¬∞</span>
          </div>
          <div style="height:100px;"><canvas id="leg-cog-chart"></canvas></div>
        </div>
      ` : `
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Speed / VMG</span>
            <span class="text-xs" style="color:#9ca3af;"><span style="color:#3b82f6;">‚îÅ</span> Spd <span style="color:#22c55e;">‚îÅ</span> VMG | <span style="color:#ef4444;background:#fecaca;padding:0 3px;border-radius:2px;">!</span> Spd‚Üë VMG‚Üì</span>
          </div>
          <div style="height:100px;"><canvas id="leg-speed-vmg-chart"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Mag Heading Deviation from ${leg.hdg}¬∞</span>
            <span class="text-xs" style="color:#9ca3af;">‚Ü∂ Port | Stbd ‚Ü∑ | <span style="color:#22c55e;">‚îÅ</span> ¬±5¬∞ <span style="color:#f59e0b;">‚îÅ</span> ¬±10¬∞</span>
          </div>
          <div style="height:100px;"><canvas id="leg-mag-chart"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Steering Rate</span>
            <span class="text-xs" style="color:#9ca3af;">0-10 ¬∞/s | <span style="color:#22c55e;">‚îÅ</span> 1.5 <span style="color:#3b82f6;">‚îÅ</span> 3</span>
          </div>
          <div style="height:100px;"><canvas id="leg-rate-chart"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">COG Deviation from ${leg.hdg}¬∞</span>
            <span class="text-xs" style="color:#9ca3af;">‚Ü∂ Port | Stbd ‚Ü∑ | <span style="color:#22c55e;">‚îÅ</span> ¬±5¬∞ <span style="color:#f59e0b;">‚îÅ</span> ¬±10¬∞</span>
          </div>
          <div style="height:100px;"><canvas id="leg-cog-chart"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Heel Angle</span>
            <span class="text-xs" style="color:#9ca3af;">‚Ü∂ Port | Stbd ‚Ü∑ | <span style="color:#22c55e;">‚îÅ</span> ¬±10¬∞ <span style="color:#f59e0b;">‚îÅ</span> ¬±15¬∞</span>
          </div>
          <div style="height:100px;"><canvas id="leg-heel-chart"></canvas></div>
        </div>
      `;

      document.getElementById('leg-detail').innerHTML = `
        <div class="detail-box">
          <div class="detail-header">
            <span class="detail-title">Leg #${leg.id}: ${posNames[leg.pos]}</span>
            <div style="display:flex;align-items:center;gap:8px;">
              <span class="text-sm text-purple">${leg.start.toFixed(1)} - ${leg.end.toFixed(1)} min (${leg.dur}s)</span>
              <button class="zoom-btn" onclick="zoomToLeg(${leg.id})" title="Zoom to leg on map">üîç</button>
            </div>
          </div>
          ${statsRow1}
          ${statsRow2}
          ${maneuverHtml}
        </div>
        ${chartsHtml}
      `;

      // Render charts if we have timeseries data
      if (leg.ts && leg.ts.length > 0) {
        const labels = leg.ts.map(p => p.t.toFixed(1));
        
        // Steering Rate Chart
        const rateCtx = document.getElementById('leg-rate-chart').getContext('2d');
        legRateChart = new Chart(rateCtx, {
          type: 'line',
          data: {
            labels,
            datasets: [{
              data: leg.ts.map(p => p.rate),
              borderColor: '#ef4444',
              backgroundColor: 'rgba(239, 68, 68, 0.1)',
              borderWidth: 2,
              pointRadius: 0,
              tension: 0.3,
              fill: true
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { 
              legend: { display: false },
              annotation: {
                annotations: {
                  line1: { type: 'line', yMin: 1.5, yMax: 1.5, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                  line2: { type: 'line', yMin: 3, yMax: 3, borderColor: '#3b82f6', borderDash: [5,5], borderWidth: 1 }
                }
              }
            },
            scales: {
              x: { 
                display: true,
                ticks: { font: { size: 9 }, maxTicksLimit: 6, callback: v => labels[v] + 'm' }
              },
              y: { 
                display: false,
                min: 0, 
                max: 10
              }
            }
          }
        });

        // Calculate deviation range - round up to nearest 5
        const allDevs = [...leg.ts.map(p => p.dev), ...leg.ts.map(p => p.mdev)];
        const rawMax = Math.max(Math.abs(Math.min(...allDevs)), Math.abs(Math.max(...allDevs)), 15);
        const maxDev = Math.ceil(rawMax / 5) * 5;

        // COG Deviation Chart
        const cogCtx = document.getElementById('leg-cog-chart').getContext('2d');
        legCogChart = new Chart(cogCtx, {
          type: 'line',
          data: {
            labels,
            datasets: [{
              data: leg.ts.map(p => p.dev),
              borderColor: '#3b82f6',
              backgroundColor: 'rgba(59, 130, 246, 0.1)',
              borderWidth: 2,
              pointRadius: 0,
              tension: 0.3,
              fill: true
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { 
              legend: { display: false },
              annotation: {
                annotations: {
                  zero: { type: 'line', yMin: 0, yMax: 0, borderColor: '#666', borderWidth: 2 },
                  plus5: { type: 'line', yMin: 5, yMax: 5, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                  minus5: { type: 'line', yMin: -5, yMax: -5, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                  plus10: { type: 'line', yMin: 10, yMax: 10, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 },
                  minus10: { type: 'line', yMin: -10, yMax: -10, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 }
                }
              }
            },
            scales: {
              x: { 
                display: true,
                ticks: { font: { size: 9 }, maxTicksLimit: 6, callback: v => labels[v] + 'm' }
              },
              y: { 
                display: false,
                min: -maxDev, 
                max: maxDev
              }
            }
          }
        });

        // Mag Heading Deviation Chart and Heel Chart - only for VKX data (not Garmin)
        if (!isGarmin) {
          const magCtx = document.getElementById('leg-mag-chart').getContext('2d');
          legMagChart = new Chart(magCtx, {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: leg.ts.map(p => p.mdev),
                borderColor: '#8b5cf6',
                backgroundColor: 'rgba(139, 92, 246, 0.1)',
                borderWidth: 2,
                pointRadius: 0,
                tension: 0.3,
                fill: true
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: { 
                legend: { display: false },
                annotation: {
                  annotations: {
                    zero: { type: 'line', yMin: 0, yMax: 0, borderColor: '#666', borderWidth: 2 },
                    plus5: { type: 'line', yMin: 5, yMax: 5, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                    minus5: { type: 'line', yMin: -5, yMax: -5, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                    plus10: { type: 'line', yMin: 10, yMax: 10, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 },
                    minus10: { type: 'line', yMin: -10, yMax: -10, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 }
                  }
                }
              },
              scales: {
                x: { 
                  display: true,
                  ticks: { font: { size: 9 }, maxTicksLimit: 6, callback: v => labels[v] + 'm' }
                },
                y: { 
                  display: false,
                  min: -maxDev, 
                  max: maxDev
                }
              }
            }
          });

          // Heel Chart
          const heelData = leg.ts.map(p => p.heel);
          const maxHeel = Math.max(Math.abs(Math.min(...heelData)), Math.abs(Math.max(...heelData)), 15);
          const heelMax = Math.ceil(maxHeel / 5) * 5;
          
          const heelCtx = document.getElementById('leg-heel-chart').getContext('2d');
          legHeelChart = new Chart(heelCtx, {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: heelData,
                borderColor: '#f59e0b',
                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                borderWidth: 2,
                pointRadius: 0,
                tension: 0.3,
                fill: true
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: { 
                legend: { display: false },
                annotation: {
                  annotations: {
                    zero: { type: 'line', yMin: 0, yMax: 0, borderColor: '#666', borderWidth: 2 },
                    plus10: { type: 'line', yMin: 10, yMax: 10, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                    minus10: { type: 'line', yMin: -10, yMax: -10, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                    plus15: { type: 'line', yMin: 15, yMax: 15, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 },
                    minus15: { type: 'line', yMin: -15, yMax: -15, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 }
                  }
                }
              },
              scales: {
                x: { 
                  display: true,
                  ticks: { font: { size: 9 }, maxTicksLimit: 6, callback: v => labels[v] + 'm' }
                },
                y: { 
                  display: false,
                  min: -heelMax, 
                  max: heelMax
                }
              }
            }
          });
        }

        // Speed/VMG Chart - for both Garmin and VKX
        const speedVmgCtx = document.getElementById('leg-speed-vmg-chart');
        if (speedVmgCtx) {
          const spdData = leg.ts.map(p => p.spd);
          const vmgData = leg.ts.map(p => p.vmg);
          const maxSpd = Math.max(...spdData, ...vmgData) * 1.1;
          
          // Improved algorithm: Detect VMG efficiency drops
          // VMG efficiency = VMG / Speed (how well speed converts to progress)
          const inefficientRegions = [];
          const minSpeed = 3.0; // Only analyze when moving at reasonable speed
          const rollingWindow = 5; // 5-point rolling average
          const efficiencyDropThreshold = 0.10; // 10% efficiency drop triggers
          
          // Calculate VMG efficiency for each point
          const efficiencyData = spdData.map((spd, i) => 
            spd > 0.5 ? vmgData[i] / spd : 0
          );
          
          // Calculate leg median efficiency (for context)
          const validEfficiencies = efficiencyData.filter((e, i) => spdData[i] >= minSpeed);
          const sortedEff = [...validEfficiencies].sort((a, b) => a - b);
          const legMedianEfficiency = sortedEff.length > 0 
            ? sortedEff[Math.floor(sortedEff.length / 2)] 
            : 0.7;
          
          // Detect efficiency drops
          for (let i = rollingWindow; i < leg.ts.length; i++) {
            // Skip low speed points
            if (spdData[i] < minSpeed) continue;
            
            // Calculate rolling average efficiency
            let avgEff = 0;
            let validCount = 0;
            for (let j = i - rollingWindow; j < i; j++) {
              if (spdData[j] >= minSpeed) {
                avgEff += efficiencyData[j];
                validCount++;
              }
            }
            if (validCount < 3) continue; // Need enough valid points
            avgEff /= validCount;
            
            // Calculate efficiency drop
            const currEff = efficiencyData[i];
            const efficiencyDrop = avgEff - currEff;
            
            // Mark as inefficient if:
            // 1. Efficiency dropped by more than threshold from recent average
            // 2. Current efficiency is below the leg's median (context-aware)
            // 3. Speed is maintained or increased (not just slowing down naturally)
            const spdChange = spdData[i] - spdData[Math.max(0, i - rollingWindow)];
            
            if (efficiencyDrop > efficiencyDropThreshold && 
                currEff < legMedianEfficiency &&
                spdChange > -0.5) {
              inefficientRegions.push(i);
            }
          }
          
          // Create point colors - highlight inefficient regions in red
          const pointColors = spdData.map((_, i) => 
            inefficientRegions.includes(i) ? 'rgba(239, 68, 68, 0.8)' : 'rgba(59, 130, 246, 0)'
          );
          const pointRadius = spdData.map((_, i) => 
            inefficientRegions.includes(i) ? 4 : 0
          );
          
          legSpeedVmgChart = new Chart(speedVmgCtx.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  label: 'Speed',
                  data: spdData,
                  borderColor: '#3b82f6',
                  backgroundColor: 'rgba(59, 130, 246, 0.1)',
                  borderWidth: 2,
                  pointRadius: pointRadius,
                  pointBackgroundColor: pointColors,
                  tension: 0.3,
                  fill: false
                },
                {
                  label: 'VMG',
                  data: vmgData,
                  borderColor: '#22c55e',
                  backgroundColor: 'rgba(34, 197, 94, 0.1)',
                  borderWidth: 2,
                  pointRadius: 0,
                  tension: 0.3,
                  fill: true
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: 'index',
                intersect: false
              },
              plugins: { 
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: ctx => `${ctx.dataset.label}: ${ctx.raw.toFixed(1)} kts`
                  }
                }
              },
              scales: {
                x: { 
                  display: true,
                  ticks: { font: { size: 9 }, maxTicksLimit: 6, callback: v => labels[v] + 'm' }
                },
                y: { 
                  display: true,
                  position: 'right',
                  min: 0,
                  max: Math.ceil(maxSpd),
                  ticks: { font: { size: 9 }, callback: v => v + ' kts' }
                }
              }
            }
          });
        }
      }
      
      // Restore scroll position after content is rendered
      if (detailContainer && savedScrollTop > 0) {
        // Use requestAnimationFrame to ensure DOM is updated
        requestAnimationFrame(() => {
          detailContainer.scrollTop = savedScrollTop;
        });
      }
    }

    function renderScatterCharts() {
      const filter = document.getElementById('pos-filter-config')?.value || 'all';
      
      console.log('[renderScatterCharts] multiSessionView:', multiSessionView, 'ALL_SESSIONS.length:', ALL_SESSIONS.length);
      
      // Multi-session view: gather intervals from all sessions
      let allIntervalsData = [];
      
      if (multiSessionView && ALL_SESSIONS.length > 1) {
        console.log('[renderScatterCharts] Using multi-session mode - gathering from all sessions');
        // Gather intervals from all sessions
        ALL_SESSIONS.forEach((session, sessionIdx) => {
          // Use unified helper to get visible intervals
          const sessionIntervals = getVisibleIntervals(session.intervals, filter, session);
          
          // Add session info to each interval
          sessionIntervals.forEach(interval => {
            allIntervalsData.push({
              ...interval,
              sessionIdx: sessionIdx,
              sessionColor: BOAT_COLORS[sessionIdx % BOAT_COLORS.length]
            });
          });
        });
      } else {
        // Single session view
        if (!DATA || !DATA.intervals) {
          console.warn('[renderScatterCharts] No DATA available in single session mode');
          return;
        }
        
        // Use unified helper to get visible intervals
        const intervals = getVisibleIntervals(DATA.intervals, filter);
        
        // Add session info for consistency
        allIntervalsData = intervals.map(interval => ({
          ...interval,
          sessionIdx: ALL_SESSIONS.indexOf(DATA),
          sessionColor: '#7c3aed'
        }));
      }

      const isGarmin = DATA.dataSource === 'garmin';
      
      // Hide/show MAG corridor chart based on data source
      const magContainer = document.getElementById('mag-corridor-chart-container');
      if (magContainer) {
        magContainer.style.display = isGarmin ? 'none' : 'block';
      }

      if (allIntervalsData.length === 0) {
        document.getElementById('rate-scatter').parentElement.innerHTML = '<p style="text-align:center;color:#6b7280;padding:40px;">No intervals for selected filter</p>';
        document.getElementById('corridor-scatter').parentElement.innerHTML = '<p style="text-align:center;color:#6b7280;padding:40px;">No intervals for selected filter</p>';
        document.getElementById('rate-pct').innerHTML = '';
        document.getElementById('corr-pct').innerHTML = '';
        if (!isGarmin) {
          document.getElementById('mag-corridor-scatter').parentElement.innerHTML = '<p style="text-align:center;color:#6b7280;padding:40px;">No intervals for selected filter</p>';
          document.getElementById('mag-pct').innerHTML = '';
        }
        return;
      }

      const bestRate = Math.min(...allIntervalsData.map(i => i.rate));
      const bestCorr = Math.min(...allIntervalsData.map(i => i.corridor_pm));
      document.getElementById('best-rate').textContent = bestRate.toFixed(2) + '¬∞/s';
      document.getElementById('best-rate').style.color = getRateColor(bestRate);
      document.getElementById('best-int-corridor').textContent = '¬±' + bestCorr.toFixed(1) + '¬∞';
      document.getElementById('best-int-corridor').style.color = getCorridorColor(bestCorr);

      // Update legend
      if (selectedLeg) {
        document.getElementById('legend-selected-rate').style.display = 'flex';
        document.getElementById('legend-selected-corr').style.display = 'flex';
        document.getElementById('legend-leg-rate').textContent = `Leg #${selectedLeg.id}`;
        document.getElementById('legend-leg-corr').textContent = `Leg #${selectedLeg.id}`;
        if (!isGarmin) {
          document.getElementById('legend-selected-mag').style.display = 'flex';
          document.getElementById('legend-leg-mag').textContent = `Leg #${selectedLeg.id}`;
        }
      } else {
        document.getElementById('legend-selected-rate').style.display = 'none';
        document.getElementById('legend-selected-corr').style.display = 'none';
        if (!isGarmin) {
          document.getElementById('legend-selected-mag').style.display = 'none';
        }
      }

      // Prepare data - in multi-session view, color by session instead of performance
      // Position sessions side-by-side using x-offset
      const sessionCount = multiSessionView && ALL_SESSIONS.length > 1 ? ALL_SESSIONS.length : 1;
      const xOffset = 0.15; // Offset between sessions (in minutes)
      
      const rateData = allIntervalsData.map(i => {
        const isSelected = selectedLeg?.id === i.leg_id && (!multiSessionView || selectedLeg?.sessionIdx === i.sessionIdx);
        
        // In multi-session view, offset x position based on session index
        let xPosition = i.minute;
        if (multiSessionView && ALL_SESSIONS.length > 1) {
          // Center the sessions around the original minute value
          const totalOffset = (sessionCount - 1) * xOffset;
          xPosition = i.minute - (totalOffset / 2) + (i.sessionIdx * xOffset);
        }
        
        return {
          x: xPosition,
          y: i.rate,
          legId: i.leg_id,
          sessionIdx: i.sessionIdx,
          color: isSelected ? '#a855f7' : (multiSessionView && ALL_SESSIONS.length > 1 ? i.sessionColor : getRateColor(i.rate)),
          radius: isSelected ? 8 : 5
        };
      });

      const corrData = allIntervalsData.map(i => {
        const isSelected = selectedLeg?.id === i.leg_id && (!multiSessionView || selectedLeg?.sessionIdx === i.sessionIdx);
        
        let xPosition = i.minute;
        if (multiSessionView && ALL_SESSIONS.length > 1) {
          const totalOffset = (sessionCount - 1) * xOffset;
          xPosition = i.minute - (totalOffset / 2) + (i.sessionIdx * xOffset);
        }
        
        return {
          x: xPosition,
          y: i.corridor_pm,
          legId: i.leg_id,
          sessionIdx: i.sessionIdx,
          color: isSelected ? '#a855f7' : (multiSessionView && ALL_SESSIONS.length > 1 ? i.sessionColor : getCorridorColor(i.corridor_pm)),
          radius: isSelected ? 8 : 5
        };
      });

      const magCorrData = !isGarmin ? allIntervalsData.map(i => {
        const isSelected = selectedLeg?.id === i.leg_id && (!multiSessionView || selectedLeg?.sessionIdx === i.sessionIdx);
        
        let xPosition = i.minute;
        if (multiSessionView && ALL_SESSIONS.length > 1) {
          const totalOffset = (sessionCount - 1) * xOffset;
          xPosition = i.minute - (totalOffset / 2) + (i.sessionIdx * xOffset);
        }
        
        return {
          x: xPosition,
          y: i.mag_corridor_pm,
          legId: i.leg_id,
          sessionIdx: i.sessionIdx,
          color: isSelected ? '#a855f7' : (multiSessionView && ALL_SESSIONS.length > 1 ? i.sessionColor : getMagCorridorColor(i.mag_corridor_pm)),
          radius: isSelected ? 8 : 5
        };
      }) : [];

      // Calculate percentages for each category
      const total = allIntervalsData.length;
      
      // Steering Rate percentages
      const rateExpert = allIntervalsData.filter(i => i.rate <= 1.5).length;
      const rateClub = allIntervalsData.filter(i => i.rate > 1.5 && i.rate <= 3).length;
      const rateRec = allIntervalsData.filter(i => i.rate > 3 && i.rate <= 5).length;
      const rateLearning = allIntervalsData.filter(i => i.rate > 5).length;
      document.getElementById('rate-pct').innerHTML = 
        `<span style="color:#22c55e">${Math.round(rateExpert/total*100)}%</span> ¬∑ ` +
        `<span style="color:#3b82f6">${Math.round(rateClub/total*100)}%</span> ¬∑ ` +
        `<span style="color:#f59e0b">${Math.round(rateRec/total*100)}%</span> ¬∑ ` +
        `<span style="color:#ef4444">${Math.round(rateLearning/total*100)}%</span>`;
      
      // COG Corridor percentages
      const corrExcellent = allIntervalsData.filter(i => i.corridor_pm <= 8).length;
      const corrGood = allIntervalsData.filter(i => i.corridor_pm > 8 && i.corridor_pm <= 12).length;
      const corrFair = allIntervalsData.filter(i => i.corridor_pm > 12 && i.corridor_pm <= 18).length;
      const corrNeedsWork = allIntervalsData.filter(i => i.corridor_pm > 18).length;
      document.getElementById('corr-pct').innerHTML = 
        `<span style="color:#22c55e">${Math.round(corrExcellent/total*100)}%</span> ¬∑ ` +
        `<span style="color:#3b82f6">${Math.round(corrGood/total*100)}%</span> ¬∑ ` +
        `<span style="color:#f59e0b">${Math.round(corrFair/total*100)}%</span> ¬∑ ` +
        `<span style="color:#ef4444">${Math.round(corrNeedsWork/total*100)}%</span>`;
      
      // MAG Corridor percentages (only for VKX)
      if (!isGarmin) {
        const magExcellent = allIntervalsData.filter(i => i.mag_corridor_pm <= 5).length;
        const magGood = allIntervalsData.filter(i => i.mag_corridor_pm > 5 && i.mag_corridor_pm <= 8).length;
        const magFair = allIntervalsData.filter(i => i.mag_corridor_pm > 8 && i.mag_corridor_pm <= 12).length;
        const magNeedsWork = allIntervalsData.filter(i => i.mag_corridor_pm > 12).length;
        document.getElementById('mag-pct').innerHTML = 
          `<span style="color:#22c55e">${Math.round(magExcellent/total*100)}%</span> ¬∑ ` +
          `<span style="color:#3b82f6">${Math.round(magGood/total*100)}%</span> ¬∑ ` +
          `<span style="color:#f59e0b">${Math.round(magFair/total*100)}%</span> ¬∑ ` +
          `<span style="color:#ef4444">${Math.round(magNeedsWork/total*100)}%</span>`;
      }

      // Destroy old charts
      if (rateChart) rateChart.destroy();
      if (corridorChart) corridorChart.destroy();
      if (magCorridorChart) magCorridorChart.destroy();

      // Rate chart - create datasets per session in multi-view
      const rateCtx = document.getElementById('rate-scatter').getContext('2d');
      
      let rateDatasets, corrDatasets, magCorrDatasets;
      
      if (multiSessionView && ALL_SESSIONS.length > 1) {
        // Multi-session view: create separate dataset for each session
        rateDatasets = [];
        corrDatasets = [];
        magCorrDatasets = [];
        
        ALL_SESSIONS.forEach((session, sessionIdx) => {
          const sessionRateData = rateData.filter(d => d.sessionIdx === sessionIdx);
          const sessionCorrData = corrData.filter(d => d.sessionIdx === sessionIdx);
          const sessionMagData = magCorrData.filter(d => d.sessionIdx === sessionIdx);
          
          const sessionColor = BOAT_COLORS[sessionIdx % BOAT_COLORS.length];
          const sessionName = session.filename.replace(/\.(vkx|fit|gpx|csv|gz)$/gi, '').substring(0, 20);
          
          if (sessionRateData.length > 0) {
            rateDatasets.push({
              label: sessionName,
              data: sessionRateData,
              backgroundColor: sessionRateData.map(d => d.color),
              pointRadius: sessionRateData.map(d => d.radius),
              pointHoverRadius: 10
            });
          }
          
          if (sessionCorrData.length > 0) {
            corrDatasets.push({
              label: sessionName,
              data: sessionCorrData,
              backgroundColor: sessionCorrData.map(d => d.color),
              pointRadius: sessionCorrData.map(d => d.radius),
              pointHoverRadius: 10
            });
          }
          
          if (sessionMagData.length > 0) {
            magCorrDatasets.push({
              label: sessionName,
              data: sessionMagData,
              backgroundColor: sessionMagData.map(d => d.color),
              pointRadius: sessionMagData.map(d => d.radius),
              pointHoverRadius: 10
            });
          }
        });
      } else {
        // Single session view: one dataset
        rateDatasets = [{
          data: rateData,
          backgroundColor: rateData.map(d => d.color),
          pointRadius: rateData.map(d => d.radius),
          pointHoverRadius: 10
        }];
        
        corrDatasets = [{
          data: corrData,
          backgroundColor: corrData.map(d => d.color),
          pointRadius: corrData.map(d => d.radius),
          pointHoverRadius: 10
        }];
        
        magCorrDatasets = [{
          data: magCorrData,
          backgroundColor: magCorrData.map(d => d.color),
          pointRadius: magCorrData.map(d => d.radius),
          pointHoverRadius: 10
        }];
      }
      
      rateChart = new Chart(rateCtx, {
        type: 'scatter',
        data: { datasets: rateDatasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { 
              display: multiSessionView && ALL_SESSIONS.length > 1,
              position: 'top',
              labels: { boxWidth: 12, font: { size: 10 } }
            },
            tooltip: {
              callbacks: {
                label: ctx => {
                  const d = ctx.dataset.data[ctx.dataIndex];
                  const sessionInfo = multiSessionView && ALL_SESSIONS.length > 1 ? ` (${ctx.dataset.label})` : '';
                  return `Min ${d.x} (Leg ${d.legId})${sessionInfo}: ${d.y.toFixed(2)}¬∞/s`;
                }
              }
            }
          },
          scales: {
            x: { title: { display: true, text: 'Minute' } },
            y: { min: 0, max: 10, title: { display: true, text: '¬∞/s' } }
          },
          onClick: (e, elements) => {
            if (elements.length > 0) {
              const datasetIdx = elements[0].datasetIndex;
              const idx = elements[0].index;
              const d = rateDatasets[datasetIdx].data[idx];
              
              if (multiSessionView && ALL_SESSIONS.length > 1) {
                const targetSession = ALL_SESSIONS[d.sessionIdx];
                const leg = targetSession.legs.find(l => l.id === d.legId);
                if (leg) {
                  const legWithSession = {
                    ...leg,
                    sessionIdx: d.sessionIdx,
                    sessionColor: d.color
                  };
                  selectLeg(legWithSession);
                }
              } else {
                const leg = DATA.legs.find(l => l.id === d.legId);
                if (selectedLeg?.id === d.legId) {
                  clearSelection();
                } else {
                  selectLeg(leg);
                }
              }
            }
          }
        }
      });

      // Corridor chart
      const corrCtx = document.getElementById('corridor-scatter').getContext('2d');
      corridorChart = new Chart(corrCtx, {
        type: 'scatter',
        data: { datasets: corrDatasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { 
              display: multiSessionView && ALL_SESSIONS.length > 1,
              position: 'top',
              labels: { boxWidth: 12, font: { size: 10 } }
            },
            tooltip: {
              callbacks: {
                label: ctx => {
                  const d = ctx.dataset.data[ctx.dataIndex];
                  const sessionInfo = multiSessionView && ALL_SESSIONS.length > 1 ? ` (${ctx.dataset.label})` : '';
                  return `Min ${d.x} (Leg ${d.legId})${sessionInfo}: ¬±${d.y.toFixed(1)}¬∞`;
                }
              }
            }
          },
          scales: {
            x: { title: { display: true, text: 'Minute' } },
            y: { min: 0, max: 30, title: { display: true, text: '¬±¬∞' } }
          },
          onClick: (e, elements) => {
            if (elements.length > 0) {
              const datasetIdx = elements[0].datasetIndex;
              const idx = elements[0].index;
              const d = corrDatasets[datasetIdx].data[idx];
              
              if (multiSessionView && ALL_SESSIONS.length > 1) {
                const targetSession = ALL_SESSIONS[d.sessionIdx];
                const leg = targetSession.legs.find(l => l.id === d.legId);
                if (leg) {
                  const legWithSession = {
                    ...leg,
                    sessionIdx: d.sessionIdx,
                    sessionColor: d.color
                  };
                  selectLeg(legWithSession);
                }
              } else {
                const leg = DATA.legs.find(l => l.id === d.legId);
                if (selectedLeg?.id === d.legId) {
                  clearSelection();
                } else {
                  selectLeg(leg);
                }
              }
            }
          }
        }
      });

      // MAG Corridor chart (only for VKX data)
      if (!isGarmin && magCorrDatasets.length > 0 && magCorrDatasets[0].data && magCorrDatasets[0].data.length > 0) {
        const magCtx = document.getElementById('mag-corridor-scatter').getContext('2d');
        magCorridorChart = new Chart(magCtx, {
          type: 'scatter',
          data: { datasets: magCorrDatasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { 
                display: multiSessionView && ALL_SESSIONS.length > 1,
                position: 'top',
                labels: { boxWidth: 12, font: { size: 10 } }
              },
              tooltip: {
                callbacks: {
                  label: ctx => {
                    const d = ctx.dataset.data[ctx.dataIndex];
                    const sessionInfo = multiSessionView && ALL_SESSIONS.length > 1 ? ` (${ctx.dataset.label})` : '';
                    return `Min ${d.x} (Leg ${d.legId})${sessionInfo}: ¬±${d.y.toFixed(1)}¬∞`;
                  }
                }
              }
            },
            scales: {
              x: { title: { display: true, text: 'Minute' } },
              y: { min: 0, max: 20, title: { display: true, text: '¬±¬∞' } }
            },
            onClick: (e, elements) => {
              if (elements.length > 0) {
                const datasetIdx = elements[0].datasetIndex;
                const idx = elements[0].index;
                const d = magCorrDatasets[datasetIdx].data[idx];
                
                if (multiSessionView && ALL_SESSIONS.length > 1) {
                  const targetSession = ALL_SESSIONS[d.sessionIdx];
                  const leg = targetSession.legs.find(l => l.id === d.legId);
                  if (leg) {
                    const legWithSession = {
                      ...leg,
                      sessionIdx: d.sessionIdx,
                      sessionColor: d.color
                    };
                    selectLeg(legWithSession);
                  }
                } else {
                  const leg = DATA.legs.find(l => l.id === d.legId);
                  if (selectedLeg?.id === d.legId) {
                    clearSelection();
                  } else {
                    selectLeg(leg);
                  }
                }
              }
            }
          }
        });
      }
    }

    function renderPOSBreakdown() {
      const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };
      const posNames = { upwind: 'Upwind', reaching: 'Reaching', downwind: 'Downwind' };
      const isGarmin = DATA.dataSource === 'garmin';
      
      if (multiSessionView && ALL_SESSIONS.length > 1) {
        // Multi-session comparison view
        let html = '<div style="overflow-x:auto;"><table style="width:100%;border-collapse:collapse;font-size:11px;">';
        html += '<thead><tr style="background:#f3f4f6;"><th style="padding:8px;text-align:left;position:sticky;left:0;background:#f3f4f6;z-index:1;">Metric</th>';
        
        ALL_SESSIONS.forEach((session, idx) => {
          const sessionName = session.filename.replace(/\.(vkx|fit|gpx|csv|gz)$/gi, '').substring(0, 15);
          const sessionColor = BOAT_COLORS[idx % BOAT_COLORS.length];
          html += `<th colspan="3" style="padding:8px;border-left:2px solid ${sessionColor};"><span style="color:${sessionColor};font-weight:600;">${sessionName}</span></th>`;
        });
        html += '</tr><tr style="background:#f9fafb;font-size:10px;"><th style="padding:4px;text-align:left;position:sticky;left:0;background:#f9fafb;z-index:1;"></th>';
        ALL_SESSIONS.forEach(() => {
          html += '<th style="padding:4px;">Up</th><th style="padding:4px;">Reach</th><th style="padding:4px;">Down</th>';
        });
        html += '</tr></thead><tbody>';
        
        // Time row
        html += '<tr><td style="padding:8px;font-weight:500;position:sticky;left:0;background:white;z-index:1;">Time (min)</td>';
        ALL_SESSIONS.forEach(session => {
          ['upwind', 'reaching', 'downwind'].forEach(pos => {
            const d = session.pos[pos];
            html += `<td style="padding:8px;text-align:center;">${Math.round(d.time/60)}</td>`;
          });
        });
        html += '</tr>';
        
        // Speed/VMG row
        html += '<tr style="background:#f9fafb;"><td style="padding:8px;font-weight:500;position:sticky;left:0;background:#f9fafb;z-index:1;">Spd/VMG (kts)</td>';
        ALL_SESSIONS.forEach(session => {
          ['upwind', 'reaching', 'downwind'].forEach(pos => {
            const d = session.pos[pos];
            html += `<td style="padding:8px;text-align:center;font-size:10px;">${d.speed}/${d.vmg}</td>`;
          });
        });
        html += '</tr>';
        
        // COG Corridor row
        html += '<tr><td style="padding:8px;font-weight:500;position:sticky;left:0;background:white;z-index:1;">COG Corridor (¬∞)</td>';
        ALL_SESSIONS.forEach(session => {
          ['upwind', 'reaching', 'downwind'].forEach(pos => {
            const d = session.pos[pos];
            const color = getCorridorColor(parseFloat(d.corridor));
            html += `<td style="padding:8px;text-align:center;color:${color};">¬±${d.corridor}</td>`;
          });
        });
        html += '</tr>';
        
        // Steer Rate row
        html += '<tr style="background:#f9fafb;"><td style="padding:8px;font-weight:500;position:sticky;left:0;background:#f9fafb;z-index:1;">Steer Rate (¬∞/s)</td>';
        ALL_SESSIONS.forEach(session => {
          ['upwind', 'reaching', 'downwind'].forEach(pos => {
            const d = session.pos[pos];
            const color = getRateColor(parseFloat(d.rate));
            html += `<td style="padding:8px;text-align:center;color:${color};">${d.rate}</td>`;
          });
        });
        html += '</tr>';
        
        // Heel row (if not Garmin)
        if (!isGarmin) {
          html += '<tr><td style="padding:8px;font-weight:500;position:sticky;left:0;background:white;z-index:1;">Avg Heel (¬∞)</td>';
          ALL_SESSIONS.forEach(session => {
            ['upwind', 'reaching', 'downwind'].forEach(pos => {
              const d = session.pos[pos];
              html += `<td style="padding:8px;text-align:center;">${d.heel}</td>`;
            });
          });
          html += '</tr>';
        }
        
        html += '</tbody></table></div>';
        document.getElementById('pos-breakdown').innerHTML = html;
      } else {
        // Single session view (original)
        if (!DATA || !DATA.pos) {
          console.warn('[renderPOSBreakdown] No DATA available in single session mode');
          return;
        }
        
        document.getElementById('pos-breakdown').innerHTML = ['upwind', 'reaching', 'downwind'].map(pos => {
          const d = DATA.pos[pos];
          const devDisplay = d.linedev !== '-' ? `${d.linedev}% (${d.lostm}m)` : '-';
          return `
            <div class="pos-breakdown" style="border-left: 4px solid ${posColors[pos]};">
              <div class="pos-title" style="color: ${posColors[pos]};">${posNames[pos]}</div>
              <div class="pos-stat"><span>Time</span><span>${Math.round(d.time/60)} min (${d.pct}%)</span></div>
              <div class="pos-stat"><span>Spd/VMG</span><span>${d.speed}/${d.vmg} kts</span></div>
              <div class="pos-stat"><span>COG Corridor</span><span>¬±${d.corridor}¬∞</span></div>
              <div class="pos-stat"><span>Line Deviation</span><span>${devDisplay}</span></div>
              <div class="pos-stat"><span>Steer Rate</span><span>${d.rate}¬∞/s</span></div>
              ${!isGarmin ? `<div class="pos-stat"><span>Avg Heel</span><span>${d.heel}¬∞</span></div>` : ''}
            </div>
          `;
        }).join('');
      }
    }

    function renderLegTimelineWidget(leg) {
      if (!leg || !DATA) return;
      
      const container = document.getElementById('leg-timeline-bar');
      if (!container) return;
      
      // Calculate leg position within full session duration
      const fullDuration = DATA.fullDuration || DATA.s.dur;
      const trimStartMin = DATA.timelineStart || 0;
      
      // Leg times are relative to trimmed start
      // Convert to absolute position in full session
      const legAbsoluteStart = trimStartMin + leg.start;
      const legAbsoluteEnd = trimStartMin + leg.end;
      
      const legStartPct = (legAbsoluteStart / fullDuration) * 100;
      const legEndPct = (legAbsoluteEnd / fullDuration) * 100;
      const legWidthPct = legEndPct - legStartPct;
      
      // Calculate playback pointer position within the leg
      const absolutePlaybackMin = trimStartMin + playbackTime;
      const playbackPct = (absolutePlaybackMin / fullDuration) * 100;
      
      // Position of sail colors
      const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };
      const legColor = posColors[leg.pos] || '#7c3aed';
      
      let html = '';
      
      // Background - full session duration
      html += `<div style="position:absolute;left:0;right:0;top:6px;height:20px;background:#e5e7eb;border-radius:3px;"></div>`;
      
      // Leg segment - highlighted
      html += `<div style="position:absolute;left:${legStartPct}%;width:${legWidthPct}%;top:6px;height:20px;background:${legColor};opacity:0.8;border-radius:3px;"></div>`;
      
      // Playback pointer
      if (playbackPct >= legStartPct && playbackPct <= legEndPct) {
        html += `<div id="leg-timeline-pointer" style="position:absolute;left:${playbackPct}%;top:0;width:3px;height:32px;background:#7c3aed;border-radius:2px;transform:translateX(-50%);z-index:15;pointer-events:none;box-shadow:0 0 4px #7c3aed;"></div>`;
      }
      
      // Time labels
      const legStartTime = `${legAbsoluteStart.toFixed(1)}m`;
      const legEndTime = `${legAbsoluteEnd.toFixed(1)}m`;
      html += `<div style="position:absolute;left:${legStartPct}%;bottom:0;font-size:9px;color:#6b7280;transform:translateX(-50%);">${legStartTime}</div>`;
      html += `<div style="position:absolute;left:${legEndPct}%;bottom:0;font-size:9px;color:#6b7280;transform:translateX(-50%);">${legEndTime}</div>`;
      
      container.innerHTML = html;
      
      // Add click handler for seeking
      container.addEventListener('click', (e) => {
        const rect = container.getBoundingClientRect();
        const clickPct = ((e.clientX - rect.left) / rect.width) * 100;
        
        // Convert click percentage to absolute time in full session
        const clickAbsoluteMin = (clickPct / 100) * fullDuration;
        
        // Clamp to leg boundaries
        const clampedMin = Math.max(legAbsoluteStart, Math.min(legAbsoluteEnd, clickAbsoluteMin));
        
        // Convert to playback time (relative to trimmed start)
        playbackTime = Math.max(0, clampedMin - trimStartMin);
        
        // Update UI
        updatePlaybackUI();
        updateBoatInfoPanel();
        updateCurrentLegsPanel();
        updateChartTimePointers();
        updateTimelinePlaybackPointer();
        updateLegTimelinePointer();
        renderMap();
        
        // Update video if present
        if (typeof updateActiveVideoDisplay !== 'undefined') updateActiveVideoDisplay();
        if (typeof syncVideosToPlayback !== 'undefined') syncVideosToPlayback(true);
      });
    }
    
    function updateLegTimelinePointer() {
      if (!selectedLeg || !DATA) return;
      
      const pointer = document.getElementById('leg-timeline-pointer');
      if (!pointer) return;
      
      const fullDuration = DATA.fullDuration || DATA.s.dur;
      const trimStartMin = DATA.timelineStart || 0;
      const absolutePlaybackMin = trimStartMin + playbackTime;
      const playbackPct = (absolutePlaybackMin / fullDuration) * 100;
      
      // Check if playback is within selected leg
      const legAbsoluteStart = trimStartMin + selectedLeg.start;
      const legAbsoluteEnd = trimStartMin + selectedLeg.end;
      
      if (playbackPct >= (legAbsoluteStart / fullDuration) * 100 && 
          playbackPct <= (legAbsoluteEnd / fullDuration) * 100) {
        pointer.style.left = `${playbackPct}%`;
        pointer.style.display = 'block';
      } else {
        pointer.style.display = 'none';
      }
    }

    function selectLeg(leg) {
      if (selectedLeg?.id === leg?.id) {
        clearSelection();
        return;
      }
      selectedLeg = leg;
      
      // Update selected leg badge in view config card
      const badge = document.getElementById('selected-leg-badge-config');
      const text = document.getElementById('selected-leg-text-config');
      if (badge) badge.classList.remove('hidden');
      if (text) text.textContent = `Leg #${leg.id}`;
      
      const intervalHelp = document.getElementById('interval-help');
      if (leg.isOutsideTrim) {
        if (intervalHelp) intervalHelp.innerHTML = `<span class="text-purple" style="font-weight:500;">Leg #${leg.id}</span> <span style="color:#9ca3af;">(outside trim - limited data)</span>`;
      } else {
        if (intervalHelp) intervalHelp.innerHTML = `<span class="text-purple" style="font-weight:500;">Leg #${leg.id} selected</span> - <button onclick="switchTab('leg-details')" style="color:#7c3aed;text-decoration:underline;background:none;border:none;cursor:pointer;">view details ‚Üí</button>`;
      }
      
      renderMap();
      renderLegsTable();
      renderLegDetail(leg.isOutsideTrim ? null : leg);
      renderScatterCharts();
      renderTimeline();
      
      // Update fullscreen footer if in fullscreen mode
      if (mapFullscreen) {
        updateFsSelectedLegDetails();
      }
      
      // Scroll to selected leg row in the table and reset detail panel scroll
      if (!leg.isOutsideTrim) {
        setTimeout(() => {
          const row = document.querySelector(`#legs-tbody tr[data-leg="${leg.id}"]`);
          const scrollContainer = document.getElementById('legs-scroll-container');
          if (row && scrollContainer) {
            const rowTop = row.offsetTop;
            const rowHeight = row.offsetHeight;
            // Position selected row as second from top (one row visible above it)
            // Account for sticky header (~35px)
            scrollContainer.scrollTo({
              top: Math.max(0, rowTop - rowHeight - 35),
              behavior: 'smooth'
            });
          }
          
          // Also scroll side table in legs view mode
          if (viewMode === 'legs') {
            const sideRow = document.querySelector(`#legs-tbody-side tr.selected`);
            const sideScrollContainer = document.getElementById('legs-scroll-container-side');
            if (sideRow && sideScrollContainer) {
              const sideRowTop = sideRow.offsetTop;
              const sideRowHeight = sideRow.offsetHeight;
              sideScrollContainer.scrollTo({
                top: Math.max(0, sideRowTop - sideRowHeight - 35),
                behavior: 'smooth'
              });
            }
          }
        }, 50);
      }
    }

    function clearSelection() {
      selectedLeg = null;
      const badge = document.getElementById('selected-leg-badge-config');
      if (badge) badge.classList.add('hidden');
      const intervalHelp = document.getElementById('interval-help');
      if (intervalHelp) intervalHelp.textContent = 'Click dots to select leg on map.';
      renderMap();
      renderLegsTable();
      renderLegDetail(null);
      renderScatterCharts();
      renderTimeline();
    }
    
    // Navigate to next/previous leg
    function navigateLegs(direction) {
      if (!DATA || !DATA.legs || DATA.legs.length === 0) return;
      
      const filter = document.getElementById('pos-filter-config')?.value || 'all';
      const filteredLegs = filter === 'all' ? DATA.legs : DATA.legs.filter(l => l.pos === filter);
      
      if (filteredLegs.length === 0) return;
      
      let currentIndex = -1;
      if (selectedLeg) {
        currentIndex = filteredLegs.findIndex(l => l.id === selectedLeg.id);
      }
      
      let newIndex;
      if (direction === 'next') {
        // Don't wrap around - stop at end
        if (currentIndex >= filteredLegs.length - 1) return;
        newIndex = currentIndex + 1;
      } else {
        // Don't wrap around - stop at beginning
        if (currentIndex <= 0) return;
        newIndex = currentIndex - 1;
      }
      
      selectLeg(filteredLegs[newIndex]);
      
      // In multi-session mode, broadcast navigation to iframes
      if (!isIframeMode && ALL_SESSIONS.length > 1) {
        broadcastToIframes('navigateLeg', { direction });
      }
    }
    
    // Handle keyboard navigation for legs in initial screen
    function handleInitialScreenKeydown(e) {
      // Don't handle if in race replay mode
      if (raceReplayMode) return;
      
      // Don't handle if focus is in an input field
      const activeElement = document.activeElement;
      if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT')) {
        return;
      }
      
      // Don't handle if dashboard is not visible
      const dashboard = document.getElementById('dashboard');
      if (!dashboard || dashboard.classList.contains('hidden')) return;
      
      if (e.code === 'ArrowDown' || e.code === 'ArrowRight') {
        e.preventDefault();
        navigateLegs('next');
      } else if (e.code === 'ArrowUp' || e.code === 'ArrowLeft') {
        e.preventDefault();
        navigateLegs('prev');
      } else if (e.code === 'Escape') {
        if (selectedLeg) {
          e.preventDefault();
          clearSelection();
        }
      }
    }
    
    // Add keyboard listener for initial screen
    document.addEventListener('keydown', handleInitialScreenKeydown);
    
    // Global keyboard listener for performance widget toggle (q key)
    document.addEventListener('keydown', function(e) {
      // Don't handle if focus is in an input field
      const activeElement = document.activeElement;
      if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT')) {
        return;
      }
      
      // Toggle performance/quality widget with 'Z' key
      if (e.code === 'KeyZ') {
        const perfWidget = document.getElementById('video-fps-sync');
        if (perfWidget) {
          const isVisible = perfWidget.classList.contains('perf-visible');
          if (isVisible) {
            perfWidget.classList.remove('perf-visible');
            perfWidget.style.display = 'none';
          } else {
            perfWidget.classList.add('perf-visible');
            perfWidget.style.display = 'flex';
          }
        }
      }
      
      // Show hotkey help popup with 'I' key
      if (e.code === 'KeyI') {
        showHotkeyHelp();
      }
      
      // Show telemetry offset popup with 'T' key
      if (e.code === 'KeyT') {
        showTelemetryOffsetPopup();
      }
      
      // Tilt correction controls for 360 video (Q and W keys)
      if (current360Player && (e.code === 'KeyQ' || e.code === 'KeyW')) {
        const delta = e.code === 'KeyQ' ? -0.5 : 0.5;  // 0.5 degrees per press
        tiltCorrection360 += delta * Math.PI / 180;
        tiltCorrection360 = Math.max(-30 * Math.PI / 180, Math.min(30 * Math.PI / 180, tiltCorrection360));
        
        // Update all shader uniforms
        // Use 0 base roll for equirectangular, rollAngle360 for dual-fisheye
        const baseRoll = current360Format === 'equirectangular' ? 0 : rollAngle360;
        const totalRoll = baseRoll + tiltCorrection360;
        if (threeSphere && threeSphere.material && threeSphere.material.uniforms) {
          threeSphere.material.uniforms.rollAngle.value = totalRoll;
        }
        if (megaViewMaterial && megaViewMaterial.uniforms) {
          megaViewMaterial.uniforms.rollAngle.value = totalRoll;
        }
        if (materialDual && materialDual.uniforms) {
          materialDual.uniforms.rollAngle.value = totalRoll;
        }
        if (materialFrontOnly && materialFrontOnly.uniforms) {
          materialFrontOnly.uniforms.rollAngle.value = totalRoll;
        }
        if (materialBackOnly && materialBackOnly.uniforms) {
          materialBackOnly.uniforms.rollAngle.value = totalRoll;
        }
        
        // Update display
        updateViewModeTag360();
        console.log('Tilt correction:', (tiltCorrection360 * 180 / Math.PI).toFixed(1) + '¬∞');
      }
      
      // Tilt 2 correction controls for 360 video (A and S keys) - perpendicular rotation
      if (current360Player && (e.code === 'KeyA' || e.code === 'KeyS')) {
        const delta = e.code === 'KeyA' ? -0.5 : 0.5;  // 0.5 degrees per press
        tilt2Correction360 += delta * Math.PI / 180;
        tilt2Correction360 = Math.max(-30 * Math.PI / 180, Math.min(30 * Math.PI / 180, tilt2Correction360));
        
        // Update all shader uniforms
        if (threeSphere && threeSphere.material && threeSphere.material.uniforms && threeSphere.material.uniforms.tilt2) {
          threeSphere.material.uniforms.tilt2.value = tilt2Correction360;
        }
        if (megaViewMaterial && megaViewMaterial.uniforms && megaViewMaterial.uniforms.tilt2) {
          megaViewMaterial.uniforms.tilt2.value = tilt2Correction360;
        }
        if (materialDual && materialDual.uniforms && materialDual.uniforms.tilt2) {
          materialDual.uniforms.tilt2.value = tilt2Correction360;
        }
        if (materialFrontOnly && materialFrontOnly.uniforms && materialFrontOnly.uniforms.tilt2) {
          materialFrontOnly.uniforms.tilt2.value = tilt2Correction360;
        }
        if (materialBackOnly && materialBackOnly.uniforms && materialBackOnly.uniforms.tilt2) {
          materialBackOnly.uniforms.tilt2.value = tilt2Correction360;
        }
        
        // Update display
        updateViewModeTag360();
        console.log('Tilt 2:', (tilt2Correction360 * 180 / Math.PI).toFixed(1) + '¬∞');
      }
      
      // Reset both corrections with '0' key
      if (current360Player && e.key === '0') {
        tiltCorrection360 = 0;
        tilt2Correction360 = 0;
        // Use 0 base roll for equirectangular, rollAngle360 for dual-fisheye
        const baseRoll = current360Format === 'equirectangular' ? 0 : rollAngle360;
        const totalRoll = baseRoll + tiltCorrection360;
        if (threeSphere && threeSphere.material && threeSphere.material.uniforms) {
          threeSphere.material.uniforms.rollAngle.value = totalRoll;
          if (threeSphere.material.uniforms.tilt2) {
            threeSphere.material.uniforms.tilt2.value = 0;
          }
        }
        if (megaViewMaterial && megaViewMaterial.uniforms) {
          megaViewMaterial.uniforms.rollAngle.value = totalRoll;
          if (megaViewMaterial.uniforms.tilt2) {
            megaViewMaterial.uniforms.tilt2.value = 0;
          }
        }
        if (materialDual && materialDual.uniforms) {
          materialDual.uniforms.rollAngle.value = totalRoll;
          if (materialDual.uniforms.tilt2) {
            materialDual.uniforms.tilt2.value = 0;
          }
        }
        if (materialFrontOnly && materialFrontOnly.uniforms) {
          materialFrontOnly.uniforms.rollAngle.value = totalRoll;
          if (materialFrontOnly.uniforms.tilt2) {
            materialFrontOnly.uniforms.tilt2.value = 0;
          }
        }
        if (materialBackOnly && materialBackOnly.uniforms) {
          materialBackOnly.uniforms.rollAngle.value = totalRoll;
          if (materialBackOnly.uniforms.tilt2) {
            materialBackOnly.uniforms.tilt2.value = 0;
          }
        }
        updateViewModeTag360();
        console.log('Tilt corrections reset to 0¬∞');
      }
    });

    function applyFilter() {
      // Broadcast to iframes if in multi-session mode
      if (multiSessionView && !isIframeMode) {
        const filterEl = document.getElementById('pos-filter-config');
        if (filterEl) {
          broadcastToIframes('setFilter', { filter: filterEl.value });
        }
      }
      
      renderLegsTable();
      renderLegDetail(selectedLeg);
      renderScatterCharts();
      
      // Re-check leg selection after filter change
      preselectFirstVisibleLeg();
    }

    function switchTab(tabId) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');
      document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
      document.getElementById(`tab-${tabId}`).classList.remove('hidden');
    }

    // Store all sessions for comparison
    let ALL_SESSIONS = [];

    function resetDashboard() {
      DATA = null;
      selectedLeg = null;
      mapZoom = 1;
      mapPanX = 0;
      mapPanY = 0;
      if (rateChart) { rateChart.destroy(); rateChart = null; }
      if (corridorChart) { corridorChart.destroy(); corridorChart = null; }
      if (magCorridorChart) { magCorridorChart.destroy(); magCorridorChart = null; }
      if (legRateChart) { legRateChart.destroy(); legRateChart = null; }
      if (legCogChart) { legCogChart.destroy(); legCogChart = null; }
      if (legMagChart) { legMagChart.destroy(); legMagChart = null; }
      if (legHeelChart) { legHeelChart.destroy(); legHeelChart = null; }
      document.getElementById('upload-section').classList.remove('hidden');
      document.getElementById('upload-zone').classList.remove('hidden');
      document.getElementById('dashboard').classList.add('hidden');
      document.getElementById('loading').classList.add('hidden');
      resetWizardState();  // Reset wizard to step 1
      
      // Reset file input by replacing it (allows re-selecting same file)
      const oldInput = document.getElementById('file-input');
      const newInput = document.createElement('input');
      newInput.type = 'file';
      newInput.id = 'file-input';
      // Add accept filter for desktop only (mobile has issues with accept)
      if (!isMobile) {
        newInput.accept = '.vkx,.fit,.gpx,.gz,.csv';
      }
      newInput.multiple = true;
      newInput.style.display = 'none';
      newInput.addEventListener('change', handleFileSelect);
      oldInput.parentNode.insertBefore(newInput, oldInput);
      oldInput.remove();
      
      renderComparison();
    }

    function handleFileSelect(e) {
      const files = Array.from(e.target.files).filter(f => {
        const name = f.name.toLowerCase();
        return name.endsWith('.vkx') || name.endsWith('.fit') || name.endsWith('.gpx') || name.endsWith('.csv') || name.endsWith('.gz');
      });
      if (files.length > 0) processFiles(files);
    }

    function clearAllSessions() {
      ALL_SESSIONS = [];
      selectedSessionsForReplay.clear();
      replaySessionOrder = [];
      window.lastKnownSessionCount = 0;
      resetDashboard();
    }

    // ===== FILE HANDLING =====
    const uploadZone = document.getElementById('upload-zone');

    uploadZone.addEventListener('click', (e) => {
      if (e.target.tagName !== 'INPUT') {
        document.getElementById('file-input').click();
      }
    });
    uploadZone.addEventListener('dragover', e => { e.preventDefault(); uploadZone.classList.add('dragover'); });
    uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('dragover'));
    uploadZone.addEventListener('drop', e => {
      e.preventDefault();
      uploadZone.classList.remove('dragover');
      const files = Array.from(e.dataTransfer.files).filter(f => {
        const name = f.name.toLowerCase();
        return name.endsWith('.vkx') || name.endsWith('.fit') || name.endsWith('.gpx') || name.endsWith('.csv') || name.endsWith('.gz');
      });
      if (files.length > 0) processFiles(files);
    });
    
    // Initial file input listener
    document.getElementById('file-input').addEventListener('change', handleFileSelect);
    
    // Video file input - use event delegation for iOS compatibility
    document.addEventListener('change', function(e) {
      if (e.target && e.target.id === 'video-file-input') {
        handleVideoFiles(e);
      }
    });
    document.addEventListener('input', function(e) {
      if (e.target && e.target.id === 'video-file-input') {
        handleVideoFiles(e);
      }
    });

    async function processFiles(files) {
      document.getElementById('upload-zone').classList.add('hidden');
      document.getElementById('loading').classList.remove('hidden');

      try {
        for (const file of files) {
          let buffer = await file.arrayBuffer();
          
          // Check if gzipped and decompress
          const bytes = new Uint8Array(buffer);
          if (bytes[0] === 0x1f && bytes[1] === 0x8b) {
            // Gzip compressed - decompress using pako
            const pako = await loadPako();
            const decompressed = pako.ungzip(bytes);
            buffer = decompressed.buffer;
          }
          
          // Detect file type and parse
          const fileType = detectFileType(buffer);
          let records;
          let dataSource = 'vkx';
          
          if (fileType === 'FIT') {
            records = parseFIT(buffer);
            dataSource = 'garmin';
            console.log(`Parsed ${records.length} GPS records from Garmin FIT file: ${file.name}`);
          } else if (fileType === 'GPX') {
            records = parseGPX(buffer);
            dataSource = 'garmin'; // Treat GPX same as Garmin (GPS-only, no compass)
            console.log(`Parsed ${records.length} GPS records from GPX file: ${file.name}`);
          } else if (fileType === 'CSV') {
            records = parseCSV(buffer);
            dataSource = 'vkx'; // CSV has full telemetry like VKX
            console.log(`Parsed ${records.length} telemetry records from CSV file: ${file.name}`);
          } else {
            records = parseVKX(buffer);
            dataSource = 'vkx';
            console.log(`Parsed ${records.length} telemetry records from VKX file: ${file.name}`);
          }

          const sessionData = analyzeSession(records);
          sessionData.filename = file.name;
          sessionData.rawRecords = records;
          sessionData.dataSource = dataSource; // Track data source for UI adaptation
          
          // Calculate actual session duration from the last leg's end time (not sum of leg durations)
          const actualDuration = sessionData.legs.length > 0 
            ? Math.max(...sessionData.legs.map(l => l.end))
            : sessionData.s.dur;
          
          sessionData.timelineStart = 0; // Start time in minutes (relative)
          sessionData.timelineEnd = actualDuration; // End time in minutes
          sessionData.fullDuration = actualDuration; // Original full duration (actual elapsed time)
          
          // Store original milestones from full analysis (for timeline display)
          sessionData.originalMilestones = sessionData.legs
            .filter(leg => leg.next_maneuver)
            .map(leg => ({
              time: leg.end,
              type: leg.next_maneuver.type,
              angle: leg.next_maneuver.angle
            }));
          // Store original legs for timeline display
          sessionData.originalLegs = sessionData.legs.map(leg => ({
            id: leg.id,
            start: leg.start,
            end: leg.end,
            pos: leg.pos,
            startLat: leg.startLat,
            startLon: leg.startLon,
            endLat: leg.endLat,
            endLon: leg.endLon
          }));
          // Store original track for map display with grey regions
          sessionData.originalTrack = sessionData.track.slice();
          // Store session start timestamp (ms) for time of day labels
          sessionData.startTimestampMs = records[0].timestamp_ms;
          
          ALL_SESSIONS.push(sessionData);
          console.log(`Detected ${sessionData.legs.length} legs, ${sessionData.intervals.length} intervals`);
        }

        // Sort sessions by timestamp (newest first), then by filename
        ALL_SESSIONS.sort((a, b) => {
          // Compare by timestamp (newer sessions first)
          if (a.s.timestamp !== b.s.timestamp) {
            return b.s.timestamp - a.s.timestamp;
          }
          // Same timestamp, sort by filename (descending)
          return b.filename.localeCompare(a.filename);
        });

        // Apply auto-trim if enabled
        if (document.getElementById('auto-trim-checkbox')?.checked) {
          ALL_SESSIONS.forEach((session, idx) => {
            applyAutoTrim(idx);
          });
        }

        // Use first session as active (newest after sorting)
        DATA = ALL_SESSIONS[0];

        document.getElementById('upload-section').classList.add('hidden');
        document.getElementById('dashboard').classList.remove('hidden');
        updateWizardState({ trackLoaded: true });  // Update wizard
        renderDashboard();
        renderComparison();
        
        // Delay map fit to ensure DOM is fully rendered with correct dimensions
        setTimeout(() => {
          fitMapToTrimmedTrack(); // Auto-fit map to track
        }, 50);
        
        // Pre-select first leg so leg details panel isn't empty
        if (DATA.legs && DATA.legs.length > 0) {
          selectLeg(DATA.legs[0]);
        }
      } catch (err) {
        console.error(err);
        alert('Error processing file: ' + err.message);
        document.getElementById('upload-zone').classList.remove('hidden');
        document.getElementById('loading').classList.add('hidden');
      }
    }

    function switchSession(index) {
      DATA = ALL_SESSIONS[index];
      selectedLeg = null;
      
      renderDashboard();
      renderComparison();
      renderTimeline();
      fitMapToTrimmedTrack(); // Auto-fit map to new session's track
      
      // Pre-select first leg so leg details panel isn't empty
      if (DATA.legs && DATA.legs.length > 0) {
        selectLeg(DATA.legs[0]);
      }
    }

    function renderComparison() {
      const container = document.getElementById('comparison-section');
      if (!container) return;
      
      if (ALL_SESSIONS.length < 1) {
        container.classList.add('hidden');
        return;
      }
      
      container.classList.remove('hidden');
      const activeIdx = ALL_SESSIONS.indexOf(DATA);
      
      // Check if we're in aligned timeline mode (multiple sessions)
      const hasMultipleSessions = !raceReplayMode && ALL_SESSIONS.length > 1;
      let virtualTrimSessions = null;
      
      // Only calculate virtual trim if analysis range is set
      const hasAnalysisRange = analysisRangeStartMs !== null && analysisRangeEndMs !== null;
      if (hasMultipleSessions && hasAnalysisRange) {
        // Calculate virtual trim for each session (overlap between timeslot and actual trim)
        const timeslotStartMs = analysisRangeStartMs;
        const timeslotEndMs = analysisRangeEndMs;
        
        // Calculate virtual trim for each session
        virtualTrimSessions = ALL_SESSIONS.map(session => {
          const sessionStartMs = session.startTimestampMs || 0;
          const fullDuration = session.fullDuration || session.s.dur;
          
          // Get session's current trim range in absolute ms
          const trimStartMin = session.timelineStart || 0;
          const trimEndMin = session.timelineEnd || fullDuration;
          const sessionTrimStartMs = sessionStartMs + trimStartMin * 60000;
          const sessionTrimEndMs = sessionStartMs + trimEndMin * 60000;
          
          // Calculate overlap between timeslot and session trim
          const overlapStartMs = Math.max(timeslotStartMs, sessionTrimStartMs);
          const overlapEndMs = Math.min(timeslotEndMs, sessionTrimEndMs);
          
          // If there's no overlap, return null
          if (overlapStartMs >= overlapEndMs) {
            return null;
          }
          
          // Convert overlap back to session-local minutes
          const virtualStartMin = Math.max(0, (overlapStartMs - sessionStartMs) / 60000);
          const virtualEndMin = Math.min(fullDuration, (overlapEndMs - sessionStartMs) / 60000);
          
          // Filter legs to those within virtual trim
          const virtualLegs = session.legs.filter(leg => {
            // Leg times are relative to trim start, so adjust them
            const legAbsStart = trimStartMin + leg.start;
            const legAbsEnd = trimStartMin + leg.end;
            
            // Check if leg overlaps with virtual trim
            const overlapStart = Math.max(virtualStartMin, legAbsStart);
            const overlapEnd = Math.min(virtualEndMin, legAbsEnd);
            return overlapEnd > overlapStart;
          });
          
          return {
            ...session,
            legs: virtualLegs,
            virtualStartMin,
            virtualEndMin
          };
        });
      }
      
      // Helper: calculate median (robust to outliers, good for "typical" values)
      const median = (arr) => {
        if (!arr.length) return null;
        const sorted = [...arr].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
      };
      
      // Helper: calculate weighted average
      const weightedAvg = (legs, prop) => {
        if (legs.length === 0) return 0;
        const totalDur = legs.reduce((s, l) => s + l.dur, 0);
        if (totalDur === 0) return 0;
        return legs.reduce((s, l) => s + (typeof l[prop] === 'string' ? parseFloat(l[prop]) : l[prop]) * l.dur, 0) / totalDur;
      };
      
      // Pre-calculate stats for each session (using virtual trim if in aligned mode)
      const sessionsForStats = virtualTrimSessions || ALL_SESSIONS;
      const sessionStats = sessionsForStats.map((session, idx) => {
        if (!session) {
          // No overlap with timeslot
          return {
            tackCount: 0,
            gybeCount: 0,
            tackAngle: null,
            gybeAngle: null,
            speedUp: 0,
            speedDn: 0,
            vmgUp: 0,
            vmgDn: 0,
            heelUp: 0,
            heelDn: 0,
            corrUp: 999,
            corrDn: 999,
            magUp: 999,
            magDn: 999,
            mag70Up: 999,
            mag70Dn: 999,
            rateUp: 999,
            rateDn: 999,
            devUp: 999,
            devDn: 999
          };
        }
        
        const tackAngles = session.legs
          .filter(l => l.next_maneuver?.type === 'tack')
          .map(l => l.next_maneuver.angle);
        const gybeAngles = session.legs
          .filter(l => l.next_maneuver?.type === 'gybe')
          .map(l => l.next_maneuver.angle);
        
        // If we have virtual trim (analysis range), calculate stats from filtered legs
        // Otherwise use the session's pre-calculated stats
        if (virtualTrimSessions) {
          const upwindLegs = session.legs.filter(l => l.pos === 'upwind' && parseFloat(l.speed) > 1);
          const downwindLegs = session.legs.filter(l => l.pos === 'downwind' && parseFloat(l.speed) > 1);
          
          return {
            tackCount: tackAngles.length,
            gybeCount: gybeAngles.length,
            tackAngle: tackAngles.length ? Math.round(median(tackAngles)) : null,
            gybeAngle: gybeAngles.length ? Math.round(median(gybeAngles)) : null,
            speedUp: upwindLegs.length ? weightedAvg(upwindLegs, 'speed') : 0,
            speedDn: downwindLegs.length ? weightedAvg(downwindLegs, 'speed') : 0,
            vmgUp: upwindLegs.length ? weightedAvg(upwindLegs, 'vmg') : 0,
            vmgDn: downwindLegs.length ? weightedAvg(downwindLegs, 'vmg') : 0,
            heelUp: upwindLegs.length ? weightedAvg(upwindLegs, 'heel') : 0,
            heelDn: downwindLegs.length ? weightedAvg(downwindLegs, 'heel') : 0,
            corrUp: upwindLegs.length ? weightedAvg(upwindLegs, 'corridor') : 999,
            corrDn: downwindLegs.length ? weightedAvg(downwindLegs, 'corridor') : 999,
            magUp: upwindLegs.length ? weightedAvg(upwindLegs, 'mag_corridor') : 999,
            magDn: downwindLegs.length ? weightedAvg(downwindLegs, 'mag_corridor') : 999,
            mag70Up: upwindLegs.length ? weightedAvg(upwindLegs, 'mag70') : 999,
            mag70Dn: downwindLegs.length ? weightedAvg(downwindLegs, 'mag70') : 999,
            rateUp: upwindLegs.length ? weightedAvg(upwindLegs, 'rate') : 999,
            rateDn: downwindLegs.length ? weightedAvg(downwindLegs, 'rate') : 999,
            devUp: upwindLegs.length ? weightedAvg(upwindLegs, 'lineDeviation') * 100 : 999,
            devDn: downwindLegs.length ? weightedAvg(downwindLegs, 'lineDeviation') * 100 : 999
          };
        }
        
        // Use original session stats when not in analysis range mode
        const originalSession = ALL_SESSIONS[idx];
        
        return {
          tackCount: tackAngles.length,
          gybeCount: gybeAngles.length,
          tackAngle: tackAngles.length ? Math.round(median(tackAngles)) : null,
          gybeAngle: gybeAngles.length ? Math.round(median(gybeAngles)) : null,
          speedUp: parseFloat(originalSession.o.speed_upwind) || 0,
          speedDn: parseFloat(originalSession.o.speed_downwind) || 0,
          vmgUp: parseFloat(originalSession.o.vmg_upwind) || 0,
          vmgDn: parseFloat(originalSession.o.vmg_downwind) || 0,
          heelUp: parseFloat(originalSession.o.heel_upwind) || 0,
          heelDn: parseFloat(originalSession.o.heel_downwind) || 0,
          corrUp: parseFloat(originalSession.o.corridor_upwind) || 999,
          corrDn: parseFloat(originalSession.o.corridor_downwind) || 999,
          magUp: parseFloat(originalSession.o.mag_corridor_upwind) || 999,
          magDn: parseFloat(originalSession.o.mag_corridor_downwind) || 999,
          mag70Up: parseFloat(originalSession.o.mag70_upwind) || 999,
          mag70Dn: parseFloat(originalSession.o.mag70_downwind) || 999,
          rateUp: parseFloat(originalSession.o.rate_upwind) || 999,
          rateDn: parseFloat(originalSession.o.rate_downwind) || 999,
          devUp: parseFloat(originalSession.o.linedev_upwind) || 999,
          devDn: parseFloat(originalSession.o.linedev_downwind) || 999
        };
      });
      
      // Find best values for highlighting
      const bestSpeedUp = Math.max(...sessionStats.map(s => s.speedUp));
      const bestSpeedDn = Math.max(...sessionStats.map(s => s.speedDn));
      const bestVmgUp = Math.max(...sessionStats.map(s => s.vmgUp));
      const bestVmgDn = Math.max(...sessionStats.map(s => s.vmgDn));
      const bestCorrUp = Math.min(...sessionStats.filter(s => s.corrUp < 999).map(s => s.corrUp));
      const bestCorrDn = Math.min(...sessionStats.filter(s => s.corrDn < 999).map(s => s.corrDn));
      const bestMagUp = Math.min(...sessionStats.filter(s => s.magUp < 999).map(s => s.magUp));
      const bestMagDn = Math.min(...sessionStats.filter(s => s.magDn < 999).map(s => s.magDn));
      const bestMag70Up = Math.min(...sessionStats.filter(s => s.mag70Up < 999).map(s => s.mag70Up));
      const bestMag70Dn = Math.min(...sessionStats.filter(s => s.mag70Dn < 999).map(s => s.mag70Dn));
      const bestRateUp = Math.min(...sessionStats.filter(s => s.rateUp < 999).map(s => s.rateUp));
      const bestRateDn = Math.min(...sessionStats.filter(s => s.rateDn < 999).map(s => s.rateDn));
      const bestDevUp = Math.min(...sessionStats.filter(s => s.devUp < 999).map(s => s.devUp));
      const bestDevDn = Math.min(...sessionStats.filter(s => s.devDn < 999).map(s => s.devDn));
      
      // In race replay mode, always use detailed view (show legs)
      // In normal mode, respect the checkbox
      const summaryView = raceReplayMode ? false : (document.getElementById('summary-view-checkbox')?.checked ?? true);
      const hasGarmin = ALL_SESSIONS.some(s => s.dataSource === 'garmin');
      
      // Only auto-select NEW sessions (not previously seen)
      // Track the max index we've seen to detect truly new additions
      if (!window.lastKnownSessionCount) window.lastKnownSessionCount = 0;
      
      // Add only new sessions (indices >= lastKnownSessionCount)
      for (let idx = window.lastKnownSessionCount; idx < ALL_SESSIONS.length; idx++) {
        selectedSessionsForReplay.add(idx);
      }
      window.lastKnownSessionCount = ALL_SESSIONS.length;
      
      // Remove any indices that no longer exist (e.g., sessions were cleared)
      selectedSessionsForReplay.forEach(idx => {
        if (idx >= ALL_SESSIONS.length) {
          selectedSessionsForReplay.delete(idx);
        }
      });
      
      let html = `
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
          <h3 style="margin:0;">Sessions Comparison (${ALL_SESSIONS.length} files)</h3>
          <div style="display:flex;align-items:center;gap:12px;">
            <button class="btn btn-sm btn-start-replay" onclick="startRaceReplay()" ${selectedSessionsForReplay.size < 1 ? 'disabled title="Select at least 1 session"' : ''}>
              üèÅ Start Race Replay (${selectedSessionsForReplay.size})
            </button>
            <label style="display:flex;align-items:center;gap:4px;font-size:0.75rem;cursor:pointer;">
              <input type="checkbox" id="summary-view-checkbox" ${summaryView ? 'checked' : ''} ${raceReplayMode ? 'disabled' : ''} onchange="renderComparison()">
              Summary View
            </label>
            <button class="btn btn-sm" onclick="clearAllSessions()">Clear All</button>
          </div>
        </div>
        <div style="overflow-x:auto;">
          <table style="width:100%;font-size:0.75rem;">
            <thead>
              <tr>
                <th style="width:30px;text-align:center;"><input type="checkbox" ${selectedSessionsForReplay.size === ALL_SESSIONS.length ? 'checked' : ''} onchange="toggleAllSessionsForReplay(this.checked)" title="Select all for replay"></th>
                <th>File</th>
                <th>Date</th>
                ${!summaryView ? '<th style="text-align:right;">Dur</th>' : ''}
                ${!summaryView ? '<th style="text-align:right;">Wind</th>' : ''}
                ${!summaryView ? '<th style="text-align:right;">Legs</th>' : ''}
                ${!summaryView ? '<th style="text-align:right;">Tacks</th>' : ''}
                <th style="text-align:right;">Tack¬∞</th>
                ${!summaryView ? '<th style="text-align:right;">Gybes</th>' : ''}
                <th style="text-align:right;">Gybe¬∞</th>
                <th style="text-align:right;">Spd/VMG‚Üë</th>
                <th style="text-align:right;">Spd/VMG‚Üì</th>
                ${!hasGarmin ? '<th style="text-align:right;">Heel‚Üë</th>' : ''}
                ${!hasGarmin ? '<th style="text-align:right;">Heel‚Üì</th>' : ''}
                <th style="text-align:right;">COG‚Üë</th>
                <th style="text-align:right;">COG‚Üì</th>
                ${!hasGarmin ? '<th style="text-align:right;">MAG70/90‚Üë</th>' : ''}
                ${!hasGarmin ? '<th style="text-align:right;">MAG70/90‚Üì</th>' : ''}
                <th style="text-align:right;">Dev‚Üë</th>
                <th style="text-align:right;">Dev‚Üì</th>
                <th style="text-align:right;">Rate‚Üë</th>
                <th style="text-align:right;">Rate‚Üì</th>
                <th></th>
              </tr>
            </thead>
            <tbody>
      `;
      
      ALL_SESSIONS.forEach((session, idx) => {
        const isActive = idx === activeIdx;
        const stats = sessionStats[idx];
        
        // In aligned mode, use virtual session leg count
        const displaySession = (virtualTrimSessions && virtualTrimSessions[idx]) ? virtualTrimSessions[idx] : session;
        const legCount = displaySession ? displaySession.legs.length : 0;
        
        const bestSpUpStyle = stats.speedUp === bestSpeedUp || stats.vmgUp === bestVmgUp ? 'color:#22c55e;font-weight:bold;' : '';
        const bestSpDnStyle = stats.speedDn === bestSpeedDn || stats.vmgDn === bestVmgDn ? 'color:#22c55e;font-weight:bold;' : '';
        const bestCrUpStyle = stats.corrUp === bestCorrUp ? 'color:#22c55e;font-weight:bold;' : '';
        const bestCrDnStyle = stats.corrDn === bestCorrDn ? 'color:#22c55e;font-weight:bold;' : '';
        const bestMag70UpStyle = stats.mag70Up === bestMag70Up && stats.mag70Up < 999 ? 'color:#22c55e;font-weight:bold;' : '';
        const bestMag70DnStyle = stats.mag70Dn === bestMag70Dn && stats.mag70Dn < 999 ? 'color:#22c55e;font-weight:bold;' : '';
        const bestDevUpStyle = stats.devUp === bestDevUp && stats.devUp < 999 ? 'color:#22c55e;font-weight:bold;' : '';
        const bestDevDnStyle = stats.devDn === bestDevDn && stats.devDn < 999 ? 'color:#22c55e;font-weight:bold;' : '';
        const bestRtUpStyle = stats.rateUp === bestRateUp ? 'color:#22c55e;font-weight:bold;' : '';
        const bestRtDnStyle = stats.rateDn === bestRateDn ? 'color:#22c55e;font-weight:bold;' : '';
        
        const rowStyle = isActive 
          ? 'background:#ede9fe;' 
          : 'cursor:pointer;';
        const hoverAttr = isActive ? '' : 'onmouseover="this.style.background=\'#f5f3ff\'" onmouseout="this.style.background=\'\'"';
        
        html += `
          <tr style="${rowStyle}" ${hoverAttr} ${!isActive ? `onclick="switchSession(${idx})"` : ''}>
            <td style="text-align:center;" onclick="event.stopPropagation()">
              <input type="checkbox" ${selectedSessionsForReplay.has(idx) ? 'checked' : ''} onchange="toggleSessionForReplay(${idx}, this.checked)" title="Include in race replay">
            </td>
            <td style="max-width:120px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;${isActive ? 'font-weight:500;' : ''}" title="${session.filename}">${session.filename}</td>
            <td>${session.s.d}</td>
            ${!summaryView ? `<td style="text-align:right;">${session.s.dur}m</td>` : ''}
            ${!summaryView ? `<td style="text-align:right;">${session.s.twd}¬∞</td>` : ''}
            ${!summaryView ? `<td style="text-align:right;">${legCount}</td>` : ''}
            ${!summaryView ? `<td style="text-align:right;">${stats.tackCount}</td>` : ''}
            <td style="text-align:right;">${stats.tackAngle !== null ? stats.tackAngle + '¬∞' : '-'}</td>
            ${!summaryView ? `<td style="text-align:right;">${stats.gybeCount}</td>` : ''}
            <td style="text-align:right;">${stats.gybeAngle !== null ? stats.gybeAngle + '¬∞' : '-'}</td>
            <td style="text-align:right;${bestSpUpStyle}">${stats.speedUp > 0 ? stats.speedUp.toFixed(1) : '-'}/${stats.vmgUp > 0 ? stats.vmgUp.toFixed(1) : '-'}</td>
            <td style="text-align:right;${bestSpDnStyle}">${stats.speedDn > 0 ? stats.speedDn.toFixed(1) : '-'}/${stats.vmgDn > 0 ? stats.vmgDn.toFixed(1) : '-'}</td>
            ${!hasGarmin ? `<td style="text-align:right;">${stats.heelUp > 0 ? Math.round(stats.heelUp) : '-'}¬∞</td>` : ''}
            ${!hasGarmin ? `<td style="text-align:right;">${stats.heelDn > 0 ? Math.round(stats.heelDn) : '-'}¬∞</td>` : ''}
            <td style="text-align:right;${bestCrUpStyle}">¬±${stats.corrUp < 999 ? stats.corrUp.toFixed(1) : '-'}¬∞</td>
            <td style="text-align:right;${bestCrDnStyle}">¬±${stats.corrDn < 999 ? stats.corrDn.toFixed(1) : '-'}¬∞</td>
            ${!hasGarmin ? `<td style="text-align:right;${bestMag70UpStyle}">${stats.mag70Up < 999 ? stats.mag70Up.toFixed(1) : '-'}¬∞/${stats.magUp < 999 ? stats.magUp.toFixed(1) : '-'}¬∞</td>` : ''}
            ${!hasGarmin ? `<td style="text-align:right;${bestMag70DnStyle}">${stats.mag70Dn < 999 ? stats.mag70Dn.toFixed(1) : '-'}¬∞/${stats.magDn < 999 ? stats.magDn.toFixed(1) : '-'}¬∞</td>` : ''}
            <td style="text-align:right;${bestDevUpStyle}">${stats.devUp < 999 ? stats.devUp.toFixed(1) : '-'}%</td>
            <td style="text-align:right;${bestDevDnStyle}">${stats.devDn < 999 ? stats.devDn.toFixed(1) : '-'}%</td>
            <td style="text-align:right;${bestRtUpStyle}">${stats.rateUp < 999 ? stats.rateUp.toFixed(2) : '-'}</td>
            <td style="text-align:right;${bestRtDnStyle}">${stats.rateDn < 999 ? stats.rateDn.toFixed(2) : '-'}</td>
            <td style="text-align:center;">${isActive ? '<span style="color:#7c3aed;">‚óè</span>' : ''}</td>
          </tr>
        `;
      });
      
      html += '</tbody></table></div>';
      html += '<p class="text-xs" style="color:#6b7280;margin-top:8px;"><span style="color:#22c55e;">‚óè</span> Best value (higher speed/VMG, lower corridor/deviation/rate) ‚Ä¢ Tack¬∞/Gybe¬∞ = median angle</p>';
      container.innerHTML = html;
      
      // Update view config card visibility
      updateViewConfigCard();
    }

    // ===== TIMELINE SELECTION =====
    let timelineCollapsed = false;
    let isDraggingTimeline = null; // { sessionIdx, handle: 'start'|'end' }
    let timelineDragStartX = 0;
    let timelineDragStartPct = 0;
    let timelineDragEndPct = 0;
    let pendingTimelineUpdate = null;

    function toggleTimelineSection() {
      timelineCollapsed = !timelineCollapsed;
      document.getElementById('timeline-content').classList.toggle('collapsed', timelineCollapsed);
      document.getElementById('timeline-fold-icon').classList.toggle('collapsed', timelineCollapsed);
    }

    function getSessionTimelinePcts(session) {
      const fullDur = session.fullDuration || session.s.dur;
      const start = session.timelineStart || 0;
      const end = session.timelineEnd || fullDur;
      return {
        startPct: (start / fullDur) * 100,
        endPct: (end / fullDur) * 100
      };
    }

    function renderTimeline() {
      if (!DATA) return;
      
      const container = document.getElementById('all-timelines-container');
      if (!container) return;
      
      // In race replay mode, render a global timeline view
      if (raceReplayMode) {
        renderRaceReplayTimeline();
        return;
      }
      
      // Check if we have multiple sessions - if so, use timestamp alignment
      const hasMultipleSessions = ALL_SESSIONS.length > 1;
      
      if (hasMultipleSessions) {
        renderAlignedTimeline();
        return;
      }
      
      // Single session mode - original rendering
      // Count sessions with active filters
      const filteredCount = ALL_SESSIONS.filter(s => {
        const fullDur = s.fullDuration || s.s.dur;
        return (s.timelineStart || 0) > 0.1 || (s.timelineEnd || fullDur) < fullDur - 0.1;
      }).length;
      
      // Update summary
      const summary = document.getElementById('timeline-summary');
      if (filteredCount > 0) {
        summary.textContent = `(${filteredCount} filtered)`;
        document.getElementById('reset-all-btn').style.display = '';
      } else {
        summary.textContent = '';
        document.getElementById('reset-all-btn').style.display = 'none';
      }
      
      let html = '';
      
      const sessionsToRender = ALL_SESSIONS.map((s, idx) => ({ session: s, idx }));
      
      sessionsToRender.forEach(({ session, idx }) => {
        const isActive = session === DATA;
        const fullDuration = session.fullDuration || session.s.dur;
        const { startPct, endPct } = getSessionTimelinePcts(session);
        const selStart = (startPct / 100) * fullDuration;
        const selEnd = (endPct / 100) * fullDuration;
        const isFiltered = startPct > 0.1 || endPct < 99.9;
        
        const fullShortName = session.filename.replace('.vkx', '').replace('.fit', '').replace('.gpx', '').replace('.csv', '').replace('.gz', '').substring(0, 30);
        const rangeText = isFiltered ? `${selStart.toFixed(1)}-${selEnd.toFixed(1)}m selected` : '';
        
        const nameColor = isActive ? '#7c3aed' : '#6b7280';
        
        // Don't allow switching sessions by clicking in race replay mode
        const clickHandler = !isActive ? `onclick="switchSession(${idx})"` : '';
        
        const trackClass = isActive ? 'active' : 'inactive';
        
        html += `
          <div class="timeline-track ${trackClass}" data-session="${idx}" ${clickHandler}>
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
              <span class="text-sm" style="font-weight:${isActive ? '600' : '400'};color:${nameColor};display:flex;align-items:center;">${fullShortName}</span>
              ${rangeText ? `<span class="text-xs" style="color:#9ca3af;">${rangeText}</span>` : ''}
            </div>
            <div class="timeline-bar" data-session="${idx}" style="position:relative;height:42px;"></div>
          </div>
        `;
      });
      
      container.innerHTML = html;
      
      // Render each timeline SVG
      sessionsToRender.forEach(({ session, idx }) => {
        renderSingleTimeline(session, idx, session === DATA);
      });
    }
    
    // Aligned timeline - shows all sessions aligned to global time (similar to race replay but for normal mode)
    function renderAlignedTimeline() {
      const container = document.getElementById('all-timelines-container');
      if (!container) return;
      
      // Calculate global time range using FULL (untrimmed) duration
      const globalStartMs = Math.min(...ALL_SESSIONS.map(s => s.startTimestampMs || 0));
      const globalEndMs = Math.max(...ALL_SESSIONS.map(s => (s.startTimestampMs || 0) + (s.fullDuration || s.s.dur) * 60000));
      const totalDurationMs = globalEndMs - globalStartMs;
      const totalDurationMin = totalDurationMs / 60000;
      
      if (totalDurationMs <= 0) {
        container.innerHTML = '<p class="text-xs" style="color:#9ca3af;">Invalid time range.</p>';
        return;
      }
      
      // Helper: convert absolute ms timestamp to percentage on global timeline
      const msToGlobalPct = (ms) => ((ms - globalStartMs) / totalDurationMs) * 100;
      
      const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };
      
      // Update summary
      const summary = document.getElementById('timeline-summary');
      summary.textContent = `(${ALL_SESSIONS.length} sessions, ${totalDurationMin.toFixed(1)} min)`;
      document.getElementById('reset-all-btn').style.display = '';
      
      let html = '';
      
      // Render each session on the global timeline
      ALL_SESSIONS.forEach((session, sessionIdx) => {
        const isActive = session === DATA;
        const startTimestampMs = session.startTimestampMs || 0;
        const fullDuration = session.fullDuration || session.s.dur;
        
        // Full session range (untrimmed)
        const fullStartMs = startTimestampMs;
        const fullEndMs = startTimestampMs + fullDuration * 60000;
        const fullLeftPct = msToGlobalPct(fullStartMs);
        const fullRightPct = msToGlobalPct(fullEndMs);
        const fullWidthPct = Math.max(1, fullRightPct - fullLeftPct);
        
        // Get trimmed range
        const trimStartMin = session.timelineStart || 0;
        const trimEndMin = session.timelineEnd || fullDuration;
        const trimmedStartMs = startTimestampMs + trimStartMin * 60000;
        const trimmedEndMs = startTimestampMs + trimEndMin * 60000;
        const sessionLeftPct = msToGlobalPct(trimmedStartMs);
        const sessionRightPct = msToGlobalPct(trimmedEndMs);
        
        const originalLegs = session.originalLegs || session.legs || [];
        const fullShortName = session.filename.replace('.vkx', '').replace('.fit', '').replace('.gpx', '').replace('.csv', '').replace('.gz', '').substring(0, 30);
        
        const nameColor = isActive ? '#7c3aed' : '#6b7280';
        const clickHandler = !isActive ? `onclick="switchSession(${sessionIdx})"` : '';
        const trackClass = isActive ? 'active' : 'inactive';
        
        // Time labels
        const sessionStartDate = new Date(startTimestampMs);
        const sessionEndDate = new Date(startTimestampMs + fullDuration * 60000);
        const sessionStartTime = sessionStartDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
        const sessionEndTime = sessionEndDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
        
        html += `
          <div class="timeline-track ${trackClass}" data-session="${sessionIdx}" ${clickHandler} style="padding:6px 10px;margin-bottom:4px;">
            <div style="display:flex;align-items:center;gap:6px;">
              <div style="display:flex;align-items:center;width:120px;flex-shrink:0;">
                <span style="font-size:11px;color:${nameColor};font-weight:${isActive ? '600' : '400'};overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${fullShortName}</span>
              </div>
              <div class="aligned-timeline-bar" data-session="${sessionIdx}" style="flex:1;position:relative;height:24px;cursor:pointer;">
                <!-- Full timeline background -->
                <div style="position:absolute;left:0;right:0;top:4px;height:16px;background:#e5e7eb;border-radius:3px;"></div>
                <!-- Session background -->
                <div style="position:absolute;left:${fullLeftPct}%;width:${fullWidthPct}%;top:4px;height:16px;background:${isActive ? '#c4b5fd' : '#d1d5db'};opacity:0.3;border-radius:3px;"></div>`;
        
        // Render leg segments from originalLegs
        originalLegs.forEach((leg) => {
          const legStartMs = startTimestampMs + leg.start * 60000;
          const legEndMs = startTimestampMs + leg.end * 60000;
          
          const leftPct = msToGlobalPct(legStartMs);
          const rightPct = msToGlobalPct(legEndMs);
          const widthPct = Math.max(0.3, rightPct - leftPct);
          const legColor = posColors[leg.pos] || '#9ca3af';
          
          html += `<div class="aligned-tl-leg" data-session="${sessionIdx}" data-leg-id="${leg.id}" style="position:absolute;left:${leftPct}%;top:6px;width:${widthPct}%;height:12px;background:${legColor};opacity:${isActive ? 0.85 : 0.4};border-radius:2px;cursor:pointer;"></div>`;
        });
        
        // Trimming handles
        const handleColor = isActive ? '#7c3aed' : '#9ca3af';
        html += `
                <div class="aligned-trim-handle" data-session="${sessionIdx}" data-handle="start" style="position:absolute;left:${sessionLeftPct}%;top:0;width:6px;height:24px;background:${handleColor};border-radius:2px;cursor:ew-resize;transform:translateX(-50%);z-index:20;box-shadow:0 1px 3px rgba(0,0,0,0.3);"></div>
                <div class="aligned-trim-handle" data-session="${sessionIdx}" data-handle="end" style="position:absolute;left:${sessionRightPct}%;top:0;width:6px;height:24px;background:${handleColor};border-radius:2px;cursor:ew-resize;transform:translateX(-50%);z-index:20;box-shadow:0 1px 3px rgba(0,0,0,0.3);"></div>
              </div>
            </div>
            <div style="display:flex;align-items:center;gap:6px;margin-top:2px;">
              <div style="width:120px;flex-shrink:0;"></div>
              <div style="flex:1;position:relative;display:flex;font-size:9px;color:#9ca3af;padding:0 4px;">
                <span style="position:absolute;left:calc(${fullLeftPct}% + 2px);">${sessionStartTime}</span>
                <span style="position:absolute;left:calc(${fullRightPct}% - 2px);transform:translateX(-100%);">${sessionEndTime}</span>
              </div>
            </div>
          </div>`;
      });
      
      // Add "Selected Timeslot" row for filtering
      const playbackMs = globalStartMs + playbackTime * 60000;
      const playbackPct = msToGlobalPct(playbackMs);
      
      html += `
        <div style="display:flex;align-items:center;gap:6px;margin-top:8px;padding:6px 10px;background:#fef3c7;border-radius:8px;border:1px solid #fcd34d;">
          <div style="display:flex;align-items:center;width:120px;flex-shrink:0;">
            <span style="font-size:11px;color:#b45309;font-weight:600;">üìä Analysis Range</span>
          </div>
          <div style="flex:1;position:relative;height:24px;cursor:pointer;" id="aligned-timeline-selector">
            <div style="position:absolute;left:0;right:0;top:4px;height:16px;background:#fde68a;border-radius:3px;"></div>
            <div id="aligned-selection-range" style="position:absolute;top:4px;height:16px;background:#f59e0b;opacity:0.4;border-radius:3px;left:${replayTimelineStartPct}%;right:${100 - replayTimelineEndPct}%;"></div>
            <div id="aligned-handle-start" style="position:absolute;top:0;width:8px;height:24px;background:#d97706;border-radius:3px;cursor:ew-resize;left:${replayTimelineStartPct}%;transform:translateX(-50%);z-index:20;box-shadow:0 1px 3px rgba(0,0,0,0.3);"></div>
            <div id="aligned-handle-end" style="position:absolute;top:0;width:8px;height:24px;background:#d97706;border-radius:3px;cursor:ew-resize;left:${replayTimelineEndPct}%;transform:translateX(-50%);z-index:20;box-shadow:0 1px 3px rgba(0,0,0,0.3);"></div>
          </div>
        </div>`;
      
      // Add global time labels
      const globalStartDate = new Date(globalStartMs);
      const globalEndDate = new Date(globalEndMs);
      const startTimeStr = globalStartDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
      const endTimeStr = globalEndDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
      
      html += `
        <div style="display:flex;align-items:center;gap:6px;margin-top:4px;padding:0 10px;">
          <div style="width:120px;flex-shrink:0;"></div>
          <div style="flex:1;position:relative;display:flex;justify-content:space-between;font-size:9px;color:#6b7280;">
            <span>${startTimeStr}</span>`;
      
      // Add interval labels (15 min intervals)
      const startMinOfDay = globalStartDate.getHours() * 60 + globalStartDate.getMinutes();
      const firstInterval = Math.ceil(startMinOfDay / 15) * 15;
      const offsetMin = firstInterval - startMinOfDay;
      
      for (let min = offsetMin; min <= totalDurationMin; min += 15) {
        const pct = (min / totalDurationMin) * 100;
        if (pct < 8 || pct > 92) continue;
        
        const labelDate = new Date(globalStartMs + min * 60000);
        const timeStr = labelDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
        html += `<span style="position:absolute;left:${pct}%;transform:translateX(-50%);">${timeStr}</span>`;
      }
      
      html += `
            <span>${endTimeStr}</span>
          </div>
        </div>`;
      
      container.innerHTML = html;
      
      // Add event listeners
      initAlignedTimelineInteractions();
    }
    
    // Initialize interactions for aligned timeline (normal mode with multiple sessions)
    function initAlignedTimelineInteractions() {
      const globalStartMs = Math.min(...ALL_SESSIONS.map(s => s.startTimestampMs || 0));
      const globalEndMs = Math.max(...ALL_SESSIONS.map(s => (s.startTimestampMs || 0) + (s.fullDuration || s.s.dur) * 60000));
      const totalDurationMs = globalEndMs - globalStartMs;
      
      // Timeslot selector handles
      const selector = document.getElementById('aligned-timeline-selector');
      const handleStart = document.getElementById('aligned-handle-start');
      const handleEnd = document.getElementById('aligned-handle-end');
      
      let dragState = null;
      
      const onMouseMove = (e) => {
        if (!dragState) return;
        
        const rect = selector.getBoundingClientRect();
        const pct = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
        
        if (dragState.type === 'start') {
          replayTimelineStartPct = Math.min(pct, replayTimelineEndPct - 1);
          handleStart.style.left = `${replayTimelineStartPct}%`;
          document.getElementById('aligned-selection-range').style.left = `${replayTimelineStartPct}%`;
        } else if (dragState.type === 'end') {
          replayTimelineEndPct = Math.max(pct, replayTimelineStartPct + 1);
          handleEnd.style.left = `${replayTimelineEndPct}%`;
          document.getElementById('aligned-selection-range').style.right = `${100 - replayTimelineEndPct}%`;
        } else if (dragState.type === 'playback') {
          // Update playback position
          playbackTime = (pct / 100) * (totalDurationMs / 60000);
          indicator.style.left = `${pct}%`;
          updatePlaybackUI();
          updateBoatInfoPanel();
          updateCurrentLegsPanel();
          updateChartTimePointers();
          updateTimelinePlaybackPointer();
          renderMap();
          if (typeof updateActiveVideoDisplay !== 'undefined') updateActiveVideoDisplay();
          if (typeof syncVideosToPlayback !== 'undefined') syncVideosToPlayback(true);
        }
      };
      
      const onMouseUp = () => {
        if (dragState) {
          if (dragState.type === 'start' || dragState.type === 'end') {
            // Timeslot changed - re-calculate statistics based on virtual trim
            // Virtual trim = overlap between timeslot and each session's actual trim
            cachedRacingMarks = null;
            
            // Update absolute timestamps from percentages
            updateAnalysisRangeFromPct();
            
            // Broadcast to iframes if in multi-session mode
            if (multiSessionView && !isIframeMode) {
              console.log('[Parent] Broadcasting setAnalysisRange to iframes:', analysisRangeStartMs, '-', analysisRangeEndMs);
              broadcastToIframes('setAnalysisRange', {
                startMs: analysisRangeStartMs,
                endMs: analysisRangeEndMs
              });
            }
            
            renderMap();
            renderLegsTable();
            if (viewMode === 'legs') {
              updateSideLegsTable();
            }
            renderScatterCharts();
            renderComparison();
            
            // Re-check leg selection after range change
            preselectFirstVisibleLeg();
          }
          dragState = null;
        }
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
      };
      
      if (handleStart) {
        handleStart.addEventListener('mousedown', (e) => {
          e.preventDefault();
          e.stopPropagation();
          dragState = { type: 'start' };
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });
      }
      
      if (handleEnd) {
        handleEnd.addEventListener('mousedown', (e) => {
          e.preventDefault();
          e.stopPropagation();
          dragState = { type: 'end' };
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });
      }
      
      // Trim handles for sessions
      document.querySelectorAll('.aligned-trim-handle').forEach(handle => {
        handle.addEventListener('mousedown', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          const sessionIdx = parseInt(handle.dataset.session);
          const handleType = handle.dataset.handle;
          const session = ALL_SESSIONS[sessionIdx];
          if (!session) return;
          
          let trimDragState = { sessionIdx, handleType, session, globalStartMs, totalDurationMs };
          
          const onTrimMove = (e) => {
            const bar = document.querySelector(`.aligned-timeline-bar[data-session="${sessionIdx}"]`);
            if (!bar) return;
            
            const rect = bar.getBoundingClientRect();
            const pct = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
            
            // Convert global timeline percentage to session time
            const fullDuration = session.fullDuration || session.s.dur;
            const timeMin = (pct / 100) * (totalDurationMs / 60000);
            
            // Convert to session-local time
            const sessionStartMs = session.startTimestampMs || 0;
            const sessionOffsetMin = (sessionStartMs - globalStartMs) / 60000;
            const sessionLocalMin = timeMin - sessionOffsetMin;
            
            // Clamp to valid range
            const currentStart = session.timelineStart || 0;
            const currentEnd = session.timelineEnd || fullDuration;
            
            if (handleType === 'start') {
              const newStart = Math.max(0, Math.min(currentEnd - 0.5, sessionLocalMin));
              session.timelineStart = newStart;
            } else {
              const newEnd = Math.max(currentStart + 0.5, Math.min(fullDuration, sessionLocalMin));
              session.timelineEnd = newEnd;
            }
            
            // Update handle position visually
            const newTrimStartMs = (session.startTimestampMs || 0) + (session.timelineStart || 0) * 60000;
            const newTrimEndMs = (session.startTimestampMs || 0) + (session.timelineEnd || fullDuration) * 60000;
            const startPct = ((newTrimStartMs - globalStartMs) / totalDurationMs) * 100;
            const endPct = ((newTrimEndMs - globalStartMs) / totalDurationMs) * 100;
            
            const startHandle = bar.querySelector('.aligned-trim-handle[data-handle="start"]');
            const endHandle = bar.querySelector('.aligned-trim-handle[data-handle="end"]');
            if (startHandle) startHandle.style.left = `${startPct}%`;
            if (endHandle) endHandle.style.left = `${endPct}%`;
            
            // Update map to show grey areas
            renderMap();
          };
          
          const onTrimUp = () => {
            // Apply final trim change - re-analyze session
            const pcts = getSessionTimelinePcts(session);
            applyTimelineChange(sessionIdx, pcts.startPct, pcts.endPct, true);
            renderTimeline();
            renderMap();
            renderLegsTable();
            if (viewMode === 'legs') {
              updateSideLegsTable();
            }
            renderScatterCharts();
            renderComparison();
            
            // Broadcast to iframes if in multi-session mode
            if (multiSessionView && !isIframeMode) {
              // Send updated trim range to corresponding iframe
              const iframe = document.getElementById(`session-iframe-${sessionIdx}`);
              if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage({
                  type: 'setTrimRange',
                  payload: {
                    start: session.timelineStart || 0,
                    end: session.timelineEnd || (session.fullDuration || session.s.dur)
                  }
                }, '*');
              }
            }
            
            // If this is the active session, update dashboard
            if (session === DATA) {
              DATA = ALL_SESSIONS[sessionIdx];
              selectedLeg = null;
              renderDashboard();
            }
            
            // Re-check leg selection after trim change
            preselectFirstVisibleLeg();
            
            document.removeEventListener('mousemove', onTrimMove);
            document.removeEventListener('mouseup', onTrimUp);
          };
          
          document.addEventListener('mousemove', onTrimMove);
          document.addEventListener('mouseup', onTrimUp);
        });
      });
      
      // Click on timeline bars to switch sessions (background clicks only)
      document.querySelectorAll('.aligned-timeline-bar').forEach(bar => {
        bar.addEventListener('click', (e) => {
          // Don't switch if clicking on handles
          if (e.target.classList.contains('aligned-trim-handle')) return;
          
          const sessionIdx = parseInt(bar.dataset.session);
          const session = ALL_SESSIONS[sessionIdx];
          if (!session || session === DATA) return; // Already active
          
          switchSession(sessionIdx);
        });
      });
    }
    
    // Race replay mode timeline - shows all sessions aligned to global time
    function renderRaceReplayTimeline() {
      const container = document.getElementById('all-timelines-container');
      if (!container) return;
      
      const sessions = getReplaySessions();
      if (sessions.length === 0) {
        container.innerHTML = '<p class="text-xs" style="color:#9ca3af;">No sessions selected for replay.</p>';
        return;
      }
      
      // Calculate global time range using FULL (untrimmed) duration
      const globalStartMs = getFullStartTimeMs();
      const globalEndMs = getFullEndTimeMs();
      const totalDurationMs = globalEndMs - globalStartMs;
      const totalDurationMin = totalDurationMs / 60000;
      
      if (totalDurationMs <= 0) {
        container.innerHTML = '<p class="text-xs" style="color:#9ca3af;">Invalid time range.</p>';
        return;
      }
      
      // Helper: convert absolute ms timestamp to percentage on global timeline
      const msToGlobalPct = (ms) => ((ms - globalStartMs) / totalDurationMs) * 100;
      
      // Calculate current playback position as percentage
      const currentPlaybackMs = globalStartMs + playbackTime * 60000;
      const playbackPct = msToGlobalPct(currentPlaybackMs);
      
      const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };
      
      // Update summary
      const summary = document.getElementById('timeline-summary');
      summary.textContent = `(${sessions.length} boats, ${totalDurationMin.toFixed(1)} min)`;
      document.getElementById('reset-all-btn').style.display = 'none';
      
      let html = '';
      
      // Render each session on the global timeline - show FULL session with trim handles
      sessions.forEach((session, boatIdx) => {
        const color = BOAT_COLORS[boatIdx % BOAT_COLORS.length];
        const boatSymbol = getBoatSymbol(session.filename);
        const startTimestampMs = session.startTimestampMs || 0;
        const fullDuration = session.fullDuration || session.s.dur;
        const originalIdx = replaySessionOrder[boatIdx];
        
        // Full session range (untrimmed)
        const fullStartMs = startTimestampMs;
        const fullEndMs = startTimestampMs + fullDuration * 60000;
        const fullLeftPct = msToGlobalPct(fullStartMs);
        const fullRightPct = msToGlobalPct(fullEndMs);
        const fullWidthPct = Math.max(1, fullRightPct - fullLeftPct);
        
        // Get trimmed range in minutes from original session start
        const trimStartMin = session.timelineStart || 0;
        const trimEndMin = session.timelineEnd || fullDuration;
        
        // Calculate the actual trimmed start/end in absolute ms
        const trimmedStartMs = startTimestampMs + trimStartMin * 60000;
        const trimmedEndMs = startTimestampMs + trimEndMin * 60000;
        
        // Position on global timeline (for trim handles)
        const sessionLeftPct = msToGlobalPct(trimmedStartMs);
        const sessionRightPct = msToGlobalPct(trimmedEndMs);
        const sessionWidthPct = Math.max(1, sessionRightPct - sessionLeftPct);
        
        // Use originalLegs for full track display
        const originalLegs = session.originalLegs || session.legs || [];
        
        // Calculate time labels for this session
        const sessionStartDate = new Date(startTimestampMs);
        const sessionEndDate = new Date(startTimestampMs + fullDuration * 60000);
        const sessionStartTime = sessionStartDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
        const sessionEndTime = sessionEndDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
        
        html += `
          <div class="timeline-track active draggable" data-session="${originalIdx}" draggable="true" style="padding:6px 10px;margin-bottom:4px;">
            <div style="display:flex;align-items:center;gap:6px;">
              <span class="drag-handle" title="Drag to reorder">‚ò∞</span>
              <div style="display:flex;align-items:center;width:60px;flex-shrink:0;">
                <span style="display:inline-flex;align-items:center;justify-content:center;width:16px;height:16px;border-radius:50%;background:${color};color:white;font-size:9px;font-weight:bold;margin-right:4px;">${boatIdx + 1}</span>
                <span style="font-size:11px;color:${color};font-weight:600;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${boatSymbol}</span>
              </div>
              <div class="replay-timeline-bar" data-session="${originalIdx}" style="flex:1;position:relative;height:24px;cursor:pointer;" draggable="false">
                <!-- Full timeline background (gray) -->
                <div style="position:absolute;left:0;right:0;top:4px;height:16px;background:#e5e7eb;border-radius:3px;"></div>
                <!-- Session background -->
                <div class="replay-session-range" style="position:absolute;left:${fullLeftPct}%;width:${fullWidthPct}%;top:4px;height:16px;background:${color};opacity:0.15;border-radius:3px;"></div>`;
        
        // Render leg segments from originalLegs (full track)
        originalLegs.forEach((leg) => {
          // Original legs have times relative to session start (not trimmed start)
          const legStartMs = startTimestampMs + leg.start * 60000;
          const legEndMs = startTimestampMs + leg.end * 60000;
          
          const leftPct = msToGlobalPct(legStartMs);
          const rightPct = msToGlobalPct(legEndMs);
          const widthPct = Math.max(0.3, rightPct - leftPct);
          const legColor = posColors[leg.pos] || '#9ca3af';
          
          html += `<div style="position:absolute;left:${leftPct}%;top:6px;width:${widthPct}%;height:12px;background:${legColor};opacity:0.85;border-radius:2px;"></div>`;
        });
        
        // Trimming handles at trim boundaries
        html += `
                <div class="replay-trim-handle" data-session="${originalIdx}" data-handle="start" style="position:absolute;left:${sessionLeftPct}%;top:0;width:6px;height:24px;background:${color};border-radius:2px;cursor:ew-resize;transform:translateX(-50%);z-index:20;box-shadow:0 1px 3px rgba(0,0,0,0.3);"></div>
                <div class="replay-trim-handle" data-session="${originalIdx}" data-handle="end" style="position:absolute;left:${sessionRightPct}%;top:0;width:6px;height:24px;background:${color};border-radius:2px;cursor:ew-resize;transform:translateX(-50%);z-index:20;box-shadow:0 1px 3px rgba(0,0,0,0.3);"></div>`;
        
        // Playback position marker
        html += `
                <div class="replay-playback-marker" style="position:absolute;left:${playbackPct}%;top:0;width:2px;height:24px;background:#dc2626;pointer-events:none;z-index:15;box-shadow:0 0 3px #dc2626;"></div>
              </div>
            </div>
            <div style="display:flex;align-items:center;gap:6px;margin-top:2px;">
              <div style="width:28px;flex-shrink:0;"></div>
              <div style="width:60px;flex-shrink:0;"></div>
              <div style="flex:1;position:relative;display:flex;font-size:9px;color:#9ca3af;padding:0 4px;">
                <span style="position:absolute;left:calc(${fullLeftPct}% + 2px);">${sessionStartTime}</span>
                <span style="position:absolute;left:calc(${fullRightPct}% - 2px);transform:translateX(-100%);">${sessionEndTime}</span>
              </div>
            </div>
          </div>`;
      });
      
      // Add "Selected Timeslot" row - structure matches session rows for alignment
      html += `
        <div style="display:flex;align-items:center;gap:6px;margin-top:8px;padding:6px 10px;background:#fef3c7;border-radius:8px;border:1px solid #fcd34d;">
          <div style="width:28px;flex-shrink:0;"></div>
          <div style="display:flex;align-items:center;width:60px;flex-shrink:0;">
            <span style="font-size:11px;color:#b45309;font-weight:600;">üé¨ Timeslot</span>
          </div>
          <div style="flex:1;position:relative;height:24px;cursor:pointer;" id="replay-timeline-selector">
            <div style="position:absolute;left:0;right:0;top:4px;height:16px;background:#fde68a;border-radius:3px;"></div>
            <div id="replay-selection-range" style="position:absolute;top:4px;height:16px;background:#f59e0b;opacity:0.4;border-radius:3px;left:${replayTimelineStartPct}%;right:${100 - replayTimelineEndPct}%;"></div>
            <div id="replay-handle-start" style="position:absolute;top:0;width:8px;height:24px;background:#d97706;border-radius:3px;cursor:ew-resize;left:${replayTimelineStartPct}%;transform:translateX(-50%);z-index:20;box-shadow:0 1px 3px rgba(0,0,0,0.3);"></div>
            <div id="replay-handle-end" style="position:absolute;top:0;width:8px;height:24px;background:#d97706;border-radius:3px;cursor:ew-resize;left:${replayTimelineEndPct}%;transform:translateX(-50%);z-index:20;box-shadow:0 1px 3px rgba(0,0,0,0.3);"></div>
            <div id="replay-playback-indicator" style="position:absolute;left:${playbackPct}%;top:0;width:12px;height:24px;background:linear-gradient(90deg, transparent 0%, transparent 40%, #dc2626 40%, #dc2626 60%, transparent 60%, transparent 100%);cursor:ew-resize;z-index:15;transform:translateX(-50%);"></div>
          </div>
        </div>`;
      
      // Add global time labels
      const globalStartDate = new Date(globalStartMs);
      const globalEndDate = new Date(globalEndMs);
      const startTimeStr = globalStartDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
      const endTimeStr = globalEndDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
      
      html += `
        <div style="display:flex;align-items:center;gap:6px;margin-top:4px;padding:0 10px;">
          <div style="width:28px;flex-shrink:0;"></div>
          <div style="width:60px;flex-shrink:0;"></div>
          <div style="flex:1;position:relative;display:flex;justify-content:space-between;font-size:9px;color:#6b7280;">
            <span>${startTimeStr}</span>`;
      
      // Add interval labels
      const startMinOfDay = globalStartDate.getHours() * 60 + globalStartDate.getMinutes();
      const firstInterval = Math.ceil(startMinOfDay / 15) * 15;
      const offsetMin = firstInterval - startMinOfDay;
      
      for (let min = offsetMin; min <= totalDurationMin; min += 15) {
        const pct = (min / totalDurationMin) * 100;
        if (pct < 8 || pct > 92) continue;
        
        const labelDate = new Date(globalStartMs + min * 60000);
        const timeStr = labelDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
        html += `<span style="position:absolute;left:${pct}%;transform:translateX(-50%);">${timeStr}</span>`;
      }
      
      html += `
            <span>${endTimeStr}</span>
          </div>
        </div>`;
      
      container.innerHTML = html;
      
      // Add drag-and-drop event listeners
      initTimelineDragDrop();
      
      // Add timeslot selector interaction
      initReplayTimelineSelector();
      
      // Add click-to-seek for all session timeline bars
      initReplayTimelineBarClicks();
      
      // Add trimming handles for session tracks
      initReplayTrimHandles();
    }
    
    // Global state for trim handle dragging
    let trimDragState = null;
    
    function initReplayTrimHandles() {
      // Use shared handler for consistency between main and fullscreen panels
      document.querySelectorAll('#all-timelines-container .replay-trim-handle').forEach(handle => {
        // Remove any existing listener by cloning (prevents double-binding)
        const newHandle = handle.cloneNode(true);
        handle.parentNode.replaceChild(newHandle, handle);
        
        newHandle.addEventListener('mousedown', handleTrimMouseDown);
      });
    }
    
    // Initialize trim handles in the fullscreen panel's cloned timeline
    function initFsTrimHandles() {
      const fsDetailsPanel = document.getElementById('fs-details-panel');
      if (!fsDetailsPanel) return;
      
      // Find trim handles only within the fullscreen panel and add listeners
      fsDetailsPanel.querySelectorAll('.replay-trim-handle').forEach(handle => {
        // Remove any existing listener by cloning (prevents double-binding)
        const newHandle = handle.cloneNode(true);
        handle.parentNode.replaceChild(newHandle, handle);
        
        newHandle.addEventListener('mousedown', handleTrimMouseDown);
      });
      
      // Also initialize drag-to-seek on timeline bars
      initFsTimelineBarSeek(fsDetailsPanel);
    }
    
    // Shared mousedown handler for trim handles (works for both panels)
    function handleTrimMouseDown(e) {
      e.preventDefault();
      e.stopPropagation();
      
      const handle = e.currentTarget;
      const sessionIdx = parseInt(handle.dataset.session);
      const handleType = handle.dataset.handle;
      const session = ALL_SESSIONS[sessionIdx];
      if (!session) return;
      
      const bar = handle.closest('.replay-timeline-bar');
      if (!bar) return;
      
      // Get fresh values at drag time
      const globalStartMs = getFullStartTimeMs();
      const globalEndMs = getFullEndTimeMs();
      const totalDurationMs = globalEndMs - globalStartMs;
      
      if (totalDurationMs <= 0) return;
      
      trimDragState = {
        sessionIdx,
        handleType,
        session,
        bar,
        globalStartMs,
        totalDurationMs
      };
      
      document.addEventListener('mousemove', onTrimHandleMove);
      document.addEventListener('mouseup', onTrimHandleUpUnified);
    }
    
    // Shared click handler for timeline bars (supports drag-to-seek)
    function initFsTimelineBarSeek(fsDetailsPanel) {
      const globalStartMs = getFullStartTimeMs();
      const globalEndMs = getFullEndTimeMs();
      const totalDurationMs = globalEndMs - globalStartMs;
      
      if (totalDurationMs <= 0) return;
      
      fsDetailsPanel.querySelectorAll('.replay-timeline-bar').forEach(bar => {
        let isDragging = false;
        
        const getMousePct = (e) => {
          const rect = bar.getBoundingClientRect();
          return Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
        };
        
        const seekToPosition = (pct) => {
          playbackTime = (pct / 100) * (totalDurationMs / 60000);
          updatePlaybackUI();
          renderMap();
          updateReplayTimelineMarkers();
          syncVideosToPlayback(true);
        };
        
        const onDragStart = (e) => {
          // Skip if clicking on trim handles
          if (e.target.classList.contains('replay-trim-handle')) return;
          
          e.preventDefault();
          e.stopPropagation();
          isDragging = true;
          seekToPosition(getMousePct(e));
          document.addEventListener('mousemove', onDragMove);
          document.addEventListener('mouseup', onDragEnd);
        };
        
        const onDragMove = (e) => {
          if (!isDragging) return;
          seekToPosition(getMousePct(e));
        };
        
        const onDragEnd = () => {
          isDragging = false;
          document.removeEventListener('mousemove', onDragMove);
          document.removeEventListener('mouseup', onDragEnd);
        };
        
        bar.addEventListener('mousedown', onDragStart);
      });
    }
    
    // Unified mouseup handler - final re-analysis on drag end
    function onTrimHandleUpUnified() {
      document.removeEventListener('mousemove', onTrimHandleMove);
      document.removeEventListener('mouseup', onTrimHandleUpUnified);
      
      if (trimDragState) {
        const { sessionIdx, session } = trimDragState;
        trimDragState = null;
        
        // Clear racing marks cache
        cachedRacingMarks = null;
        
        // Get current trim values
        const fullDuration = session.fullDuration || session.s.dur;
        const startMin = session.timelineStart || 0;
        const endMin = session.timelineEnd || fullDuration;
        
        if (!session.rawRecords) {
          console.error('Session has no rawRecords!');
          return;
        }
        
        // Re-analyze session with new trim
        try {
          const newData = analyzeSession(session.rawRecords, startMin, endMin);
          newData.filename = session.filename;
          newData.rawRecords = session.rawRecords;
          newData.timelineStart = startMin;
          newData.timelineEnd = endMin;
          newData.fullDuration = fullDuration;
          newData.originalMilestones = session.originalMilestones;
          newData.originalLegs = session.originalLegs;
          newData.originalTrack = session.originalTrack;
          newData.startTimestampMs = session.startTimestampMs;
          
          ALL_SESSIONS[sessionIdx] = newData;
          
          // Re-render everything
          renderRaceReplayTimeline();
          renderMap();
          renderVideoMinimap();
          updateVideoTelemetry();
          
          // Update fullscreen panel if visible
          if (mapFullscreen) {
            updateFsTimelineContent();
            currentLegIds = [];
            updateCurrentLegsPanel();
          }
        } catch (err) {
          console.error('Error applying trim:', err);
          alert('Error applying trim: ' + err.message);
        }
      }
    }
    
    // Update the timeline content in fullscreen panel
    function updateFsTimelineContent() {
      const fsDetailsPanel = document.getElementById('fs-details-panel');
      if (!fsDetailsPanel || !mapFullscreen) return;
      
      // Find the timeline card - it contains .replay-timeline-bar elements
      const cards = fsDetailsPanel.querySelectorAll('.card');
      let timelineCard = null;
      for (const card of cards) {
        if (card.querySelector('.replay-timeline-bar') || card.querySelector('[id^="timeline-"]')) {
          timelineCard = card;
          break;
        }
      }
      
      if (!timelineCard && cards.length > 0) {
        // Fallback to first card
        timelineCard = cards[0];
      }
      
      if (!timelineCard) return;
      
      // Clone timeline without analysis range row
      const timelinesContainer = document.getElementById('all-timelines-container');
      if (timelinesContainer && timelinesContainer.innerHTML) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = timelinesContainer.innerHTML;
        const analysisRangeRow = tempDiv.querySelector('[style*="background:#fef3c7"]');
        if (analysisRangeRow) {
          analysisRangeRow.parentElement?.removeChild(analysisRangeRow);
        }
        const lastRow = tempDiv.querySelector('[style*="margin-top:4px"]');
        if (lastRow && lastRow.textContent.includes(':')) {
          lastRow.parentElement?.removeChild(lastRow);
        }
        timelineCard.innerHTML = tempDiv.innerHTML;
        
        // Re-initialize trim handles
        initFsTrimHandles();
      }
    }
    
    function onTrimHandleMove(e) {
      if (!trimDragState) return;
      
      const { handleType, session, bar, globalStartMs, totalDurationMs, sessionIdx } = trimDragState;
      
      const rect = bar.getBoundingClientRect();
      const pct = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
      
      // Convert global timeline percentage to session time
      const fullDuration = session.fullDuration || session.s.dur;
      const timeMin = (pct / 100) * (totalDurationMs / 60000);
      
      // Convert to session-local time
      const sessionStartMs = session.startTimestampMs || 0;
      const sessionOffsetMin = (sessionStartMs - globalStartMs) / 60000;
      const sessionLocalMin = timeMin - sessionOffsetMin;
      
      // Clamp to valid range
      const currentStart = session.timelineStart || 0;
      const currentEnd = session.timelineEnd || fullDuration;
      
      if (handleType === 'start') {
        const newStart = Math.max(0, Math.min(currentEnd - 0.5, sessionLocalMin));
        session.timelineStart = newStart;
      } else {
        const newEnd = Math.max(currentStart + 0.5, Math.min(fullDuration, sessionLocalMin));
        session.timelineEnd = newEnd;
      }
      
      // Update handle positions and range background visually
      const newTrimStartMs = (session.startTimestampMs || 0) + (session.timelineStart || 0) * 60000;
      const newTrimEndMs = (session.startTimestampMs || 0) + (session.timelineEnd || fullDuration) * 60000;
      const startPct = ((newTrimStartMs - globalStartMs) / totalDurationMs) * 100;
      const endPct = ((newTrimEndMs - globalStartMs) / totalDurationMs) * 100;
      
      const startHandle = bar.querySelector('.replay-trim-handle[data-handle="start"]');
      const endHandle = bar.querySelector('.replay-trim-handle[data-handle="end"]');
      if (startHandle) startHandle.style.left = `${startPct}%`;
      if (endHandle) endHandle.style.left = `${endPct}%`;
      
      // Update range background
      const rangeDiv = bar.querySelector('.replay-session-range');
      if (rangeDiv) {
        rangeDiv.style.left = `${startPct}%`;
        rangeDiv.style.width = `${endPct - startPct}%`;
      }
      
      // Also update the main timeline bar if dragging in fullscreen
      if (mapFullscreen) {
        const mainBar = document.querySelector(`#all-timelines-container .replay-timeline-bar[data-session="${sessionIdx}"]`);
        if (mainBar && mainBar !== bar) {
          const mainStartHandle = mainBar.querySelector('.replay-trim-handle[data-handle="start"]');
          const mainEndHandle = mainBar.querySelector('.replay-trim-handle[data-handle="end"]');
          if (mainStartHandle) mainStartHandle.style.left = `${startPct}%`;
          if (mainEndHandle) mainEndHandle.style.left = `${endPct}%`;
          const mainRangeDiv = mainBar.querySelector('.replay-session-range');
          if (mainRangeDiv) {
            mainRangeDiv.style.left = `${startPct}%`;
            mainRangeDiv.style.width = `${endPct - startPct}%`;
          }
        }
      }
      
      // Move playback position to follow handle (same as timeslot handles)
      const handlePct = handleType === 'start' ? startPct : endPct;
      playbackTime = (handlePct / 100) * (totalDurationMs / 60000);
      
      // Update UI - same calls as timeslot handles, no throttling
      updatePlaybackUI();
      updateReplayTimelineMarkers();
      renderMap();
      syncVideosToPlayback(true);
    }
    
    function initReplayTimelineBarClicks() {
      // Use FULL time range for positioning
      const fullStartMs = getFullStartTimeMs();
      const fullEndMs = getFullEndTimeMs();
      const fullDurationMs = fullEndMs - fullStartMs;
      
      if (fullDurationMs <= 0) return;
      
      document.querySelectorAll('.replay-timeline-bar').forEach(bar => {
        let isDragging = false;
        
        const getMousePct = (e) => {
          const rect = bar.getBoundingClientRect();
          return Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
        };
        
        const seekToPosition = (pct) => {
          // pct is percentage of the FULL timeline
          const targetMs = fullStartMs + (pct / 100) * fullDurationMs;
          
          // playbackTime is in minutes relative to fullStartMs
          playbackTime = (targetMs - fullStartMs) / 60000;
          
          updatePlaybackUI();
          renderMap();
          updateReplayTimelineMarkers();
          syncVideosToPlayback(true);  // Sync video to new position
        };
        
        const onDragStart = (e) => {
          // Skip if clicking on trim handles
          if (e.target.classList.contains('replay-trim-handle')) return;
          
          e.preventDefault();
          e.stopPropagation();
          isDragging = true;
          seekToPosition(getMousePct(e));
          document.addEventListener('mousemove', onDragMove);
          document.addEventListener('mouseup', onDragEnd);
        };
        
        const onDragMove = (e) => {
          if (!isDragging) return;
          seekToPosition(getMousePct(e));
        };
        
        const onDragEnd = () => {
          isDragging = false;
          document.removeEventListener('mousemove', onDragMove);
          document.removeEventListener('mouseup', onDragEnd);
        };
        
        bar.addEventListener('mousedown', onDragStart);
        
        // Prevent native drag from interfering
        bar.addEventListener('dragstart', (e) => {
          e.preventDefault();
          e.stopPropagation();
        });
      });
    }
    
    // Variables for replay timeline selection
    let replayTimelineStartPct = 0;
    let replayTimelineEndPct = 100;
    
    // Absolute analysis range in milliseconds (GPS time)
    // These are the canonical values - percentages are only for UI
    let analysisRangeStartMs = null;  // null means no filter
    let analysisRangeEndMs = null;    // null means no filter
    
    function initReplayTimelineSelector() {
      const selector = document.getElementById('replay-timeline-selector');
      const handleStart = document.getElementById('replay-handle-start');
      const handleEnd = document.getElementById('replay-handle-end');
      const selectionRange = document.getElementById('replay-selection-range');
      
      if (!selector || !handleStart || !handleEnd) return;
      
      let dragging = null;
      
      const getMousePct = (e) => {
        const rect = selector.getBoundingClientRect();
        return Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
      };
      
      const updateSelection = () => {
        handleStart.style.left = `${replayTimelineStartPct}%`;
        handleEnd.style.left = `${replayTimelineEndPct}%`;
        handleEnd.style.right = 'auto';
        handleEnd.style.transform = 'translateX(-50%)';
        selectionRange.style.left = `${replayTimelineStartPct}%`;
        selectionRange.style.right = `${100 - replayTimelineEndPct}%`;
        
        // Update all playback markers
        updateReplayTimelineMarkers();
      };
      
      const seekToPosition = (pct) => {
        // pct is percentage of the FULL timeline
        const fullStartMs = getFullStartTimeMs();
        const fullEndMs = getFullEndTimeMs();
        const fullDurationMs = fullEndMs - fullStartMs;
        
        // Convert to absolute ms
        const targetMs = fullStartMs + (pct / 100) * fullDurationMs;
        
        // playbackTime is in minutes relative to fullStartMs
        playbackTime = (targetMs - fullStartMs) / 60000;
        
        updatePlaybackUI();
        renderMap();
        updateReplayTimelineMarkers();
        syncVideosToPlayback(true);  // Sync video to new position
      };
      
      const onHandleMouseDown = (e, type) => {
        e.preventDefault();
        e.stopPropagation();
        dragging = type;
        document.addEventListener('mousemove', onHandleMouseMove);
        document.addEventListener('mouseup', onHandleMouseUp);
      };
      
      const onHandleMouseMove = (e) => {
        if (!dragging) return;
        
        const pct = getMousePct(e);
        
        if (dragging === 'start') {
          replayTimelineStartPct = Math.min(pct, replayTimelineEndPct - 1);
        } else if (dragging === 'end') {
          replayTimelineEndPct = Math.max(pct, replayTimelineStartPct + 1);
        }
        
        updateSelection();
        
        // Move playback position to follow the handle being dragged
        const fullStartMs = getFullStartTimeMs();
        const fullEndMs = getFullEndTimeMs();
        const fullDurationMs = fullEndMs - fullStartMs;
        const handlePct = dragging === 'start' ? replayTimelineStartPct : replayTimelineEndPct;
        const targetMs = fullStartMs + (handlePct / 100) * fullDurationMs;
        playbackTime = (targetMs - fullStartMs) / 60000;
        
        updatePlaybackUI();
        updateReplayTimelineMarkers();
        renderMap();
        syncVideosToPlayback(true);
      };
      
      const onHandleMouseUp = () => {
        dragging = null;
        document.removeEventListener('mousemove', onHandleMouseMove);
        document.removeEventListener('mouseup', onHandleMouseUp);
        
        // Clear racing marks cache since timeslot changed
        cachedRacingMarks = null;
        
        // Timeslot change affects map/replay view, not individual track trims
        // Just re-render to update visible elements
        renderMap();
        renderVideoMinimap();
      };
      
      // Handle trimming
      handleStart.addEventListener('mousedown', (e) => onHandleMouseDown(e, 'start'));
      handleEnd.addEventListener('mousedown', (e) => onHandleMouseDown(e, 'end'));
      
      // Drag-to-seek on timeline bar (not handles)
      let isDraggingPlayback = false;
      
      const playbackIndicator = document.getElementById('replay-playback-indicator');
      
      const onPlaybackDragStart = (e) => {
        if (e.target === handleStart || e.target === handleEnd) return;
        e.preventDefault();
        isDraggingPlayback = true;
        seekToPosition(getMousePct(e));
        document.addEventListener('mousemove', onPlaybackDragMove);
        document.addEventListener('mouseup', onPlaybackDragEnd);
      };
      
      const onPlaybackDragMove = (e) => {
        if (!isDraggingPlayback) return;
        seekToPosition(getMousePct(e));
      };
      
      const onPlaybackDragEnd = () => {
        isDraggingPlayback = false;
        document.removeEventListener('mousemove', onPlaybackDragMove);
        document.removeEventListener('mouseup', onPlaybackDragEnd);
      };
      
      selector.addEventListener('mousedown', onPlaybackDragStart);
      
      // Also allow dragging from the playback indicator itself
      if (playbackIndicator) {
        playbackIndicator.addEventListener('mousedown', (e) => {
          e.preventDefault();
          e.stopPropagation();
          isDraggingPlayback = true;
          document.addEventListener('mousemove', onPlaybackDragMove);
          document.addEventListener('mouseup', onPlaybackDragEnd);
        });
      }
    }
    
    function updateReplayTimelineMarkers() {
      // Use FULL time range for positioning on timeline
      const fullStartMs = getFullStartTimeMs();
      const fullEndMs = getFullEndTimeMs();
      const fullDurationMs = fullEndMs - fullStartMs;
      
      if (fullDurationMs <= 0) return;
      
      // playbackTime is in minutes relative to fullStartMs
      const currentPlaybackMs = fullStartMs + playbackTime * 60000;
      
      // Calculate percentage on full timeline
      const playbackPct = ((currentPlaybackMs - fullStartMs) / fullDurationMs) * 100;
      
      // Update main playback indicator
      const mainIndicator = document.getElementById('replay-playback-indicator');
      if (mainIndicator) {
        mainIndicator.style.left = `${playbackPct}%`;
      }
      
      // Update all session playback markers
      document.querySelectorAll('.replay-playback-marker').forEach(marker => {
        marker.style.left = `${playbackPct}%`;
      });
    }
    
    // Drag and drop functionality for reordering boats in race replay mode
    function initTimelineDragDrop() {
      const container = document.getElementById('all-timelines-container');
      if (!container) return;
      
      const tracks = container.querySelectorAll('.timeline-track.draggable');
      let draggedElement = null;
      let draggedSessionIdx = null;
      
      tracks.forEach(track => {
        track.addEventListener('dragstart', (e) => {
          draggedElement = track;
          draggedSessionIdx = parseInt(track.dataset.session);
          track.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', draggedSessionIdx);
        });
        
        track.addEventListener('dragend', (e) => {
          track.classList.remove('dragging');
          draggedElement = null;
          draggedSessionIdx = null;
          // Remove all drag-over classes
          container.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        });
        
        track.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          if (track !== draggedElement) {
            track.classList.add('drag-over');
          }
        });
        
        track.addEventListener('dragleave', (e) => {
          track.classList.remove('drag-over');
        });
        
        track.addEventListener('drop', (e) => {
          e.preventDefault();
          track.classList.remove('drag-over');
          
          if (draggedElement === track) return;
          
          const targetSessionIdx = parseInt(track.dataset.session);
          const draggedOrderIdx = replaySessionOrder.indexOf(draggedSessionIdx);
          const targetOrderIdx = replaySessionOrder.indexOf(targetSessionIdx);
          
          if (draggedOrderIdx === -1 || targetOrderIdx === -1) return;
          
          // Reorder the array
          replaySessionOrder.splice(draggedOrderIdx, 1);
          replaySessionOrder.splice(targetOrderIdx, 0, draggedSessionIdx);
          
          // Re-render everything
          renderTimeline();
          renderMap();
          if (raceReplayMode) {
            renderRaceReplay();
            updateVideoTelemetry();
            renderVideoMinimap();
          }
        });
      });
    }

    function renderSingleTimeline(session, sessionIdx, isActive) {
      const container = document.querySelector(`.timeline-bar[data-session="${sessionIdx}"]`);
      if (!container) return;
      
      const fullDuration = session.fullDuration || session.s.dur;
      const { startPct, endPct } = getSessionTimelinePcts(session);
      const originalLegs = session.originalLegs || [];
      const startTimestampMs = session.startTimestampMs || 0;
      
      // Check if this session is in the replay
      const isInReplay = raceReplayMode && selectedSessionsForReplay.has(sessionIdx);
      const boatIdx = isInReplay ? replaySessionOrder.indexOf(sessionIdx) : -1;
      const boatColor = isInReplay ? BOAT_COLORS[boatIdx % BOAT_COLORS.length] : null;
      
      // Helper: time to percentage
      const timeToPct = (min) => (min / fullDuration) * 100;
      
      let html = '';
      
      // Background track - use boat color in replay mode
      const bgColor = isInReplay ? boatColor : (isActive ? '#e5e7eb' : '#f3f4f6');
      const bgOpacity = isInReplay ? '0.2' : '1';
      html += `<div class="tl-track" style="position:absolute;left:0;right:0;top:4px;height:20px;background:${bgColor};opacity:${bgOpacity};border-radius:3px;"></div>`;
      
      // Grey out unselected regions (only for active, and NOT in race replay mode)
      if (isActive && !raceReplayMode) {
        if (startPct > 0.1) {
          html += `<div style="position:absolute;left:0;top:4px;width:${startPct}%;height:20px;background:#9ca3af;opacity:0.4;border-radius:3px 0 0 3px;"></div>`;
        }
        if (endPct < 99.9) {
          html += `<div style="position:absolute;left:${endPct}%;right:0;top:4px;height:20px;background:#9ca3af;opacity:0.4;border-radius:0 3px 3px 0;"></div>`;
        }
      }
      
      // Leg segments - simple divs with percentage positioning
      const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };
      originalLegs.forEach((leg) => {
        const leftPct = timeToPct(leg.start);
        const widthPct = Math.max(0.3, timeToPct(leg.end) - timeToPct(leg.start));
        
        // Check if selected by time overlap (not in race replay mode)
        let isSelected = false;
        if (!raceReplayMode) {
          // selectedLeg times are relative to trimmed start, originalLegs times are relative to full session
          const timeOffset = session.timelineStart || 0;
          if (isActive && selectedLeg) {
            const adjSelectedStart = selectedLeg.start + timeOffset;
            const adjSelectedEnd = selectedLeg.end + timeOffset;
            const overlapStart = Math.max(adjSelectedStart, leg.start);
            const overlapEnd = Math.min(adjSelectedEnd, leg.end);
            const overlap = overlapEnd - overlapStart;
            const legDuration = leg.end - leg.start;
            isSelected = overlap > legDuration * 0.5;
          }
        }
        
        // In replay mode, use boat color for legs
        let color;
        if (isInReplay) {
          // Keep position colors (upwind/downwind/reaching) in replay mode
          color = posColors[leg.pos];
        } else {
          color = isSelected ? '#a855f7' : posColors[leg.pos];
        }
        
        // In replay mode, all selected sessions get full opacity
        let opacity;
        if (isInReplay) {
          opacity = 0.8;
        } else if (isActive) {
          opacity = isSelected ? 1 : 0.8;
        } else {
          opacity = 0.4;
        }
        
        const cursor = (isActive && !raceReplayMode) ? 'pointer' : 'default';
        const glow = isSelected ? 'box-shadow:0 0 6px #c084fc;' : '';
        
        html += `<div class="tl-leg" data-leg-id="${leg.id}" style="position:absolute;left:${leftPct}%;top:6px;width:${widthPct}%;height:16px;background:${color};opacity:${opacity};border-radius:2px;cursor:${cursor};${glow}"></div>`;
      });
      
      // Handles - show for active timeline OR all replay sessions
      const showHandles = isActive || isInReplay;
      if (showHandles) {
        const handleColor = isInReplay ? boatColor : '#7c3aed';
        html += `<div class="tl-handle" data-handle="start" style="position:absolute;left:${startPct}%;top:0;width:8px;height:28px;background:${handleColor};border-radius:3px;cursor:ew-resize;transform:translateX(-50%);z-index:10;"></div>`;
        html += `<div class="tl-handle" data-handle="end" style="position:absolute;left:${endPct}%;top:0;width:8px;height:28px;background:${handleColor};border-radius:3px;cursor:ew-resize;transform:translateX(-50%);z-index:10;"></div>`;
      }
      
      // Playback pointer (in race replay mode OR for active session in normal mode)
      if (isInReplay || (isActive && !raceReplayMode)) {
        // Calculate pointer position
        let playbackPct;
        
        if (isInReplay) {
          // Race replay mode: use real-world time synchronization
          const referenceStartMs = getFullStartTimeMs();
          const currentTimeMs = referenceStartMs + playbackTime * 60000;
          const sessionLocalTimeMin = (currentTimeMs - startTimestampMs) / 60000;
          playbackPct = (sessionLocalTimeMin / fullDuration) * 100;
        } else {
          // Normal mode: use session's relative playback time
          // playbackTime is relative to trimmed start, so we need to add the trim offset
          const trimStartMin = session.timelineStart || 0;
          const absolutePlaybackMin = trimStartMin + playbackTime;
          playbackPct = (absolutePlaybackMin / fullDuration) * 100;
        }
        
        const pointerColor = isInReplay ? boatColor : '#7c3aed';
        html += `<div class="tl-playback-pointer" data-session="${sessionIdx}" style="position:absolute;left:${Math.max(0, Math.min(100, playbackPct))}%;top:0;width:3px;height:28px;background:${pointerColor};border-radius:2px;transform:translateX(-50%);z-index:15;pointer-events:none;box-shadow:0 0 4px ${pointerColor};"></div>`;
      }
      
      // Time labels
      if (startTimestampMs) {
        const startDate = new Date(startTimestampMs);
        const startTimeStr = startDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
        html += `<div style="position:absolute;left:0;bottom:0;font-size:9px;color:#6b7280;">${startTimeStr}</div>`;
        
        const endDate = new Date(startTimestampMs + fullDuration * 60000);
        const endTimeStr = endDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
        html += `<div style="position:absolute;right:0;bottom:0;font-size:9px;color:#6b7280;">${endTimeStr}</div>`;
        
        // Add half-hour interval labels (11:30, 12:00, 12:30, etc.)
        const startMinOfDay = startDate.getHours() * 60 + startDate.getMinutes();
        const firstHalfHour = Math.ceil(startMinOfDay / 30) * 30;
        const offsetMin = firstHalfHour - startMinOfDay;
        
        for (let min = offsetMin; min <= fullDuration; min += 30) {
          const pct = (min / fullDuration) * 100;
          // Skip if too close to start or end (within 8%)
          if (pct < 8 || pct > 92) continue;
          
          const labelDate = new Date(startTimestampMs + min * 60000);
          const timeStr = labelDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
          html += `<div style="position:absolute;left:${pct}%;bottom:0;font-size:9px;color:#9ca3af;transform:translateX(-50%);">${timeStr}</div>`;
        }
      }
      
      container.innerHTML = html;
      
      // Add event listeners
      // Handle drag - allow for active session OR all replay sessions
      if (isActive || isInReplay) {
        container.querySelectorAll('.tl-handle').forEach(handle => {
          handle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            isDraggingTimeline = { sessionIdx, handle: handle.dataset.handle };
            timelineDragStartX = e.clientX;
            const pcts = getSessionTimelinePcts(session);
            timelineDragStartPct = pcts.startPct;
            timelineDragEndPct = pcts.endPct;
          });
        });
      }
      
      // Leg click (only in normal mode for active session)
      if (isActive && !raceReplayMode) {
        container.querySelectorAll('.tl-leg').forEach(legEl => {
          legEl.addEventListener('click', (e) => {
            e.stopPropagation();
            const legId = parseInt(legEl.dataset.legId);
            const origLeg = session.originalLegs.find(l => l.id === legId);
            if (!origLeg) return;
            
            // DATA.legs times are relative to trimmed start, originalLegs times are relative to full session
            // Add timelineStart offset to DATA.legs times for comparison
            const timeOffset = session.timelineStart || 0;
            
            // Find matching leg in DATA.legs by time overlap
            const matchingLeg = DATA.legs.find(l => {
              const adjStart = l.start + timeOffset;
              const adjEnd = l.end + timeOffset;
              const overlapStart = Math.max(adjStart, origLeg.start);
              const overlapEnd = Math.min(adjEnd, origLeg.end);
              const overlap = overlapEnd - overlapStart;
              return overlap > (origLeg.end - origLeg.start) * 0.5;
            });
              
              if (matchingLeg) {
                selectLeg(matchingLeg);
              } else {
                // Leg is outside current trim - select it using origLeg data
                // Adjust times so highlight code works correctly (it will add timeOffset back)
                const pseudoLeg = {
                  ...origLeg,
                  start: origLeg.start - timeOffset,
                  end: origLeg.end - timeOffset,
                  isOutsideTrim: true
                };
                selectLeg(pseudoLeg);
              }
            });
          });
      }
      
      // Timeline bar click for seeking (active session in normal mode, or any session in replay mode)
      if ((isActive && !raceReplayMode) || isInReplay) {
        container.addEventListener('click', (e) => {
          // Don't seek if clicking on a handle
          if (e.target.classList.contains('tl-handle')) return;
          
          const rect = container.getBoundingClientRect();
          const clickPct = ((e.clientX - rect.left) / rect.width) * 100;
          
          // Convert click percentage to absolute time in this session
          const clickTimeMin = (clickPct / 100) * fullDuration;
          
          if (raceReplayMode) {
            // In race replay mode, convert to global playback time
            const sessionStartMs = startTimestampMs || 0;
            const clickAbsoluteMs = sessionStartMs + clickTimeMin * 60000;
            const referenceStartMs = getFullStartTimeMs();
            playbackTime = (clickAbsoluteMs - referenceStartMs) / 60000;
          } else {
            // In normal mode, convert to trimmed playback time
            const trimStartMin = session.timelineStart || 0;
            playbackTime = Math.max(0, clickTimeMin - trimStartMin);
          }
          
          // Update UI
          updatePlaybackUI();
          updateBoatInfoPanel();
          updateCurrentLegsPanel();
          updateChartTimePointers();
          updateTimelinePlaybackPointer();
          renderMap();
          
          // Update video if present
          if (typeof updateActiveVideoDisplay !== 'undefined') updateActiveVideoDisplay();
          if (typeof syncVideosToPlayback !== 'undefined') syncVideosToPlayback(true);
        });
      }
    }

    // Update playback pointer positions on all timelines
    function updateTimelinePlaybackPointer() {
      if (raceReplayMode) {
        // Race replay mode: update all session pointers with real-world time synchronization
        // playbackTime is offset in minutes from the earliest session's trimmed start
        // Convert to real-world timestamp for synchronization
        const referenceStartMs = getFullStartTimeMs();
        const currentTimeMs = referenceStartMs + playbackTime * 60000;
        
        selectedSessionsForReplay.forEach(sessionIdx => {
          const session = ALL_SESSIONS[sessionIdx];
          if (!session) return;
          
          const fullDuration = session.fullDuration || session.s.dur;
          const sessionStartMs = session.startTimestampMs || 0;
          
          // Calculate where currentTimeMs falls on this session's timeline
          // sessionStartMs is when this session started recording
          // The timeline shows 0 to fullDuration minutes from sessionStartMs
          const sessionLocalTimeMin = (currentTimeMs - sessionStartMs) / 60000;
          const playbackPct = (sessionLocalTimeMin / fullDuration) * 100;
          
          const pointer = document.querySelector(`.tl-playback-pointer[data-session="${sessionIdx}"]`);
          if (pointer) {
            pointer.style.left = `${Math.max(0, Math.min(100, playbackPct))}%`;
          }
        });
      } else {
        // Normal mode: update active session pointer (single session mode only)
        if (!DATA) return;
        
        const hasMultipleSessions = ALL_SESSIONS.length > 1;
        if (hasMultipleSessions) {
          // Aligned timeline mode: no playback pointers to update
          return;
        }
        
        // Single session mode: update active session pointer
        const activeSessionIdx = ALL_SESSIONS.indexOf(DATA);
        if (activeSessionIdx === -1) return;
        
        const session = DATA;
        const fullDuration = session.fullDuration || session.s.dur;
        const trimStartMin = session.timelineStart || 0;
        
        // playbackTime is relative to trimmed start, so add trim offset for absolute position
        const absolutePlaybackMin = trimStartMin + playbackTime;
        const playbackPct = (absolutePlaybackMin / fullDuration) * 100;
        
        const pointer = document.querySelector(`.tl-playback-pointer[data-session="${activeSessionIdx}"]`);
        if (pointer) {
          pointer.style.left = `${Math.max(0, Math.min(100, playbackPct))}%`;
        }
      }
    }

    // Global mouse handlers for timeline dragging
    document.addEventListener('mousemove', (e) => {
      if (!isDraggingTimeline) return;
      
      const session = ALL_SESSIONS[isDraggingTimeline.sessionIdx];
      if (!session) return;
      
      const bar = document.querySelector(`.timeline-bar[data-session="${isDraggingTimeline.sessionIdx}"]`);
      if (!bar) return;
      
      const rect = bar.getBoundingClientRect();
      const width = rect.width;
      
      const dx = e.clientX - timelineDragStartX;
      const dPct = (dx / width) * 100;
      
      let newStartPct = timelineDragStartPct;
      let newEndPct = timelineDragEndPct;
      
      if (isDraggingTimeline.handle === 'start') {
        newStartPct = Math.max(0, Math.min(newEndPct - 5, timelineDragStartPct + dPct));
      } else if (isDraggingTimeline.handle === 'end') {
        newEndPct = Math.max(newStartPct + 5, Math.min(100, timelineDragEndPct + dPct));
      }
      
      // Update session timeline values immediately for visual feedback
      const fullDuration = session.fullDuration || session.s.dur;
      session.timelineStart = (newStartPct / 100) * fullDuration;
      session.timelineEnd = (newEndPct / 100) * fullDuration;
      
      // Re-render just this timeline for immediate visual feedback
      renderSingleTimeline(session, isDraggingTimeline.sessionIdx, true);
      
      // Update map to show grey areas
      renderMap();
      
      // Debounce the actual re-analysis
      if (pendingTimelineUpdate) {
        clearTimeout(pendingTimelineUpdate);
      }
      pendingTimelineUpdate = setTimeout(() => {
        applyTimelineChange(isDraggingTimeline.sessionIdx, newStartPct, newEndPct, true);
      }, 150);
    });

    document.addEventListener('mouseup', () => {
      if (isDraggingTimeline) {
        // Apply final change
        const session = ALL_SESSIONS[isDraggingTimeline.sessionIdx];
        if (session) {
          const pcts = getSessionTimelinePcts(session);
          applyTimelineChange(isDraggingTimeline.sessionIdx, pcts.startPct, pcts.endPct, true);
        }
        isDraggingTimeline = null;
      }
    });

    function applyTimelineChange(sessionIdx, startPct, endPct, skipTimelineRender = false) {
      const session = ALL_SESSIONS[sessionIdx];
      if (!session || !session.rawRecords) return;
      
      const fullDuration = session.fullDuration || session.s.dur;
      const startMin = (startPct / 100) * fullDuration;
      const endMin = (endPct / 100) * fullDuration;
      
      // Clear racing marks cache so they get recalculated with new trim
      cachedRacingMarks = null;
      
      try {
        const newData = analyzeSession(session.rawRecords, startMin, endMin);
        newData.filename = session.filename;
        newData.rawRecords = session.rawRecords;
        newData.timelineStart = startMin;
        newData.timelineEnd = endMin;
        newData.fullDuration = fullDuration;
        newData.originalMilestones = session.originalMilestones;
        newData.originalLegs = session.originalLegs;
        newData.originalTrack = session.originalTrack;
        newData.startTimestampMs = session.startTimestampMs;
        
        ALL_SESSIONS[sessionIdx] = newData;
        
        // Only render dashboard in normal mode
        if (!raceReplayMode) {
          if (DATA === session || sessionIdx === ALL_SESSIONS.indexOf(DATA)) {
            DATA = newData;
            selectedLeg = null;
            renderDashboard();
            renderComparison();
            fitMapToTrimmedTrack(); // Auto-center map on trimmed area
          }
          
          if (!skipTimelineRender) {
            renderTimeline();
          }
        }
      } catch (err) {
        console.error('Error applying timeline:', err);
      }
    }

    function resetAllTimelines() {
      // Clear racing marks cache so they get recalculated
      cachedRacingMarks = null;
      
      try {
        ALL_SESSIONS.forEach((session, idx) => {
          const newData = analyzeSession(session.rawRecords);
          newData.filename = session.filename;
          newData.rawRecords = session.rawRecords;
          newData.timelineStart = 0;
          // Use the stored fullDuration (actual session duration), not the re-analyzed s.dur
          const actualDuration = session.fullDuration || Math.max(...newData.legs.map(l => l.end), newData.s.dur);
          newData.timelineEnd = actualDuration;
          newData.fullDuration = actualDuration;
          newData.originalMilestones = session.originalMilestones;
          newData.originalLegs = session.originalLegs;
          newData.originalTrack = session.originalTrack || newData.track.slice();
          newData.startTimestampMs = session.startTimestampMs;
          
          ALL_SESSIONS[idx] = newData;
        });
        
        // Re-apply auto-trim if enabled
        if (document.getElementById('auto-trim-checkbox')?.checked) {
          ALL_SESSIONS.forEach((session, idx) => {
            applyAutoTrim(idx);
          });
        }
        
        DATA = ALL_SESSIONS.find(s => s.filename === DATA.filename) || ALL_SESSIONS[0];
        selectedLeg = null;
        
        // Re-render based on current mode
        if (raceReplayMode) {
          renderRaceReplayTimeline();
          renderMap();
          renderVideoMinimap();
          updateVideoTelemetry();
        } else {
          renderDashboard();
          renderComparison();
          renderTimeline();
          fitMapToTrimmedTrack(); // Reset map to fit track
        }
      } catch (err) {
        alert('Error resetting timelines: ' + err.message);
      }
    }

    // ===== AUTO-TRIM FUNCTIONS =====
    // Haversine formula for distance between two GPS points
    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000; // Earth radius in meters
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }
    
    // Calculate bearing from point 1 to point 2
    function calculateBearing(lat1, lon1, lat2, lon2) {
      const lat1Rad = lat1 * Math.PI / 180;
      const lat2Rad = lat2 * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const y = Math.sin(dLon) * Math.cos(lat2Rad);
      const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
      let bearing = Math.atan2(y, x) * 180 / Math.PI;
      if (bearing < 0) bearing += 360;
      return bearing;
    }
    
    // Detect racing marks from track geographic extremes
    // Upmark: most extreme (furthest upwind) track point
    // Downmark: most extreme (furthest downwind) track point
    // Returns { upmarks: [{lat, lon}], downmarks: [{lat, lon}] }
    function detectRacingMarks(sessions) {
      // Get wind direction from first session
      const twd = sessions[0]?.s?.twd || 0;
      
      // Get timeslot range for filtering
      const { startMs: timeslotStartMs, endMs: timeslotEndMs } = getTimeslotRangeMs();
      
      // Collect track points within timeslot and trim range
      const allTrackPoints = [];
      sessions.forEach(session => {
        if (!session.track) return;
        
        const sessionStartMs = session.startTimestampMs || 0;
        const trimStartMin = session.timelineStart || 0;
        const trimEndMin = session.timelineEnd || session.s.dur;
        const trimDuration = trimEndMin - trimStartMin;
        
        session.track.forEach(pt => {
          // Check if point is within trim range
          if (pt.t < 0 || pt.t > trimDuration) return;
          
          // Check if point is within timeslot
          const ptAbsMs = sessionStartMs + (trimStartMin + pt.t) * 60000;
          if (ptAbsMs < timeslotStartMs || ptAbsMs > timeslotEndMs) return;
          
          allTrackPoints.push({ lat: pt.lat, lon: pt.lon });
        });
      });
      
      if (allTrackPoints.length === 0) {
        return { upmarks: [], downmarks: [] };
      }
      
      // Calculate reference point (center of all tracks)
      const refLat = allTrackPoints.reduce((sum, p) => sum + p.lat, 0) / allTrackPoints.length;
      const refLon = allTrackPoints.reduce((sum, p) => sum + p.lon, 0) / allTrackPoints.length;
      
      // Calculate upwind score for a point
      const twdRad = twd * Math.PI / 180;
      const upwindX = Math.sin(twdRad);
      const upwindY = Math.cos(twdRad);
      
      const calcUpwindScore = (pt) => {
        const dx = (pt.lon - refLon) * Math.cos(refLat * Math.PI / 180) * 111320;
        const dy = (pt.lat - refLat) * 111320;
        return dx * upwindX + dy * upwindY;
      };
      
      // Calculate scores for all points
      const pointsWithScores = allTrackPoints.map(pt => ({
        lat: pt.lat,
        lon: pt.lon,
        score: calcUpwindScore(pt)
      }));
      
      // For upmark: find the MOST UPWIND point (maximum score)
      let bestUpmark = null;
      let maxScore = -Infinity;
      pointsWithScores.forEach(pt => {
        if (pt.score > maxScore) {
          maxScore = pt.score;
          bestUpmark = pt;
        }
      });
      
      // For downmark: find the MOST DOWNWIND point (minimum score)
      let bestDownmark = null;
      let minScore = Infinity;
      pointsWithScores.forEach(pt => {
        if (pt.score < minScore) {
          minScore = pt.score;
          bestDownmark = pt;
        }
      });
      
      return {
        upmarks: bestUpmark ? [{ lat: bestUpmark.lat, lon: bestUpmark.lon }] : [],
        downmarks: bestDownmark ? [{ lat: bestDownmark.lat, lon: bestDownmark.lon }] : []
      };
    }
    
    // Calculate typical TWA values for upwind (tack) and downwind (gybe) from race data
    // Returns { upwindTwa, downwindTwa } based on actual leg TWAs from the sessions
    function getTypicalRaceTWA(sessions) {
      const upwindTwas = [];
      const downwindTwas = [];
      
      // Collect TWA values from all sessions
      sessions.forEach(session => {
        if (!session.legs) return;
        
        session.legs.forEach(leg => {
          if (leg.twa == null || leg.dur < 10) return; // Skip very short legs
          
          if (leg.pos === 'upwind' || leg.twa < 75) {
            upwindTwas.push(leg.twa);
          } else if (leg.pos === 'downwind' || leg.twa > 112) {
            downwindTwas.push(leg.twa);
          }
        });
      });
      
      // Calculate median values (more robust than mean against outliers)
      const median = (arr) => {
        if (arr.length === 0) return null;
        const sorted = [...arr].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
      };
      
      // Use median if available, otherwise fall back to defaults
      const upwindTwa = median(upwindTwas) || 45;
      const downwindTwa = median(downwindTwas) || 150;
      
      return {
        upwindTwa: Math.max(30, Math.min(70, upwindTwa)),    // Clamp to reasonable range
        downwindTwa: Math.max(130, Math.min(175, downwindTwa)) // Clamp to reasonable range
      };
    }
    
    // Calculate typical boat speeds for upwind and downwind from recent leg data
    // Returns { upwindSpeed, downwindSpeed } in knots based on nearby legs (previous, current, next)
    // session: the specific boat's session
    // globalTimeMin: current playback time to find nearby legs
    function getTypicalRaceSpeeds(session, globalTimeMin) {
      const upwindSpeeds = [];
      const downwindSpeeds = [];
      
      if (!session || !session.legs || session.legs.length === 0) {
        return { upwindSpeed: 4.0, downwindSpeed: 5.0 }; // Defaults
      }
      
      // Find current leg index
      const sessionLocalTime = getSessionLocalTime(session, globalTimeMin);
      const sessionStart = session.timelineStart || 0;
      const trackTime = sessionLocalTime - sessionStart;
      
      let currentLegIdx = -1;
      for (let i = 0; i < session.legs.length; i++) {
        const leg = session.legs[i];
        if (trackTime >= leg.start && trackTime <= leg.end) {
          currentLegIdx = i;
          break;
        }
      }
      
      // If no current leg found, find closest one
      if (currentLegIdx === -1) {
        let minDist = Infinity;
        for (let i = 0; i < session.legs.length; i++) {
          const leg = session.legs[i];
          const legMid = (leg.start + leg.end) / 2;
          const dist = Math.abs(trackTime - legMid);
          if (dist < minDist) {
            minDist = dist;
            currentLegIdx = i;
          }
        }
      }
      
      // Collect speeds from nearby legs (3 before, current, 3 after = up to 7 legs)
      const startIdx = Math.max(0, currentLegIdx - 3);
      const endIdx = Math.min(session.legs.length - 1, currentLegIdx + 3);
      
      for (let i = startIdx; i <= endIdx; i++) {
        const leg = session.legs[i];
        if (leg.speed == null || leg.dur < 10) continue; // Skip very short legs
        
        const speed = parseFloat(leg.speed);
        if (isNaN(speed) || speed < 0.5) continue; // Skip invalid/very slow speeds
        
        if (leg.pos === 'upwind' || (leg.twa != null && leg.twa < 75)) {
          upwindSpeeds.push(speed);
        } else if (leg.pos === 'downwind' || (leg.twa != null && leg.twa > 112)) {
          downwindSpeeds.push(speed);
        }
      }
      
      // Calculate median values (more robust than mean against outliers)
      const median = (arr) => {
        if (arr.length === 0) return null;
        const sorted = [...arr].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
      };
      
      // Use median if available, otherwise fall back to defaults
      const upwindSpeed = median(upwindSpeeds) || 4.0;   // Default 4 knots upwind
      const downwindSpeed = median(downwindSpeeds) || 5.0; // Default 5 knots downwind
      
      return {
        upwindSpeed: Math.max(1, Math.min(15, upwindSpeed)),    // Clamp to reasonable range
        downwindSpeed: Math.max(1, Math.min(20, downwindSpeed)) // Clamp to reasonable range
      };
    }
    
    // Get typical headings from boat's actual nearby legs
    // Returns { portUpwind, stbdUpwind, portDownwind, stbdDownwind } headings
    // Based on the 3 previous + current + 3 next legs of each type
    function getTypicalHeadings(session, globalTimeMin, twd) {
      const portUpwindHdgs = [];
      const stbdUpwindHdgs = [];
      const portDownwindHdgs = [];
      const stbdDownwindHdgs = [];
      
      // Default TWAs if no data
      const defaultUpwindTwa = 50;
      const defaultDownwindTwa = 145;
      
      if (!session || !session.legs || session.legs.length === 0) {
        return {
          portUpwind: (twd - defaultUpwindTwa + 360) % 360,
          stbdUpwind: (twd + defaultUpwindTwa) % 360,
          portDownwind: (twd + 180 - (180 - defaultDownwindTwa) + 360) % 360,
          stbdDownwind: (twd + 180 + (180 - defaultDownwindTwa)) % 360
        };
      }
      
      // Find current leg index
      const sessionLocalTime = getSessionLocalTime(session, globalTimeMin);
      const sessionStart = session.timelineStart || 0;
      const trackTime = sessionLocalTime - sessionStart;
      
      let currentLegIdx = -1;
      for (let i = 0; i < session.legs.length; i++) {
        const leg = session.legs[i];
        if (trackTime >= leg.start && trackTime <= leg.end) {
          currentLegIdx = i;
          break;
        }
      }
      
      if (currentLegIdx === -1) {
        let minDist = Infinity;
        for (let i = 0; i < session.legs.length; i++) {
          const leg = session.legs[i];
          const legMid = (leg.start + leg.end) / 2;
          const dist = Math.abs(trackTime - legMid);
          if (dist < minDist) {
            minDist = dist;
            currentLegIdx = i;
          }
        }
      }
      
      // Search wider range to find enough legs of each type
      const searchRadius = 10;
      const startIdx = Math.max(0, currentLegIdx - searchRadius);
      const endIdx = Math.min(session.legs.length - 1, currentLegIdx + searchRadius);
      
      for (let i = startIdx; i <= endIdx; i++) {
        const leg = session.legs[i];
        if (leg.dur < 10 || leg.hdg == null) continue;
        
        const hdg = leg.hdg;
        const isUpwind = leg.pos === 'upwind' || (leg.twa != null && leg.twa < 80);
        const isDownwind = leg.pos === 'downwind' || (leg.twa != null && leg.twa > 100);
        
        if (!isUpwind && !isDownwind) continue;
        
        // Determine port vs starboard based on heading relative to wind
        // Port: wind coming from starboard (heading is to left of wind)
        // Starboard: wind coming from port (heading is to right of wind)
        const hdgRelWind = ((hdg - twd) + 360) % 360;
        
        if (isUpwind) {
          // Upwind: hdgRelWind < 180 means starboard tack, >= 180 means port tack
          if (hdgRelWind < 180) {
            stbdUpwindHdgs.push(hdg);
          } else {
            portUpwindHdgs.push(hdg);
          }
        } else if (isDownwind) {
          // Downwind: hdgRelWind < 180 means starboard gybe, >= 180 means port gybe
          if (hdgRelWind < 180) {
            stbdDownwindHdgs.push(hdg);
          } else {
            portDownwindHdgs.push(hdg);
          }
        }
      }
      
      // Calculate median heading for each category
      const medianAngle = (angles) => {
        if (angles.length === 0) return null;
        // For angles, we need to handle wrap-around
        // Convert to unit vectors, average, then back to angle
        let sumX = 0, sumY = 0;
        for (const a of angles) {
          sumX += Math.cos(a * Math.PI / 180);
          sumY += Math.sin(a * Math.PI / 180);
        }
        const avgAngle = Math.atan2(sumY / angles.length, sumX / angles.length) * 180 / Math.PI;
        return (avgAngle + 360) % 360;
      };
      
      // Use actual data if available, otherwise defaults based on TWD
      const portUpwind = medianAngle(portUpwindHdgs) ?? (twd - defaultUpwindTwa + 360) % 360;
      const stbdUpwind = medianAngle(stbdUpwindHdgs) ?? (twd + defaultUpwindTwa) % 360;
      const portDownwind = medianAngle(portDownwindHdgs) ?? (twd + 180 - (180 - defaultDownwindTwa) + 360) % 360;
      const stbdDownwind = medianAngle(stbdDownwindHdgs) ?? (twd + 180 + (180 - defaultDownwindTwa)) % 360;
      
      return { portUpwind, stbdUpwind, portDownwind, stbdDownwind };
    }
    
    // Calculate precise sailing route between two boats
    // Algorithm:
    // 1. Determine if target requires UPWIND or DOWNWIND sailing (based on bearing to wind)
    // 2. Current mode determines maneuver label (U‚ÜíU, D‚ÜíD, U‚ÜíD, D‚ÜíU)
    // 3. Route legs use the TARGET zone's headings:
    //    - Target in upwind zone ‚Üí both legs are upwind, use upwind speed
    //    - Target in downwind zone ‚Üí both legs are downwind, use downwind speed
    // 4. Speed is boat-specific and time-local (from nearby legs of matching type)
    function calculateSailingRoute(b1Pos, b2Pos, sessions, sourceSessionIdx = 0) {
      const twd = sessions[0].s.twd || 0;
      const sourceSession = sessions[sourceSessionIdx] || sessions[0];
      const sourcePos = sourceSessionIdx === 0 ? b1Pos : b2Pos;
      const targetPos = sourceSessionIdx === 0 ? b2Pos : b1Pos;
      
      // Get typical boat speeds from SOURCE BOAT's recent legs (boat-specific, time-local)
      const raceSpeeds = getTypicalRaceSpeeds(sourceSession, playbackTime);
      const upwindSpeed = raceSpeeds.upwindSpeed;
      const downwindSpeed = raceSpeeds.downwindSpeed;
      
      // Get current leg info for source boat to determine current mode
      const currentLeg = getCurrentLegAtTime(sourceSession, playbackTime);
      const currentHdg = (currentLeg && currentLeg.hdg != null) ? currentLeg.hdg : (sourcePos.hdg || sourcePos.cog || 0);
      let currentTwa = Math.abs(angleDiff(currentHdg, twd));
      if (currentLeg && currentLeg.twa != null) {
        currentTwa = currentLeg.twa;
      }
      const currentIsUpwind = currentTwa < 90;
      
      // Calculate bearing from source to target
      const bearing = calculateBearing(sourcePos.lat, sourcePos.lon, targetPos.lat, targetPos.lon);
      
      // Direct distance
      const directDist = haversineDistance(sourcePos.lat, sourcePos.lon, targetPos.lat, targetPos.lon);
      
      // Get typical headings from SOURCE BOAT's actual recent legs (boat-specific, time-local)
      const typicalHdgs = getTypicalHeadings(sourceSession, playbackTime, twd);
      const portUpwindHdg = typicalHdgs.portUpwind;
      const stbdUpwindHdg = typicalHdgs.stbdUpwind;
      const portDownwindHdg = typicalHdgs.portDownwind;
      const stbdDownwindHdg = typicalHdgs.stbdDownwind;
      
      // Calculate TWA from typical headings (for zone determination)
      const typicalUpwindTwa = Math.abs(angleDiff(stbdUpwindHdg, twd));
      const typicalDownwindTwa = Math.abs(angleDiff(stbdDownwindHdg, twd));
      
      // Determine if target is in upwind or downwind zone (using boat's actual typical angles)
      const bearingRelWind = ((bearing - twd) + 360) % 360;
      const targetInUpwindZone = bearingRelWind <= typicalUpwindTwa || bearingRelWind >= (360 - typicalUpwindTwa);
      
      // Determine maneuver type label based on current mode and target zone
      let maneuverType;
      if (currentIsUpwind && targetInUpwindZone) {
        maneuverType = 'upwind';          // U‚ÜíU: stay upwind
      } else if (!currentIsUpwind && !targetInUpwindZone) {
        maneuverType = 'downwind';        // D‚ÜíD: stay downwind
      } else if (currentIsUpwind && !targetInUpwindZone) {
        maneuverType = 'upwind-downwind'; // U‚ÜíD: continue upwind, then bear away
      } else {
        maneuverType = 'downwind-upwind'; // D‚ÜíU: continue downwind, then head up
      }
      
      // Select leg headings and speeds based on CURRENT mode (leg 1) and TARGET zone (leg 2)
      let leg1Hdg, leg2Hdg, leg1Speed, leg2Speed;
      let waypoint = null;
      
      if (currentIsUpwind && targetInUpwindZone) {
        // U‚ÜíU: Both legs are upwind - use tack point intersection
        leg1Speed = upwindSpeed;
        leg2Speed = upwindSpeed;
        
        // Pick upwind heading closer to bearing for leg 1, opposite for leg 2
        const portDiff = Math.abs(angleDiff(portUpwindHdg, bearing));
        const stbdDiff = Math.abs(angleDiff(stbdUpwindHdg, bearing));
        leg1Hdg = portDiff < stbdDiff ? portUpwindHdg : stbdUpwindHdg;
        leg2Hdg = portDiff < stbdDiff ? stbdUpwindHdg : portUpwindHdg;
        
        waypoint = calculateLaylineIntersection(
          sourcePos.lat, sourcePos.lon, leg1Hdg,
          targetPos.lat, targetPos.lon, (leg2Hdg + 180) % 360
        );
        
        // Try swapping if invalid
        if (!waypoint || !isValidWaypoint(waypoint, sourcePos, targetPos, directDist)) {
          waypoint = calculateLaylineIntersection(
            sourcePos.lat, sourcePos.lon, leg2Hdg,
            targetPos.lat, targetPos.lon, (leg1Hdg + 180) % 360
          );
          if (waypoint && isValidWaypoint(waypoint, sourcePos, targetPos, directDist)) {
            [leg1Hdg, leg2Hdg] = [leg2Hdg, leg1Hdg];
          }
        }
        
      } else if (!currentIsUpwind && !targetInUpwindZone) {
        // D‚ÜíD: Both legs are downwind - use gybe point intersection
        leg1Speed = downwindSpeed;
        leg2Speed = downwindSpeed;
        
        // Pick downwind heading closer to bearing for leg 1, opposite for leg 2
        const portDiff = Math.abs(angleDiff(portDownwindHdg, bearing));
        const stbdDiff = Math.abs(angleDiff(stbdDownwindHdg, bearing));
        leg1Hdg = portDiff < stbdDiff ? portDownwindHdg : stbdDownwindHdg;
        leg2Hdg = portDiff < stbdDiff ? stbdDownwindHdg : portDownwindHdg;
        
        waypoint = calculateLaylineIntersection(
          sourcePos.lat, sourcePos.lon, leg1Hdg,
          targetPos.lat, targetPos.lon, (leg2Hdg + 180) % 360
        );
        
        // Try swapping if invalid
        if (!waypoint || !isValidWaypoint(waypoint, sourcePos, targetPos, directDist)) {
          waypoint = calculateLaylineIntersection(
            sourcePos.lat, sourcePos.lon, leg2Hdg,
            targetPos.lat, targetPos.lon, (leg1Hdg + 180) % 360
          );
          if (waypoint && isValidWaypoint(waypoint, sourcePos, targetPos, directDist)) {
            [leg1Hdg, leg2Hdg] = [leg2Hdg, leg1Hdg];
          }
        }
        
      } else if (currentIsUpwind && !targetInUpwindZone) {
        // U‚ÜíD: Sail upwind until we can bear away and fetch target directly
        leg1Speed = upwindSpeed;
        leg2Speed = downwindSpeed;
        
        // Try both upwind headings, find where we can bear away to a valid downwind angle
        const upwindOptions = [portUpwindHdg, stbdUpwindHdg];
        let bestWaypoint = null;
        let bestDist = Infinity;
        let bestLeg1Hdg = null;
        
        for (const testLeg1Hdg of upwindOptions) {
          // Find point on leg1 line where bearing to target becomes valid downwind
          const wp = findModeTransitionPoint(sourcePos, targetPos, testLeg1Hdg, twd, 'upwind-to-downwind', directDist, typicalDownwindTwa);
          
          if (wp) {
            const totalDist = haversineDistance(sourcePos.lat, sourcePos.lon, wp.lat, wp.lon) +
                              haversineDistance(wp.lat, wp.lon, targetPos.lat, targetPos.lon);
            if (totalDist < bestDist) {
              bestDist = totalDist;
              bestWaypoint = wp;
              bestLeg1Hdg = testLeg1Hdg;
            }
          }
        }
        
        if (bestWaypoint) {
          waypoint = bestWaypoint;
          leg1Hdg = bestLeg1Hdg;
          // Leg 2 goes directly to target - calculate actual bearing
          leg2Hdg = calculateBearing(waypoint.lat, waypoint.lon, targetPos.lat, targetPos.lon);
        } else {
          // Fallback: pick closer upwind heading
          const portDiff = Math.abs(angleDiff(portUpwindHdg, bearing));
          const stbdDiff = Math.abs(angleDiff(stbdUpwindHdg, bearing));
          leg1Hdg = portDiff < stbdDiff ? portUpwindHdg : stbdUpwindHdg;
          leg2Hdg = bearing; // Direct to target
        }
        
      } else {
        // D‚ÜíU: Sail downwind until we can head up and fetch target directly  
        leg1Speed = downwindSpeed;
        leg2Speed = upwindSpeed;
        
        // Try both downwind headings, find where we can head up to a valid upwind angle
        const downwindOptions = [portDownwindHdg, stbdDownwindHdg];
        let bestWaypoint = null;
        let bestDist = Infinity;
        let bestLeg1Hdg = null;
        
        for (const testLeg1Hdg of downwindOptions) {
          // Find point on leg1 line where bearing to target becomes valid upwind
          const wp = findModeTransitionPoint(sourcePos, targetPos, testLeg1Hdg, twd, 'downwind-to-upwind', directDist, typicalUpwindTwa);
          
          if (wp) {
            const totalDist = haversineDistance(sourcePos.lat, sourcePos.lon, wp.lat, wp.lon) +
                              haversineDistance(wp.lat, wp.lon, targetPos.lat, targetPos.lon);
            if (totalDist < bestDist) {
              bestDist = totalDist;
              bestWaypoint = wp;
              bestLeg1Hdg = testLeg1Hdg;
            }
          }
        }
        
        if (bestWaypoint) {
          waypoint = bestWaypoint;
          leg1Hdg = bestLeg1Hdg;
          // Leg 2 goes directly to target - calculate actual bearing
          leg2Hdg = calculateBearing(waypoint.lat, waypoint.lon, targetPos.lat, targetPos.lon);
        } else {
          // Fallback: pick closer downwind heading
          const portDiff = Math.abs(angleDiff(portDownwindHdg, bearing));
          const stbdDiff = Math.abs(angleDiff(stbdDownwindHdg, bearing));
          leg1Hdg = portDiff < stbdDiff ? portDownwindHdg : stbdDownwindHdg;
          leg2Hdg = bearing; // Direct to target
        }
      }
      
      // Final fallback: estimate waypoint if still not found
      if (!waypoint || !isValidWaypoint(waypoint, sourcePos, targetPos, directDist)) {
        const factor = currentIsUpwind ? 0.4 : 0.5;
        waypoint = {
          lat: sourcePos.lat + (directDist * factor / 111320) * Math.cos(leg1Hdg * Math.PI / 180),
          lon: sourcePos.lon + (directDist * factor / (111320 * Math.cos(sourcePos.lat * Math.PI / 180))) * Math.sin(leg1Hdg * Math.PI / 180)
        };
      }
      
      // Calculate leg distances
      const dist1 = haversineDistance(sourcePos.lat, sourcePos.lon, waypoint.lat, waypoint.lon);
      const dist2 = haversineDistance(waypoint.lat, waypoint.lon, targetPos.lat, targetPos.lon);
      const sailDist = dist1 + dist2;
      
      // Calculate TWA for each leg (for display)
      const leg1Twa = Math.abs(angleDiff(leg1Hdg, twd));
      const leg2Twa = Math.abs(angleDiff(leg2Hdg, twd));
      
      // Calculate time - each leg uses its own speed based on upwind/downwind
      const leg1Time = leg1Speed > 0.1 ? dist1 / (leg1Speed * 0.514444) : 9999;
      const leg2Time = leg2Speed > 0.1 ? dist2 / (leg2Speed * 0.514444) : 9999;
      const sailTime = leg1Time + leg2Time;
      
      return {
        type: maneuverType,
        waypoints: [sourcePos, waypoint, targetPos],
        directDist: directDist,
        sailDist: sailDist,
        time: sailTime,
        typicalSpeeds: { upwind: upwindSpeed, downwind: downwindSpeed },
        typicalTwa: { upwind: typicalUpwindTwa, downwind: typicalDownwindTwa },
        leg1: { dist: dist1, hdg: leg1Hdg, twa: leg1Twa, time: leg1Time, sog: leg1Speed },
        leg2: { dist: dist2, hdg: leg2Hdg, twa: leg2Twa, time: leg2Time, sog: leg2Speed }
      };
    }
    
    // Find the point along leg1 heading where we can transition to leg2 mode
    // For U‚ÜíD: find where bearing to target becomes valid downwind (TWA > 90)
    // For D‚ÜíU: find where bearing to target becomes valid upwind (TWA <= targetTwa)
    // targetTwa: the boat's typical TWA for the target mode
    function findModeTransitionPoint(source, target, leg1Hdg, twd, transitionType, maxDist, targetTwa) {
      const R = 6371000;
      const mPerDegLat = R * Math.PI / 180;
      const mPerDegLon = R * Math.PI / 180 * Math.cos(source.lat * Math.PI / 180);
      
      // Direction vector for leg1
      const hdgRad = leg1Hdg * Math.PI / 180;
      const dx = Math.sin(hdgRad); // East component per meter
      const dy = Math.cos(hdgRad); // North component per meter
      
      // Binary search for transition point
      // Start from source, move along leg1Hdg until bearing to target is valid for leg2
      let minT = 0;
      let maxT = maxDist * 2; // Search up to 2x direct distance
      
      const getBearingToTarget = (t) => {
        const wpLat = source.lat + (t * dy) / mPerDegLat;
        const wpLon = source.lon + (t * dx) / mPerDegLon;
        return calculateBearing(wpLat, wpLon, target.lat, target.lon);
      };
      
      const getTwaToTarget = (t) => {
        const brg = getBearingToTarget(t);
        return Math.abs(angleDiff(brg, twd));
      };
      
      // Check if transition is even possible
      const startTwa = getTwaToTarget(0);
      
      if (transitionType === 'upwind-to-downwind') {
        // Looking for TWA >= targetTwa (valid downwind, typically ~145¬∞)
        if (startTwa >= targetTwa) {
          // Already valid, return source with small offset
          return {
            lat: source.lat + (10 * dy) / mPerDegLat,
            lon: source.lon + (10 * dx) / mPerDegLon
          };
        }
        
        // Binary search for point where TWA reaches targetTwa
        for (let i = 0; i < 20; i++) {
          const midT = (minT + maxT) / 2;
          const midTwa = getTwaToTarget(midT);
          
          if (midTwa < targetTwa) {
            minT = midT; // Need to go further
          } else {
            maxT = midT; // Found valid region
          }
        }
        
        // Use maxT (first valid point with margin)
        const t = maxT * 1.05; // Small margin past transition
        if (t > maxDist * 2) return null;
        
        return {
          lat: source.lat + (t * dy) / mPerDegLat,
          lon: source.lon + (t * dx) / mPerDegLon
        };
        
      } else {
        // downwind-to-upwind: looking for TWA <= targetTwa (valid upwind, typically ~50¬∞)
        if (startTwa <= targetTwa) {
          // Already valid, return source with small offset
          return {
            lat: source.lat + (10 * dy) / mPerDegLat,
            lon: source.lon + (10 * dx) / mPerDegLon
          };
        }
        
        // Binary search for point where TWA reaches targetTwa
        for (let i = 0; i < 20; i++) {
          const midT = (minT + maxT) / 2;
          const midTwa = getTwaToTarget(midT);
          
          if (midTwa > targetTwa) {
            minT = midT; // Need to go further
          } else {
            maxT = midT; // Found valid region
          }
        }
        
        // Use maxT (first valid point with margin)
        const t = maxT * 1.05; // Small margin past transition
        if (t > maxDist * 2) return null;
        
        return {
          lat: source.lat + (t * dy) / mPerDegLat,
          lon: source.lon + (t * dx) / mPerDegLon
        };
      }
    }
    
    // Helper: validate that waypoint is reasonable (not overshooting)
    function isValidWaypoint(wp, source, target, directDist) {
      if (!wp) return false;
      const distToWp = haversineDistance(source.lat, source.lon, wp.lat, wp.lon);
      const distWpToTarget = haversineDistance(wp.lat, wp.lon, target.lat, target.lon);
      const totalDist = distToWp + distWpToTarget;
      
      // Valid if total distance is reasonable (< 2.5x direct) and waypoint isn't too far
      return totalDist < directDist * 2.5 && distToWp < directDist * 2;
    }

    
    // Calculate intersection of two rhumb lines (laylines)
    // Returns the optimal tack/gybe point between source and target
    function calculateLaylineIntersection(lat1, lon1, hdg1, lat2, lon2, hdg2) {
      // Use planar approximation for short distances (works well for typical racing distances)
      const R = 6371000; // Earth radius in meters
      const latMid = (lat1 + lat2) / 2;
      const mPerDegLat = R * Math.PI / 180;
      const mPerDegLon = R * Math.PI / 180 * Math.cos(latMid * Math.PI / 180);
      
      // Convert to local x,y coordinates (meters) relative to source
      const x1 = 0;
      const y1 = 0;
      const x2 = (lon2 - lon1) * mPerDegLon;
      const y2 = (lat2 - lat1) * mPerDegLat;
      
      // Distance from source to target
      const distToTarget = Math.sqrt(x2 * x2 + y2 * y2);
      
      // Direction vectors (heading 0 = north = +y, 90 = east = +x)
      const hdg1Rad = hdg1 * Math.PI / 180;
      const hdg2Rad = hdg2 * Math.PI / 180;
      const dx1 = Math.sin(hdg1Rad);
      const dy1 = Math.cos(hdg1Rad);
      const dx2 = Math.sin(hdg2Rad);
      const dy2 = Math.cos(hdg2Rad);
      
      // Solve parametric line intersection
      // P1 + t1 * D1 = P2 + t2 * D2
      const det = dx1 * (-dy2) - dy1 * (-dx2);
      if (Math.abs(det) < 1e-10) return null; // Parallel lines
      
      const t1 = ((x2 - x1) * (-dy2) - (y2 - y1) * (-dx2)) / det;
      
      // Only valid if intersection is ahead of starting point
      if (t1 < 0) return null;
      
      // Calculate intersection point in local coords
      const ix = x1 + t1 * dx1;
      const iy = y1 + t1 * dy1;
      
      // Check if intersection is too far past the target (overshoot)
      // Calculate distance from intersection to target
      const distFromIntersectionToTarget = Math.sqrt((ix - x2) * (ix - x2) + (iy - y2) * (iy - y2));
      const distFromSourceToIntersection = Math.sqrt(ix * ix + iy * iy);
      
      // If tack point is significantly past the target (intersection to target > 30% of source to target),
      // this is an overshoot - return null to trigger alternative calculation
      if (distFromIntersectionToTarget > distToTarget * 0.3 && distFromSourceToIntersection > distToTarget) {
        return null;
      }
      
      // Verify second boat can reach intersection (t2 should also be positive-ish)
      const t2 = dx1 !== 0 ? (x1 + t1 * dx1 - x2) / dx2 : (y1 + t1 * dy1 - y2) / dy2;
      if (t2 < -0.1) return null; // Intersection is behind b2's layline
      
      // Convert back to lat/lon
      const iLat = lat1 + iy / mPerDegLat;
      const iLon = lon1 + ix / mPerDegLon;
      
      return { lat: iLat, lon: iLon };
    }
    
    // Rolling window for sailing time smoothing (10 seconds of playback time)
    // Separate histories for each route to avoid mixing times
    let sailingTimeHistory1to2 = [];
    let sailingTimeHistory2to1 = [];
    let lastPlaybackTimeForSmoothing = -1;
    
    function getSmoothedSailingTime(currentTime, routeId = '1to2') {
      const windowMin = 10 / 60; // 10 seconds in minutes
      
      // Select the appropriate history array
      const isRoute1to2 = routeId === '1to2';
      let history = isRoute1to2 ? sailingTimeHistory1to2 : sailingTimeHistory2to1;
      
      // Detect timeline jump (more than 1 second difference or going backwards)
      const timeDiff = playbackTime - lastPlaybackTimeForSmoothing;
      if (lastPlaybackTimeForSmoothing < 0 || timeDiff < 0 || timeDiff > 0.5) {
        // Timeline jumped - clear both histories and start fresh
        sailingTimeHistory1to2 = [];
        sailingTimeHistory2to1 = [];
        history = isRoute1to2 ? sailingTimeHistory1to2 : sailingTimeHistory2to1;
      }
      lastPlaybackTimeForSmoothing = playbackTime;
      
      // Add current value with playback timestamp
      history.push({ time: currentTime, playbackT: playbackTime });
      
      // Remove entries outside the 10-second playback window
      history = history.filter(entry => 
        playbackTime - entry.playbackT >= 0 && playbackTime - entry.playbackT < windowMin
      );
      
      // Update the appropriate global array
      if (isRoute1to2) {
        sailingTimeHistory1to2 = history;
      } else {
        sailingTimeHistory2to1 = history;
      }
      
      // Calculate average
      if (history.length === 0) return currentTime;
      
      const sum = history.reduce((acc, entry) => acc + entry.time, 0);
      return sum / history.length;
    }

    function detectOutlierLegs(legs) {
      if (legs.length < 5) return { trimStart: 0, trimEnd: legs.length };
      
      // Calculate centroid of all leg midpoints (excluding first/last 20%)
      const excludeCount = Math.floor(legs.length * 0.2);
      const middleLegs = legs.slice(excludeCount, legs.length - excludeCount);
      if (middleLegs.length < 3) return { trimStart: 0, trimEnd: legs.length };
      
      let sumLat = 0, sumLon = 0;
      middleLegs.forEach(leg => {
        sumLat += (leg.startLat + leg.endLat) / 2;
        sumLon += (leg.startLon + leg.endLon) / 2;
      });
      const centroidLat = sumLat / middleLegs.length;
      const centroidLon = sumLon / middleLegs.length;
      
      // Calculate distance of each leg's START and END points from centroid (not just midpoint)
      const legDistances = legs.map(leg => {
        const startDist = haversineDistance(centroidLat, centroidLon, leg.startLat, leg.startLon);
        const endDist = haversineDistance(centroidLat, centroidLon, leg.endLat, leg.endLon);
        const midDist = haversineDistance(centroidLat, centroidLon, (leg.startLat + leg.endLat) / 2, (leg.startLon + leg.endLon) / 2);
        // Use maximum of all three - if any point is far, consider the leg an outlier
        return Math.max(startDist, endDist, midDist);
      });
      
      // Find median distance from middle legs only
      const middleDistances = legDistances.slice(excludeCount, legs.length - excludeCount);
      const sortedMiddle = [...middleDistances].sort((a, b) => a - b);
      const medianDist = sortedMiddle[Math.floor(sortedMiddle.length / 2)];
      
      // More aggressive threshold: 2x median or 300m minimum
      const threshold = Math.max(medianDist * 2, 300);
      
      // Find first leg from start that's within threshold (check up to 20 legs)
      let trimStart = 0;
      const maxCheckStart = Math.min(20, legs.length - 3);
      for (let i = 0; i < maxCheckStart; i++) {
        if (legDistances[i] <= threshold) {
          trimStart = i;
          break;
        }
        trimStart = i + 1;
      }
      
      // Find last leg from end that's within threshold (check up to 20 legs)
      let trimEnd = legs.length;
      const minCheckEnd = Math.max(3, legs.length - 20);
      for (let i = legs.length - 1; i >= minCheckEnd; i--) {
        if (legDistances[i] <= threshold) {
          trimEnd = i + 1;
          break;
        }
        trimEnd = i;
      }
      
      // Ensure we keep at least 3 legs
      if (trimEnd - trimStart < 3) {
        return { trimStart: 0, trimEnd: legs.length };
      }
      
      return { trimStart, trimEnd };
    }

    function applyAutoTrim(sessionIdx) {
      const session = ALL_SESSIONS[sessionIdx];
      if (!session || !session.originalLegs || session.originalLegs.length < 5) return;
      
      const { trimStart, trimEnd } = detectOutlierLegs(session.originalLegs);
      
      if (trimStart === 0 && trimEnd === session.originalLegs.length) {
        // No trimming needed
        return;
      }
      
      // Convert leg indices to time
      const fullDuration = session.fullDuration || session.s.dur;
      const startTime = session.originalLegs[trimStart]?.start || 0;
      const endTime = session.originalLegs[trimEnd - 1]?.end || fullDuration;
      
      const startPct = (startTime / fullDuration) * 100;
      const endPct = (endTime / fullDuration) * 100;
      
      console.log(`Auto-trim session ${sessionIdx}: trimming legs 0-${trimStart} and ${trimEnd}-${session.originalLegs.length}, time ${startTime.toFixed(1)}-${endTime.toFixed(1)}m`);
      
      applyTimelineChange(sessionIdx, startPct, endPct, true);
    }

    function toggleAutoTrim() {
      const enabled = document.getElementById('auto-trim-checkbox')?.checked;
      
      if (enabled) {
        // Apply auto-trim to all sessions
        ALL_SESSIONS.forEach((session, idx) => {
          // First reset to full duration
          session.timelineStart = 0;
          session.timelineEnd = session.fullDuration || session.s.dur;
        });
        
        // Then apply auto-trim
        ALL_SESSIONS.forEach((session, idx) => {
          applyAutoTrim(idx);
        });
      } else {
        // Reset all to full duration
        ALL_SESSIONS.forEach((session, idx) => {
          const fullDuration = session.fullDuration || session.s.dur;
          applyTimelineChange(idx, 0, 100, true);
        });
      }
      
      // Clear racing marks cache
      cachedRacingMarks = null;
      
      // Refresh current view
      const currentIdx = ALL_SESSIONS.indexOf(DATA);
      if (currentIdx >= 0) {
        DATA = ALL_SESSIONS[currentIdx];
      }
      
      selectedLeg = null;
      
      // Re-render based on current mode
      if (raceReplayMode) {
        renderRaceReplayTimeline();
        renderMap();
        renderVideoMinimap();
        updateVideoTelemetry();
      } else {
        renderDashboard();
        renderComparison();
        renderTimeline();
        fitMapToTrimmedTrack();
      }
    }

    // Re-render timeline on window resize
    window.addEventListener('resize', () => {
      if (DATA) renderTimeline();
      // Update race replay leg charts on resize
      if (raceReplayMode) {
        Object.values(raceReplayLegCharts).forEach(chart => {
          if (chart) chart.resize();
        });
      }
    });

    // ===== RACE REPLAY FUNCTIONS =====
    function toggleSessionForReplay(idx, checked) {
      if (checked) {
        selectedSessionsForReplay.add(idx);
        if (!replaySessionOrder.includes(idx)) {
          replaySessionOrder.push(idx);
        }
      } else {
        selectedSessionsForReplay.delete(idx);
        replaySessionOrder = replaySessionOrder.filter(i => i !== idx);
      }
      renderComparison();
      // Update video overlay visibility when sessions change in race replay mode
      if (raceReplayMode) {
        updateVideoTelemetry();
        renderVideoMinimap();
      }
    }

    function toggleAllSessionsForReplay(checked) {
      if (checked) {
        ALL_SESSIONS.forEach((_, idx) => {
          selectedSessionsForReplay.add(idx);
          if (!replaySessionOrder.includes(idx)) {
            replaySessionOrder.push(idx);
          }
        });
      } else {
        selectedSessionsForReplay.clear();
        replaySessionOrder = [];
      }
      renderComparison();
      // Update video overlay visibility when sessions change in race replay mode
      if (raceReplayMode) {
        updateVideoTelemetry();
        renderVideoMinimap();
      }
    }

    // Get the earliest real-world timestamp across all replay sessions (considering trim)
    function getPlaybackStartTimeMs() {
      const sessions = getReplaySessions();
      if (sessions.length === 0) return 0;
      
      let minTimestamp = Infinity;
      sessions.forEach(session => {
        const sessionStartMs = session.startTimestampMs || 0;
        const trimStartMin = session.timelineStart || 0;
        const effectiveStartMs = sessionStartMs + trimStartMin * 60000;
        minTimestamp = Math.min(minTimestamp, effectiveStartMs);
      });
      return minTimestamp;
    }

    // Get the latest real-world timestamp across all replay sessions (considering trim)
    function getPlaybackEndTimeMs() {
      const sessions = getReplaySessions();
      if (sessions.length === 0) return 0;
      
      let maxTimestamp = 0;
      sessions.forEach(session => {
        const sessionStartMs = session.startTimestampMs || 0;
        const trimEndMin = session.timelineEnd || session.s.dur;
        const effectiveEndMs = sessionStartMs + trimEndMin * 60000;
        maxTimestamp = Math.max(maxTimestamp, effectiveEndMs);
      });
      return maxTimestamp;
    }
    
    // Get the earliest real-world timestamp across all replay sessions (FULL, ignoring trim)
    function getFullStartTimeMs() {
      // In aligned timeline mode (normal mode with multiple sessions), use ALL_SESSIONS
      // In race replay mode, use getReplaySessions()
      const sessions = raceReplayMode ? getReplaySessions() : ALL_SESSIONS;
      if (sessions.length === 0) return 0;
      
      let minTimestamp = Infinity;
      sessions.forEach(session => {
        const sessionStartMs = session.startTimestampMs || 0;
        minTimestamp = Math.min(minTimestamp, sessionStartMs);
      });
      return minTimestamp;
    }
    
    // Get the latest real-world timestamp across all replay sessions (FULL, ignoring trim)
    function getFullEndTimeMs() {
      // In aligned timeline mode (normal mode with multiple sessions), use ALL_SESSIONS
      // In race replay mode, use getReplaySessions()
      const sessions = raceReplayMode ? getReplaySessions() : ALL_SESSIONS;
      if (sessions.length === 0) return 0;
      
      let maxTimestamp = 0;
      sessions.forEach(session => {
        const sessionStartMs = session.startTimestampMs || 0;
        const fullDuration = session.fullDuration || session.s.dur;
        const fullEndMs = sessionStartMs + fullDuration * 60000;
        maxTimestamp = Math.max(maxTimestamp, fullEndMs);
      });
      return maxTimestamp;
    }

    // playbackTimeMs is the current real-world timestamp being displayed
    let playbackTimeMs = 0;

    // Get the latest trim start across all replay sessions (so all boats are visible from the start)
    function getPlaybackStartTime() {
      const sessions = getReplaySessions();
      if (sessions.length === 0) return 0;
      
      // Find the latest effective start time across all sessions
      const referenceStartMs = getFullStartTimeMs();  // Earliest absolute start
      let maxOffsetMin = 0;
      
      sessions.forEach(session => {
        const sessionStartMs = session.startTimestampMs || 0;
        const trimStartMin = session.timelineStart || 0;
        const effectiveStartMs = sessionStartMs + trimStartMin * 60000;
        // Calculate offset from reference (earliest) start
        const offsetMin = (effectiveStartMs - referenceStartMs) / 60000;
        maxOffsetMin = Math.max(maxOffsetMin, offsetMin);
      });
      
      return maxOffsetMin;  // Return offset where all boats have started
    }
    
    function getPlaybackDuration() {
      // Return the latest trimmed end as offset in minutes from fullStartMs
      const fullStartMs = getFullStartTimeMs();
      const endMs = getPlaybackEndTimeMs();
      return (endMs - fullStartMs) / 60000;
    }

    function startRaceReplay() {
      if (selectedSessionsForReplay.size < 1) return;
      
      // Synchronize replaySessionOrder with selectedSessionsForReplay
      // Add any selected sessions that aren't in the order yet
      selectedSessionsForReplay.forEach(idx => {
        if (!replaySessionOrder.includes(idx)) {
          replaySessionOrder.push(idx);
        }
      });
      // Remove any sessions from order that are no longer selected
      replaySessionOrder = replaySessionOrder.filter(idx => selectedSessionsForReplay.has(idx));
      
      raceReplayMode = true;
      
      // Disable multi-session/split-screen mode if it was enabled
      if (multiSessionView) {
        multiSessionView = false;
        disableSplitScreenMode();
      }
      
      // Hide multi-session toggle in race replay mode
      updateMultiSessionToggleVisibility();
      
      // Reset timeslot to full range
      replayTimelineStartPct = 0;
      replayTimelineEndPct = 100;
      
      // Start at the beginning of full timeline
      // playbackTime is in minutes relative to fullStartMs
      playbackTime = 0;
      
      isPlaying = false;
      currentLegIds = [];  // Reset leg tracking for fresh start
      currentBoatLegsData = [];  // Reset boat legs data
      lastValidBoatLegs = [];  // Reset last valid legs
      lastValidMapLegs = [];  // Reset last valid map legs
      cachedRacingMarks = null;  // Clear marks cache to recalculate for new session
      
      // Hide normal dashboard elements, show race replay
      // Keep timeline section visible for trimming
      document.getElementById('comparison-section').classList.add('hidden');
      document.getElementById('stats-and-tabs-section').classList.add('hidden');
      document.getElementById('stats-panel').classList.add('hidden');
      document.getElementById('legs-panel').style.display = 'none';
      document.getElementById('view-config-section').style.display = 'none';
      document.getElementById('race-replay-right-column').style.display = 'flex';
      document.getElementById('legs-comparison-section').classList.remove('hidden');
      document.getElementById('back-to-sessions-header-btn').classList.remove('hidden');
      
      // Update view config card to show hide gray toggle
      updateViewConfigCard();
      
      // Expand container for full-width race replay
      document.querySelector('.container').style.maxWidth = 'none';
      document.querySelector('.container').style.padding = '0 24px';
      
      // Make map bigger for race replay
      const mapEl = document.getElementById('map');
      mapEl.setAttribute('width', '500');
      mapEl.setAttribute('height', '500');
      
      // Show fullscreen button in race replay mode
      const fullscreenBtn = document.getElementById('map-fullscreen-btn');
      if (fullscreenBtn) fullscreenBtn.style.display = 'block';
      
      renderRaceReplay();
      renderTimeline();  // Re-render timelines with boat colors and pointers
      updatePlaybackUI();
      updateBoatInfoPanel();
      updateCurrentLegsPanel();
      resetMapZoom();  // Reset map to show all tracks
      renderMap();
      
      // Add keyboard listeners for race replay
      document.addEventListener('keydown', handleRaceReplayKeydown);
    }

    function exitRaceReplay() {
      stopPlayback();
      destroyRaceReplayCharts();  // Clean up leg charts
      currentLegIds = [];  // Reset leg tracking
      currentBoatLegsData = [];  // Reset boat legs data
      lastValidBoatLegs = [];  // Reset last valid legs
      lastValidMapLegs = [];  // Reset last valid map legs
      raceReplayMode = false;
      playbackTime = 0;
      
      // Exit fullscreen mode if active
      if (mapFullscreen) {
        exitMapFullscreen();
      }
      
      // Hide fullscreen button when exiting race replay
      const fullscreenBtn = document.getElementById('map-fullscreen-btn');
      if (fullscreenBtn) fullscreenBtn.style.display = 'none';
      
      // Show multi-session toggle if applicable (aligned mode with 2+ sessions)
      updateMultiSessionToggleVisibility();
      
      // Remove keyboard listeners
      document.removeEventListener('keydown', handleRaceReplayKeydown);
      
      // Show normal dashboard elements, hide race replay
      document.getElementById('comparison-section').classList.remove('hidden');
      document.getElementById('stats-and-tabs-section').classList.remove('hidden');
      document.getElementById('view-config-section').style.display = '';
      document.getElementById('race-replay-right-column').style.display = 'none';
      document.getElementById('legs-comparison-section').classList.add('hidden');
      document.getElementById('back-to-sessions-header-btn').classList.add('hidden');
      
      // Update view config card to hide the hide gray toggle
      updateViewConfigCard();
      
      // Restore the correct panel based on view mode
      setViewMode(viewMode);
      
      // Pause all videos
      pauseAllVideos();
      
      // Reset video display to placeholder
      resetVideoDisplay();
      
      // Restore container width
      document.querySelector('.container').style.maxWidth = '1400px';
      document.querySelector('.container').style.padding = '';
      
      // Restore map size (match initial 500x500 from HTML/CSS)
      const mapEl = document.getElementById('map');
      mapEl.setAttribute('width', '500');
      mapEl.setAttribute('height', '500');
      
      renderComparison();
      renderTimeline();  // Re-render timelines to remove boat colors and pointers
      fitMapToTrimmedTrack();
      renderMap();
      
      // Pre-select first leg so leg details panel isn't empty
      if (DATA && DATA.legs && DATA.legs.length > 0) {
        selectLeg(DATA.legs[0]);
      }
    }

    function getReplaySessions() {
      return replaySessionOrder
        .map(idx => ALL_SESSIONS[idx])
        .filter(s => s);
    }

    function renderRaceReplay() {
      const container = document.getElementById('race-replay-section');
      if (!container) return;
      
      const sessions = getReplaySessions();
      const duration = getPlaybackDuration();
      
      container.innerHTML = `
        <div class="race-replay-container" style="display:flex;align-items:center;gap:12px;flex-wrap:nowrap;">
          <div class="race-replay-title">üèÅ ${sessions.length} Boat${sessions.length !== 1 ? 's' : ''}</div>
          <button class="btn btn-play" id="playback-btn" onclick="togglePlayback()">‚ñ∂ Play</button>
          <div style="display:flex;gap:2px;align-items:center;">
            <button class="speed-btn active" data-speed="1" onclick="setPlaybackSpeed(1)">1√ó</button>
            <button class="speed-btn" data-speed="2" onclick="setPlaybackSpeed(2)">2√ó</button>
            <button class="speed-btn" data-speed="4" onclick="setPlaybackSpeed(4)">4√ó</button>
            <button class="speed-btn" data-speed="8" onclick="setPlaybackSpeed(8)">8√ó</button>
            <button class="speed-btn" data-speed="16" onclick="setPlaybackSpeed(16)">16√ó</button>
          </div>
          <button class="fs-overlay-btn" onclick="decreaseWidgetScale()" style="font-size:11px;padding:2px 6px;background:#374151;color:#9ca3af;border:1px solid #4b5563;border-radius:3px;cursor:pointer;display:none;" title="Decrease overlay size">‚àí</button>
          <button class="fs-overlay-btn" onclick="resetWidgetOverlays()" style="font-size:9px;padding:2px 6px;background:#374151;color:#9ca3af;border:1px solid #4b5563;border-radius:3px;cursor:pointer;white-space:nowrap;display:none;" title="Reset overlay widgets to default position and size">Reset overlays</button>
          <button class="fs-overlay-btn" onclick="increaseWidgetScale()" style="font-size:11px;padding:2px 6px;background:#374151;color:#9ca3af;border:1px solid #4b5563;border-radius:3px;cursor:pointer;display:none;" title="Increase overlay size">+</button>
          <div class="status-dot" style="width:10px;height:10px;border-radius:50%;background:#22c55e;flex-shrink:0;display:none;"></div>
          <div class="timeline-wrapper">
            <div class="video-coverage-bar" id="video-coverage-bar"></div>
            <div class="playback-timeline" id="playback-timeline">
              <div class="playback-progress" id="playback-progress" style="width:0%"></div>
              <div class="playback-handle" id="playback-handle" style="left:0%"></div>
            </div>
          </div>
          <div class="playback-time" id="playback-time" style="font-size:11px;white-space:nowrap;">0:00 / ${formatPlaybackTime(duration)}</div>
        </div>
      `;
      
      // Initialize playback listeners
      initPlaybackListeners();
      updatePlaybackUI();
      
      // Render video timeline markers if videos are loaded
      renderVideoTimelineMarkers();
      updateActiveVideoDisplay();
    }
    
    function toggleHideGrayTracksMap() {
      const toggle = document.getElementById('hide-gray-tracks-map');
      const slider = document.getElementById('hide-gray-slider');
      const track = toggle.nextElementSibling;
      
      hideGrayTracks = toggle ? toggle.checked : false;
      
      if (slider && track) {
        if (hideGrayTracks) {
          slider.style.transform = 'translateX(14px)';
          track.style.backgroundColor = '#7c3aed';
        } else {
          slider.style.transform = 'translateX(0)';
          track.style.backgroundColor = '#ccc';
        }
      }
      
      renderMap();  // Re-render map with new setting
      renderVideoMinimap();  // Re-render minimap too
    }
    
    function openTrackFadeConfigDialog() {
      // Remove existing dialog if any
      const existing = document.getElementById('track-fade-config-modal');
      if (existing) existing.remove();
      
      const modal = document.createElement('div');
      modal.id = 'track-fade-config-modal';
      modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:10001;';
      
      modal.innerHTML = `
        <div style="background:white;border-radius:12px;padding:24px;max-width:360px;width:90%;box-shadow:0 20px 60px rgba(0,0,0,0.3);">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
            <h3 style="margin:0;font-size:18px;color:#1f2937;">Track Fade Settings</h3>
            <button onclick="closeTrackFadeConfigDialog()" style="background:none;border:none;font-size:20px;cursor:pointer;color:#6b7280;">√ó</button>
          </div>
          
          <div style="margin-bottom:20px;">
            <label style="display:block;font-size:13px;color:#374151;margin-bottom:8px;font-weight:500;">
              Full opacity period: <span id="recent-value" style="color:#7c3aed;font-weight:bold;">${trackRecentWindow}</span> min
            </label>
            <input type="range" id="track-recent-slider" min="1" max="60" value="${trackRecentWindow}" 
              oninput="document.getElementById('recent-value').textContent=this.value"
              style="width:100%;accent-color:#7c3aed;">
            <div style="display:flex;justify-content:space-between;font-size:10px;color:#9ca3af;">
              <span>1 min</span>
              <span>60 min</span>
            </div>
          </div>
          
          <div style="margin-bottom:20px;">
            <label style="display:block;font-size:13px;color:#374151;margin-bottom:8px;font-weight:500;">
              Fade to gray period: <span id="fade-value" style="color:#7c3aed;font-weight:bold;">${trackFadeWindow}</span> min
            </label>
            <input type="range" id="track-fade-slider" min="5" max="120" value="${trackFadeWindow}" 
              oninput="document.getElementById('fade-value').textContent=this.value"
              style="width:100%;accent-color:#7c3aed;">
            <div style="display:flex;justify-content:space-between;font-size:10px;color:#9ca3af;">
              <span>5 min</span>
              <span>120 min</span>
            </div>
          </div>
          
          <div style="background:#f3f4f6;border-radius:8px;padding:12px;margin-bottom:20px;">
            <div style="font-size:11px;color:#6b7280;">
              <div style="margin-bottom:4px;">‚Ä¢ <strong>Full opacity</strong>: Track from last ${trackRecentWindow} min shown at 100%</div>
              <div style="margin-bottom:4px;">‚Ä¢ <strong>Fading</strong>: Track from ${trackRecentWindow}-${trackFadeWindow} min gradually fades</div>
              <div>‚Ä¢ <strong>Gray</strong>: Track older than ${trackFadeWindow} min shown in gray</div>
            </div>
          </div>
          
          <div style="display:flex;gap:10px;">
            <button onclick="closeTrackFadeConfigDialog()" style="flex:1;padding:10px;border:1px solid #d1d5db;background:white;border-radius:6px;cursor:pointer;font-size:14px;">Cancel</button>
            <button onclick="applyTrackFadeConfig()" style="flex:1;padding:10px;border:none;background:#7c3aed;color:white;border-radius:6px;cursor:pointer;font-size:14px;font-weight:500;">Apply</button>
          </div>
        </div>
      `;
      
      getModalContainer().appendChild(modal);
      
      // Update preview text when sliders change
      const recentSlider = document.getElementById('track-recent-slider');
      const fadeSlider = document.getElementById('track-fade-slider');
      
      const updatePreview = () => {
        const recent = recentSlider.value;
        const fade = fadeSlider.value;
        const previewDiv = modal.querySelector('.background\\:#f3f4f6');
        if (previewDiv) {
          previewDiv.innerHTML = `
            <div style="font-size:11px;color:#6b7280;">
              <div style="margin-bottom:4px;">‚Ä¢ <strong>Full opacity</strong>: Track from last ${recent} min shown at 100%</div>
              <div style="margin-bottom:4px;">‚Ä¢ <strong>Fading</strong>: Track from ${recent}-${fade} min gradually fades</div>
              <div>‚Ä¢ <strong>Gray</strong>: Track older than ${fade} min shown in gray</div>
            </div>
          `;
        }
      };
      
      recentSlider.addEventListener('input', updatePreview);
      fadeSlider.addEventListener('input', updatePreview);
      
      // Close on backdrop click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) closeTrackFadeConfigDialog();
      });
    }
    
    function closeTrackFadeConfigDialog() {
      const modal = document.getElementById('track-fade-config-modal');
      if (modal) modal.remove();
    }
    
    function applyTrackFadeConfig() {
      const recentSlider = document.getElementById('track-recent-slider');
      const fadeSlider = document.getElementById('track-fade-slider');
      
      if (recentSlider && fadeSlider) {
        trackRecentWindow = parseInt(recentSlider.value);
        trackFadeWindow = parseInt(fadeSlider.value);
        
        // Ensure fade window is at least equal to recent window
        if (trackFadeWindow < trackRecentWindow) {
          trackFadeWindow = trackRecentWindow;
        }
      }
      
      closeTrackFadeConfigDialog();
      renderMap();
      renderVideoMinimap();
    }
    
    function resetWidgetOverlays() {
      // Reset all widget states to default
      Object.keys(widgetState).forEach(widgetId => {
        widgetState[widgetId] = { minimized: false, x: null, y: null, dragged: false, width: null, height: null, resized: false };
        
        const widget = document.getElementById(widgetId);
        if (!widget) return;
        
        // Remove dragged class and inline styles
        widget.classList.remove('dragged', 'minimized');
        widget.style.top = '';
        widget.style.left = '';
        widget.style.bottom = '';
        widget.style.right = '';
        widget.style.transform = '';
        widget.style.width = '';
        widget.style.height = '';
        
        // Update minimize button (‚ñº = expanded)
        const btn = widget.querySelector('.fs-minimize-btn');
        if (btn) {
          btn.textContent = '‚ñº';
        }
      });
      
      // Reset leg2 telemetry font size
      const leg2Panel = document.getElementById('minimap-leg2-telemetry');
      if (leg2Panel) {
        leg2Panel.style.fontSize = '';
      }
      const leg2Label = document.getElementById('telem-leg2-label');
      if (leg2Label) {
        leg2Label.style.fontSize = '';
      }
      
      // Reset widget scale to default
      widgetScale = 1.0;
      applyWidgetScale();
      
      // Re-render minimap
      renderVideoMinimap();
    }

    // Playback toggle mutex to prevent race conditions
    let playbackToggleLock = false;
    
    async function togglePlayback() {
      // Prevent rapid toggle race conditions
      if (playbackToggleLock) {
        console.log('togglePlayback: locked, ignoring');
        return;
      }
      
      playbackToggleLock = true;
      try {
        if (isPlaying) {
          await stopPlayback();
        } else {
          await startPlayback();
        }
      } finally {
        // Release lock after a short delay to debounce rapid presses
        setTimeout(() => { playbackToggleLock = false; }, 100);
      }
    }

    async function startPlayback() {
      if (!raceReplayMode) return;
      
      const duration = getPlaybackDuration();
      const startTime = getPlaybackStartTime();
      const timeslotStart = getTimeslotStartTime();
      const timeslotEnd = getTimeslotEndTime();
      
      // If at or past the end, restart from timeslot start
      if (playbackTime >= timeslotEnd || playbackTime < timeslotStart) {
        playbackTime = timeslotStart;
      }
      
      isPlaying = true;
      playbackLastFrameTime = 0;  // Will be set on first frame
      // Update all playback buttons (main and fullscreen)
      document.querySelectorAll('#playback-btn').forEach(btn => {
        btn.textContent = '‚è∏ Pause';
        btn.classList.add('playing');
      });
      playbackAnimationId = requestAnimationFrame(playbackLoop);
      
      // Start videos - await to ensure proper sequencing
      await playAllVideos();
    }

    async function stopPlayback() {
      isPlaying = false;
      // Update all playback buttons (main and fullscreen)
      document.querySelectorAll('#playback-btn').forEach(btn => {
        btn.textContent = '‚ñ∂ Play';
        btn.classList.remove('playing');
      });
      if (playbackAnimationId) {
        cancelAnimationFrame(playbackAnimationId);
        playbackAnimationId = null;
      }
      
      // Pause videos - await to ensure proper sequencing
      await pauseAllVideos();
      
      // Force UI update to clear any buffering status
      updateVideoOverlays();
    }

    let lastRenderTime = 0;
    const RENDER_INTERVAL = 100; // Render at most every 100ms (10fps) to give priority to video
    
    // Check if video is currently playing
    function isVideoPlaying() {
      if (currentActiveVideo && currentActiveVideo.is360Video && current360Player) {
        return !current360Player.paused;
      }
      return currentActiveVideo && !currentActiveVideo.element.paused;
    }
    
    function playbackLoop(timestamp) {
      if (!isPlaying) return;
      
      // First frame - initialize timestamp
      if (playbackLastFrameTime === 0) {
        playbackLastFrameTime = timestamp;
        lastRenderTime = timestamp;
        playbackAnimationId = requestAnimationFrame(playbackLoop);
        return;
      }
      
      const elapsed = (timestamp - playbackLastFrameTime) / 1000;  // seconds
      playbackLastFrameTime = timestamp;
      
      // Skip if elapsed is too large (tab was inactive) or negative
      if (elapsed > 0.5 || elapsed < 0) {
        playbackAnimationId = requestAnimationFrame(playbackLoop);
        return;
      }
      
      // If video is stalled, don't advance playback time - wait for video to catch up
      // EXCEPT for INSV 360 videos which use wall-clock timing (time keeps advancing even during buffer issues)
      const isINSVWallClock = current360Player && current360Player.wallClockStart && 
                               currentActiveVideo && currentActiveVideo.is360Video;
      if (videoStalled && currentActiveVideo && !isINSVWallClock) {
        // Continue the animation loop but don't advance time
        playbackAnimationId = requestAnimationFrame(playbackLoop);
        return;
      }
      
      // Advance playback time (convert seconds to minutes, apply speed multiplier)
      // When video is playing, periodic sync will correct any drift
      playbackTime += (elapsed * playbackSpeed) / 60;
      
      // Get effective end time based on timeslot selection
      const duration = getPlaybackDuration();
      const startTime = getPlaybackStartTime();
      const effectiveEndTime = getTimeslotEndTime();
      
      if (playbackTime >= effectiveEndTime) {
        playbackTime = effectiveEndTime;
        stopPlayback();
        updatePlaybackUI();
        updateBoatInfoPanel();
        updateCurrentLegsPanel();
        updateTimelinePlaybackPointer();
        updateLegTimelinePointer();
        renderMap();
        return;
      }
      
      // Update UI on every frame
      perfMonitor.track('playbackUI', () => updatePlaybackUI());
      
      // Use longer intervals when video is playing to reduce CPU competition
      // Map at 500ms (2fps) is sufficient - boat barely moves at 10fps video
      const effectiveRenderInterval = isVideoPlaying() ? 500 : RENDER_INTERVAL;
      const CHART_UPDATE_INTERVAL = isVideoPlaying() ? 1000 : 500;
      
      if (timestamp - lastRenderTime >= effectiveRenderInterval) {
        lastRenderTime = timestamp;
        
        // Check if we need to switch videos
        // But don't switch if a load is already in progress for the target video
        const targetVideo = getCurrentOrNextVideo();
        if (targetVideo !== currentActiveVideo && !window.videoLoadInProgress) {
          updateActiveVideoDisplay();
        } else {
          // Sync video target time for INSV wall-clock tracking
          perfMonitor.track('videoSync', () => syncVideosToPlayback(false));
          // Update video time display (lightweight operation)
          perfMonitor.track('videoOverlays', () => updateVideoOverlays());
        }
        
        // Use idle callback for heavy renders when video is playing
        if (isVideoPlaying() && window.requestIdleCallback) {
          requestIdleCallback(() => {
            perfMonitor.track('boatPanel', () => updateBoatInfoPanel());
            perfMonitor.track('timelinePointer', () => updateTimelinePlaybackPointer());
            updateLegTimelinePointer();
            perfMonitor.track('mapRender', () => renderMap());
          }, { timeout: 300 });
        } else {
          perfMonitor.track('boatPanel', () => updateBoatInfoPanel());
          perfMonitor.track('timelinePointer', () => updateTimelinePlaybackPointer());
          updateLegTimelinePointer();
          perfMonitor.track('mapRender', () => renderMap());
        }
      }
      
      // Update leg charts less frequently
      if (!window.lastChartRenderTime) window.lastChartRenderTime = 0;
      if (timestamp - window.lastChartRenderTime >= CHART_UPDATE_INTERVAL) {
        window.lastChartRenderTime = timestamp;
        
        if (isVideoPlaying() && window.requestIdleCallback) {
          requestIdleCallback(() => {
            perfMonitor.track('legsPanel', () => updateCurrentLegsPanel());
            perfMonitor.track('chartPointers', () => updateChartTimePointers());
          }, { timeout: 500 });
        } else {
          perfMonitor.track('legsPanel', () => updateCurrentLegsPanel());
          perfMonitor.track('chartPointers', () => updateChartTimePointers());
        }
      }
      
      // Log performance summary periodically
      perfMonitor.logSummary();
      
      if (isPlaying) {
        playbackAnimationId = requestAnimationFrame(playbackLoop);
      }
    }
    
    // Get the effective end time based on timeslot selection (in playbackTime units)
    // playbackTime is in minutes relative to fullStartMs
    function getTimeslotEndTime() {
      const fullStartMs = getFullStartTimeMs();
      const fullEndMs = getFullEndTimeMs();
      const fullDurationMs = fullEndMs - fullStartMs;
      
      // Target absolute ms
      const targetMs = fullStartMs + (replayTimelineEndPct / 100) * fullDurationMs;
      
      // Return in minutes relative to fullStartMs
      return (targetMs - fullStartMs) / 60000;
    }
    
    // Get the effective start time based on timeslot selection (in playbackTime units)
    // playbackTime is in minutes relative to fullStartMs
    function getTimeslotStartTime() {
      const fullStartMs = getFullStartTimeMs();
      const fullEndMs = getFullEndTimeMs();
      const fullDurationMs = fullEndMs - fullStartMs;
      
      // Target absolute ms
      const targetMs = fullStartMs + (replayTimelineStartPct / 100) * fullDurationMs;
      
      // Return in minutes relative to fullStartMs
      return (targetMs - fullStartMs) / 60000;
    }
    
    // Get timeslot range in absolute milliseconds
    function getTimeslotRangeMs() {
      const fullStartMs = getFullStartTimeMs();
      const fullEndMs = getFullEndTimeMs();
      const fullDurationMs = fullEndMs - fullStartMs;
      
      return {
        startMs: fullStartMs + (replayTimelineStartPct / 100) * fullDurationMs,
        endMs: fullStartMs + (replayTimelineEndPct / 100) * fullDurationMs
      };
    }
    
    // Check if a track point (with session context) is within timeslot
    function isPointInTimeslot(session, trackPointTime) {
      const { startMs, endMs } = getTimeslotRangeMs();
      const sessionStartMs = session.startTimestampMs || 0;
      const trimStartMin = session.timelineStart || 0;
      
      // Convert track point time to absolute ms
      // trackPointTime is relative to trimmed start
      const pointAbsMs = sessionStartMs + (trimStartMin + trackPointTime) * 60000;
      
      return pointAbsMs >= startMs && pointAbsMs <= endMs;
    }
    
    // Recalculate all tracks based on timeslot selection
    function setPlaybackSpeed(speed) {
      playbackSpeed = speed;
      // Update button active states - only highlight 1, 2, 4, 8, 16x buttons
      // For 32x and 64x, don't highlight any button
      document.querySelectorAll('.speed-btn').forEach(btn => {
        const btnSpeed = parseInt(btn.dataset.speed);
        btn.classList.toggle('active', btnSpeed === speed && speed <= 16);
      });
      
      // Update video mute and playback rate
      updateVideoPlaybackRate();
    }

    // Flag to disable keyboard shortcuts when export dialog is open
    let videoExportDialogOpen = false;
    let lastExportMarkerChanged = 'start'; // Track which export marker was last changed
    
    // Global function to update active marker visual state
    function updateExportActiveMarkerUI() {
      const handleStart = document.getElementById('export-handle-start');
      const handleEnd = document.getElementById('export-handle-end');
      const startInput = document.getElementById('export-start-time');
      const endInput = document.getElementById('export-end-time');
      const startHint = document.getElementById('start-time-hint');
      const endHint = document.getElementById('end-time-hint');
      
      if (!handleStart || !handleEnd || !startInput || !endInput) return;
      
      const startInputFocused = document.activeElement === startInput;
      const endInputFocused = document.activeElement === endInput;
      
      if (lastExportMarkerChanged === 'start') {
        startInput.style.border = '2px solid #2563eb';
        endInput.style.border = '1px solid #d1d5db';
        handleStart.style.background = '#1d4ed8';
        handleStart.style.boxShadow = '0 0 6px #2563eb';
        handleEnd.style.background = '#2563eb';
        handleEnd.style.boxShadow = '0 1px 3px rgba(0,0,0,0.3)';
        if (startHint) startHint.textContent = startInputFocused ? '(‚Üë‚Üì to adjust)' : '(‚Üê‚Üí active)';
        if (endHint) endHint.textContent = '';
      } else {
        startInput.style.border = '1px solid #d1d5db';
        endInput.style.border = '2px solid #2563eb';
        handleStart.style.background = '#2563eb';
        handleStart.style.boxShadow = '0 1px 3px rgba(0,0,0,0.3)';
        handleEnd.style.background = '#1d4ed8';
        handleEnd.style.boxShadow = '0 0 6px #2563eb';
        if (startHint) startHint.textContent = '';
        if (endHint) endHint.textContent = endInputFocused ? '(‚Üë‚Üì to adjust)' : '(‚Üê‚Üí active)';
      }
    }
    
    // Update export marker position based on current playbackTime
    function updateExportMarkerFromPlayback() {
      if (!videoExportDialogOpen) return;
      
      const globalStartMs = window.exportGlobalStartMs;
      const totalDurationMs = window.exportTotalDurationMs;
      if (!globalStartMs || !totalDurationMs) return;
      
      const globalDurationMin = totalDurationMs / 60000;
      const pct = (playbackTime / globalDurationMin) * 100;
      const clampedPct = Math.max(0, Math.min(100, pct));
      
      const handleStart = document.getElementById('export-handle-start');
      const handleEnd = document.getElementById('export-handle-end');
      const selectionRange = document.getElementById('export-selection-range');
      const startInput = document.getElementById('export-start-time');
      const endInput = document.getElementById('export-end-time');
      
      if (!handleStart || !handleEnd) return;
      
      const formatClockTime = (ms) => new Date(ms).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit', hour12: false});
      
      const startPct = parseFloat(handleStart.style.left) || 0;
      const endPct = 100 - (parseFloat(handleEnd.style.right) || 0);
      
      if (lastExportMarkerChanged === 'start') {
        // Update start marker (but don't go past end - 2%)
        const newStartPct = Math.min(clampedPct, endPct - 2);
        handleStart.style.left = newStartPct + '%';
        selectionRange.style.left = newStartPct + '%';
        const startMs = globalStartMs + (newStartPct / 100) * totalDurationMs;
        if (startInput) startInput.value = formatClockTime(startMs);
        // Update start marker lines
        document.querySelectorAll('.export-marker-start').forEach(m => {
          m.style.left = newStartPct + '%';
        });
      } else {
        // Update end marker (but don't go before start + 2%)
        const newEndPct = Math.max(clampedPct, startPct + 2);
        handleEnd.style.right = (100 - newEndPct) + '%';
        selectionRange.style.right = (100 - newEndPct) + '%';
        const endMs = globalStartMs + (newEndPct / 100) * totalDurationMs;
        if (endInput) endInput.value = formatClockTime(endMs);
        // Update end marker lines
        document.querySelectorAll('.export-marker-end').forEach(m => {
          m.style.left = newEndPct + '%';
          m.style.right = 'auto';
        });
      }
    }
    
    // Handle keydown events on video wrapper (for fullscreen mode)
    function handleVideoWrapperKeydown(e) {
      // Delegate to the main race replay keydown handler
      handleRaceReplayKeydown(e);
    }
    
    // Refocus video wrapper in fullscreen to ensure keyboard events work
    function refocusVideoWrapper() {
      if (isInFullscreen()) {
        const wrapper = document.getElementById('video-wrapper');
        if (wrapper) {
          // Use setTimeout to ensure focus happens after click processing
          setTimeout(() => {
            wrapper.focus();
          }, 0);
        }
      }
    }
    
    function handleRaceReplayKeydown(e) {
      if (!raceReplayMode) return;
      
      // Check if export dialog input is focused - let input handlers deal with it
      const activeElement = document.activeElement;
      if (activeElement && (activeElement.id === 'export-start-time' || activeElement.id === 'export-end-time')) {
        // Input fields handle their own up/down arrows
        return;
      }
      
      // If export dialog is open, handle arrow keys for marker adjustment
      if (videoExportDialogOpen) {
        if (e.code === 'ArrowRight' || e.code === 'ArrowLeft') {
          e.preventDefault();
          
          const globalStartMs = window.exportGlobalStartMs;
          const totalDurationMs = window.exportTotalDurationMs;
          if (globalStartMs === undefined || !totalDurationMs) return;
          
          const stepMs = 10000; // 10 seconds
          const stepPct = (stepMs / totalDurationMs) * 100;
          const delta = e.code === 'ArrowRight' ? stepPct : -stepPct;
          
          const handleStart = document.getElementById('export-handle-start');
          const handleEnd = document.getElementById('export-handle-end');
          const selectionRange = document.getElementById('export-selection-range');
          const startInput = document.getElementById('export-start-time');
          const endInput = document.getElementById('export-end-time');
          
          if (!handleStart || !handleEnd) return;
          
          const formatClockTime = (ms) => new Date(ms).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit', hour12: false});
          
          const startPct = parseFloat(handleStart.style.left) || 0;
          const endPct = 100 - (parseFloat(handleEnd.style.right) || 0);
          
          if (lastExportMarkerChanged === 'start') {
            const newStartPct = Math.max(0, Math.min(endPct - 2, startPct + delta));
            handleStart.style.left = newStartPct + '%';
            selectionRange.style.left = newStartPct + '%';
            const startMs = globalStartMs + (newStartPct / 100) * totalDurationMs;
            if (startInput) startInput.value = formatClockTime(startMs);
            document.querySelectorAll('.export-marker-start').forEach(m => {
              m.style.left = newStartPct + '%';
            });
            // Also update playback position to match
            playbackTime = (newStartPct / 100) * (totalDurationMs / 60000);
          } else {
            const newEndPct = Math.max(startPct + 2, Math.min(100, endPct + delta));
            handleEnd.style.right = (100 - newEndPct) + '%';
            selectionRange.style.right = (100 - newEndPct) + '%';
            const endMs = globalStartMs + (newEndPct / 100) * totalDurationMs;
            if (endInput) endInput.value = formatClockTime(endMs);
            document.querySelectorAll('.export-marker-end').forEach(m => {
              m.style.left = newEndPct + '%';
              m.style.right = 'auto';
            });
            // Also update playback position to match
            playbackTime = (newEndPct / 100) * (totalDurationMs / 60000);
          }
          
          // Update map to show current position and active marker UI
          renderMap();
          updatePlaybackUI();
          updateBoatInfoPanel();
          updateExportActiveMarkerUI();
          return;
        }
        
        // Space still toggles playback
        if (e.code === 'Space') {
          e.preventDefault();
          togglePlayback();
        }
        return;
      }
      
      const timeslotStart = getTimeslotStartTime();
      const timeslotEnd = getTimeslotEndTime();
      const stepSize = 10 / 60;  // 10 seconds in minutes
      
      // Helper for arrow-based seeking with debounce
      const handleArrowSeek = (newTime) => {
        playbackTime = newTime;
        updatePlaybackUI();
        updateBoatInfoPanel();
        updateCurrentLegsPanel();
        updateChartTimePointers();
        updateTimelinePlaybackPointer();
        renderMap();
        
        // Debounce the actual video seek - only seek after 80ms of no key presses
        // This prevents overwhelming the decoder with rapid seeks
        if (window.arrowSeekTimeout) {
          clearTimeout(window.arrowSeekTimeout);
        }
        window.arrowSeekTimeout = setTimeout(() => {
          window.arrowSeekTimeout = null;
          syncVideosToPlayback(true);  // Force seek on manual scrub
        }, 80);
      };
      
      if (e.code === 'Space') {
        e.preventDefault();
        togglePlayback();
      } else if (e.code === 'KeyF') {
        e.preventDefault();
        // If video is available, toggle video fullscreen; otherwise toggle map fullscreen
        if (current360Player) {
          toggleVideoFullscreen();
        } else {
          toggleMapFullscreen();
        }
      } else if (e.code === 'ArrowRight') {
        e.preventDefault();
        handleArrowSeek(Math.min(timeslotEnd, playbackTime + stepSize));
      } else if (e.code === 'ArrowLeft') {
        e.preventDefault();
        handleArrowSeek(Math.max(timeslotStart, playbackTime - stepSize));
      } else if (e.code === 'ArrowUp') {
        e.preventDefault();
        const smallStep = 1 / 60;  // 1 second in minutes
        handleArrowSeek(Math.min(timeslotEnd, playbackTime + smallStep));
      } else if (e.code === 'ArrowDown') {
        e.preventDefault();
        const smallStep = 1 / 60;  // 1 second in minutes
        handleArrowSeek(Math.max(timeslotStart, playbackTime - smallStep));
      } else if (e.key === '1') {
        e.preventDefault();
        setPlaybackSpeed(1);
      } else if (e.key === '2') {
        e.preventDefault();
        setPlaybackSpeed(2);
      } else if (e.key === '3') {
        e.preventDefault();
        setPlaybackSpeed(4);
      } else if (e.key === '5') {
        e.preventDefault();
        setPlaybackSpeed(8);
      } else if (e.key === '6') {
        e.preventDefault();
        setPlaybackSpeed(16);
      } else if (e.key === '7') {
        e.preventDefault();
        setPlaybackSpeed(32);
      } else if (e.key === '8') {
        e.preventDefault();
        setPlaybackSpeed(64);
      }
    }

    function updatePlaybackUI() {
      // In race replay mode, use timeslot range for progress bar
      let startTime, endTime;
      if (raceReplayMode) {
        startTime = getTimeslotStartTime();
        endTime = getTimeslotEndTime();
      } else {
        startTime = getPlaybackStartTime();
        endTime = getPlaybackDuration();
      }
      
      const range = endTime - startTime;
      const progress = range > 0 ? ((playbackTime - startTime) / range) * 100 : 0;
      
      // Update all matching elements (main and fullscreen)
      document.querySelectorAll('#playback-progress').forEach(el => {
        el.style.width = `${Math.max(0, Math.min(100, progress))}%`;
      });
      document.querySelectorAll('#playback-handle').forEach(el => {
        el.style.left = `${Math.max(0, Math.min(100, progress))}%`;
      });
      document.querySelectorAll('#playback-time').forEach(el => {
        // Show time relative to timeslot start
        const relativeTime = playbackTime - startTime;
        const totalTime = endTime - startTime;
        el.textContent = `${formatPlaybackTime(Math.max(0, relativeTime))} / ${formatPlaybackTime(totalTime)}`;
      });
      
      // Update replay timeline markers
      if (raceReplayMode) {
        updateReplayTimelineMarkers();
      }
      
      // Update fullscreen map telemetry overlay
      if (mapFullscreen && fsMapTelemetryVisible) {
        updateFsMapTelemetry();
        updateFsMapLegTelemetry();
      }
    }

    function formatPlaybackTime(minutes) {
      const m = Math.floor(minutes);
      const s = Math.floor((minutes - m) * 60);
      return `${m}:${s.toString().padStart(2, '0')}`;
    }

    function initPlaybackListeners() {
      const timeline = document.getElementById('playback-timeline');
      const handle = document.getElementById('playback-handle');
      const coverageBar = document.getElementById('video-coverage-bar');
      
      if (!timeline || !handle) return;
      
      // Remove old listeners by cloning
      const newTimeline = timeline.cloneNode(true);
      timeline.parentNode.replaceChild(newTimeline, timeline);
      
      const newHandle = newTimeline.querySelector('#playback-handle');
      
      newHandle.addEventListener('mousedown', handleTimelineDragStart);
      newHandle.addEventListener('touchstart', handleTimelineTouchStart, { passive: false });
      newTimeline.addEventListener('click', handleTimelineClick);
      newTimeline.addEventListener('touchend', handleTimelineTouchEnd, { passive: false });
      
      // Add click listener to coverage bar
      if (coverageBar) {
        coverageBar.addEventListener('click', handleTimelineClick);
        coverageBar.addEventListener('touchend', handleTimelineTouchEnd, { passive: false });
      }
    }
    
    function handleTimelineDragStart(e) {
      e.preventDefault();
      e.stopPropagation();
      isDraggingPlayback = true;
    }
    
    function handleTimelineTouchStart(e) {
      e.preventDefault();
      e.stopPropagation();
      isDraggingPlayback = true;
    }
    
    function handleTimelineTouchEnd(e) {
      if (e.target.id === 'playback-handle') {
        isDraggingPlayback = false;
        return;
      }
      const touch = e.changedTouches[0];
      if (!touch) return;
      const timeline = e.currentTarget;
      const rect = timeline.getBoundingClientRect();
      const pct = Math.max(0, Math.min(1, (touch.clientX - rect.left) / rect.width));
      
      // In race replay mode, use timeslot range
      let startTime, endTime;
      if (raceReplayMode) {
        startTime = getTimeslotStartTime();
        endTime = getTimeslotEndTime();
      } else {
        startTime = getPlaybackStartTime();
        endTime = getPlaybackDuration();
      }
      
      playbackTime = startTime + pct * (endTime - startTime);
      updatePlaybackUI();
      updateBoatInfoPanel();
      updateCurrentLegsPanel();
      updateChartTimePointers();
      updateTimelinePlaybackPointer();
      renderMap();
      syncVideosToPlayback(true);
    }
    
    function handleTimelineClick(e) {
      if (e.target.id === 'playback-handle') return;
      const timeline = e.currentTarget;
      const rect = timeline.getBoundingClientRect();
      const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      
      // In race replay mode, use timeslot range
      let startTime, endTime;
      if (raceReplayMode) {
        startTime = getTimeslotStartTime();
        endTime = getTimeslotEndTime();
      } else {
        startTime = getPlaybackStartTime();
        endTime = getPlaybackDuration();
      }
      
      playbackTime = startTime + pct * (endTime - startTime);
      updatePlaybackUI();
      updateBoatInfoPanel();
      updateCurrentLegsPanel();
      updateChartTimePointers();
      updateTimelinePlaybackPointer();
      updateLegTimelinePointer();
      renderMap();
      
      // Update video display (may switch videos if needed)
      updateActiveVideoDisplay();
      syncVideosToPlayback(true);  // Force seek on click
    }
    
    // Global mouse handlers for playback drag
    document.addEventListener('mousemove', (e) => {
      if (!isDraggingPlayback) return;
      // Find visible timeline (main or fullscreen)
      let timeline = document.getElementById('playback-timeline');
      const replayControls = document.getElementById('video-replay-controls');
      if (replayControls && replayControls.style.display !== 'none') {
        const fsTimeline = replayControls.querySelector('.playback-timeline');
        if (fsTimeline) timeline = fsTimeline;
      }
      if (!timeline) return;
      const rect = timeline.getBoundingClientRect();
      const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      
      // In race replay mode, use timeslot range
      let startTime, endTime;
      if (raceReplayMode) {
        startTime = getTimeslotStartTime();
        endTime = getTimeslotEndTime();
      } else {
        startTime = getPlaybackStartTime();
        endTime = getPlaybackDuration();
      }
      
      playbackTime = startTime + pct * (endTime - startTime);
      updatePlaybackUI();
      updateBoatInfoPanel();
      updateCurrentLegsPanel();
      updateChartTimePointers();
      updateTimelinePlaybackPointer();
      updateLegTimelinePointer();
      renderMap();
      syncVideosToPlayback(true);  // Force seek on drag (handles video switching and overlays)
    });
    
    document.addEventListener('mouseup', () => {
      isDraggingPlayback = false;
    });
    
    // Touch event handlers for mobile timeline scrubbing
    document.addEventListener('touchmove', (e) => {
      if (!isDraggingPlayback) return;
      const touch = e.touches[0];
      if (!touch) return;
      
      // Find visible timeline (main or fullscreen)
      let timeline = document.getElementById('playback-timeline');
      const replayControls = document.getElementById('video-replay-controls');
      if (replayControls && replayControls.style.display !== 'none') {
        const fsTimeline = replayControls.querySelector('.playback-timeline');
        if (fsTimeline) timeline = fsTimeline;
      }
      if (!timeline) return;
      const rect = timeline.getBoundingClientRect();
      const pct = Math.max(0, Math.min(1, (touch.clientX - rect.left) / rect.width));
      
      // In race replay mode, use timeslot range
      let startTime, endTime;
      if (raceReplayMode) {
        startTime = getTimeslotStartTime();
        endTime = getTimeslotEndTime();
      } else {
        startTime = getPlaybackStartTime();
        endTime = getPlaybackDuration();
      }
      
      playbackTime = startTime + pct * (endTime - startTime);
      updatePlaybackUI();
      updateBoatInfoPanel();
      updateCurrentLegsPanel();
      updateChartTimePointers();
      updateTimelinePlaybackPointer();
      renderMap();
      syncVideosToPlayback(true);  // Handles video switching and overlays
    }, { passive: true });
    
    document.addEventListener('touchend', () => {
      isDraggingPlayback = false;
    });

    // Convert global playbackTime to session-local time in minutes
    // playbackTime is in minutes relative to fullStartMs
    function getSessionLocalTime(session, globalPlaybackTime) {
      const fullStartMs = getFullStartTimeMs();
      const currentTimeMs = fullStartMs + globalPlaybackTime * 60000;
      const sessionStartMs = session.startTimestampMs || 0;
      return (currentTimeMs - sessionStartMs) / 60000;
    }
    
    // Check if a session has data at the given playback time (based on full data, not trim)
    function isSessionActiveAtTime(session, globalPlaybackTime) {
      const sessionLocalTime = getSessionLocalTime(session, globalPlaybackTime);
      const fullDuration = session.fullDuration || session.s.dur;
      return sessionLocalTime >= 0 && sessionLocalTime <= fullDuration;
    }
    
    // Check if a session's trimmed data overlaps with the current timeslot
    function isSessionInTimeslot(session) {
      // Use export timeslot if set, otherwise main view's timeslot
      let timeslotStartMs, timeslotEndMs;
      if (window.exportTimeslotStartMs !== undefined && window.exportTimeslotEndMs !== undefined) {
        timeslotStartMs = window.exportTimeslotStartMs;
        timeslotEndMs = window.exportTimeslotEndMs;
      } else {
        const timeslotRange = getTimeslotRangeMs();
        timeslotStartMs = timeslotRange.startMs;
        timeslotEndMs = timeslotRange.endMs;
      }
      
      const sessionStartMs = session.startTimestampMs || 0;
      const trimStartMin = session.timelineStart || 0;
      const trimEndMin = session.timelineEnd || session.s.dur;
      
      // Session's trimmed range in absolute milliseconds
      const sessionTrimStartMs = sessionStartMs + trimStartMin * 60000;
      const sessionTrimEndMs = sessionStartMs + trimEndMin * 60000;
      
      // Check if ranges overlap
      return sessionTrimStartMs <= timeslotEndMs && sessionTrimEndMs >= timeslotStartMs;
    }
    
    // Combined check: session has data AND it overlaps with timeslot
    function isSessionVisibleAtTime(session, globalPlaybackTime) {
      return isSessionActiveAtTime(session, globalPlaybackTime) && isSessionInTimeslot(session);
    }

    function getBoatPositionAtTime(session, globalTimeMin) {
      // Use originalTrack (full session) for consistent time values during trim drag
      const track = session.originalTrack || session.track;
      if (!session || !track || track.length === 0) return null;
      
      // Convert global time to session-local time
      const sessionLocalTime = getSessionLocalTime(session, globalTimeMin);
      
      const sessionStart = session.timelineStart || 0;
      const sessionEnd = session.timelineEnd || (session.fullDuration || session.s.dur);
      
      // Check if time is within session bounds (in session-local coordinates)
      if (sessionLocalTime < sessionStart || sessionLocalTime > sessionEnd) return null;
      
      // When using originalTrack, t values are relative to session start (not trim start)
      // So trackTime = sessionLocalTime directly
      const trackTime = sessionLocalTime;
      
      // Find closest track point within the current trim range
      let closestIdx = -1;
      let minDiff = Infinity;
      
      for (let i = 0; i < track.length; i++) {
        // Skip points outside current trim
        if (track[i].t < sessionStart || track[i].t > sessionEnd) continue;
        
        const diff = Math.abs(track[i].t - trackTime);
        if (diff < minDiff) {
          minDiff = diff;
          closestIdx = i;
        }
      }
      
      if (closestIdx < 0 || minDiff > 2) return null;
      
      const p = track[closestIdx];
      const twd = session.s.twd || 0;
      const twa = Math.abs(angleDiff(p.hdg || p.cog, twd));
      const vmg = Math.abs((p.sog || 0) * Math.cos(twa * Math.PI / 180));
      
      return {
        lat: p.lat,
        lon: p.lon,
        sog: p.sog || 0,
        cog: p.cog || 0,
        hdg: p.hdg || p.cog || 0,
        vmg: vmg,
        twa: twa,
        heel: p.roll_deg || 0,
        t: p.t
      };
    }
    
    // Get smoothed telemetry over a time window (in minutes)
    function getSmoothedTelemetry(session, globalTimeMin, windowSec = 2) {
      // Use originalTrack for consistent time values during trim drag
      const track = session.originalTrack || session.track;
      if (!session || !track || track.length === 0) return null;
      
      const sessionLocalTime = getSessionLocalTime(session, globalTimeMin);
      const sessionStart = session.timelineStart || 0;
      const sessionEnd = session.timelineEnd || (session.fullDuration || session.s.dur);
      
      if (sessionLocalTime < sessionStart || sessionLocalTime > sessionEnd) return null;
      
      // When using originalTrack, t values are relative to session start
      const trackTime = sessionLocalTime;
      const windowMin = windowSec / 60;
      
      // Find points within the window and within trim range
      const windowStart = trackTime - windowMin;
      const windowEnd = trackTime;
      
      const pointsInWindow = track.filter(p => 
        p.t >= windowStart && p.t <= windowEnd && p.t >= sessionStart && p.t <= sessionEnd
      );
      
      if (pointsInWindow.length === 0) {
        // Fall back to single point
        const pos = getBoatPositionAtTime(session, globalTimeMin);
        if (pos) pos.steeringRate = 0;
        return pos;
      }
      
      // Calculate averages
      const twd = session.s.twd || 0;
      let sogSum = 0, vmgSum = 0, heelSum = 0;
      let hdgSin = 0, hdgCos = 0;
      
      // Calculate steering rate (heading change rate)
      let steeringRateSum = 0;
      let steeringCount = 0;
      
      pointsInWindow.forEach((p, i) => {
        sogSum += p.sog || 0;
        heelSum += p.roll_deg || 0;
        const hdgRad = (p.hdg || p.cog || 0) * Math.PI / 180;
        hdgSin += Math.sin(hdgRad);
        hdgCos += Math.cos(hdgRad);
        
        const twa = Math.abs(angleDiff(p.hdg || p.cog, twd));
        vmgSum += Math.abs((p.sog || 0) * Math.cos(twa * Math.PI / 180));
        
        // Calculate steering rate between consecutive points
        if (i > 0) {
          const prevP = pointsInWindow[i - 1];
          const dt = (p.t - prevP.t) * 60; // Convert minutes to seconds
          if (dt > 0) {
            const hdgChange = Math.abs(angleDiff(p.hdg || p.cog, prevP.hdg || prevP.cog));
            steeringRateSum += hdgChange / dt;
            steeringCount++;
          }
        }
      });
      
      const n = pointsInWindow.length;
      const avgHdg = Math.atan2(hdgSin / n, hdgCos / n) * 180 / Math.PI;
      const avgSteeringRate = steeringCount > 0 ? steeringRateSum / steeringCount : 0;
      
      return {
        sog: sogSum / n,
        vmg: vmgSum / n,
        hdg: (avgHdg + 360) % 360,
        heel: heelSum / n,
        steeringRate: avgSteeringRate
      };
    }

    function getCurrentLegAtTime(session, globalTimeMin) {
      if (!session || !session.legs) return null;
      
      // Convert global time to session-local time
      const sessionLocalTime = getSessionLocalTime(session, globalTimeMin);
      
      const sessionStart = session.timelineStart || 0;
      // Leg start/end times are relative to the trimmed track (starting from 0)
      const trackTime = sessionLocalTime - sessionStart;
      
      for (const leg of session.legs) {
        if (trackTime >= leg.start && trackTime <= leg.end) {
          return leg;
        }
      }
      return null;
    }

    function updateBoatInfoPanel() {
      const sessions = getReplaySessions();
      const boatInfoTelemetryTime = getTelemetryDisplayTime();
      
      sessions.forEach((session, i) => {
        const isActive = isSessionVisibleAtTime(session, boatInfoTelemetryTime);
        const pos = getBoatPositionAtTime(session, boatInfoTelemetryTime);
        const sogEl = document.getElementById(`boat-${i}-sog`);
        const vmgEl = document.getElementById(`boat-${i}-vmg`);
        const cogEl = document.getElementById(`boat-${i}-cog`);
        const rowEl = document.getElementById(`boat-${i}-row`);
        
        // Hide entire row if session is not active at current time
        if (rowEl) {
          rowEl.style.display = isActive ? '' : 'none';
        }
        
        if (pos && isActive) {
          if (sogEl) sogEl.textContent = `${(pos.sog || 0).toFixed(1)}kt`;
          if (vmgEl) vmgEl.textContent = `${(pos.vmg || 0).toFixed(1)}kt`;
          if (cogEl) cogEl.textContent = `${Math.round(pos.cog || 0)}¬∞`;
        } else {
          if (sogEl) sogEl.textContent = '-';
          if (vmgEl) vmgEl.textContent = '-';
          if (cogEl) cogEl.textContent = '-';
        }
      });
    }

    // Store race replay leg charts
    let raceReplayLegCharts = {};
    // Track current leg IDs to avoid unnecessary rebuilds
    let currentLegIds = [];
    // Track sessions for time pointer updates
    let currentBoatLegsData = [];
    // Store last valid legs for each boat (to show during transitions)
    let lastValidBoatLegs = [];
    // Store last valid legs for map legend
    let lastValidMapLegs = [];

    function destroyRaceReplayCharts() {
      Object.values(raceReplayLegCharts).forEach(chart => {
        if (chart) chart.destroy();
      });
      raceReplayLegCharts = {};
    }

    function updateChartTimePointers() {
      // Update time pointer annotations on existing charts without rebuilding
      if (currentBoatLegsData.length === 0) return;
      
      currentBoatLegsData.forEach(({ session, leg, idx }) => {
        if (!leg || !leg.ts || leg.ts.length === 0) return;
        
        // Calculate current time position within the leg
        const sessionLocalTime = getSessionLocalTime(session, playbackTime);
        const sessionStart = session.timelineStart || 0;
        const trackTime = sessionLocalTime - sessionStart;
        
        // Find the index in ts array closest to current time
        let timePointerIdx = null;
        if (trackTime >= leg.start && trackTime <= leg.end) {
          let minDiff = Infinity;
          for (let i = 0; i < leg.ts.length; i++) {
            const diff = Math.abs(leg.ts[i].t - trackTime);
            if (diff < minDiff) {
              minDiff = diff;
              timePointerIdx = i;
            }
          }
        }
        
        // Update each chart's annotation (main panel)
        ['rate', 'cog', 'heel', 'spd', 'mag'].forEach(chartType => {
          const chart = raceReplayLegCharts[`${chartType}-${idx}`];
          if (chart && chart.options.plugins.annotation) {
            if (timePointerIdx !== null) {
              chart.options.plugins.annotation.annotations.timePointer = {
                type: 'line',
                xMin: timePointerIdx,
                xMax: timePointerIdx,
                borderColor: '#ef4444',
                borderWidth: 2,
                borderDash: [3, 3]
              };
            } else {
              delete chart.options.plugins.annotation.annotations.timePointer;
            }
            chart.update('none');  // Update without animation
          }
          
          // Also update fullscreen charts if in fullscreen mode
          if (mapFullscreen) {
            const fsChart = fsRaceReplayLegCharts[`${chartType}-${idx}`];
            if (fsChart && fsChart.options.plugins.annotation) {
              if (timePointerIdx !== null) {
                fsChart.options.plugins.annotation.annotations.timePointer = {
                  type: 'line',
                  xMin: timePointerIdx,
                  xMax: timePointerIdx,
                  borderColor: '#ef4444',
                  borderWidth: 2,
                  borderDash: [3, 3]
                };
              } else {
                delete fsChart.options.plugins.annotation.annotations.timePointer;
              }
              fsChart.update('none');
            }
          }
        });
      });
    }

    function updateCurrentLegsPanel() {
      const container = document.getElementById('current-legs-content');
      if (!container) return;
      
      const sessions = getReplaySessions();
      const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };
      const posNames = { upwind: 'Upwind', reaching: 'Reaching', downwind: 'Downwind' };
      
      // Filter to only sessions that have data at current playback time
      const activeSessions = sessions.map((session, i) => ({
        session,
        originalIdx: i,
        isActive: isSessionVisibleAtTime(session, playbackTime)
      })).filter(s => s.isActive);
      
      // Get current leg for each active session, fall back to last valid leg
      const boatLegs = activeSessions.map(({ session, originalIdx }) => {
        const color = BOAT_COLORS[originalIdx % BOAT_COLORS.length];
        const boatSymbol = getBoatSymbol(session.filename);
        let leg = getCurrentLegAtTime(session, playbackTime);
        let isStale = false;
        
        // If no current leg, use last valid leg for this boat
        if (!leg && lastValidBoatLegs[originalIdx]) {
          leg = lastValidBoatLegs[originalIdx];
          isStale = true;  // Mark as showing previous data
        }
        
        // Update last valid leg if we have a current one
        if (leg && !isStale) {
          lastValidBoatLegs[originalIdx] = leg;
        }
        
        return { session, color, boatSymbol, leg, idx: originalIdx, isStale };
      });
      
      // Check if legs have changed - only rebuild if different
      const newLegIds = boatLegs.map(b => b.leg ? `${b.leg.id}-${b.isStale}` : null);
      const legsChanged = newLegIds.length !== currentLegIds.length || 
                          newLegIds.some((id, i) => id !== currentLegIds[i]);
      
      if (!legsChanged) {
        return;  // Same legs, no need to rebuild
      }
      
      currentLegIds = newLegIds;
      currentBoatLegsData = boatLegs;  // Save for time pointer updates
      
      // Destroy previous charts only when rebuilding
      destroyRaceReplayCharts();
      
      // Check if any boat has a leg (current or stale)
      const hasAnyLeg = boatLegs.some(b => b.leg);
      
      if (!hasAnyLeg) {
        container.innerHTML = '<div style="color:#9ca3af;text-align:center;padding:12px;min-height:240px;display:flex;align-items:center;justify-content:center;">No leg data available</div>';
        return;
      }
      
      // Build side-by-side detailed leg views
      const cardCount = boatLegs.length;
      let html = '<div style="display:flex;gap:12px;min-height:240px;width:100%;box-sizing:border-box;">';
      
      boatLegs.forEach(({ session, color, boatSymbol, leg, idx, isStale }) => {
        if (!leg) {
          // This should rarely happen now with lastValidBoatLegs fallback
          html += `
            <div style="flex:1 1 0;min-width:0;min-height:220px;background:#f9fafb;border-radius:8px;padding:12px;border-top:3px solid ${color};opacity:0.5;display:flex;flex-direction:column;overflow:hidden;">
              <div style="display:flex;align-items:center;gap:6px;margin-bottom:8px;">
                <div style="width:20px;height:20px;background:${color};border-radius:50%;display:flex;align-items:center;justify-content:center;color:white;font-size:10px;font-weight:bold;">${idx+1}</div>
                <span style="font-weight:600;color:${color};">${boatSymbol}</span>
              </div>
              <div style="color:#9ca3af;text-align:center;flex:1;display:flex;align-items:center;justify-content:center;">Waiting for data...</div>
            </div>
          `;
          return;
        }
        
        const posBadge = leg.pos === 'upwind' ? 'badge-up' : leg.pos === 'reaching' ? 'badge-reach' : 'badge-down';
        const staleOpacity = isStale ? 'opacity:0.6;' : '';
        const staleIndicator = isStale ? '<span style="font-size:8px;color:#9ca3af;margin-left:4px;">(prev)</span>' : '';
        
        // Safe access to leg properties
        const dur = leg.dur != null ? `${leg.dur}s` : '-';
        const rate = leg.rate != null ? leg.rate.toFixed(2) : '-';
        const corridor = leg.corridor != null ? `¬±${leg.corridor.toFixed(1)}¬∞` : '-';
        const devPct = leg.lineDeviation != null ? `${(leg.lineDeviation * 100).toFixed(1)}%` : '-';
        const speed = leg.speed != null ? leg.speed : '-';
        const vmg = leg.vmg != null ? leg.vmg : '-';
        const hdg = leg.hdg != null ? `${leg.hdg}¬∞` : '-';
        const twa = leg.twa != null ? `${leg.twa}¬∞` : '-';
        const twd = leg.localWind != null ? `${leg.localWind}¬∞` : (session.s.twd != null ? `${session.s.twd}¬∞` : '-');
        const heel = leg.heel != null ? `${leg.heel}¬∞` : '-';
        
        // Rate/Corridor colors
        const rateVal = leg.rate || 0;
        const rateColor = rateVal <= 2 ? '#22c55e' : rateVal <= 4 ? '#84cc16' : rateVal <= 6 ? '#eab308' : rateVal <= 10 ? '#f97316' : '#ef4444';
        const corrVal = leg.corridor || 0;
        const corrColor = corrVal <= 5 ? '#22c55e' : corrVal <= 10 ? '#84cc16' : corrVal <= 15 ? '#eab308' : corrVal <= 20 ? '#f97316' : '#ef4444';
        
        // Next maneuver badge
        let nextBadge = '<span style="color:#9ca3af;">‚Äî</span>';
        if (leg.next_maneuver) {
          const bgColor = leg.next_maneuver.type === 'tack' ? '#dbeafe' : '#fef3c7';
          const textColor = leg.next_maneuver.type === 'tack' ? '#1d4ed8' : '#b45309';
          nextBadge = `<span style="background:${bgColor};color:${textColor};padding:2px 6px;border-radius:3px;font-weight:600;">${leg.next_maneuver.type === 'tack' ? 'T' : 'G'}${leg.next_maneuver.angle}¬∞</span>`;
        }
        
        html += `
          <div style="flex:1 1 0;min-width:0;background:#f9fafb;border-radius:8px;padding:12px;border-top:3px solid ${color};${staleOpacity}overflow:hidden;">
            <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">
              <div style="display:flex;align-items:center;gap:6px;">
                <div style="width:20px;height:20px;background:${color};border-radius:50%;display:flex;align-items:center;justify-content:center;color:white;font-size:10px;font-weight:bold;">${idx+1}</div>
                <span style="font-weight:600;color:${color};">${boatSymbol}</span>
              </div>
              <span class="badge ${posBadge}">Leg #${leg.id} ${posNames[leg.pos]}${staleIndicator}</span>
            </div>
            
            <!-- Stats grid -->
            <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:6px;margin-bottom:8px;">
              <div style="background:white;border-radius:4px;padding:6px;text-align:center;">
                <div style="font-size:9px;color:#6b7280;">TWD/Hdg/TWA</div>
                <div style="font-weight:600;font-size:10px;">${twd}/${hdg}/${twa}</div>
              </div>
              <div style="background:white;border-radius:4px;padding:6px;text-align:center;">
                <div style="font-size:9px;color:#6b7280;">Spd/VMG</div>
                <div style="font-weight:600;font-size:11px;">${speed}/${vmg}</div>
              </div>
              <div style="background:white;border-radius:4px;padding:6px;text-align:center;">
                <div style="font-size:9px;color:#6b7280;">Duration</div>
                <div style="font-weight:600;font-size:11px;">${dur}</div>
              </div>
              <div style="background:white;border-radius:4px;padding:6px;text-align:center;">
                <div style="font-size:9px;color:#6b7280;">Next</div>
                <div style="font-weight:600;font-size:11px;">${nextBadge}</div>
              </div>
            </div>
            
            <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:6px;margin-bottom:8px;">
              <div style="background:white;border-radius:4px;padding:6px;text-align:center;">
                <div style="font-size:9px;color:#6b7280;">Rate</div>
                <div style="font-weight:600;font-size:11px;color:${rateColor};">${rate}¬∞/s</div>
              </div>
              <div style="background:white;border-radius:4px;padding:6px;text-align:center;">
                <div style="font-size:9px;color:#6b7280;">COG Corr</div>
                <div style="font-weight:600;font-size:11px;color:${corrColor};">${corridor}</div>
              </div>
              <div style="background:white;border-radius:4px;padding:6px;text-align:center;">
                <div style="font-size:9px;color:#6b7280;">Deviation</div>
                <div style="font-weight:600;font-size:11px;">${devPct}</div>
              </div>
              <div style="background:white;border-radius:4px;padding:6px;text-align:center;">
                <div style="font-size:9px;color:#6b7280;">Heel</div>
                <div style="font-weight:600;font-size:11px;">${heel}</div>
              </div>
            </div>
            
            <!-- Charts - same order as main page: Speed, Mag Dev, Steering, COG Dev, Heel -->
            <div style="margin-top:10px;">
              <div style="font-size:9px;color:#6b7280;margin-bottom:2px;">Speed/VMG</div>
              <div style="height:50px;position:relative;width:100%;"><canvas id="race-leg-spd-${idx}"></canvas></div>
            </div>
            <div style="margin-top:8px;">
              <div style="font-size:9px;color:#6b7280;margin-bottom:2px;">MAG Deviation</div>
              <div style="height:50px;position:relative;width:100%;"><canvas id="race-leg-mag-${idx}"></canvas></div>
            </div>
            <div style="margin-top:8px;">
              <div style="font-size:9px;color:#6b7280;margin-bottom:2px;">Steering Rate</div>
              <div style="height:50px;position:relative;width:100%;"><canvas id="race-leg-rate-${idx}"></canvas></div>
            </div>
            <div style="margin-top:8px;">
              <div style="font-size:9px;color:#6b7280;margin-bottom:2px;">COG Deviation</div>
              <div style="height:50px;position:relative;width:100%;"><canvas id="race-leg-cog-${idx}"></canvas></div>
            </div>
            <div style="margin-top:8px;">
              <div style="font-size:9px;color:#6b7280;margin-bottom:2px;">Heel</div>
              <div style="height:50px;position:relative;width:100%;"><canvas id="race-leg-heel-${idx}"></canvas></div>
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      container.innerHTML = html;
      
      // Render charts for each boat
      boatLegs.forEach(({ session, color, leg, idx }) => {
        if (!leg || !leg.ts || leg.ts.length === 0) return;
        
        const labels = leg.ts.map(p => p.t.toFixed(1));
        
        // Calculate current time position within the leg for the time pointer
        const sessionLocalTime = getSessionLocalTime(session, playbackTime);
        const sessionStart = session.timelineStart || 0;
        const trackTime = sessionLocalTime - sessionStart;
        
        // Find the index in ts array closest to current time
        let timePointerIdx = null;
        if (trackTime >= leg.start && trackTime <= leg.end) {
          let minDiff = Infinity;
          for (let i = 0; i < leg.ts.length; i++) {
            const diff = Math.abs(leg.ts[i].t - trackTime);
            if (diff < minDiff) {
              minDiff = diff;
              timePointerIdx = i;
            }
          }
        }
        
        // Time pointer annotation - always include structure for updates
        const timePointerAnnotation = {
          annotation: {
            annotations: timePointerIdx !== null ? {
              timePointer: {
                type: 'line',
                xMin: timePointerIdx,
                xMax: timePointerIdx,
                borderColor: '#ef4444',
                borderWidth: 2,
                borderDash: [3, 3]
              }
            } : {}
          }
        };
        
        const chartOptions = {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          plugins: { 
            legend: { display: false },
            ...timePointerAnnotation
          },
          scales: {
            x: { display: false },
            y: { 
              display: true,
              ticks: { font: { size: 8 }, maxTicksLimit: 3 },
              grid: { display: false }
            }
          },
          elements: { point: { radius: 0 } }
        };
        
        // Speed/VMG chart (first)
        const spdCtx = document.getElementById(`race-leg-spd-${idx}`);
        if (spdCtx) {
          raceReplayLegCharts[`spd-${idx}`] = new Chart(spdCtx.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  data: leg.ts.map(p => p.spd),
                  borderColor: '#3b82f6',
                  borderWidth: 1.5,
                  tension: 0.3,
                  fill: false
                },
                {
                  data: leg.ts.map(p => p.vmg),
                  borderColor: '#22c55e',
                  borderWidth: 1.5,
                  tension: 0.3,
                  fill: false
                }
              ]
            },
            options: chartOptions
          });
        }
        
        // MAG Deviation chart (second)
        const magCtx = document.getElementById(`race-leg-mag-${idx}`);
        if (magCtx && leg.ts.some(p => p.mdev != null)) {
          raceReplayLegCharts[`mag-${idx}`] = new Chart(magCtx.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: leg.ts.map(p => p.mdev),
                borderColor: '#8b5cf6',
                backgroundColor: '#8b5cf620',
                borderWidth: 1.5,
                tension: 0.3,
                fill: true
              }]
            },
            options: {
              ...chartOptions,
              scales: {
                ...chartOptions.scales,
                y: { ...chartOptions.scales.y, min: -20, max: 20 }
              }
            }
          });
        }
        
        // Rate chart (third)
        const rateCtx = document.getElementById(`race-leg-rate-${idx}`);
        if (rateCtx) {
          raceReplayLegCharts[`rate-${idx}`] = new Chart(rateCtx.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: leg.ts.map(p => p.rate),
                borderColor: color,
                backgroundColor: `${color}20`,
                borderWidth: 1.5,
                tension: 0.3,
                fill: true
              }]
            },
            options: {
              ...chartOptions,
              scales: {
                ...chartOptions.scales,
                y: { ...chartOptions.scales.y, min: 0, max: 10 }
              }
            }
          });
        }
        
        // COG deviation chart (fourth)
        const cogCtx = document.getElementById(`race-leg-cog-${idx}`);
        if (cogCtx) {
          raceReplayLegCharts[`cog-${idx}`] = new Chart(cogCtx.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: leg.ts.map(p => p.dev),
                borderColor: color,
                backgroundColor: `${color}20`,
                borderWidth: 1.5,
                tension: 0.3,
                fill: true
              }]
            },
            options: {
              ...chartOptions,
              scales: {
                ...chartOptions.scales,
                y: { ...chartOptions.scales.y, min: -20, max: 20 }
              }
            }
          });
        }
        
        // Heel chart (fifth)
        const heelCtx = document.getElementById(`race-leg-heel-${idx}`);
        if (heelCtx && leg.ts.some(p => p.heel != null)) {
          raceReplayLegCharts[`heel-${idx}`] = new Chart(heelCtx.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: leg.ts.map(p => p.heel),
                borderColor: '#f59e0b',
                backgroundColor: '#f59e0b20',
                borderWidth: 1.5,
                tension: 0.3,
                fill: true
              }]
            },
            options: {
              ...chartOptions,
              scales: {
                ...chartOptions.scales,
                y: { ...chartOptions.scales.y, min: -25, max: 25 }
              }
            }
          });
        }
      });
      
      // If in fullscreen mode with race replay, also update the fullscreen panel
      if (mapFullscreen && raceReplayMode) {
        updateFsLegComparisonContent();
      }
    }
    
    // Update the fullscreen leg comparison panel content and charts
    function updateFsLegComparisonContent() {
      const fsDetailsPanel = document.getElementById('fs-details-panel');
      if (!fsDetailsPanel || !mapFullscreen) return;
      
      // Find the leg comparison card in fullscreen panel (third card after header and timeline)
      const cards = fsDetailsPanel.querySelectorAll('.card');
      const legComparisonCard = cards.length >= 2 ? cards[cards.length - 1] : null;
      
      if (legComparisonCard) {
        // Clone the current legs content from the main panel
        const mainLegsContent = document.getElementById('current-legs-content');
        if (mainLegsContent) {
          legComparisonCard.innerHTML = mainLegsContent.innerHTML;
          
          // Initialize the fullscreen charts
          initFsLegComparisonCharts();
        }
      }
    }

    // Fullscreen leg comparison charts (separate from main panel charts)
    let fsRaceReplayLegCharts = {};
    
    function destroyFsRaceReplayCharts() {
      Object.values(fsRaceReplayLegCharts).forEach(chart => {
        if (chart) chart.destroy();
      });
      fsRaceReplayLegCharts = {};
    }
    
    // Initialize charts in the fullscreen panel after content is cloned
    function initFsLegComparisonCharts() {
      if (!mapFullscreen || !raceReplayMode) return;
      
      const fsDetailsPanel = document.getElementById('fs-details-panel');
      if (!fsDetailsPanel) return;
      
      // Destroy any existing fullscreen charts
      destroyFsRaceReplayCharts();
      
      // Find all canvas elements in the fullscreen panel and rename their IDs to avoid conflicts
      const canvases = fsDetailsPanel.querySelectorAll('canvas[id^="race-leg-"]');
      canvases.forEach(canvas => {
        const newId = 'fs-' + canvas.id;
        canvas.id = newId;
      });
      
      // Now create charts on the renamed canvases using currentBoatLegsData
      if (!currentBoatLegsData || currentBoatLegsData.length === 0) return;
      
      currentBoatLegsData.forEach(({ session, color, leg, idx }) => {
        if (!leg || !leg.ts || leg.ts.length === 0) return;
        
        const labels = leg.ts.map(p => p.t.toFixed(1));
        
        // Calculate current time position within the leg for the time pointer
        const sessionLocalTime = getSessionLocalTime(session, playbackTime);
        const sessionStart = session.timelineStart || 0;
        const trackTime = sessionLocalTime - sessionStart;
        
        // Find the index in ts array closest to current time
        let timePointerIdx = null;
        if (trackTime >= leg.start && trackTime <= leg.end) {
          let minDiff = Infinity;
          for (let i = 0; i < leg.ts.length; i++) {
            const diff = Math.abs(leg.ts[i].t - trackTime);
            if (diff < minDiff) {
              minDiff = diff;
              timePointerIdx = i;
            }
          }
        }
        
        // Time pointer annotation
        const timePointerAnnotation = {
          annotation: {
            annotations: timePointerIdx !== null ? {
              timePointer: {
                type: 'line',
                xMin: timePointerIdx,
                xMax: timePointerIdx,
                borderColor: '#ef4444',
                borderWidth: 2,
                borderDash: [3, 3]
              }
            } : {}
          }
        };
        
        const chartOptions = {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          plugins: { 
            legend: { display: false },
            ...timePointerAnnotation
          },
          scales: {
            x: { display: false },
            y: { 
              display: true,
              ticks: { font: { size: 8 }, maxTicksLimit: 3 },
              grid: { display: false }
            }
          },
          elements: { point: { radius: 0 } }
        };
        
        // Speed/VMG chart
        const spdCtx = document.getElementById(`fs-race-leg-spd-${idx}`);
        if (spdCtx) {
          fsRaceReplayLegCharts[`spd-${idx}`] = new Chart(spdCtx.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  data: leg.ts.map(p => p.spd),
                  borderColor: '#3b82f6',
                  borderWidth: 1.5,
                  tension: 0.3,
                  fill: false
                },
                {
                  data: leg.ts.map(p => p.vmg),
                  borderColor: '#22c55e',
                  borderWidth: 1.5,
                  tension: 0.3,
                  fill: false
                }
              ]
            },
            options: chartOptions
          });
        }
        
        // MAG Deviation chart
        const magCtx = document.getElementById(`fs-race-leg-mag-${idx}`);
        if (magCtx && leg.ts.some(p => p.mdev != null)) {
          fsRaceReplayLegCharts[`mag-${idx}`] = new Chart(magCtx.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: leg.ts.map(p => p.mdev),
                borderColor: '#8b5cf6',
                backgroundColor: '#8b5cf620',
                borderWidth: 1.5,
                tension: 0.3,
                fill: true
              }]
            },
            options: {
              ...chartOptions,
              scales: {
                ...chartOptions.scales,
                y: { ...chartOptions.scales.y, min: -20, max: 20 }
              }
            }
          });
        }
        
        // Rate chart
        const rateCtx = document.getElementById(`fs-race-leg-rate-${idx}`);
        if (rateCtx) {
          fsRaceReplayLegCharts[`rate-${idx}`] = new Chart(rateCtx.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: leg.ts.map(p => p.rate),
                borderColor: color,
                backgroundColor: `${color}20`,
                borderWidth: 1.5,
                tension: 0.3,
                fill: true
              }]
            },
            options: {
              ...chartOptions,
              scales: {
                ...chartOptions.scales,
                y: { ...chartOptions.scales.y, min: 0, max: 10 }
              }
            }
          });
        }
        
        // COG deviation chart
        const cogCtx = document.getElementById(`fs-race-leg-cog-${idx}`);
        if (cogCtx) {
          fsRaceReplayLegCharts[`cog-${idx}`] = new Chart(cogCtx.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: leg.ts.map(p => p.dev),
                borderColor: color,
                backgroundColor: `${color}20`,
                borderWidth: 1.5,
                tension: 0.3,
                fill: true
              }]
            },
            options: {
              ...chartOptions,
              scales: {
                ...chartOptions.scales,
                y: { ...chartOptions.scales.y, min: -20, max: 20 }
              }
            }
          });
        }
        
        // Heel chart
        const heelCtx = document.getElementById(`fs-race-leg-heel-${idx}`);
        if (heelCtx && leg.ts.some(p => p.heel != null)) {
          fsRaceReplayLegCharts[`heel-${idx}`] = new Chart(heelCtx.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: leg.ts.map(p => p.heel),
                borderColor: '#f59e0b',
                backgroundColor: '#f59e0b20',
                borderWidth: 1.5,
                tension: 0.3,
                fill: true
              }]
            },
            options: {
              ...chartOptions,
              scales: {
                ...chartOptions.scales,
                y: { ...chartOptions.scales.y, min: -25, max: 25 }
              }
            }
          });
        }
      });
    }

    // ===== VIDEO REPLAY FUNCTIONS =====
    
    // Set file input accept attributes for desktop only (mobile has issues with accept filters)
    if (!isMobile) {
      // Add accept filters for desktop browsers
      const fileInput = document.getElementById('file-input');
      if (fileInput) {
        fileInput.accept = '.vkx,.fit,.gpx,.csv,.gz';
      }
      const videoInput = document.getElementById('video-file-input');
      if (videoInput) {
        videoInput.accept = 'video/*,.mp4,.mov,.m4v,.avi,.mkv,.webm';
      }
    }
    
    let swReady = false;
    let videoFileIdCounter = 0;
    
    // Service Worker setup for iOS (provides Range request support for large videos)
    async function ensureServiceWorker() {
      if (!isIOS) return false;
      if (!('serviceWorker' in navigator)) return false;
      if (navigator.serviceWorker.controller) {
        swReady = true;
        return true;
      }

      try {
        await navigator.serviceWorker.register('./sw.js', { scope: './' });
        await navigator.serviceWorker.ready;
        
        if (!navigator.serviceWorker.controller) {
          console.log('Service Worker installed. Reload may be needed.');
          return false;
        }
        swReady = true;
        return true;
      } catch (e) {
        console.log('Service Worker failed, using blob fallback:', e);
        return false;
      }
    }
    
    async function sendFileToSW(file, fileId) {
      if (!navigator.serviceWorker.controller) return false;

      return new Promise((resolve) => {
        const mc = new MessageChannel();
        const timer = setTimeout(() => resolve(false), 2000);

        mc.port1.onmessage = (e) => {
          clearTimeout(timer);
          resolve(e.data && e.data.type === 'FILE_SET');
        };

        navigator.serviceWorker.controller.postMessage(
          { type: 'SET_FILE', file, fileId },
          [mc.port2]
        );
      });
    }
    
    function removeFileFromSW(fileId) {
      if (navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage({ type: 'REMOVE_FILE', fileId });
      }
    }
    
    // Initialize Service Worker for iOS
    if (isIOS) {
      ensureServiceWorker().then(ok => {
        console.log('iOS detected, Service Worker:', ok ? 'ready' : 'fallback to blob');
      });
    }
    
    let loadedVideos = [];  // Array of { element, filename, startTimestampMs, offsetMs }
    
    function parseVideoInfo(filename) {
      // Parse filename like VID_20251130_142618_00_015.mp4 or LRV_20251220_153605_01_018.lrv
      // Also support INSV naming: VID_YYYYMMDD_HHMMSS_XX_YYY.insv, INS_..., PRO_...
      // Format: PREFIX_YYYYMMDD_HHMMSS_XX_YYY.ext
      // XX = lens identifier (00 = front/lens0, 10 = back/lens1 for Insta360)
      // YYY = sequence number within recording session
      const match = filename.match(/(?:VID|LRV|INS|PRO)_(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})(\d{2})_(\d{2})_(\d{3})/i);
      if (!match) {
        console.log('parseVideoInfo: no match for', filename);
        return null;
      }
      
      const [, year, month, day, hour, min, sec, lensId, seqNum] = match;
      const baseDate = new Date(
        parseInt(year),
        parseInt(month) - 1,  // Month is 0-indexed
        parseInt(day),
        parseInt(hour),
        parseInt(min),
        parseInt(sec)
      );
      
      // For INSV files, lensId 10 = back lens (should be filtered out)
      // Only use lensId 00 files as primary
      const isBackLens = lensId === '10';
      
      // Sequence number is just the last 3 digits (YYY part)
      const sequenceNum = parseInt(seqNum);
      
      // Base key for grouping (date/time without sequence, include lens for proper grouping)
      // But for INSV, we want to group by date/time only, regardless of lens
      const baseKey = `${year}${month}${day}_${hour}${min}${sec}`;
      
      console.log('parseVideoInfo:', filename, '-> baseKey:', baseKey, 'seq:', sequenceNum, 'lens:', lensId);
      
      return {
        baseTimestampMs: baseDate.getTime(),
        sequenceNum: sequenceNum,
        baseKey: baseKey,
        lensId: lensId,
        isBackLens: isBackLens
      };
    }
    
    // Fallback for non-sequence format
    function parseVideoTimestamp(filename) {
      const info = parseVideoInfo(filename);
      if (info) return info.baseTimestampMs;
      
      // Try simpler format without sequence (various prefixes)
      let match = filename.match(/(?:VID|LRV|INS|PRO)_(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})(\d{2})/i);
      if (match) {
        const [, year, month, day, hour, min, sec] = match;
        const date = new Date(
          parseInt(year),
          parseInt(month) - 1,
          parseInt(day),
          parseInt(hour),
          parseInt(min),
          parseInt(sec)
        );
        return date.getTime();
      }
      
      // Generic fallback: any YYYYMMDD_HHMMSS pattern in filename
      match = filename.match(/(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})(\d{2})/);
      if (match) {
        const [, year, month, day, hour, min, sec] = match;
        const date = new Date(
          parseInt(year),
          parseInt(month) - 1,
          parseInt(day),
          parseInt(hour),
          parseInt(min),
          parseInt(sec)
        );
        return date.getTime();
      }
      
      return null;
    }
    
    function handleVideoFiles(event) {
      const file = event.target.files && event.target.files[0];
      if (!file) return;
      
      const inputId = event.target.id;
      const allFiles = Array.from(event.target.files);
      
      // Reset input immediately
      event.target.value = '';
      
      // Show loading
      const p = document.getElementById('video-placeholder');
      if (p) p.textContent = 'Loading ' + allFiles.length + ' video(s)...';
      
      // Mobile: simple direct processing
      // Desktop: full filtering with timeframe and sequence handling
      if (isMobile) {
        processVideoFilesSimple(allFiles);
      } else {
        processVideoFilesWithFiltering(allFiles, inputId);
      }
    }
    
    // Simple processing for mobile - minimal overhead but still handles sequences
    async function processVideoFilesSimple(allFiles) {
      // Group files by baseKey for sequence handling
      const fileInfos = [];
      const sequenceGroups = {};
      
      for (const file of allFiles) {
        const info = parseVideoInfo(file.name);
        
        if (info) {
          // Skip back lens INSV files
          if (info.isBackLens && isINSVFile(file.name)) {
            console.log('Skipping back lens INSV:', file.name);
            continue;
          }
          
          fileInfos.push({ file, info });
          if (info.baseKey) {
            if (!sequenceGroups[info.baseKey]) {
              sequenceGroups[info.baseKey] = [];
            }
            sequenceGroups[info.baseKey].push(info);
          }
        } else {
          const timestamp = parseVideoTimestamp(file.name);
          if (timestamp) {
            fileInfos.push({ file, info: { baseTimestampMs: timestamp, sequenceNum: 0, baseKey: null } });
          } else {
            console.log('Skipped video (no timestamp):', file.name);
          }
        }
      }
      
      // Find minimum sequence for each group
      const minSequenceByGroup = {};
      Object.keys(sequenceGroups).forEach(key => {
        minSequenceByGroup[key] = Math.min(...sequenceGroups[key].map(i => i.sequenceNum));
      });
      
      // Process files with sequence offsets
      for (const { file, info } of fileInfos) {
        let timestampMs = info.baseTimestampMs;
        
        // Apply sequence offset (30 min per increment from minimum)
        if (info.baseKey && minSequenceByGroup[info.baseKey] !== undefined) {
          const seqOffset = info.sequenceNum - minSequenceByGroup[info.baseKey];
          timestampMs += seqOffset * 30 * 60 * 1000;
          console.log('File', file.name, 'seq:', info.sequenceNum, 'minSeq:', minSequenceByGroup[info.baseKey], 'offset:', seqOffset * 30, 'min');
        }
        
        await addVideoFile(file, info, timestampMs);
      }
      
      // Re-sort loadedVideos by startTimestampMs
      loadedVideos.sort((a, b) => a.startTimestampMs - b.startTimestampMs);
      
      // Update timeline markers immediately after all videos processed
      renderVideoTimelineMarkers();
      console.log('Video processing complete, timeline markers rendered');
      
      // Also schedule a delayed re-render in case async duration extractions complete
      setTimeout(() => {
        renderVideoTimelineMarkers();
        console.log('Delayed timeline markers re-render');
      }, 500);
      
      // Show remove button and update display
      if (loadedVideos.length > 0) {
        document.getElementById('remove-videos-btn').style.display = '';
      }
      updateActiveVideoDisplay();
      updateBufferingStatus();
    }
    
    // Full processing for desktop with filtering and sequence handling
    async function processVideoFilesWithFiltering(files, inputId) {
      const isFolderSelection = inputId.startsWith('video-folder-');
      
      let videoFiles;
      
      if (isFolderSelection) {
        // Get filter type from input element's data-filter attribute
        const inputElement = document.getElementById(inputId);
        const filterType = inputElement ? inputElement.getAttribute('data-filter') : 'all';
        
        // Define extension filter based on filter type
        let extensionFilter;
        let typeLabel;
        switch (filterType) {
          case 'lrv':
            extensionFilter = /\.lrv$/i;
            typeLabel = 'LRV';
            break;
          case 'insv':
            extensionFilter = /\.insv$/i;
            typeLabel = 'INSV';
            break;
          case 'all':
          default:
            extensionFilter = /\.(mp4|mov|avi|mkv|webm|m4v|3gp|3g2|lrv|insv)$/i;
            typeLabel = 'video';
            break;
        }
        
        // For folder selection, filter for selected video type only
        videoFiles = files.filter(file => {
          const name = file.name.toLowerCase();
          return extensionFilter.test(name);
        });
        
        if (videoFiles.length === 0) {
          alert(`No ${typeLabel} files found in the selected folder.`);
          return;
        }
      } else {
        // For direct file selection, accept all video files
        videoFiles = files.filter(file => {
          const isVideoType = file.type && file.type.startsWith('video/');
          const name = file.name.toLowerCase();
          const isVideoExt = /\.(mp4|mov|avi|mkv|webm|m4v|3gp|3g2|lrv|insv)$/.test(name);
          return isVideoType || isVideoExt;
        });
      }
      
      if (videoFiles.length === 0) {
        alert('No video files found in selection.');
        return;
      }
      
      // For folder selection, filter to only videos within track timeframe
      let timeframeFilteredCount = 0;
      if (isFolderSelection && ALL_SESSIONS.length > 0) {
        const MARGIN_MS = 60 * 60 * 1000;  // 1 hour margin
        let minTrackTime = Infinity;
        let maxTrackTime = -Infinity;
        
        ALL_SESSIONS.forEach(session => {
          if (session.startTimestampMs) {
            minTrackTime = Math.min(minTrackTime, session.startTimestampMs);
            const durationMs = (session.fullDuration || session.s.dur) * 60 * 1000;
            maxTrackTime = Math.max(maxTrackTime, session.startTimestampMs + durationMs);
          }
        });
        
        if (minTrackTime !== Infinity && maxTrackTime !== -Infinity) {
          const startWindow = minTrackTime - MARGIN_MS;
          const endWindow = maxTrackTime + MARGIN_MS;
          
          const originalCount = videoFiles.length;
          videoFiles = videoFiles.filter(file => {
            const info = parseVideoInfo(file.name);
            const timestamp = info ? info.baseTimestampMs : parseVideoTimestamp(file.name);
            if (!timestamp) return true;  // Keep files we can't parse
            return timestamp >= startWindow && timestamp <= endWindow;
          });
          timeframeFilteredCount = originalCount - videoFiles.length;
        }
      }
      
      if (videoFiles.length === 0) {
        alert(`No video files found matching the track timeframe.\n\n${timeframeFilteredCount} video(s) were outside the sailing session time window.`);
        return;
      }
      
      // Parse all files and group by base timestamp
      const fileInfos = [];
      const sequenceGroups = {};
      const skippedFiles = [];
      
      videoFiles.forEach(file => {
        const info = parseVideoInfo(file.name);
        console.log('parseVideoInfo:', file.name, '->', info);
        
        // For INSV files, skip back lens files (lensId = 10)
        if (info && info.isBackLens && isINSVFile(file.name)) {
          console.log('Skipping back lens INSV file:', file.name);
          skippedFiles.push(file.name + ' (back lens)');
          return;
        }
        
        if (info) {
          fileInfos.push({ file, info });
          if (!sequenceGroups[info.baseKey]) {
            sequenceGroups[info.baseKey] = [];
          }
          sequenceGroups[info.baseKey].push({ file, info });
        } else {
          const timestamp = parseVideoTimestamp(file.name);
          if (timestamp) {
            fileInfos.push({ file, info: { baseTimestampMs: timestamp, sequenceNum: 0, baseKey: null } });
          } else {
            skippedFiles.push(file.name);
          }
        }
      });
      
      console.log('Sequence groups:', Object.keys(sequenceGroups).map(k => k + ': ' + sequenceGroups[k].length + ' files'));
      console.log('Sequence groups detail:', Object.keys(sequenceGroups).map(k => {
        return k + ': [' + sequenceGroups[k].map(g => g.file.name + '(seq=' + g.info.sequenceNum + ')').join(', ') + ']';
      }));
      console.log('Total fileInfos:', fileInfos.length);
      
      // Show alerts for skipped files
      if (skippedFiles.length > 0) {
        const fileList = skippedFiles.length <= 10 
          ? skippedFiles.join('\n') 
          : skippedFiles.slice(0, 10).join('\n') + `\n... and ${skippedFiles.length - 10} more`;
        
        if (fileInfos.length === 0) {
          alert(`Could not parse timestamps from ${skippedFiles.length} video file(s):\n\n${fileList}\n\nExpected format: VID_YYYYMMDD_HHMMSS_XX_YYY.mp4`);
          return;
        } else {
          const timeframeMsg = timeframeFilteredCount > 0 ? `\n\n${timeframeFilteredCount} video(s) filtered (outside track timeframe).` : '';
          alert(`Skipped ${skippedFiles.length} video(s) without valid timestamp:\n\n${fileList}\n\nLoaded ${fileInfos.length} video(s) successfully.${timeframeMsg}`);
        }
      } else if (timeframeFilteredCount > 0) {
        console.log(`Filtered ${timeframeFilteredCount} video(s) outside track timeframe. Loaded ${fileInfos.length} video(s).`);
      }
      
      if (fileInfos.length === 0) {
        return;
      }
      
      // Find minimum sequence number for each group (including both new and existing videos)
      const minSequenceByGroup = {};
      const oldMinSequenceByGroup = {};
      
      Object.keys(sequenceGroups).forEach(key => {
        const group = sequenceGroups[key];
        const existingInGroup = loadedVideos.filter(v => v.baseKey === key);
        
        // Calculate old minimum (from existing videos only)
        if (existingInGroup.length > 0) {
          oldMinSequenceByGroup[key] = Math.min(...existingInGroup.map(v => v.sequenceNum || 0));
        }
        
        // Calculate new minimum (including new files)
        const allSequences = [
          ...group.map(g => g.info.sequenceNum),
          ...existingInGroup.map(v => v.sequenceNum || 0)
        ];
        minSequenceByGroup[key] = Math.min(...allSequences);
      });
      
      // If minimum sequence changed for any group, update existing videos' timestamps
      Object.keys(minSequenceByGroup).forEach(key => {
        if (oldMinSequenceByGroup[key] !== undefined && 
            minSequenceByGroup[key] < oldMinSequenceByGroup[key]) {
          // New file(s) have lower sequence number - shift existing videos forward
          const shiftAmount = (oldMinSequenceByGroup[key] - minSequenceByGroup[key]) * 30 * 60 * 1000;
          
          loadedVideos.forEach(v => {
            if (v.baseKey === key) {
              v.startTimestampMs += shiftAmount;
              v.endTimestampMs += shiftAmount;
              v.offsetMs = v.startTimestampMs - getFullStartTimeMs();
            }
          });
          
          console.log(`Sequence ${key}: shifted existing videos forward by ${shiftAmount / 60000} minutes`);
        }
      });
      
      // Process files with adjusted timestamps for sequences
      const placeholder = document.getElementById('video-placeholder');
      console.log('Processing', fileInfos.length, 'files for timeline');
      for (let i = 0; i < fileInfos.length; i++) {
        if (placeholder) {
          placeholder.textContent = `Loading video ${i + 1} of ${fileInfos.length}...`;
        }
        
        const { file, info } = fileInfos[i];
        let timestampMs = info.baseTimestampMs;
        
        // Apply sequence offset (30 min per increment from minimum)
        if (info.baseKey && minSequenceByGroup[info.baseKey] !== undefined) {
          const seqOffset = info.sequenceNum - minSequenceByGroup[info.baseKey];
          timestampMs += seqOffset * 30 * 60 * 1000;
          console.log('File', file.name, 'seq:', info.sequenceNum, 'minSeq:', minSequenceByGroup[info.baseKey], 
                     'offset:', seqOffset * 30, 'min, timestamp:', new Date(timestampMs).toISOString());
        } else {
          console.log('File', file.name, 'no sequence offset (baseKey:', info.baseKey, '), timestamp:', new Date(timestampMs).toISOString());
        }
        
        await addVideoFile(file, info, timestampMs);
      }
      
      // Re-sort loadedVideos by startTimestampMs to maintain correct order
      loadedVideos.sort((a, b) => a.startTimestampMs - b.startTimestampMs);
      
      // Update timeline markers to reflect any changes
      renderVideoTimelineMarkers();
      console.log('Video processing complete, timeline markers rendered');
      
      // Also schedule a delayed re-render in case async duration extractions complete
      setTimeout(() => {
        renderVideoTimelineMarkers();
        console.log('Delayed timeline markers re-render');
      }, 500);
      
      // Show remove button and update display
      if (loadedVideos.length > 0) {
        document.getElementById('remove-videos-btn').style.display = '';
      }
      updateActiveVideoDisplay();
      updateBufferingStatus();
    }
    
    // Shared function to add a video file
    // Check if file is a 360 video (LRV or INSV)
    function is360VideoFile(filename) {
      const ext = filename.toLowerCase().split('.').pop();
      if (ext === 'lrv' || ext === 'insv') return true;
      // Also check for Insta360 exported MP4 files
      if (ext === 'mp4' && isInsta360MP4File(filename)) return true;
      return false;
    }
    
    function isINSVFile(filename) {
      return filename.toLowerCase().endsWith('.insv');
    }
    
    // Detect Insta360 exported/stitched MP4 files by filename pattern
    // Pattern: VID_YYYYMMDD_HHMMSS_XX_XXX... .mp4 (with varying number segments)
    // Examples: VID_20251205_145056_00_005_008_221148.mp4
    //           VID_20251220_153605_00_018.mp4
    function isInsta360MP4File(filename) {
      const lower = filename.toLowerCase();
      if (!lower.endsWith('.mp4')) return false;
      
      // Match VID_YYYYMMDD_HHMMSS followed by underscore-separated segments
      const pattern = /^vid_\d{8}_\d{6}(_\d+)+\.mp4$/i;
      return pattern.test(filename);
    }
    
    // Extract duration from INSV file by parsing MP4 moov atom
    async function getINSVDuration(file) {
      try {
        // moov is typically 36-86 MB from end of INSV files
        // Use 100 MB to be safe
        const fileSize = file.size;
        const chunkSize = Math.min(100 * 1024 * 1024, fileSize); // 100MB max
        
        // Try reading from end first (moov is usually there)
        const endStart = Math.max(0, fileSize - chunkSize);
        console.log('INSV getINSVDuration:', file.name, 'size:', (fileSize / 1024 / 1024 / 1024).toFixed(2), 'GB, reading last', (chunkSize / 1024 / 1024).toFixed(0), 'MB');
        const endChunk = await file.slice(endStart, fileSize).arrayBuffer();
        const endView = new DataView(endChunk);
        
        // Search for 'moov' atom
        for (let i = 0; i < endChunk.byteLength - 8; i++) {
          if (endView.getUint8(i + 4) === 0x6D && // 'm'
              endView.getUint8(i + 5) === 0x6F && // 'o'
              endView.getUint8(i + 6) === 0x6F && // 'o'
              endView.getUint8(i + 7) === 0x76) { // 'v'
            const moovSize = endView.getUint32(i, false);
            const moovStart = endStart + i;
            console.log('Found moov at offset', moovStart, 'size', moovSize, 'for', file.name);
            
            // Read moov atom
            const moovData = await file.slice(moovStart, moovStart + Math.min(moovSize, 10 * 1024 * 1024)).arrayBuffer();
            const moovView = new DataView(moovData);
            
            // Search for mvhd atom inside moov
            for (let j = 8; j < moovData.byteLength - 20; j++) {
              if (moovView.getUint8(j + 4) === 0x6D && // 'm'
                  moovView.getUint8(j + 5) === 0x76 && // 'v'
                  moovView.getUint8(j + 6) === 0x68 && // 'h'
                  moovView.getUint8(j + 7) === 0x64) { // 'd'
                const version = moovView.getUint8(j + 8);
                let timescale, duration;
                
                if (version === 0) {
                  timescale = moovView.getUint32(j + 20, false);
                  duration = moovView.getUint32(j + 24, false);
                } else {
                  timescale = moovView.getUint32(j + 28, false);
                  // 64-bit duration
                  const high = moovView.getUint32(j + 32, false);
                  const low = moovView.getUint32(j + 36, false);
                  duration = high * 0x100000000 + low;
                }
                
                if (timescale > 0) {
                  return duration / timescale;
                }
              }
            }
            break;
          }
        }
        
        // Try from beginning if not found at end
        if (endStart > 0) {
          const startChunkSize = Math.min(50 * 1024 * 1024, fileSize); // 50MB from start
          const startChunk = await file.slice(0, startChunkSize).arrayBuffer();
          const startView = new DataView(startChunk);
          
          for (let i = 0; i < startChunk.byteLength - 8; i++) {
            if (startView.getUint8(i + 4) === 0x6D &&
                startView.getUint8(i + 5) === 0x6F &&
                startView.getUint8(i + 6) === 0x6F &&
                startView.getUint8(i + 7) === 0x76) {
              const moovSize = startView.getUint32(i, false);
              
              const moovData = await file.slice(i, i + Math.min(moovSize, 10 * 1024 * 1024)).arrayBuffer();
              const moovView = new DataView(moovData);
              
              for (let j = 8; j < moovData.byteLength - 20; j++) {
                if (moovView.getUint8(j + 4) === 0x6D &&
                    moovView.getUint8(j + 5) === 0x76 &&
                    moovView.getUint8(j + 6) === 0x68 &&
                    moovView.getUint8(j + 7) === 0x64) {
                  const version = moovView.getUint8(j + 8);
                  let timescale, duration;
                  
                  if (version === 0) {
                    timescale = moovView.getUint32(j + 20, false);
                    duration = moovView.getUint32(j + 24, false);
                  } else {
                    timescale = moovView.getUint32(j + 28, false);
                    const high = moovView.getUint32(j + 32, false);
                    const low = moovView.getUint32(j + 36, false);
                    duration = high * 0x100000000 + low;
                  }
                  
                  if (timescale > 0) {
                    return duration / timescale;
                  }
                }
              }
              break;
            }
          }
        }
        
        console.log('Could not find moov/mvhd in INSV file:', file.name);
        return 0;
      } catch (e) {
        console.error('Error extracting INSV duration:', e);
        return 0;
      }
    }
    
    async function addVideoFile(file, info, timestamp) {
      console.log('addVideoFile:', file.name, 'timestamp:', timestamp, 'date:', new Date(timestamp).toISOString());
      
      const referenceStartMs = getFullStartTimeMs();
      const offsetMs = timestamp - referenceStartMs;
      
      const is360 = is360VideoFile(file.name);
      const isINSV = isINSVFile(file.name);
      const isLRV = file.name.toLowerCase().endsWith('.lrv');
      const isInsta360MP4 = isInsta360MP4File(file.name);
      
      console.log('is360:', is360, 'isINSV:', isINSV, 'isLRV:', isLRV, 'isInsta360MP4:', isInsta360MP4, 'referenceStartMs:', referenceStartMs, 'offsetMs:', offsetMs);
      
      const video = document.createElement('video');
      video.muted = playbackSpeed > 2;
      video.playsInline = true;
      video.setAttribute('playsinline', '');
      video.setAttribute('webkit-playsinline', '');
      video.preload = 'metadata';
      video.style.display = 'none';
      
      const fileId = 'video_' + (++videoFileIdCounter) + '_' + Date.now();
      
      let blobUrl = null;
      
      // For standard videos only, create blob URL and load for metadata
      // For 360 videos (LRV/INSV), the 360 player handles everything
      if (!is360) {
        if (isIOS && swReady) {
          const sent = await sendFileToSW(file, fileId);
          if (sent) {
            video.src = './__localvideo?id=' + fileId + '&ts=' + Date.now();
          } else {
            blobUrl = URL.createObjectURL(file);
            video.src = blobUrl;
          }
        } else {
          blobUrl = URL.createObjectURL(file);
          video.src = blobUrl;
        }
        video.load();
      }
      
      const videoData = {
        element: video,
        filename: file.name,
        fileId: fileId,
        blobUrl: blobUrl,
        startTimestampMs: timestamp,
        offsetMs: offsetMs,
        durationSec: 0,
        endTimestampMs: timestamp,
        baseKey: info ? info.baseKey : null,
        sequenceNum: info ? info.sequenceNum : 0,
        buffered: false,
        bufferProgress: 0,
        isWaiting: false,
        loaded: true,
        is360Video: is360,
        file: is360 ? file : null  // Keep file reference for 360 videos
      };
      
      if (!is360) {
        // Standard video only - can get metadata from video element
        video.addEventListener('loadedmetadata', () => {
          videoData.durationSec = video.duration;
          videoData.endTimestampMs = timestamp + video.duration * 1000;
          renderVideoTimelineMarkers();
        });
        
        video.addEventListener('waiting', () => {
          videoData.isWaiting = true;
          if (currentActiveVideo === videoData && isPlaying) {
            videoStalled = true;
            updateVideoStatusIndicator();
          }
        });
        
        video.addEventListener('playing', () => {
          videoData.isWaiting = false;
          if (currentActiveVideo === videoData) {
            videoStalled = false;
          }
          updateVideoStatusIndicator();
        });
        
        video.addEventListener('canplaythrough', () => {
          videoData.buffered = true;
          videoData.bufferProgress = 100;
          updateBufferingStatus();
        });
      } else {
        // 360 video (LRV/INSV/Insta360 MP4) - mark as buffered, duration will be extracted
        videoData.buffered = true;
        videoData.bufferProgress = 100;
        
        // For INSV files, set default duration immediately, then extract actual
        if (isINSV) {
          // Set default 30-min duration immediately so timeline shows something
          videoData.durationSec = 30 * 60;
          videoData.endTimestampMs = timestamp + 30 * 60 * 1000;
          
          // Then try to extract actual duration async
          getINSVDuration(file).then(duration => {
            if (duration > 0) {
              videoData.durationSec = duration;
              videoData.endTimestampMs = timestamp + duration * 1000;
              console.log('INSV duration updated:', file.name, duration.toFixed(1), 'sec');
            } else {
              console.log('INSV using default 30min duration:', file.name);
            }
            renderVideoTimelineMarkers();
          });
        } else if (isLRV || isInsta360MP4) {
          // Set default 30-min duration immediately for LRV and Insta360 MP4
          videoData.durationSec = 30 * 60;
          videoData.endTimestampMs = timestamp + 30 * 60 * 1000;
          
          // For LRV/Insta360 MP4 files, try to get actual duration from video element
          const tempVideo = document.createElement('video');
          tempVideo.preload = 'metadata';
          tempVideo.muted = true;
          const tempUrl = URL.createObjectURL(file);
          tempVideo.src = tempUrl;
          
          tempVideo.addEventListener('loadedmetadata', () => {
            if (tempVideo.duration && tempVideo.duration !== Infinity) {
              videoData.durationSec = tempVideo.duration;
              videoData.endTimestampMs = timestamp + tempVideo.duration * 1000;
              console.log((isLRV ? 'LRV' : 'Insta360 MP4') + ' duration extracted:', file.name, tempVideo.duration.toFixed(1), 'sec');
              renderVideoTimelineMarkers();
            }
            URL.revokeObjectURL(tempUrl);
          });
          
          tempVideo.addEventListener('error', () => {
            URL.revokeObjectURL(tempUrl);
          });
        }
      }
      
      loadedVideos.push(videoData);
    }
    
    
    function removeVideo(videoData) {
      const idx = loadedVideos.findIndex(v => v === videoData);
      if (idx >= 0) {
        const video = loadedVideos[idx];
        video.element.pause();
        video.element.style.display = 'none';
        if (video.element.parentNode) {
          video.element.parentNode.removeChild(video.element);
        }
        // Clean up blob URL if used
        if (video.blobUrl) {
          URL.revokeObjectURL(video.blobUrl);
        }
        // Clean up Service Worker file if used
        if (video.fileId && isIOS && swReady) {
          removeFileFromSW(video.fileId);
        }
        loadedVideos.splice(idx, 1);
      }
      
      // Reset current active if it was removed
      if (currentActiveVideo === videoData) {
        currentActiveVideo = null;
        videoStalled = false;
      }
      
      updateActiveVideoDisplay();
      renderVideoTimelineMarkers();
      updateBufferingStatus();
      
      if (loadedVideos.length === 0) {
        document.getElementById('remove-videos-btn').style.display = 'none';
      }
    }
    
    function removeAllVideos() {
      // First, clean up 360 player if active
      if (current360Player) {
        try {
          // Use stop() for full cleanup
          if (current360Player.stop) {
            current360Player.stop();
          } else {
            current360Player.pause();
            // Close audio context if exists
            if (current360Player.audioContext) {
              current360Player.audioContext.close().catch(() => {});
            }
          }
          // Close decoders if exists
          if (current360Player.decoders) {
            current360Player.decoders.forEach(d => {
              if (d && d.state !== 'closed') d.close();
            });
          }
          if (current360Player.audioDecoder && current360Player.audioDecoder.state !== 'closed') {
            current360Player.audioDecoder.close();
          }
        } catch (e) {
          console.error('Error cleaning up 360 player:', e);
        }
        current360Player = null;
      }
      is360VideoActive = false;
      
      // Clean up all loaded videos
      loadedVideos.forEach(v => {
        v.element.pause();
        v.element.src = '';  // Clear source to stop any loading
        v.element.style.display = 'none';
        if (v.element.parentNode) {
          v.element.parentNode.removeChild(v.element);
        }
        // Clean up blob URL if used
        if (v.blobUrl) {
          URL.revokeObjectURL(v.blobUrl);
        }
        // Clean up Service Worker file if used
        if (v.fileId && isIOS && swReady) {
          removeFileFromSW(v.fileId);
        }
      });
      loadedVideos = [];
      currentActiveVideo = null;
      videoStalled = false;
      
      updateActiveVideoDisplay();
      renderVideoTimelineMarkers();
      updateBufferingStatus();
      
      document.getElementById('remove-videos-btn').style.display = 'none';
    }
    
    function updateBufferingStatus() {
      const statusEl = document.getElementById('video-buffer-status');
      if (!statusEl) return;
      
      if (loadedVideos.length === 0) {
        statusEl.innerHTML = '';
        return;
      }
      
      const bufferedCount = loadedVideos.filter(v => v.buffered).length;
      const totalCount = loadedVideos.length;
      const allBuffered = bufferedCount === totalCount;
      
      // Build video list for tooltip
      const videoList = loadedVideos
        .sort((a, b) => a.startTimestampMs - b.startTimestampMs)
        .map((v, i) => `${i + 1}. ${v.filename}`)
        .join('\n');
      
      if (allBuffered) {
        statusEl.innerHTML = `<span style="color:#22c55e;font-size:10px;cursor:pointer;" title="${videoList}">‚úì ${totalCount} video${totalCount > 1 ? 's' : ''} ready ‚ñæ</span>`;
      } else {
        // Calculate overall progress
        const totalProgress = loadedVideos.reduce((sum, v) => sum + (v.bufferProgress || 0), 0);
        const avgProgress = Math.round(totalProgress / totalCount);
        statusEl.innerHTML = `<span style="color:#f59e0b;font-size:10px;cursor:pointer;" title="${videoList}">‚è≥ Buffering ${bufferedCount}/${totalCount} (${avgProgress}%) ‚ñæ</span>`;
      }
      
      // Add click handler to show full list in alert
      statusEl.onclick = () => {
        if (loadedVideos.length > 0) {
          const list = loadedVideos
            .sort((a, b) => a.startTimestampMs - b.startTimestampMs)
            .map((v, i) => {
              const date = new Date(v.startTimestampMs);
              const time = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
              const dur = v.durationSec ? ` (${Math.round(v.durationSec)}s)` : '';
              return `${i + 1}. ${v.filename}${dur}\n   ${time}`;
            })
            .join('\n\n');
          alert(`Loaded Videos (${loadedVideos.length}):\n\n${list}`);
        }
      };
      
      // Update per-video indicator if visible
      const indicator = document.getElementById('video-buffer-indicator');
      if (indicator && currentActiveVideo) {
        if (currentActiveVideo.buffered) {
          indicator.textContent = '‚úì';
          indicator.style.color = '#22c55e';
        } else {
          indicator.textContent = `${currentActiveVideo.bufferProgress || 0}%`;
          indicator.style.color = '#f59e0b';
        }
      }
    }
    
    function updateVideoStatusIndicator() {
      // Just delegate to updateVideoOverlays which handles all badge states
      updateVideoOverlays();
    }
    
    function resetVideoDisplay() {
      // Hide all videos
      loadedVideos.forEach(v => {
        v.element.pause();
        v.element.style.display = 'none';
        if (v.element.parentNode) {
          v.element.parentNode.removeChild(v.element);
        }
      });
      
      currentActiveVideo = null;
      videoStalled = false;
      const container = document.getElementById('video-container');
      if (container) {
        if (loadedVideos.length === 0) {
          container.innerHTML = '<div id="video-placeholder" style="color:#9ca3af;text-align:center;padding:20px;width:100%;font-size:12px;">No videos loaded. Add MP4 files with timestamp in filename (e.g., VID_20251130_142618_00_015.mp4)</div>';
        } else {
          container.innerHTML = '<div style="color:#9ca3af;text-align:center;padding:20px;width:100%;font-size:12px;">Videos available. Enter race replay to view.</div>';
        }
      }
    }
    
    let currentActiveVideo = null;
    let videoLoadGeneration = 0;  // Track video load requests to prevent race conditions
    
    function getCurrentOrNextVideo() {
      if (loadedVideos.length === 0) return null;
      
      const referenceStartMs = getFullStartTimeMs();
      const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
      
      // Sort videos by start time
      const sorted = [...loadedVideos].sort((a, b) => a.startTimestampMs - b.startTimestampMs);
      
      // Find video that contains current time
      for (const v of sorted) {
        // If metadata loaded (durationSec > 0), check proper range
        if (v.durationSec > 0) {
          if (currentAbsoluteMs >= v.startTimestampMs && currentAbsoluteMs <= v.endTimestampMs) {
            return v;
          }
        } else {
          // Metadata not loaded yet - if video started before current time, assume it might contain it
          // (typical video is 30 min, so give it benefit of doubt)
          if (currentAbsoluteMs >= v.startTimestampMs && currentAbsoluteMs <= v.startTimestampMs + 60 * 60 * 1000) {
            return v;
          }
        }
      }
      
      // Find next video (first one that starts after current time)
      for (const v of sorted) {
        if (v.startTimestampMs > currentAbsoluteMs) {
          return v;
        }
      }
      
      // Check if any video started before current time (could still be playing)
      // This handles the case where timeline selection starts mid-video
      for (let i = sorted.length - 1; i >= 0; i--) {
        const v = sorted[i];
        if (v.startTimestampMs <= currentAbsoluteMs) {
          // Video started before current time - might still be playing
          // Check if we're within reasonable range (durationSec if known, else assume up to 1 hour)
          const maxEndMs = v.durationSec > 0 
            ? v.endTimestampMs 
            : v.startTimestampMs + 60 * 60 * 1000;
          if (currentAbsoluteMs <= maxEndMs) {
            return v;
          }
        }
      }
      
      // No current or next - show the last video
      return sorted[sorted.length - 1];
    }
    
    // Lazy load video - create object URL only when needed
    function ensureVideoLoaded(videoData) {
      if (videoData.loaded) return;
      
      const video = videoData.element;
      
      // Create object URL now
      video.src = URL.createObjectURL(videoData.file);
      videoData.loaded = true;
      
      // Set up metadata listener
      video.addEventListener('loadedmetadata', () => {
        videoData.durationSec = video.duration;
        videoData.endTimestampMs = videoData.startTimestampMs + video.duration * 1000;
        renderVideoTimelineMarkers();
      });
      
      // Track when video is stalled/waiting for data
      video.addEventListener('waiting', () => {
        videoData.isWaiting = true;
        if (currentActiveVideo === videoData && isPlaying) {
          videoStalled = true;
          updateVideoStatusIndicator();
        }
      });
      
      video.addEventListener('stalled', () => {
        videoData.isWaiting = true;
        if (currentActiveVideo === videoData && isPlaying) {
          videoStalled = true;
          updateVideoStatusIndicator();
        }
      });
      
      video.addEventListener('playing', () => {
        videoData.isWaiting = false;
        if (currentActiveVideo === videoData) {
          videoStalled = false;
        }
        updateVideoStatusIndicator();
      });
      
      video.addEventListener('canplay', () => {
        videoData.isWaiting = false;
        if (currentActiveVideo === videoData) {
          videoStalled = false;
        }
      });
      
      // Track buffering progress
      video.addEventListener('progress', () => {
        if (video.buffered.length > 0 && video.duration > 0) {
          const bufferedEnd = video.buffered.end(video.buffered.length - 1);
          videoData.bufferProgress = Math.round((bufferedEnd / video.duration) * 100);
          if (window.requestIdleCallback) {
            requestIdleCallback(() => updateBufferingStatus(), { timeout: 500 });
          } else {
            setTimeout(() => updateBufferingStatus(), 100);
          }
        }
      });
      
      // Mark as fully buffered when ready
      video.addEventListener('canplaythrough', () => {
        videoData.buffered = true;
        videoData.bufferProgress = 100;
        updateBufferingStatus();
      });
    }
    
    function updateActiveVideoDisplay() {
      const container = document.getElementById('video-container');
      const targetVideo = getCurrentOrNextVideo();
      const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
      
      // No videos loaded
      if (!targetVideo) {
        if (isFullscreen) {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          }
        }
        container.innerHTML = '<div id="video-placeholder" style="color:#9ca3af;text-align:center;padding:20px;width:100%;font-size:12px;">No videos loaded. Add MP4 files with timestamp in filename (e.g., VID_20251130_142618_00_015.mp4)</div>';
        currentActiveVideo = null;
        videoStalled = false;
        return;
      }
      
      // Same video already active - just update overlays and ensure correct play state
      if (currentActiveVideo === targetVideo) {
        // Make sure video is playing if isPlaying is true and video is in active range
        const refStartMs = getFullStartTimeMs();
        const currAbsMs = refStartMs + playbackTime * 60000;
        const vidTimeMs = currAbsMs - targetVideo.startTimestampMs;
        const vidTimeSec = vidTimeMs / 1000;
        const effDuration = targetVideo.durationSec > 0 
          ? targetVideo.durationSec 
          : (targetVideo.is360Video && current360Player ? current360Player.duration : 60 * 60);
        const videoInRange = vidTimeSec >= 0 && vidTimeSec <= effDuration;
        
        if (isPlaying && videoInRange) {
          if (targetVideo.is360Video && current360Player && !current360Player.playing) {
            play360Video();
          } else if (!targetVideo.is360Video && targetVideo.element.paused) {
            targetVideo.element.playbackRate = Math.min(playbackSpeed, 16);
            targetVideo.element.muted = playbackSpeed > 2;
            targetVideo.element.play().catch(() => {});
          }
        }
        
        updateVideoOverlays();
        return;
      }
      
      // Hide and pause old video if different
      if (currentActiveVideo && currentActiveVideo !== targetVideo) {
        if (currentActiveVideo.is360Video && current360Player) {
          // Save current view state before switching away from 360 video
          savedViewState360 = {
            lon360: lon360,
            lat360: lat360,
            megaHFov: megaHFov,
            viewMode360: viewMode360,
            tiltCorrection360: tiltCorrection360,
            tilt2Correction360: tilt2Correction360,
            linearFov: threeCamera ? threeCamera.fov : 100
          };
          hasUserViewState360 = true;  // Mark that we have real user state to restore
          console.log('Saved 360 view state:', savedViewState360);
          
          // Use stop() for full cleanup when switching videos
          if (current360Player.stop) {
            current360Player.stop();
          } else {
            current360Player.pause();
            // Close audio context to stop any audio
            if (current360Player.audioContext) {
              current360Player.audioContext.close().catch(() => {});
            }
          }
          // Close decoders
          if (current360Player.decoders) {
            current360Player.decoders.forEach(d => {
              if (d && d.state !== 'closed') try { d.close(); } catch(e) {}
            });
          }
          if (current360Player.audioDecoder && current360Player.audioDecoder.state !== 'closed') {
            try { current360Player.audioDecoder.close(); } catch(e) {}
          }
          current360Player = null;
          is360VideoActive = false;
          // Clean up Three.js renderer
          if (threeRenderer && threeRenderer.domElement && threeRenderer.domElement.parentNode) {
            threeRenderer.domElement.parentNode.removeChild(threeRenderer.domElement);
          }
        } else {
          currentActiveVideo.element.pause();
          currentActiveVideo.element.src = '';  // Stop any loading/playing
          currentActiveVideo.element.style.display = 'none';
          // Remove from DOM if attached
          if (currentActiveVideo.element.parentNode) {
            currentActiveVideo.element.parentNode.removeChild(currentActiveVideo.element);
          }
        }
      }
      
      currentActiveVideo = targetVideo;
      
      // Lazy load video source if not already loaded
      ensureVideoLoaded(targetVideo);
      
      // Reset waiting/stalled state for newly active video
      targetVideo.isWaiting = false;
      videoStalled = false;
      
      // Build video display
      const referenceStartMs = getFullStartTimeMs();
      const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
      const videoTimeMs = currentAbsoluteMs - targetVideo.startTimestampMs;
      const videoTimeSec = videoTimeMs / 1000;
      // Use actual duration if loaded, otherwise assume reasonable max (1 hour)
      const effectiveDuration = targetVideo.durationSec > 0 
        ? targetVideo.durationSec 
        : 60 * 60;
      const isActive = videoTimeSec >= 0 && videoTimeSec <= effectiveDuration;
      const initialTimeDisplay = isActive 
        ? formatVideoDateTime(targetVideo.startTimestampMs) 
        : formatVideoDateTime(targetVideo.startTimestampMs);
      
      // If in fullscreen, just swap the video element without rebuilding wrapper
      if (isFullscreen) {
        const videoContainer = document.getElementById('active-video-element');
        if (videoContainer) {
          // Update filename label (3rd child due to unavailable overlay)
          const filenameLabel = document.querySelector('#video-wrapper > div:nth-child(3) > div:first-child');
          if (filenameLabel) {
            filenameLabel.innerHTML = `
              ${targetVideo.filename.replace(/\.[^.]+$/, '')}
              <span id="video-buffer-indicator" style="font-size:9px;${targetVideo.buffered ? 'color:#22c55e;' : 'color:#f59e0b;'}">${targetVideo.buffered ? '‚úì' : `${targetVideo.bufferProgress || 0}%`}</span>
            `;
          }
          
          // Insert new video element
          targetVideo.element.style.cssText = `
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: translateZ(0);
            will-change: transform, contents;
            backface-visibility: hidden;
            contain: strict;
            cursor: pointer;
          `;
          targetVideo.element.preservesPitch = false;
          targetVideo.element.onclick = (e) => {
            e.preventDefault();
            togglePlayback();
          };
          videoContainer.appendChild(targetVideo.element);
          
          // Sync video position
          syncVideosToPlayback(true);
          
          // If playing and video is active, play it
          if (isPlaying && isActive) {
            targetVideo.element.playbackRate = Math.min(playbackSpeed, 16);
            targetVideo.element.muted = playbackSpeed > 2;
            targetVideo.element.play().catch(() => {});
          }
          
          updateVideoOverlays();
          return;
        }
      }
      
      container.innerHTML = `
        <div id="video-wrapper" tabindex="-1" onkeydown="handleVideoWrapperKeydown(event)" onclick="refocusVideoWrapper()" style="width:100%;max-width:100%;background:#1f2937;border-radius:8px;overflow:hidden;position:relative;isolation:isolate;box-sizing:border-box;outline:none;">
          <div id="active-video-element" style="width:100%;aspect-ratio:16/9;position:relative;background:#000;"></div>
          <div id="video-360-loading" style="position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);display:none;flex-direction:column;align-items:center;justify-content:center;z-index:100;color:white;">
            <div style="width:40px;height:40px;border:3px solid rgba(255,255,255,0.2);border-top-color:#00d4ff;border-radius:50%;animation:spin360 1s linear infinite;"></div>
            <div id="video-360-loading-text" style="margin-top:12px;font-size:12px;">Loading 360 video...</div>
          </div>
          <div id="video-unavailable-overlay" onclick="jumpToNextVideo()" style="position:absolute;top:0;left:0;right:0;bottom:0;background:#000;display:${isActive ? 'none' : 'flex'};flex-direction:column;align-items:center;justify-content:center;z-index:5;cursor:pointer;">
            <div style="color:#9ca3af;font-size:14px;text-align:center;max-width:80%;">
              <div>No video available for this timeslot</div>
              <div id="video-countdown" style="margin-top:8px;color:#3b82f6;font-size:13px;"></div>
              <div id="video-skip-btn" style="margin-top:12px;padding:8px 16px;background:rgba(59,130,246,0.2);border:1px solid rgba(59,130,246,0.5);border-radius:6px;color:#3b82f6;">‚ñ∂ Skip to next video</div>
            </div>
          </div>
          <div id="video-overlays-container" style="position:absolute;top:0;left:0;right:0;bottom:0;pointer-events:none;transform:translateZ(0);z-index:10;">
            <div style="position:absolute;top:8px;left:8px;background:rgba(0,0,0,0.7);color:white;padding:4px 8px;border-radius:4px;font-size:11px;display:flex;align-items:center;gap:6px;">
              ${targetVideo.filename.replace(/\.[^.]+$/, '')}
              <span id="video-buffer-indicator" style="font-size:9px;${targetVideo.buffered ? 'color:#22c55e;' : 'color:#f59e0b;'}">${targetVideo.buffered ? '‚úì' : `${targetVideo.bufferProgress || 0}%`}</span>
              ${targetVideo.is360Video ? `
                <span id="orient-tag-360" class="orient-tag ${currentOrientation360}" onclick="toggle360Orientation()" style="pointer-events:auto;">${currentOrientation360.toUpperCase()}</span>
                <span id="view-mode-tag-360" class="view-mode-tag" onclick="toggle360ViewMode()" style="pointer-events:auto;">${viewMode360 === '360' ? 'Linear 100¬∞' : `MEGA ${megaHFov}¬∞`}</span>
              ` : ''}
            </div>
            <div id="video-telemetry-overlay" class="fs-widget${isFullscreen && widgetState['video-telemetry-overlay']?.dragged ? ' dragged' : ''}${isFullscreen && widgetState['video-telemetry-overlay']?.minimized ? ' minimized' : ''}" style="position:absolute;background:rgba(0,0,0,0.7);color:white;padding:6px 10px;border-radius:4px;font-size:12px;font-family:monospace;text-align:right;line-height:1.5;display:${isActive ? 'block' : 'none'};${isFullscreen && widgetState['video-telemetry-overlay']?.dragged ? `top:${widgetState['video-telemetry-overlay'].y}px;left:${widgetState['video-telemetry-overlay'].x}px;` : ''}">
              <div class="fs-widget-header">Telemetry <span class="fs-minimize-btn">${isFullscreen && widgetState['video-telemetry-overlay']?.minimized ? '‚ñ≤' : '‚ñº'}</span></div>
              <div class="fs-widget-content">
                <div><span style="color:#9ca3af;">SPD</span> <span id="telem-sog">-.-</span></div>
                <div><span style="color:#9ca3af;">VMG</span> <span id="telem-vmg">-.-</span></div>
                <div><span style="color:#9ca3af;">HDG</span> <span id="telem-hdg">---</span></div>
                <div><span style="color:#9ca3af;">HEEL</span> <span id="telem-heel">--</span></div>
                <div><span style="color:#9ca3af;">STR</span> <span id="telem-str">-.-</span></div>
              </div>
            </div>
            <div id="video-leg-overlay" class="fs-widget${isFullscreen && widgetState['video-leg-overlay']?.dragged ? ' dragged' : ''}${isFullscreen && widgetState['video-leg-overlay']?.minimized ? ' minimized' : ''}" style="position:absolute;background:rgba(0,0,0,0.7);color:white;padding:6px 10px;border-radius:4px;font-size:12px;font-family:monospace;text-align:right;line-height:1.5;display:${isActive ? 'block' : 'none'};${isFullscreen && widgetState['video-leg-overlay']?.dragged ? `top:${widgetState['video-leg-overlay'].y}px;left:${widgetState['video-leg-overlay'].x}px;` : ''}">
              <div class="fs-widget-header"><span id="telem-leg-label">Leg</span> <span class="fs-minimize-btn">${isFullscreen && widgetState['video-leg-overlay']?.minimized ? '‚ñ≤' : '‚ñº'}</span></div>
              <div class="fs-widget-content">
                <div><span style="color:#9ca3af;">SPD</span> <span id="telem-leg-spd">-.-</span></div>
                <div><span style="color:#9ca3af;">VMG</span> <span id="telem-leg-vmg">-.-</span></div>
                <div><span style="color:#9ca3af;">HDG</span> <span id="telem-leg-hdg">---</span></div>
                <div><span style="color:#9ca3af;">Next</span> <span id="telem-leg-next">--</span></div>
              </div>
            </div>
            <div id="video-distance-overlay" class="fs-widget${isFullscreen && widgetState['video-distance-overlay']?.dragged ? ' dragged' : ''}${isFullscreen && widgetState['video-distance-overlay']?.minimized ? ' minimized' : ''}" style="position:absolute;background:rgba(0,0,0,0.7);color:white;padding:8px 12px;border-radius:4px;font-size:11px;font-family:monospace;text-align:left;display:${isActive && getReplaySessions().length >= 2 ? 'block' : 'none'};${isFullscreen && widgetState['video-distance-overlay']?.dragged ? `top:${widgetState['video-distance-overlay'].y}px;left:${widgetState['video-distance-overlay'].x}px;` : ''}">
              <div class="fs-widget-header" style="text-align:left;">Distance <span class="fs-minimize-btn">${isFullscreen && widgetState['video-distance-overlay']?.minimized ? '‚ñ≤' : '‚ñº'}</span></div>
              <div class="fs-widget-content" style="line-height:1.3;">
                <div id="telem-distance-direct" style="color:#f59e0b;font-weight:bold;margin-bottom:4px;">--</div>
                <div id="telem-mark-boat1" style="color:#9ca3af;font-size:10px;">--</div>
                <div id="telem-mark-boat2" style="color:#9ca3af;font-size:10px;">--</div>
              </div>
            </div>
            <div id="video-minimap-overlay" class="fs-widget${getReplaySessions().length < 2 ? ' single-boat' : ''}${isFullscreen && widgetState['video-minimap-overlay']?.dragged ? ' dragged' : ''}${isFullscreen && widgetState['video-minimap-overlay']?.minimized ? ' minimized' : ''}" style="${isFullscreen && widgetState['video-minimap-overlay']?.dragged ? `top:${widgetState['video-minimap-overlay'].y}px;left:${widgetState['video-minimap-overlay'].x}px;` : ''}">
              <div class="fs-widget-header" style="display:flex;align-items:center;gap:4px;">
                <span style="flex:1;">Map</span>
                <span id="minimap-zoom-level" ondblclick="minimapZoomReset(event)" style="font-size:9px;color:#9ca3af;margin-right:2px;cursor:pointer;" title="Double-click to reset">${minimapZoomLevel !== 1.0 ? minimapZoomLevel.toFixed(1) + 'x' : ''}</span>
                <span onclick="minimapZoomIn(event)" style="cursor:pointer;font-size:16px;padding:0 2px;user-select:none;" title="Zoom In">+</span>
                <span onclick="minimapZoomOut(event)" style="cursor:pointer;font-size:16px;padding:0 2px;user-select:none;" title="Zoom Out">‚àí</span>
                <span class="fs-minimize-btn">${isFullscreen && widgetState['video-minimap-overlay']?.minimized ? '‚ñ≤' : '‚ñº'}</span>
              </div>
              <div class="fs-widget-content" style="display:flex;gap:4px;height:calc(100% - 24px);">
                <svg id="video-minimap-svg" style="display:block;flex:1;" onwheel="handleMinimapWheel(event)"></svg>
                <div id="minimap-leg2-telemetry" class="${getReplaySessions().length >= 2 ? 'show-boat2' : ''}" style="flex-shrink:0;color:white;font-size:9px;font-family:monospace;line-height:1.4;display:${getReplaySessions().length >= 2 ? 'flex' : 'none'};flex-direction:column;justify-content:center;">
                  <div id="telem-leg2-label" style="font-size:8px;margin-bottom:2px;">Boat 2 Leg</div>
                  <div><span style="color:#9ca3af;">SPD</span> <span id="telem-leg2-spd">-.-</span></div>
                  <div><span style="color:#9ca3af;">VMG</span> <span id="telem-leg2-vmg">-.-</span></div>
                  <div><span style="color:#9ca3af;">HDG</span> <span id="telem-leg2-hdg">---</span></div>
                  <div><span style="color:#9ca3af;">HEEL</span> <span id="telem-leg2-heel">--</span></div>
                  <div><span style="color:#9ca3af;">Next</span> <span id="telem-leg2-next">--</span></div>
                </div>
              </div>
            </div>
            <div id="video-time-display" style="position:absolute;bottom:8px;right:8px;background:rgba(0,0,0,0.7);color:white;padding:4px 8px;border-radius:4px;font-size:11px;font-family:monospace;display:flex;align-items:center;gap:8px;pointer-events:auto;">
              <span id="video-time-text">${initialTimeDisplay}</span>
              <button id="video-export-btn" onclick="showVideoWithOverlaysExportDialog()" title="Export video with overlays" style="display:none;background:none;color:white;border:none;font-size:12px;cursor:pointer;padding:0;">üé¨</button>
              <button id="video-fullscreen-btn" onclick="toggleVideoFullscreen(event)" style="background:none;color:white;border:none;font-size:14px;cursor:pointer;padding:0;">‚õ∂</button>
            </div>
            <div id="video-status-badge" style="position:absolute;bottom:8px;left:8px;background:${isActive ? 'rgba(34,197,94,0.9)' : 'rgba(107,114,128,0.9)'};color:white;padding:4px 8px;border-radius:4px;font-size:11px;">
              ${isActive ? '‚óè LIVE' : 'Video not available'}
            </div>
            <div id="video-fps-selector-container" style="display:none;position:absolute;bottom:36px;left:8px;background:rgba(0,0,0,0.7);color:white;padding:4px 8px;border-radius:4px;font-size:10px;font-family:monospace;pointer-events:auto;z-index:100;">
              <select id="video-fps-selector" title="Target FPS" onchange="changeVideoFps(this.value)" style="background:rgba(0,0,0,0.5);color:white;border:1px solid #555;border-radius:3px;font-size:10px;padding:2px 4px;cursor:pointer;">
                <option value="7.5">7.5 fps</option>
                <option value="10">10 fps</option>
                <option value="15">15 fps</option>
                <option value="20" selected>20 fps</option>
                <option value="25">25 fps</option>
                <option value="30">30 fps</option>
              </select>
              <select id="video-quality-selector" title="Render Quality" onchange="changeVideoQuality(this.value)" style="background:rgba(0,0,0,0.5);color:white;border:1px solid #555;border-radius:3px;font-size:10px;padding:2px 4px;cursor:pointer;">
                <option value="low">Low</option>
                <option value="medium">Med</option>
                <option value="high">High</option>
                <option value="ultra" selected>Ultra</option>
              </select>
            </div>
            <div id="video-fps-sync" style="position:absolute;bottom:62px;left:8px;background:rgba(0,0,0,0.7);color:white;padding:4px 8px;border-radius:4px;font-size:10px;font-family:monospace;display:none;flex-direction:column;align-items:flex-start;gap:2px;pointer-events:auto;">
              <div style="display:flex;align-items:center;gap:8px;">
                <span id="video-fps-display" title="Video FPS">--fps</span>
                <span id="video-sync-display" title="Video/Timeline Sync">‚è±--</span>
              </div>
              <div id="video-audio-sync-display" title="Audio/Video Sync" style="font-size:9px;color:#9ca3af;">üîä--</div>
              <div id="video-lens-status" title="Lens Status: Decode/Render" style="font-size:9px;color:#9ca3af;">üé• F:-- B:--</div>
            </div>
          </div>
          <div id="video-replay-controls" style="display:none;"></div>
        </div>
      `;
      
      // Handle 360 video vs standard video
      if (targetVideo.is360Video && targetVideo.file) {
        // Clean up previous 360 player
        if (current360Player) {
          if (current360Player.stop) current360Player.stop();
          else if (current360Player.pause) current360Player.pause();
          current360Player = null;
        }
        is360VideoActive = false;
        
        // Increment generation and capture for this load request
        videoLoadGeneration++;
        const thisLoadGeneration = videoLoadGeneration;
        const expectedVideo = targetVideo;  // Capture reference for callback check
        console.log('[VideoLoad] Starting load gen=' + thisLoadGeneration + ' for', targetVideo.filename);
        
        // Load 360 video asynchronously - pass generation for tracking
        load360Video(targetVideo.file, targetVideo, thisLoadGeneration).then(() => {
          // CRITICAL: Check if this load is still valid (no newer load superseded it)
          if (thisLoadGeneration !== videoLoadGeneration) {
            console.log('[VideoLoad] gen=' + thisLoadGeneration + ' aborted (superseded by gen=' + videoLoadGeneration + ')');
            return;
          }
          
          // Also check if currentActiveVideo still matches what we expected
          if (currentActiveVideo !== expectedVideo) {
            console.log('[VideoLoad] gen=' + thisLoadGeneration + ' aborted (activeVideo changed from', expectedVideo.filename, 'to', currentActiveVideo?.filename || 'null', ')');
            return;
          }
          
          console.log('[VideoLoad] gen=' + thisLoadGeneration + ' completed successfully for', expectedVideo.filename);
          
          // Restore saved view state only if we have previous state (switching between 360 videos)
          if (hasUserViewState360) {
            lon360 = savedViewState360.lon360;
            lat360 = savedViewState360.lat360;
            megaHFov = savedViewState360.megaHFov;
            viewMode360 = savedViewState360.viewMode360;
            // Don't restore MEGA view for INSV videos (not supported)
            if (current360Format === 'insv' && viewMode360 === 'megaview') {
              viewMode360 = '360';
            }
            tiltCorrection360 = savedViewState360.tiltCorrection360;
            tilt2Correction360 = savedViewState360.tilt2Correction360;
            if (threeCamera) {
              threeCamera.fov = savedViewState360.linearFov;
              threeCamera.updateProjectionMatrix();
            }
            
            // Update shader uniforms with restored values
            if (megaViewMaterial && megaViewMaterial.uniforms) {
              megaViewMaterial.uniforms.hFov.value = THREE.MathUtils.degToRad(megaHFov);
              megaViewMaterial.uniforms.panniniD.value = 0.8;
            }
            
            // Update tilt uniforms
            const baseRoll = current360Format === 'equirectangular' ? 0 : rollAngle360;
            if (threeSphere && threeSphere.material && threeSphere.material.uniforms) {
              threeSphere.material.uniforms.rollAngle.value = baseRoll + tiltCorrection360;
              if (threeSphere.material.uniforms.tilt2) {
                threeSphere.material.uniforms.tilt2.value = tilt2Correction360;
              }
            }
            if (megaViewMaterial && megaViewMaterial.uniforms) {
              megaViewMaterial.uniforms.rollAngle.value = baseRoll + tiltCorrection360;
              if (megaViewMaterial.uniforms.tilt2) {
                megaViewMaterial.uniforms.tilt2.value = tilt2Correction360;
              }
            }
            
            console.log('Restored 360 view state:', savedViewState360);
            updateViewModeTag360();
          }
          
          renderVideoTimelineMarkers();
          updateVideoOverlays();
          
          // Recalculate isActive with current playback time (may have changed during load)
          const refStartMs = getFullStartTimeMs();
          const currAbsMs = refStartMs + playbackTime * 60000;
          const vidTimeMs = currAbsMs - expectedVideo.startTimestampMs;
          const vidTimeSec = vidTimeMs / 1000;
          const effDuration = current360Player ? current360Player.duration : (expectedVideo.durationSec || 60 * 60);
          const videoIsActive = vidTimeSec >= 0 && vidTimeSec <= effDuration;
          
          // If playing and video is active, start 360 playback
          if (isPlaying && videoIsActive) {
            console.log('[VideoLoad] gen=' + thisLoadGeneration + ' auto-starting playback at', vidTimeSec.toFixed(1) + 's');
            // Seek to correct position before playing
            if (vidTimeSec > 1 && current360Player) {
              current360Player.seek(vidTimeSec).then(() => {
                // Re-check generation after seek completes
                if (thisLoadGeneration === videoLoadGeneration && currentActiveVideo === expectedVideo) {
                  // Force texture update after seek to ensure frame is visible
                  if (current360Player && current360Player.forceRedrawToAllCanvases) {
                    current360Player.forceRedrawToAllCanvases('combined');
                  }
                  // Small delay to ensure textures are uploaded before playing
                  setTimeout(() => {
                    if (thisLoadGeneration === videoLoadGeneration && currentActiveVideo === expectedVideo) {
                      play360Video();
                    }
                  }, 50);
                } else {
                  console.log('[VideoLoad] gen=' + thisLoadGeneration + ' seek completed but state changed, not playing');
                }
              }).catch(err => {
                console.warn('[VideoLoad] gen=' + thisLoadGeneration + ' seek failed:', err);
                // Try to play anyway - might work at position 0
                if (thisLoadGeneration === videoLoadGeneration && currentActiveVideo === expectedVideo) {
                  play360Video();
                }
              });
            } else {
              // Force initial frame draw before playing
              if (current360Player && current360Player.forceRedrawToAllCanvases) {
                current360Player.forceRedrawToAllCanvases('combined');
              }
              setTimeout(() => {
                if (thisLoadGeneration === videoLoadGeneration && currentActiveVideo === expectedVideo) {
                  play360Video();
                }
              }, 50);
            }
          } else if (isPlaying && vidTimeSec < 0) {
            // Video not started yet but we're in playing mode - it will start when timeline reaches it
            console.log('[VideoLoad] gen=' + thisLoadGeneration + ' loaded but not yet in range, waiting...');
          }
        }).catch(err => {
          console.error('[VideoLoad] gen=' + thisLoadGeneration + ' failed to load 360 video:', err);
        });
        
        updateVideoOverlays();
        
        // Init widget dragging and resizing if in fullscreen
        if (document.fullscreenElement || document.webkitFullscreenElement) {
          initWidgetDragging();
          initWidgetResizing();
          restoreWidgetPositions();
          restoreWidgetSizes();
        }
        return;
      }
      
      // Standard video handling
      is360VideoActive = false;
      if (current360Player) {
        if (current360Player.stop) current360Player.stop();
        else if (current360Player.pause) current360Player.pause();
        current360Player = null;
      }
      
      // Insert actual video element with GPU acceleration hints
      const videoContainer = document.getElementById('active-video-element');
      targetVideo.element.style.cssText = `
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: contain;
        transform: translateZ(0);
        will-change: transform, contents;
        backface-visibility: hidden;
        contain: strict;
        cursor: pointer;
      `;
      // Allow faster playback without pitch correction overhead
      targetVideo.element.preservesPitch = false;
      // Click on video to toggle play/pause
      targetVideo.element.onclick = (e) => {
        e.preventDefault();
        togglePlayback();
      };
      videoContainer.appendChild(targetVideo.element);
      
      // Sync video position
      syncVideosToPlayback(true);
      
      // If playing and video is active, play it
      if (isPlaying && isActive) {
        targetVideo.element.playbackRate = Math.min(playbackSpeed, 16);
        targetVideo.element.muted = playbackSpeed > 2;
        targetVideo.element.play().catch(() => {});
      }
      
      updateVideoOverlays();
      
      // Init widget dragging and resizing if in fullscreen
      if (document.fullscreenElement || document.webkitFullscreenElement) {
        initWidgetDragging();
        initWidgetResizing();
        restoreWidgetPositions();
        restoreWidgetSizes();
      }
    }
    
    function updateVideoOverlays() {
      if (!currentActiveVideo) return;
      
      const referenceStartMs = getFullStartTimeMs();
      const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
      const videoTimeMs = currentAbsoluteMs - currentActiveVideo.startTimestampMs;
      const videoTimeSec = videoTimeMs / 1000;
      
      const timeText = document.getElementById('video-time-text');
      const statusBadge = document.getElementById('video-status-badge');
      const unavailableOverlay = document.getElementById('video-unavailable-overlay');
      const telemetryOverlay = document.getElementById('video-telemetry-overlay');
      const legOverlay = document.getElementById('video-leg-overlay');
      const distanceOverlay = document.getElementById('video-distance-overlay');
      const countdownEl = document.getElementById('video-countdown');
      const skipBtn = document.getElementById('video-skip-btn');
      const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
      
      // Check if we have 2 boats for distance overlay
      const hasTwoBoats = getReplaySessions().length >= 2;
      
      if (!timeText || !statusBadge) return;
      
      // Calculate actual timestamp for display
      let actualTimestampMs;
      if (currentActiveVideo.is360Video && current360Player) {
        actualTimestampMs = currentActiveVideo.startTimestampMs + (current360Player.currentTime * 1000);
      } else {
        actualTimestampMs = currentActiveVideo.startTimestampMs + (currentActiveVideo.element.currentTime * 1000);
      }
      
      // Update telemetry overlay
      updateVideoTelemetry();
      
      // Don't override LOADING state if video is waiting/stalled
      if (videoStalled && isPlaying) {
        timeText.textContent = formatVideoDateTime(currentAbsoluteMs);
        statusBadge.textContent = '‚è∏ BUFFERING';
        statusBadge.style.background = 'rgba(239,68,68,0.9)';
        if (unavailableOverlay) unavailableOverlay.style.display = 'none';
        if (telemetryOverlay) telemetryOverlay.style.display = 'block';
        if (legOverlay) legOverlay.style.display = 'block';
        if (distanceOverlay) distanceOverlay.style.display = hasTwoBoats ? 'block' : 'none';
        updateFullscreenStatus();
        // Update minimap in fullscreen mode
        if (isFullscreen) {
          renderVideoMinimap();
        }
        // Still update FPS display even when buffering
        updateVideoFpsSyncDisplay();
        return;
      }
      
      // Use actual duration if loaded, otherwise assume reasonable max (1 hour)
      const effectiveDuration = currentActiveVideo.durationSec > 0 
        ? currentActiveVideo.durationSec 
        : 60 * 60;
      
      const isVideoActive = videoTimeSec >= 0 && videoTimeSec <= effectiveDuration;
      
      if (videoTimeSec < 0) {
        // Video not yet started - show unavailable with countdown
        timeText.textContent = formatVideoDateTime(currentAbsoluteMs);
        statusBadge.textContent = 'Video not available';
        statusBadge.style.background = 'rgba(107,114,128,0.9)';
        if (unavailableOverlay) unavailableOverlay.style.display = 'flex';
        // In fullscreen, keep telemetry visible
        if (telemetryOverlay) telemetryOverlay.style.display = isFullscreen ? 'block' : 'none';
        if (legOverlay) legOverlay.style.display = isFullscreen ? 'block' : 'none';
        if (distanceOverlay) distanceOverlay.style.display = (isFullscreen && hasTwoBoats) ? 'block' : 'none';
        if (!currentActiveVideo.is360Video) {
          currentActiveVideo.element.style.visibility = 'hidden';
        }
        // Update countdown - video is coming, show skip button
        if (countdownEl) {
          const secsUntilVideo = Math.ceil(-videoTimeSec);
          const mins = Math.floor(secsUntilVideo / 60);
          const secs = secsUntilVideo % 60;
          countdownEl.textContent = `Next video starts in ${mins}:${secs.toString().padStart(2, '0')}`;
        }
        if (skipBtn) skipBtn.style.display = 'block';
      } else if (videoTimeSec > effectiveDuration) {
        // Video ended - show unavailable, find next video
        timeText.textContent = formatVideoDateTime(currentAbsoluteMs);
        statusBadge.textContent = 'Video not available';
        statusBadge.style.background = 'rgba(107,114,128,0.9)';
        if (unavailableOverlay) unavailableOverlay.style.display = 'flex';
        // In fullscreen, keep telemetry visible
        if (telemetryOverlay) telemetryOverlay.style.display = isFullscreen ? 'block' : 'none';
        if (legOverlay) legOverlay.style.display = isFullscreen ? 'block' : 'none';
        if (distanceOverlay) distanceOverlay.style.display = (isFullscreen && hasTwoBoats) ? 'block' : 'none';
        if (!currentActiveVideo.is360Video) {
          currentActiveVideo.element.style.visibility = 'hidden';
        }
        // Update countdown for next video
        const nextVideo = getNextVideoAfterCurrent();
        if (countdownEl) {
          if (nextVideo) {
            const nextVideoStartMin = (nextVideo.startTimestampMs - referenceStartMs) / 60000;
            const secsUntilNext = Math.ceil((nextVideoStartMin - playbackTime) * 60);
            if (secsUntilNext > 0) {
              const mins = Math.floor(secsUntilNext / 60);
              const secs = secsUntilNext % 60;
              countdownEl.textContent = `Next video starts in ${mins}:${secs.toString().padStart(2, '0')}`;
            } else {
              countdownEl.textContent = '';
            }
          } else {
            countdownEl.textContent = 'No more videos available';
          }
        }
        // Show/hide skip button based on whether there's a next video
        if (skipBtn) skipBtn.style.display = nextVideo ? 'block' : 'none';
      } else {
        // Video active - show live
        timeText.textContent = formatVideoDateTime(actualTimestampMs);
        statusBadge.textContent = '‚óè LIVE';
        statusBadge.style.background = 'rgba(34,197,94,0.9)';
        if (unavailableOverlay) unavailableOverlay.style.display = 'none';
        if (telemetryOverlay) telemetryOverlay.style.display = 'block';
        if (legOverlay) legOverlay.style.display = 'block';
        if (distanceOverlay) distanceOverlay.style.display = hasTwoBoats ? 'block' : 'none';
        if (!currentActiveVideo.is360Video) {
          currentActiveVideo.element.style.visibility = 'visible';
        }
      }
      
      // Sync fullscreen status
      updateFullscreenStatus();
      
      // Update minimap in fullscreen mode
      if (isFullscreen) {
        renderVideoMinimap();
      }
      
      // Update FPS and sync display
      updateVideoFpsSyncDisplay();
    }
    
    function updateVideoFpsSyncDisplay() {
      const fpsDisplay = document.getElementById('video-fps-display');
      const syncDisplay = document.getElementById('video-sync-display');
      const audioSyncDisplay = document.getElementById('video-audio-sync-display');
      
      if (!fpsDisplay || !syncDisplay) return;
      if (!currentActiveVideo) {
        fpsDisplay.textContent = '--fps';
        fpsDisplay.style.color = '#9ca3af';
        syncDisplay.textContent = '‚è±--';
        syncDisplay.style.color = '#9ca3af';
        if (audioSyncDisplay) {
          audioSyncDisplay.textContent = 'üîä--';
          audioSyncDisplay.style.color = '#9ca3af';
        }
        return;
      }
      
      // Get FPS and stats
      let fps = 0;
      let actualVideoTimeSec = 0;
      let bufferInfo = '';
      let syncOffsetSec = null;
      let audioDrift = null;
      
      if (currentActiveVideo.is360Video && current360Player) {
        if (current360Player.getStats) {
          const stats = current360Player.getStats();
          fps = stats.fps || 0;
          if (stats.bufferLength !== undefined) {
            // Show buffer length and dropped frame count
            const droppedStr = (stats.framesDropped > 0) ? ` ‚Üì${stats.framesDropped}` : '';
            bufferInfo = ` [${stats.bufferLength}${droppedStr}]`;
          }
          // Use sync offset from stats if available (more accurate)
          if (stats.syncOffset !== null && stats.syncOffset !== undefined) {
            syncOffsetSec = stats.syncOffset;
          }
          // Get audio drift from stats
          if (stats.audioDrift !== null && stats.audioDrift !== undefined) {
            audioDrift = stats.audioDrift;
          }
        }
        actualVideoTimeSec = current360Player.currentTime || 0;
      } else if (currentActiveVideo.element) {
        actualVideoTimeSec = currentActiveVideo.element.currentTime || 0;
        // For standard video, use playback rate as FPS indicator
        const rate = currentActiveVideo.element.playbackRate || 1;
        fps = !currentActiveVideo.element.paused ? Math.round(rate * 30) : 0;
      }
      
      if (!isPlaying) {
        fpsDisplay.textContent = '‚è∏';
        fpsDisplay.style.color = '#9ca3af';
      } else {
        fpsDisplay.textContent = fps > 0 ? `${fps}fps${bufferInfo}` : '--fps';
        // Color based on target FPS (default 15 for INSV)
        const targetFps = (current360Player && current360Player.getStats) ? 
          (current360Player.getStats().targetFps || 15) : 25;
        fpsDisplay.style.color = fps >= targetFps ? '#22c55e' : fps >= targetFps * 0.7 ? '#eab308' : '#ef4444';
      }
      
      // Calculate sync offset if not available from stats
      if (syncOffsetSec === null) {
        const referenceStartMs = getFullStartTimeMs();
        const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
        const expectedVideoTimeSec = (currentAbsoluteMs - currentActiveVideo.startTimestampMs) / 1000;
        syncOffsetSec = actualVideoTimeSec - expectedVideoTimeSec;
      }
      
      const absOffset = Math.abs(syncOffsetSec);
      
      // Format sync display
      let syncText, syncColor;
      if (!isPlaying) {
        syncText = `‚è±${actualVideoTimeSec.toFixed(1)}s`;
        syncColor = '#9ca3af';
      } else if (absOffset < 0.1) {
        syncText = '‚è±‚úì';
        syncColor = '#22c55e'; // Green - in sync
      } else if (absOffset < 0.5) {
        const sign = syncOffsetSec > 0 ? '+' : '';
        syncText = `‚è±${sign}${syncOffsetSec.toFixed(1)}s`;
        syncColor = '#eab308'; // Yellow - slightly off
      } else {
        const sign = syncOffsetSec > 0 ? '+' : '';
        syncText = `‚è±${sign}${syncOffsetSec.toFixed(1)}s`;
        syncColor = '#ef4444'; // Red - significantly off
      }
      
      syncDisplay.textContent = syncText;
      syncDisplay.style.color = syncColor;
      
      // Format audio sync display
      if (audioSyncDisplay) {
        let audioText, audioColor;
        if (!isPlaying) {
          audioText = 'üîä--';
          audioColor = '#9ca3af';
        } else if (audioDrift === null) {
          audioText = 'üîä--';
          audioColor = '#9ca3af';
        } else {
          const absAudioDrift = Math.abs(audioDrift);
          const sign = audioDrift > 0 ? '+' : '';
          if (absAudioDrift < 0.1) {
            audioText = 'üîä‚úì';
            audioColor = '#22c55e'; // Green - in sync
          } else if (absAudioDrift < 0.3) {
            audioText = `üîä${sign}${(audioDrift * 1000).toFixed(0)}ms`;
            audioColor = '#22c55e'; // Still green - acceptable
          } else if (absAudioDrift < 0.5) {
            audioText = `üîä${sign}${(audioDrift * 1000).toFixed(0)}ms`;
            audioColor = '#eab308'; // Yellow - slightly off
          } else {
            audioText = `üîä${sign}${audioDrift.toFixed(1)}s`;
            audioColor = '#ef4444'; // Red - significantly off
          }
        }
        audioSyncDisplay.textContent = audioText;
        audioSyncDisplay.style.color = audioColor;
      }
      
      // Update lens status display
      const lensDisplay = document.getElementById('video-lens-status');
      if (lensDisplay) {
        if (currentActiveVideo && currentActiveVideo.is360Video && current360Player && current360Player.getStats) {
          const stats = current360Player.getStats();
          // F = Front lens (track 1), B = Back lens (track 0)
          // Show decode and render status
          const frontDec = stats.activeDecoders && stats.activeDecoders.includes('T1:on') ? '‚óè' : '‚óã';
          const backDec = stats.activeDecoders && stats.activeDecoders.includes('T0:on') ? '‚óè' : '‚óã';
          const frontRnd = stats.frontLensUpdated ? '‚óè' : '‚óã';
          const backRnd = stats.backLensUpdated ? '‚óè' : '‚óã';
          
          // Show optimization status with distance to seam
          let optStatus = stats.forceFullDecode ? 'FULL' : 
                         (stats.visibleLens === 0 ? 'F' : 
                          stats.visibleLens === 1 ? 'B' : 'FB');
          
          // Add pre-warm indicator
          if (stats.preWarmMode) {
            optStatus += '‚ö°';
          }
          
          // Add holdoff indicator with remaining time
          if (stats.dualModeHoldoff) {
            optStatus += `üîí${stats.dualModeHoldoffRemaining}`;
          }
          
          // Add distance to seam
          const seamDist = stats.distToNearestSeam !== undefined ? `${stats.distToNearestSeam}¬∞` : '--';
          
          lensDisplay.textContent = `üé• ${optStatus} ‚à†${seamDist} F:${frontDec}${frontRnd} B:${backDec}${backRnd}`;
          lensDisplay.title = `Lens Optimization: ${stats.forceFullDecode ? 'Disabled (full decode)' : 'Enabled'}\n` +
                             `Visible Lens: ${stats.lensMode || '--'}\n` +
                             `Distance to Seam: ${seamDist}\n` +
                             `Pre-warm Mode: ${stats.preWarmMode ? 'Yes' : 'No'}\n` +
                             `Dual Holdoff: ${stats.dualModeHoldoff ? stats.dualModeHoldoffRemaining + 's remaining' : 'No'}\n` +
                             `Front: decode=${frontDec === '‚óè' ? 'on' : 'off'}, render=${frontRnd === '‚óè' ? 'updated' : 'stale'}\n` +
                             `Back: decode=${backDec === '‚óè' ? 'on' : 'off'}, render=${backRnd === '‚óè' ? 'updated' : 'stale'}\n` +
                             `Buffer: ${stats.bufferDualCount || 0} dual, ${stats.bufferSingleCount || 0} single`;
          
          // Color: green if optimized (single lens), yellow if pre-warm/holdoff, gray if full decode
          if (stats.forceFullDecode) {
            lensDisplay.style.color = '#9ca3af'; // Gray - full decode
          } else if (stats.preWarmMode || stats.dualModeHoldoff) {
            lensDisplay.style.color = '#eab308'; // Yellow - pre-warm or holdoff
          } else if (stats.visibleLens === 2) {
            lensDisplay.style.color = '#f97316'; // Orange - dual (at seam)
          } else {
            lensDisplay.style.color = '#22c55e'; // Green - single lens optimized
          }
        } else {
          lensDisplay.textContent = 'üé• F:-- B:--';
          lensDisplay.style.color = '#9ca3af';
        }
      }
    }
    
    // Get the next video after current playback time
    function getNextVideoAfterCurrent() {
      if (loadedVideos.length === 0) return null;
      
      const referenceStartMs = getFullStartTimeMs();
      const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
      
      // Find next video that starts after current time
      const futureVideos = loadedVideos.filter(v => v.startTimestampMs > currentAbsoluteMs);
      if (futureVideos.length === 0) return null;
      
      // Return the one that starts soonest
      return futureVideos.reduce((earliest, v) => 
        v.startTimestampMs < earliest.startTimestampMs ? v : earliest
      );
    }
    
    // Render simplified minimap for fullscreen video overlay
    // Minimap zoom functions
    function minimapZoomIn(e) {
      if (e) {
        e.stopPropagation();
        e.preventDefault();
      }
      minimapZoomLevel = Math.min(8.0, minimapZoomLevel * 1.5);
      console.log('Minimap zoom in:', minimapZoomLevel.toFixed(1) + 'x');
      updateMinimapZoomDisplay();
      renderVideoMinimap();
    }
    
    function minimapZoomOut(e) {
      if (e) {
        e.stopPropagation();
        e.preventDefault();
      }
      minimapZoomLevel = Math.max(0.25, minimapZoomLevel / 1.5);
      console.log('Minimap zoom out:', minimapZoomLevel.toFixed(1) + 'x');
      updateMinimapZoomDisplay();
      renderVideoMinimap();
    }
    
    function minimapZoomReset(e) {
      if (e) {
        e.stopPropagation();
        e.preventDefault();
      }
      minimapZoomLevel = 1.0;
      console.log('Minimap zoom reset');
      updateMinimapZoomDisplay();
      renderVideoMinimap();
    }
    
    function updateMinimapZoomDisplay() {
      const zoomEl = document.getElementById('minimap-zoom-level');
      if (zoomEl) {
        zoomEl.textContent = minimapZoomLevel !== 1.0 ? minimapZoomLevel.toFixed(1) + 'x' : '';
      }
    }
    
    function handleMinimapWheel(e) {
      e.preventDefault();
      e.stopPropagation();
      
      // Zoom in/out based on wheel direction
      if (e.deltaY < 0) {
        // Scroll up = zoom in
        minimapZoomLevel = Math.min(8.0, minimapZoomLevel * 1.2);
      } else {
        // Scroll down = zoom out
        minimapZoomLevel = Math.max(0.25, minimapZoomLevel / 1.2);
      }
      
      updateMinimapZoomDisplay();
      renderVideoMinimap();
    }
    
    function renderVideoMinimap() {
      const svg = document.getElementById('video-minimap-svg');
      if (!svg) return;
      
      const sessions = getReplaySessions();
      if (sessions.length === 0) {
        svg.innerHTML = '';
        return;
      }
      
      const rect = svg.getBoundingClientRect();
      const width = rect.width || 264;
      const height = rect.height || 184;
      
      // Get timeslot range for filtering bounds (same as main map)
      const { startMs: timeslotStartMs, endMs: timeslotEndMs } = getTimeslotRangeMs();
      
      // Calculate bounds from track points within timeslot only (matching main map behavior)
      let allLats = [], allLons = [];
      sessions.forEach(session => {
        if (!session.track) return;
        const sessionStartMs = session.startTimestampMs || 0;
        const trimStartMin = session.timelineStart || 0;
        
        session.track.forEach(p => {
          const pointAbsMs = sessionStartMs + (trimStartMin + p.t) * 60000;
          if (pointAbsMs >= timeslotStartMs && pointAbsMs <= timeslotEndMs) {
            allLats.push(p.lat);
            allLons.push(p.lon);
          }
        });
      });
      
      // Fallback to full track if no points in timeslot
      if (allLats.length === 0) {
        sessions.forEach(session => {
          if (!session.track) return;
          session.track.forEach(p => {
            allLats.push(p.lat);
            allLons.push(p.lon);
          });
        });
      }
      
      if (allLats.length === 0) {
        svg.innerHTML = '';
        return;
      }
      
      let minLat = Math.min(...allLats), maxLat = Math.max(...allLats);
      let minLon = Math.min(...allLons), maxLon = Math.max(...allLons);
      
      // Add padding
      const latPad = (maxLat - minLat) * 0.1 || 0.001;
      const lonPad = (maxLon - minLon) * 0.1 || 0.001;
      minLat -= latPad; maxLat += latPad;
      minLon -= lonPad; maxLon += lonPad;
      
      // Apply zoom centered on current boat position
      if (minimapZoomLevel > 1.0 && sessions.length > 0) {
        // Get current boat position for zoom center
        const minimapTime = getTelemetryDisplayTime();
        const pos = getBoatPositionAtTime(sessions[0], minimapTime);
        if (pos) {
          const centerLon = pos.lon;
          const centerLat = pos.lat;
          
          // Calculate new bounds based on zoom level
          const latHalfRange = (maxLat - minLat) / 2 / minimapZoomLevel;
          const lonHalfRange = (maxLon - minLon) / 2 / minimapZoomLevel;
          
          minLat = centerLat - latHalfRange;
          maxLat = centerLat + latHalfRange;
          minLon = centerLon - lonHalfRange;
          maxLon = centerLon + lonHalfRange;
        }
      } else if (minimapZoomLevel < 1.0) {
        // Zoom out - expand bounds
        const expandFactor = 1.0 / minimapZoomLevel;
        const latCenter = (minLat + maxLat) / 2;
        const lonCenter = (minLon + maxLon) / 2;
        const latHalfRange = (maxLat - minLat) / 2 * expandFactor;
        const lonHalfRange = (maxLon - minLon) / 2 * expandFactor;
        
        minLat = latCenter - latHalfRange;
        maxLat = latCenter + latHalfRange;
        minLon = lonCenter - lonHalfRange;
        maxLon = lonCenter + lonHalfRange;
      }
      
      // Coordinate transforms - apply latitude correction like main map
      const latRange = maxLat - minLat;
      const lonRange = maxLon - minLon;
      const centerLat = (minLat + maxLat) / 2;
      const latCorrection = mapProjection === 'geo' ? Math.cos(centerLat * Math.PI / 180) : 1;
      const lonRangeCorrected = lonRange * latCorrection;
      
      // Scale with 0.9 factor to match main map
      const scale = Math.min(width / lonRangeCorrected, height / latRange) * 0.9;
      
      const lonToX = lon => (lon - minLon) * latCorrection * scale + (width - lonRangeCorrected * scale) / 2;
      const latToY = lat => height - ((lat - minLat) * scale + (height - latRange * scale) / 2);
      
      let html = '';
      
      // Store VMG segments for each session (used for boat icon coloring)
      const sessionVmgSegments = new Map(); // session index -> { bestSegs: [], worstSegs: [] }
      
      // Draw VMG performance highlights for each leg (BEFORE track)
      // Red = worst 20% of leg duration, Green = best 20% of leg duration
      // Show for current leg and last 3 legs
      sessions.forEach((session, boatIdx) => {
        const track = session.track;
        const legs = session.legs;
        
        if (!track || !legs || track.length < 10) return;
        
        // Use telemetry-adjusted time for track highlighting
        const highlightTelemetryTime = getTelemetryDisplayTime();
        const sessionStart = session.timelineStart || 0;
        const sessionLocalTime = getSessionLocalTime(session, highlightTelemetryTime);
        const trackPlaybackTime = sessionLocalTime - sessionStart;
        
        // Initialize segment storage for this session
        sessionVmgSegments.set(boatIdx, { bestSegs: [], worstSegs: [], trackPlaybackTime });
        
        // Find current leg index
        let currentLegIdx = -1;
        for (let i = 0; i < legs.length; i++) {
          if (trackPlaybackTime >= legs[i].start && trackPlaybackTime <= legs[i].end) {
            currentLegIdx = i;
            break;
          }
        }
        
        if (currentLegIdx === -1) {
          for (let i = legs.length - 1; i >= 0; i--) {
            if (trackPlaybackTime > legs[i].end) {
              currentLegIdx = i;
              break;
            }
          }
        }
        
        // Highlight current and last 3 legs
        const legsToHighlight = new Set();
        if (currentLegIdx >= 0) {
          for (let i = currentLegIdx; i >= Math.max(0, currentLegIdx - 3); i--) {
            legsToHighlight.add(i);
          }
        }
        
        legs.forEach((leg, legIdx) => {
          if (!legsToHighlight.has(legIdx)) return;
          
          const legVmg = parseFloat(leg.vmg);
          if (isNaN(legVmg) || legVmg <= 0) return;
          
          const legTwd = leg.localWind || session.s.twd || 0;
          const legStart = leg.start;
          const legEnd = leg.end;
          
          // Collect leg points with VMG (ALL points for accurate segments)
          const legPoints = [];
          for (let i = 0; i < track.length; i++) {
            const pt = track[i];
            if (pt.t >= legStart && pt.t <= legEnd) {
              const hdg = pt.hdg || pt.cog || 0;
              const sog = pt.sog || 0;
              const twa = Math.abs(angleDiff(hdg, legTwd));
              const instVmg = Math.abs(sog * Math.cos(twa * Math.PI / 180));
              
              legPoints.push({
                t: pt.t,
                lat: pt.lat,
                lon: pt.lon,
                deviation: instVmg - legVmg
              });
            }
          }
          
          if (legPoints.length < 2) return;
          
          // Group into segments
          const segments = [];
          let currentSeg = null;
          
          for (let i = 0; i < legPoints.length; i++) {
            const pt = legPoints[i];
            const isAbove = pt.deviation > 0;
            
            if (!currentSeg || currentSeg.isAbove !== isAbove) {
              if (currentSeg && currentSeg.points.length > 0) segments.push(currentSeg);
              currentSeg = { isAbove, points: [pt], totalDeviation: pt.deviation };
            } else {
              currentSeg.points.push(pt);
              currentSeg.totalDeviation += pt.deviation;
            }
          }
          if (currentSeg && currentSeg.points.length > 0) segments.push(currentSeg);
          
          segments.forEach(seg => {
            seg.duration = seg.points.length >= 2 ? seg.points[seg.points.length - 1].t - seg.points[0].t : 0;
            seg.avgDeviation = seg.totalDeviation / seg.points.length;
          });
          
          const aboveSegs = segments.filter(s => s.isAbove && s.duration > 0);
          const belowSegs = segments.filter(s => !s.isAbove && s.duration > 0);
          
          // Calculate total leg duration
          const totalLegDur = legPoints.length >= 2 ? legPoints[legPoints.length - 1].t - legPoints[0].t : 0;
          const maxHighlightDur = totalLegDur * 0.2; // 20% of leg duration for each color
          
          // Function to trim segment to fit budget
          const trimSegment = (seg, maxDur, findWorst) => {
            if (seg.duration <= maxDur) return seg;
            const pts = seg.points;
            if (pts.length < 2) return seg;
            
            let bestStart = 0, bestEnd = 1, bestAvg = findWorst ? Infinity : -Infinity;
            for (let i = 0; i < pts.length; i++) {
              let sum = 0, count = 0, j = i;
              while (j < pts.length && (pts[j].t - pts[i].t) <= maxDur) {
                sum += pts[j].deviation;
                count++;
                j++;
              }
              if (count >= 2) {
                const avg = sum / count;
                if (findWorst ? avg < bestAvg : avg > bestAvg) {
                  bestAvg = avg;
                  bestStart = i;
                  bestEnd = j;
                }
              }
            }
            const trimmedPts = pts.slice(bestStart, bestEnd);
            return {
              isAbove: seg.isAbove,
              points: trimmedPts,
              duration: trimmedPts.length >= 2 ? trimmedPts[trimmedPts.length - 1].t - trimmedPts[0].t : 0,
              avgDeviation: bestAvg
            };
          };
          
          // Best 20% of leg duration
          aboveSegs.sort((a, b) => b.avgDeviation - a.avgDeviation);
          const bestSegs = [];
          let bestDur = 0;
          for (const seg of aboveSegs) {
            if (bestDur >= maxHighlightDur) break;
            const remainingBudget = maxHighlightDur - bestDur;
            if (seg.duration <= remainingBudget) {
              bestSegs.push(seg);
              bestDur += seg.duration;
            } else if (remainingBudget > 0) {
              const trimmed = trimSegment(seg, remainingBudget, false);
              if (trimmed.duration > 0) {
                bestSegs.push(trimmed);
                bestDur += trimmed.duration;
              }
            }
          }
          
          // Worst 20% of leg duration
          belowSegs.sort((a, b) => a.avgDeviation - b.avgDeviation);
          const worstSegs = [];
          let worstDur = 0;
          for (const seg of belowSegs) {
            if (worstDur >= maxHighlightDur) break;
            const remainingBudget = maxHighlightDur - worstDur;
            if (seg.duration <= remainingBudget) {
              worstSegs.push(seg);
              worstDur += seg.duration;
            } else if (remainingBudget > 0) {
              const trimmed = trimSegment(seg, remainingBudget, true);
              if (trimmed.duration > 0) {
                worstSegs.push(trimmed);
                worstDur += trimmed.duration;
              }
            }
          }
          
          // Sampling step for drawing to avoid overdraw
          // Render highlights 10 seconds ahead of boat position
          const drawStep = Math.max(1, Math.floor(legPoints.length / 100));
          const highlightLookahead = 10 / 60; // 10 seconds in minutes
          
          // Get trim and timing info for filtering
          const sessionStartMs = session.startTimestampMs || 0;
          const trimStartMin = session.timelineStart || 0;
          const trimEndMin = session.timelineEnd || session.s.dur;
          const trimDuration = trimEndMin - trimStartMin;
          
          const drawSegments = (segs, color) => {
            segs.forEach(seg => {
              for (let i = drawStep; i < seg.points.length; i += drawStep) {
                const p0 = seg.points[i - drawStep];
                const p1 = seg.points[i];
                if (p1.t > trackPlaybackTime + highlightLookahead) continue;
                
                // Skip points outside trim range
                if (p1.t < 0 || p1.t > trimDuration) continue;
                
                // Skip points outside timeslot
                const p1AbsMs = sessionStartMs + (trimStartMin + p1.t) * 60000;
                if (p1AbsMs < timeslotStartMs || p1AbsMs > timeslotEndMs) continue;
                
                const x0 = lonToX(p0.lon);
                const y0 = latToY(p0.lat);
                const x1 = lonToX(p1.lon);
                const y1 = latToY(p1.lat);
                
                html += `<line x1="${x0.toFixed(1)}" y1="${y0.toFixed(1)}" x2="${x1.toFixed(1)}" y2="${y1.toFixed(1)}" stroke="${color}" stroke-width="5" stroke-linecap="butt" opacity="0.3"/>`;
              }
            });
          };
          
          drawSegments(worstSegs, '#ef4444');
          drawSegments(bestSegs, '#22c55e');
          
          // Store segments for boat icon coloring (with time bounds)
          const vmgData = sessionVmgSegments.get(boatIdx);
          if (vmgData) {
            bestSegs.forEach(seg => {
              if (seg.points && seg.points.length >= 2) {
                vmgData.bestSegs.push({
                  startTime: seg.points[0].t,
                  endTime: seg.points[seg.points.length - 1].t
                });
              }
            });
            worstSegs.forEach(seg => {
              if (seg.points && seg.points.length >= 2) {
                vmgData.worstSegs.push({
                  startTime: seg.points[0].t,
                  endTime: seg.points[seg.points.length - 1].t
                });
              }
            });
          }
        });
      });
      
      // Draw tracks with time-based fading
      sessions.forEach((session, i) => {
        if (!session.track || session.track.length === 0) return;
        const color = BOAT_COLORS[i % BOAT_COLORS.length];
        
        // Get session timing info (use telemetry-adjusted time)
        const trackTelemetryTime = getTelemetryDisplayTime();
        const sessionLocalTime = getSessionLocalTime(session, trackTelemetryTime);
        const sessionStart = session.timelineStart || 0;
        const trackPlaybackTime = sessionLocalTime - sessionStart;
        
        // Fading parameters (in minutes) - use global config
        const recentWindow = trackRecentWindow;
        const fadeWindow = trackFadeWindow;
        
        // Sample track for performance - increase resolution when zoomed in
        // At zoom 1.0: 300 points, at zoom 4.0: 600 points, at zoom 0.5: 200 points
        const baseMaxPoints = 300;
        const zoomAdjustedMaxPoints = Math.round(baseMaxPoints * Math.min(2, Math.max(0.5, minimapZoomLevel)));
        const step = Math.max(1, Math.floor(session.track.length / zoomAdjustedMaxPoints));
        
        // Draw line segments with individual opacity
        for (let idx = step; idx < session.track.length; idx += step) {
          const p0 = session.track[idx - step];
          const p1 = session.track[idx];
          
          // Calculate opacity based on age
          let opacity = 0.8;
          let strokeColor = color;
          let isGray = false;
          
          if (sessionLocalTime >= sessionStart && trackPlaybackTime >= 0) {
            const age = trackPlaybackTime - p1.t;
            
            if (p1.t > trackPlaybackTime) {
              // Future track - faded grey
              opacity = 0.15;
              strokeColor = '#9ca3af';
              isGray = true;
            } else if (age <= recentWindow) {
              // Recent - full opacity
              opacity = 0.8;
            } else if (age <= fadeWindow) {
              // Fading
              const fadePct = (age - recentWindow) / (fadeWindow - recentWindow);
              opacity = 0.8 - fadePct * 0.5;
            } else {
              // Old - grey
              opacity = 0.2;
              strokeColor = '#9ca3af';
              isGray = true;
            }
          } else if (sessionLocalTime < sessionStart) {
            opacity = 0.15;
            strokeColor = '#9ca3af';
            isGray = true;
          }
          
          // Skip gray tracks if hide mode is enabled
          if (hideGrayTracks && isGray) continue;
          
          const x0 = lonToX(p0.lon);
          const y0 = latToY(p0.lat);
          const x1 = lonToX(p1.lon);
          const y1 = latToY(p1.lat);
          
          html += `<line x1="${x0.toFixed(1)}" y1="${y0.toFixed(1)}" x2="${x1.toFixed(1)}" y2="${y1.toFixed(1)}" stroke="${strokeColor}" stroke-width="1.5" stroke-linecap="round" opacity="${opacity.toFixed(2)}"/>`;
        }
      });
      
      // Draw boat positions (no numbers) - use telemetry-adjusted time
      const minimapTelemetryTime = getTelemetryDisplayTime();
      const vmgProximityWindow = 5 / 60; // 5 seconds in minutes
      
      sessions.forEach((session, i) => {
        const color = BOAT_COLORS[i % BOAT_COLORS.length];
        const pos = getBoatPositionAtTime(session, minimapTelemetryTime);
        
        if (pos) {
          const x = lonToX(pos.lon);
          const y = latToY(pos.lat);
          const hdg = pos.hdg || pos.cog || 0;
          
          // Determine stroke color based on VMG segment proximity
          let strokeColor = 'white';
          const vmgData = sessionVmgSegments.get(i);
          if (vmgData) {
            const currentTrackTime = vmgData.trackPlaybackTime;
            
            // Check if within 5 seconds of any best segment (green takes priority)
            const inBestZone = vmgData.bestSegs.some(seg => 
              currentTrackTime >= (seg.startTime - vmgProximityWindow) && 
              currentTrackTime <= (seg.endTime + vmgProximityWindow)
            );
            
            // Check if within 5 seconds of any worst segment
            const inWorstZone = vmgData.worstSegs.some(seg => 
              currentTrackTime >= (seg.startTime - vmgProximityWindow) && 
              currentTrackTime <= (seg.endTime + vmgProximityWindow)
            );
            
            if (inBestZone) {
              strokeColor = '#22c55e'; // Green
            } else if (inWorstZone) {
              strokeColor = '#ef4444'; // Red
            }
          }
          
          // Boat triangle
          const size = 8;
          html += `
            <g transform="translate(${x},${y}) rotate(${hdg})">
              <polygon points="0,${-size} ${size*0.6},${size*0.6} ${-size*0.6},${size*0.6}" 
                       fill="${color}" stroke="${strokeColor}" stroke-width="1.5"/>
            </g>
          `;
        }
      });
      
      svg.innerHTML = html;
    }
    
    // Jump to next video and start playing
    function jumpToNextVideo() {
      // Find the next video
      const referenceStartMs = getFullStartTimeMs();
      const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
      
      let nextVideo = null;
      
      // First check if current video hasn't started yet
      if (currentActiveVideo) {
        const videoTimeMs = currentAbsoluteMs - currentActiveVideo.startTimestampMs;
        if (videoTimeMs < 0) {
          // Current video is the next one
          nextVideo = currentActiveVideo;
        }
      }
      
      // Otherwise find next video after current time
      if (!nextVideo) {
        nextVideo = getNextVideoAfterCurrent();
      }
      
      if (!nextVideo) return;
      
      // Calculate playback time for video start (add small offset to be inside the video)
      const videoStartMin = (nextVideo.startTimestampMs - referenceStartMs) / 60000;
      playbackTime = videoStartMin + 0.01; // Small offset to ensure we're inside video timeframe
      
      // Update UI first
      updatePlaybackUI();
      
      // Start playback (this sets isPlaying = true and calls playAllVideos)
      if (!isPlaying) {
        startPlayback();
      }
      
      // Update display - will properly set up video
      updateActiveVideoDisplay();
      
      // Hide unavailable overlay immediately
      const overlay = document.getElementById('video-unavailable-overlay');
      if (overlay) overlay.style.display = 'none';
      
      // For 360 videos
      if (nextVideo.is360Video) {
        // If 360 player is ready and we're playing, seek and start
        if (current360Player && isPlaying) {
          current360Player.seek(0.01);
          if (!current360Player.playing) {
            play360Video();
          }
        }
        // Otherwise load360Video callback will handle it
        updateVideoOverlays();
        updateBoatInfoPanel();
        updateCurrentLegsPanel();
        updateChartTimePointers();
        updateTimelinePlaybackPointer();
        renderMap();
        return;
      }
      
      // For regular videos, wait for the video to be ready before playing
      const videoEl = nextVideo.element;
      
      const playWhenReady = () => {
        if (!currentActiveVideo || currentActiveVideo !== nextVideo) return;
        
        videoEl.style.visibility = 'visible';
        videoEl.muted = playbackSpeed > 2;
        videoEl.playbackRate = Math.min(playbackSpeed, 16);
        videoEl.currentTime = 0.01;
        
        const playPromise = videoEl.play();
        if (playPromise !== undefined) {
          playPromise.catch(err => {
            console.log('Play failed, trying muted:', err);
            videoEl.muted = true;
            videoEl.play().catch(() => {});
          });
        }
        
        updateVideoOverlays();
      };
      
      // If video is already ready, play immediately
      if (videoEl.readyState >= 3) { // HAVE_FUTURE_DATA or higher
        playWhenReady();
      } else {
        // Wait for video to be ready
        const onCanPlay = () => {
          videoEl.removeEventListener('canplay', onCanPlay);
          playWhenReady();
        };
        videoEl.addEventListener('canplay', onCanPlay);
        
        // Timeout fallback - try to play after 500ms anyway
        setTimeout(() => {
          videoEl.removeEventListener('canplay', onCanPlay);
          if (currentActiveVideo === nextVideo && videoEl.paused && isPlaying) {
            playWhenReady();
          }
        }, 500);
      }
      
      // Update other UI elements
      updateBoatInfoPanel();
      updateCurrentLegsPanel();
      updateChartTimePointers();
      updateTimelinePlaybackPointer();
      renderMap();
    }
    
    function updateVideoTelemetry() {
      const sogEl = document.getElementById('telem-sog');
      const vmgEl = document.getElementById('telem-vmg');
      const hdgEl = document.getElementById('telem-hdg');
      const heelEl = document.getElementById('telem-heel');
      const strEl = document.getElementById('telem-str');
      const legSpdEl = document.getElementById('telem-leg-spd');
      const legVmgEl = document.getElementById('telem-leg-vmg');
      const legHdgEl = document.getElementById('telem-leg-hdg');
      const legNextEl = document.getElementById('telem-leg-next');
      const legLabelEl = document.getElementById('telem-leg-label');
      const leg2SpdEl = document.getElementById('telem-leg2-spd');
      const leg2VmgEl = document.getElementById('telem-leg2-vmg');
      const leg2HdgEl = document.getElementById('telem-leg2-hdg');
      const leg2HeelEl = document.getElementById('telem-leg2-heel');
      const leg2NextEl = document.getElementById('telem-leg2-next');
      const leg2LabelEl = document.getElementById('telem-leg2-label');
      const distDirectEl = document.getElementById('telem-distance-direct');
      
      // Get first selected session for telemetry
      const sessions = getReplaySessions();
      
      // Apply telemetry offset for display purposes only
      const telemetryTime = getTelemetryDisplayTime();
      
      // Check if both boats have active data at current playback time (using adjusted time)
      const hasTwoBoats = sessions.length >= 2;
      const bothBoatsActive = hasTwoBoats && 
        isSessionVisibleAtTime(sessions[0], telemetryTime) && 
        isSessionVisibleAtTime(sessions[1], telemetryTime);
      
      // Hide/show boat 2 related elements based on session count and active state
      const leg2TelemPanel = document.getElementById('minimap-leg2-telemetry');
      const distanceOverlay = document.getElementById('video-distance-overlay');
      const minimapOverlay = document.getElementById('video-minimap-overlay');
      
      if (leg2TelemPanel) {
        // Use class toggle to work with CSS !important in fullscreen
        if (bothBoatsActive) {
          leg2TelemPanel.classList.add('show-boat2');
          leg2TelemPanel.style.display = 'flex';
        } else {
          leg2TelemPanel.classList.remove('show-boat2');
          leg2TelemPanel.style.display = 'none';
        }
      }
      if (distanceOverlay) {
        distanceOverlay.style.display = bothBoatsActive ? 'block' : 'none';
      }
      // Toggle single-boat class on minimap for narrower width
      if (minimapOverlay) {
        if (bothBoatsActive) {
          minimapOverlay.classList.remove('single-boat');
        } else {
          minimapOverlay.classList.add('single-boat');
        }
      }
      
      if (sessions.length === 0) {
        if (sogEl) sogEl.textContent = '-.-';
        if (vmgEl) vmgEl.textContent = '-.-';
        if (hdgEl) hdgEl.textContent = '---';
        if (heelEl) heelEl.textContent = '--';
        if (strEl) strEl.textContent = '-.-';
        if (legSpdEl) legSpdEl.textContent = '-.-';
        if (legVmgEl) legVmgEl.textContent = '-.-';
        if (legHdgEl) legHdgEl.textContent = '---';
        if (legNextEl) legNextEl.textContent = '--';
        if (leg2SpdEl) leg2SpdEl.textContent = '-.-';
        if (leg2VmgEl) leg2VmgEl.textContent = '-.-';
        if (leg2HdgEl) leg2HdgEl.textContent = '---';
        if (leg2HeelEl) leg2HeelEl.textContent = '--';
        if (leg2NextEl) leg2NextEl.textContent = '--';
        if (distEl) distEl.textContent = '--';
        return;
      }
      
      // Update leg labels with boat names
      if (legLabelEl && sessions.length >= 1) {
        const boat1Name = getBoatSymbol(sessions[0].filename);
        legLabelEl.textContent = `${boat1Name} Leg`;
      }
      if (leg2LabelEl && sessions.length >= 2) {
        const boat2Name = getBoatSymbol(sessions[1].filename);
        const boat2Color = BOAT_COLORS[1 % BOAT_COLORS.length];
        leg2LabelEl.textContent = `${boat2Name} Leg`;
        leg2LabelEl.style.color = boat2Color;
      }
      
      // Use first session for telemetry (usually the main boat)
      const session = sessions[0];
      const telemetry = getSmoothedTelemetry(session, telemetryTime, 2);
      
      // Update instant telemetry
      const telemetryOverlayEl = document.getElementById('video-telemetry-overlay');
      if (telemetry) {
        if (sogEl) sogEl.textContent = telemetry.sog.toFixed(1);
        if (vmgEl) vmgEl.textContent = telemetry.vmg.toFixed(1);
        if (hdgEl) hdgEl.textContent = Math.round(telemetry.hdg).toString().padStart(3, '0');
        if (heelEl) heelEl.textContent = Math.round(telemetry.heel);
        if (strEl) strEl.textContent = (telemetry.steeringRate || 0).toFixed(1);
        
        // Calculate VMG performance background color using same segment logic as track highlights
        // Shows green when in best 20% segments, red when in worst 20% segments
        // Check current leg + last 3 legs (same as track highlights)
        if (telemetryOverlayEl) {
          const legs = session.legs;
          const track = session.track;
          
          // Get current track time (using telemetry-adjusted time)
          const sessionLocalTime = getSessionLocalTime(session, telemetryTime);
          const sessionStart = session.timelineStart || 0;
          const currentTrackTime = sessionLocalTime - sessionStart;
          
          // Find current leg index (same logic as track highlights)
          let currentLegIdx = -1;
          if (legs) {
            for (let i = 0; i < legs.length; i++) {
              if (currentTrackTime >= legs[i].start && currentTrackTime <= legs[i].end) {
                currentLegIdx = i;
                break;
              }
            }
            if (currentLegIdx === -1) {
              for (let i = legs.length - 1; i >= 0; i--) {
                if (currentTrackTime > legs[i].end) {
                  currentLegIdx = i;
                  break;
                }
              }
            }
          }
          
          // Determine which legs to check (current and last 3)
          const legsToCheck = [];
          if (currentLegIdx >= 0 && legs) {
            for (let i = currentLegIdx; i >= Math.max(0, currentLegIdx - 3); i--) {
              legsToCheck.push(legs[i]);
            }
          }
          
          let bgColor = 'rgba(0, 0, 0, 0.7)'; // Default
          let inBestSeg = false;
          let inWorstSeg = false;
          
          // Check if current time is within trim range and timeslot
          const trimEndMin = session.timelineEnd || session.s.dur;
          const trimDuration = trimEndMin - sessionStart;
          const sessionStartMs = session.startTimestampMs || 0;
          const { startMs: timeslotStartMs, endMs: timeslotEndMs } = getTimeslotRangeMs();
          const currentAbsMs = sessionStartMs + (sessionStart + currentTrackTime) * 60000;
          const isWithinTrimAndTimeslot = currentTrackTime >= 0 && currentTrackTime <= trimDuration &&
                                          currentAbsMs >= timeslotStartMs && currentAbsMs <= timeslotEndMs;
          
          // Use ALL points for segment calculation (consistent with map highlights)
          
          // Check each leg's segments (only if within trim and timeslot)
          if (isWithinTrimAndTimeslot) {
          for (const leg of legsToCheck) {
            if (!leg || leg.vmg == null) continue;
            
            const legVmg = parseFloat(leg.vmg);
            if (isNaN(legVmg) || legVmg <= 0) continue;
            
            const legTwd = leg.localWind || session.s.twd || 0;
            const legStart = leg.start;
            const legEnd = leg.end;
            
            // Collect leg points with VMG deviations (ALL points for accuracy)
            const legPoints = [];
            if (track) {
              for (let i = 0; i < track.length; i++) {
                const pt = track[i];
                if (pt.t >= legStart && pt.t <= legEnd) {
                  const ptHdg = pt.hdg || pt.cog || 0;
                  const ptSog = pt.sog || 0;
                  const ptTwa = Math.abs(angleDiff(ptHdg, legTwd));
                  const ptVmg = Math.abs(ptSog * Math.cos(ptTwa * Math.PI / 180));
                  legPoints.push({
                    t: pt.t,
                    deviation: ptVmg - legVmg
                  });
                }
              }
            }
            
            if (legPoints.length < 2) continue;
            
            // Group into segments
            const segments = [];
            let currentSeg = null;
            
            for (let i = 0; i < legPoints.length; i++) {
              const pt = legPoints[i];
              const isAbove = pt.deviation > 0;
              
              if (!currentSeg || currentSeg.isAbove !== isAbove) {
                if (currentSeg && currentSeg.points.length > 0) segments.push(currentSeg);
                currentSeg = { isAbove, points: [pt], totalDeviation: pt.deviation };
              } else {
                currentSeg.points.push(pt);
                currentSeg.totalDeviation += pt.deviation;
              }
            }
            if (currentSeg && currentSeg.points.length > 0) segments.push(currentSeg);
            
            // Calculate duration and avg deviation
            segments.forEach(seg => {
              seg.duration = seg.points.length >= 2 ? seg.points[seg.points.length - 1].t - seg.points[0].t : 0;
              seg.avgDeviation = seg.totalDeviation / seg.points.length;
              seg.startTime = seg.points[0].t;
              seg.endTime = seg.points[seg.points.length - 1].t;
            });
            
            const aboveSegs = segments.filter(s => s.isAbove && s.duration > 0);
            const belowSegs = segments.filter(s => !s.isAbove && s.duration > 0);
            
            // Calculate total leg duration and max highlight duration (20%)
            const totalLegDur = legPoints[legPoints.length - 1].t - legPoints[0].t;
            const maxHighlightDur = totalLegDur * 0.2;
            
            // Trimming function
            const trimSegment = (seg, maxDur, findWorst) => {
              if (seg.duration <= maxDur) return seg;
              const pts = seg.points;
              if (pts.length < 2) return seg;
              
              let bestStart = 0, bestEnd = 1, bestAvg = findWorst ? Infinity : -Infinity;
              for (let i = 0; i < pts.length; i++) {
                let sum = 0, count = 0, j = i;
                while (j < pts.length && (pts[j].t - pts[i].t) <= maxDur) {
                  sum += pts[j].deviation;
                  count++;
                  j++;
                }
                if (count >= 2) {
                  const avg = sum / count;
                  if (findWorst ? avg < bestAvg : avg > bestAvg) {
                    bestAvg = avg;
                    bestStart = i;
                    bestEnd = j;
                  }
                }
              }
              const trimmedPts = pts.slice(bestStart, bestEnd);
              return {
                isAbove: seg.isAbove,
                points: trimmedPts,
                duration: trimmedPts.length >= 2 ? trimmedPts[trimmedPts.length - 1].t - trimmedPts[0].t : 0,
                startTime: trimmedPts[0].t,
                endTime: trimmedPts[trimmedPts.length - 1].t
              };
            };
            
            // Select best 20% segments
            aboveSegs.sort((a, b) => b.avgDeviation - a.avgDeviation);
            const bestSegs = [];
            let bestDur = 0;
            for (const seg of aboveSegs) {
              if (bestDur >= maxHighlightDur) break;
              const remainingBudget = maxHighlightDur - bestDur;
              if (seg.duration <= remainingBudget) {
                bestSegs.push(seg);
                bestDur += seg.duration;
              } else if (remainingBudget > 0) {
                const trimmed = trimSegment(seg, remainingBudget, false);
                if (trimmed.duration > 0) {
                  bestSegs.push(trimmed);
                  bestDur += trimmed.duration;
                }
              }
            }
            
            // Select worst 20% segments
            belowSegs.sort((a, b) => a.avgDeviation - b.avgDeviation);
            const worstSegs = [];
            let worstDur = 0;
            for (const seg of belowSegs) {
              if (worstDur >= maxHighlightDur) break;
              const remainingBudget = maxHighlightDur - worstDur;
              if (seg.duration <= remainingBudget) {
                worstSegs.push(seg);
                worstDur += seg.duration;
              } else if (remainingBudget > 0) {
                const trimmed = trimSegment(seg, remainingBudget, true);
                if (trimmed.duration > 0) {
                  worstSegs.push(trimmed);
                  worstDur += trimmed.duration;
                }
              }
            }
            
            // Check if current time is in any best/worst segment of this leg
            if (bestSegs.some(seg => currentTrackTime >= seg.startTime && currentTrackTime <= seg.endTime)) {
              inBestSeg = true;
            }
            if (worstSegs.some(seg => currentTrackTime >= seg.startTime && currentTrackTime <= seg.endTime)) {
              inWorstSeg = true;
            }
          }
          } // End isWithinTrimAndTimeslot check
          
          // Best takes priority over worst
          if (inBestSeg) {
            bgColor = 'rgba(22, 101, 52, 0.7)'; // Dark green
          } else if (inWorstSeg) {
            bgColor = 'rgba(153, 27, 27, 0.7)'; // Dark red
          }
          
          telemetryOverlayEl.style.background = bgColor;
        }
      } else {
        if (sogEl) sogEl.textContent = '-.-';
        if (vmgEl) vmgEl.textContent = '-.-';
        if (hdgEl) hdgEl.textContent = '---';
        if (heelEl) heelEl.textContent = '--';
        if (strEl) strEl.textContent = '-.-';
        if (telemetryOverlayEl) telemetryOverlayEl.style.background = 'rgba(0, 0, 0, 0.7)';
      }
      
      // Update leg telemetry (using telemetry-adjusted time)
      const currentLeg = getCurrentLegAtTime(session, telemetryTime);
      const legOverlayEl = document.getElementById('video-leg-overlay');
      if (currentLeg) {
        if (legSpdEl) legSpdEl.textContent = currentLeg.speed != null ? parseFloat(currentLeg.speed).toFixed(1) : '-.-';
        if (legVmgEl) legVmgEl.textContent = currentLeg.vmg != null ? parseFloat(currentLeg.vmg).toFixed(1) : '-.-';
        if (legHdgEl) legHdgEl.textContent = currentLeg.hdg != null ? Math.round(currentLeg.hdg).toString().padStart(3, '0') : '---';
        
        // Leg overlay uses default background
        if (legOverlayEl) {
          legOverlayEl.style.background = 'rgba(0, 0, 0, 0.7)';
        }
        
        // Calculate time until next leg and tack angle (using telemetry-adjusted time)
        const sessionLocalTime = getSessionLocalTime(session, telemetryTime);
        const sessionStart = session.timelineStart || 0;
        const trackTime = sessionLocalTime - sessionStart;
        const timeToEnd = (currentLeg.end - trackTime) * 60; // Convert to seconds
        
        if (legNextEl) {
          // Find next leg
          const nextLeg = getNextLeg(session, currentLeg);
          let tackAngle = '--';
          if (nextLeg && currentLeg.hdg != null && nextLeg.hdg != null) {
            tackAngle = Math.round(Math.abs(angleDiff(currentLeg.hdg, nextLeg.hdg)));
          }
          
          if (timeToEnd > 0) {
            const mins = Math.floor(timeToEnd / 60);
            const secs = Math.floor(timeToEnd % 60);
            legNextEl.textContent = `${tackAngle}${typeof tackAngle === 'number' ? '¬∞' : ''}, ${mins}:${secs.toString().padStart(2, '0')}`;
          } else {
            legNextEl.textContent = `${tackAngle}${typeof tackAngle === 'number' ? '¬∞' : ''}, 0:00`;
          }
        }
      } else {
        if (legSpdEl) legSpdEl.textContent = '-.-';
        if (legVmgEl) legVmgEl.textContent = '-.-';
        if (legHdgEl) legHdgEl.textContent = '---';
        if (legNextEl) legNextEl.textContent = '--';
        if (legOverlayEl) legOverlayEl.style.background = 'rgba(0, 0, 0, 0.7)';
      }
      
      // Update second boat leg telemetry (if available)
      const leg2TelemEl = document.getElementById('minimap-leg2-telemetry');
      if (sessions.length >= 2) {
        const session2 = sessions[1];
        const isBoat2Active = isSessionVisibleAtTime(session2, playbackTime);
        
        // Hide boat 2 telemetry if not active
        if (leg2TelemEl) {
          if (isBoat2Active) {
            leg2TelemEl.classList.add('show-boat2');
            leg2TelemEl.style.display = 'flex';
          } else {
            leg2TelemEl.classList.remove('show-boat2');
            leg2TelemEl.style.display = 'none';
          }
        }
        
        if (isBoat2Active) {
          const currentLeg2 = getCurrentLegAtTime(session2, telemetryTime);
          const telemetry2 = getSmoothedTelemetry(session2, telemetryTime, 2);
        
          if (currentLeg2) {
            if (leg2SpdEl) leg2SpdEl.textContent = currentLeg2.speed != null ? parseFloat(currentLeg2.speed).toFixed(1) : '-.-';
            if (leg2VmgEl) leg2VmgEl.textContent = currentLeg2.vmg != null ? parseFloat(currentLeg2.vmg).toFixed(1) : '-.-';
            if (leg2HdgEl) leg2HdgEl.textContent = currentLeg2.hdg != null ? Math.round(currentLeg2.hdg).toString().padStart(3, '0') : '---';
            if (leg2HeelEl) leg2HeelEl.textContent = currentLeg2.heel != null ? Math.round(currentLeg2.heel) : '--';
            
            // Boat 2 telemetry uses transparent background
            if (leg2TelemEl) {
              leg2TelemEl.style.background = 'transparent';
            }
            
            // Calculate time until next leg and tack angle for boat 2 (using telemetry-adjusted time)
            const sessionLocalTime2 = getSessionLocalTime(session2, telemetryTime);
            const sessionStart2 = session2.timelineStart || 0;
            const trackTime2 = sessionLocalTime2 - sessionStart2;
            const timeToEnd2 = (currentLeg2.end - trackTime2) * 60; // Convert to seconds
            
            if (leg2NextEl) {
              const nextLeg2 = getNextLeg(session2, currentLeg2);
              let tackAngle2 = '--';
              if (nextLeg2 && currentLeg2.hdg != null && nextLeg2.hdg != null) {
                tackAngle2 = Math.round(Math.abs(angleDiff(currentLeg2.hdg, nextLeg2.hdg)));
              }
              leg2NextEl.textContent = typeof tackAngle2 === 'number' ? tackAngle2 + '¬∞' : tackAngle2;
            }
          } else {
            if (leg2SpdEl) leg2SpdEl.textContent = '-.-';
            if (leg2VmgEl) leg2VmgEl.textContent = '-.-';
            if (leg2HdgEl) leg2HdgEl.textContent = '---';
            if (leg2HeelEl) leg2HeelEl.textContent = '--';
            if (leg2NextEl) leg2NextEl.textContent = '--';
            if (leg2TelemEl) leg2TelemEl.style.background = 'transparent';
          }
        } // End isBoat2Active
      } else {
        if (leg2SpdEl) leg2SpdEl.textContent = '-.-';
        if (leg2VmgEl) leg2VmgEl.textContent = '-.-';
        if (leg2HdgEl) leg2HdgEl.textContent = '---';
        if (leg2HeelEl) leg2HeelEl.textContent = '--';
        if (leg2NextEl) leg2NextEl.textContent = '--';
        if (leg2TelemEl) leg2TelemEl.style.background = 'transparent';
      }
      
      // Update distance between boats (using telemetry-adjusted time)
      if (distDirectEl) {
        const distInfo = getBoatDistanceInfo(sessions, telemetryTime);
        const formatted = formatBoatDistanceDisplay(distInfo);
        
        if (formatted && formatted.line1) {
          distDirectEl.textContent = formatted.line1;
        } else {
          distDirectEl.textContent = '--';
        }
        
        // Update time to mark for both boats
        const markBoat1El = document.getElementById('telem-mark-boat1');
        const markBoat2El = document.getElementById('telem-mark-boat2');
        
        if (markBoat1El && markBoat2El && cachedRacingMarks) {
          const formatTime = (sec) => {
            if (sec > 3600) return '>1h';
            if (sec > 600) return `${Math.round(sec/60)}m`;
            if (sec >= 60) return `${Math.floor(sec/60)}:${String(Math.round(sec%60)).padStart(2,'0')}`;
            return `${Math.round(sec)}s`;
          };
          
          // Calculate time to marks for each boat
          const upmark = cachedRacingMarks.upmarks[0];
          const downmark = cachedRacingMarks.downmarks[0];
          
          sessions.slice(0, 2).forEach((session, boatIdx) => {
            const el = boatIdx === 0 ? markBoat1El : markBoat2El;
            
            // Skip boats not active at current playback time (using telemetry-adjusted time)
            if (!isSessionVisibleAtTime(session, telemetryTime)) {
              el.textContent = '--';
              return;
            }
            
            const leg = getCurrentLegAtTime(session, telemetryTime);
            const track = session.track;
            const sessionStart = session.timelineStart || 0;
            
            if (!track || track.length === 0) {
              el.textContent = '--';
              return;
            }
            
            let isUpwind = null;
            if (leg) {
              isUpwind = leg.pos === 'upwind' || (leg.twa != null && leg.twa < 90);
            }
            
            const sessionLocalTime = getSessionLocalTime(session, telemetryTime);
            const currentTrackTime = sessionLocalTime - sessionStart;
            
            // Find time to relevant mark
            const targetMark = isUpwind !== false ? upmark : downmark;
            let timeToMark = null;
            
            if (targetMark) {
              let minDist = Infinity;
              let minDistTrackTime = null;
              let passedMin = false;
              
              for (let i = 0; i < track.length; i++) {
                const pt = track[i];
                if (pt.t <= currentTrackTime) continue;
                
                const dist = haversineDistance(pt.lat, pt.lon, targetMark.lat, targetMark.lon);
                
                if (dist < minDist) {
                  minDist = dist;
                  minDistTrackTime = pt.t;
                  passedMin = false;
                } else if (minDist < 40 && !passedMin) {
                  passedMin = true;
                  break;
                }
              }
              
              if (minDist <= 50 && minDistTrackTime != null) {
                timeToMark = (minDistTrackTime - currentTrackTime) * 60;
              }
            }
            
            if (timeToMark != null && timeToMark > 0) {
              const markLabel = isUpwind !== false ? 'Up mark in' : 'Down mark in';
              const boatName = getBoatSymbol(session.filename);
              el.textContent = `${boatName}: ${markLabel}: ${formatTime(timeToMark)}`;
            } else {
              el.textContent = '--';
            }
          });
        }
      }
    }
    
    function getNextLeg(session, currentLeg) {
      if (!session || !session.legs || !currentLeg) return null;
      
      const currentIdx = session.legs.findIndex(l => l.id === currentLeg.id);
      if (currentIdx >= 0 && currentIdx < session.legs.length - 1) {
        return session.legs[currentIdx + 1];
      }
      return null;
    }
    
    function getBoatDistanceInfo(sessions, globalTimeMin) {
      if (sessions.length < 2) return null;
      
      // Get positions for all boats
      const positions = sessions.map(s => getBoatPositionAtTime(s, globalTimeMin)).filter(p => p);
      if (positions.length < 2) return null;
      
      const b1 = positions[0];
      const b2 = positions[1];
      
      // Calculate routes in both directions
      const route1to2 = calculateSailingRoute(b1, b2, sessions, 0);
      const route2to1 = calculateSailingRoute(b1, b2, sessions, 1);
      
      if (!route1to2 || !route2to1) return null;
      
      // Apply 10-second rolling window to sailing times (separate for each route)
      const smoothedTime1to2 = getSmoothedSailingTime(route1to2.time, '1to2');
      const smoothedTime2to1 = getSmoothedSailingTime(route2to1.time, '2to1');
      
      return {
        route1to2: { ...route1to2, smoothedTime: smoothedTime1to2 },
        route2to1: { ...route2to1, smoothedTime: smoothedTime2to1 },
        directDist: route1to2.directDist
      };
    }
    
    function formatBoatDistanceDisplay(distInfo) {
      if (!distInfo) return '--';
      
      const formatDist = (m) => m >= 1000 ? `${(m/1000).toFixed(1)}km` : `${Math.round(m)}m`;
      const formatTime = (sec) => {
        if (sec > 3600) return '>1h';
        if (sec > 600) return `${Math.round(sec/60)}m`;
        if (sec >= 60) return `${Math.floor(sec/60)}:${String(Math.round(sec%60)).padStart(2,'0')}`;
        return `${Math.round(sec)}s`;
      };
      
      const r1 = distInfo.route1to2;
      const r2 = distInfo.route2to1;
      
      // Determine catching time (smaller of the two sailing times)
      let catchingTime = 0;
      if (r1.smoothedTime > 0 && r2.smoothedTime > 0) {
        catchingTime = Math.min(r1.smoothedTime, r2.smoothedTime);
      }
      
      // Simplified display: "Distance: 10m, 2:45"
      const line1 = catchingTime > 0 
        ? `Distance: ${formatDist(distInfo.directDist)}, ${formatTime(catchingTime)}`
        : `Distance: ${formatDist(distInfo.directDist)}`;
      
      return { line1, line2: '', line2b: '', line3: '', line3b: '', distInfo };
    }
    
    function renderVideoTimelineMarkers() {
      // Render video coverage segments in the coverage bar
      const coverageBar = document.getElementById('video-coverage-bar');
      if (coverageBar) {
        coverageBar.innerHTML = '';
        
        if (loadedVideos.length > 0) {
          let referenceStartMs = getFullStartTimeMs();
          let fullEndMs = getFullEndTimeMs();
          
          // If no telemetry data (referenceStartMs is 0 or Infinity), use video timestamps
          if (referenceStartMs === 0 || referenceStartMs === Infinity || fullEndMs <= referenceStartMs) {
            // Use videos themselves as reference
            const videoStarts = loadedVideos.map(v => v.startTimestampMs).filter(t => t > 0);
            const videoEnds = loadedVideos.map(v => v.endTimestampMs).filter(t => t > 0);
            
            if (videoStarts.length > 0) {
              referenceStartMs = Math.min(...videoStarts);
              fullEndMs = Math.max(...videoEnds, ...videoStarts.map((s, i) => s + (loadedVideos[i].durationSec || 1800) * 1000));
              console.log('Using video-based timeline: refStart=', referenceStartMs, 'fullEnd=', fullEndMs);
            } else {
              console.log('No valid video timestamps found');
              return; // Can't render without valid timestamps
            }
          }
          
          // Use FULL timeline range (not trimmed) to match playback slider
          const fullRangeMs = fullEndMs - referenceStartMs;
          const fullRangeMin = fullRangeMs / 60000;
          
          console.log('renderVideoTimelineMarkers: referenceStartMs=', referenceStartMs, 'fullEndMs=', fullEndMs, 'fullRangeMin=', fullRangeMin);
          
          if (fullRangeMin > 0) {
            loadedVideos.forEach((v) => {
              const videoStartMin = (v.startTimestampMs - referenceStartMs) / 60000;
              const videoEndMin = (v.endTimestampMs - referenceStartMs) / 60000;
              
              // Calculate percentage of FULL timeline
              const startPct = Math.max(0, Math.min(100, (videoStartMin / fullRangeMin) * 100));
              const endPct = Math.max(0, Math.min(100, (videoEndMin / fullRangeMin) * 100));
              const widthPct = endPct - startPct;
              
              console.log('Video:', v.filename, 'startTimestampMs=', v.startTimestampMs, 'endTimestampMs=', v.endTimestampMs, 'durationSec=', v.durationSec);
              console.log('  videoStartMin=', videoStartMin.toFixed(2), 'videoEndMin=', videoEndMin.toFixed(2), 'startPct=', startPct.toFixed(1), 'endPct=', endPct.toFixed(1), 'widthPct=', widthPct.toFixed(1));
              
              if (widthPct > 0.1) {  // Only render if visible (> 0.1%)
                const segment = document.createElement('div');
                segment.className = 'video-coverage-segment';
                segment.style.left = `${startPct}%`;
                segment.style.width = `${widthPct}%`;
                segment.title = v.filename;
                coverageBar.appendChild(segment);
              }
            });
          }
        }
      }
    }
    
    // Only called on manual scrub (click, drag, keyboard)
    function syncVideosToPlayback(forceSeek = false) {
      // Check if we need to switch videos
      const targetVideo = getCurrentOrNextVideo();
      if (targetVideo !== currentActiveVideo) {
        updateActiveVideoDisplay();
        return;
      }
      
      if (!currentActiveVideo) return;
      
      const referenceStartMs = getFullStartTimeMs();
      const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
      const videoTimeMs = currentAbsoluteMs - currentActiveVideo.startTimestampMs;
      const videoTimeSec = videoTimeMs / 1000;
      
      // Use actual duration if loaded, otherwise assume reasonable max (1 hour)
      const effectiveDuration = currentActiveVideo.durationSec > 0 
        ? currentActiveVideo.durationSec 
        : (currentActiveVideo.is360Video && current360Player ? current360Player.duration : 60 * 60);
      
      // For INSV player, always set target time for wall-clock alignment tracking
      if (currentActiveVideo.is360Video && current360Player && current360Player.setTargetTime) {
        if (videoTimeSec >= 0 && videoTimeSec <= effectiveDuration) {
          current360Player.setTargetTime(videoTimeSec);
        }
      }
      
      // Only seek on manual scrub
      if (forceSeek) {
        if (videoTimeSec >= 0 && videoTimeSec <= effectiveDuration) {
          if (currentActiveVideo.is360Video && current360Player) {
            current360Player.seek(videoTimeSec);
            // Force texture update after seek to ensure frame is visible
            if (current360Player.forceRedrawToAllCanvases) {
              setTimeout(() => {
                if (current360Player && current360Player.forceRedrawToAllCanvases) {
                  current360Player.forceRedrawToAllCanvases('combined');
                }
              }, 50);
            }
            // If we're supposed to be playing, ensure 360 video resumes after seek
            // Schedule this check for after seek completes
            if (isPlaying) {
              setTimeout(() => {
                if (isPlaying && current360Player && !current360Player.playing) {
                  console.log('syncVideosToPlayback: restarting 360 playback after seek');
                  play360Video();
                }
              }, 100);
            }
          } else {
            currentActiveVideo.element.currentTime = videoTimeSec;
            // If we're supposed to be playing, make sure video is playing
            if (isPlaying && currentActiveVideo.element.paused) {
              currentActiveVideo.element.playbackRate = Math.min(playbackSpeed, 16);
              currentActiveVideo.element.muted = playbackSpeed > 2;
              currentActiveVideo.element.play().catch(() => {});
            }
          }
        } else if (videoTimeSec < 0) {
          if (currentActiveVideo.is360Video && current360Player) {
            current360Player.seek(0);
            current360Player.pause();
          } else {
            currentActiveVideo.element.currentTime = 0;
            currentActiveVideo.element.pause();
          }
        } else {
          // Past end
          if (currentActiveVideo.is360Video && current360Player) {
            current360Player.pause();
          } else {
            currentActiveVideo.element.pause();
          }
        }
      }
      
      updateVideoOverlays();
    }
    
    function formatVideoTime(totalSeconds) {
      const mins = Math.floor(Math.abs(totalSeconds) / 60);
      const secs = Math.floor(Math.abs(totalSeconds) % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    function formatVideoDateTime(timestampMs) {
      const date = new Date(timestampMs);
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const day = date.getDate().toString().padStart(2, '0');
      const month = months[date.getMonth()];
      const year = date.getFullYear();
      const hours = date.getHours().toString().padStart(2, '0');
      const mins = date.getMinutes().toString().padStart(2, '0');
      const secs = date.getSeconds().toString().padStart(2, '0');
      return `${day}-${month}-${year} ${hours}:${mins}:${secs}`;
    }
    
    // Widget state management
    const widgetState = {
      'video-telemetry-overlay': { minimized: false, x: null, y: null, dragged: false },
      'video-leg-overlay': { minimized: false, x: null, y: null, dragged: false },
      'video-distance-overlay': { minimized: false, x: null, y: null, dragged: false },
      'video-minimap-overlay': { minimized: false, x: null, y: null, dragged: false }
    };
    
    // Widget scale (1.0 = default, range 0.5 to 2.0)
    let widgetScale = 1.0;
    const WIDGET_SCALE_MIN = 0.5;
    const WIDGET_SCALE_MAX = 2.0;
    const WIDGET_SCALE_STEP = 0.1;
    
    function increaseWidgetScale() {
      widgetScale = Math.min(WIDGET_SCALE_MAX, widgetScale + WIDGET_SCALE_STEP);
      applyWidgetScale();
    }
    
    function decreaseWidgetScale() {
      widgetScale = Math.max(WIDGET_SCALE_MIN, widgetScale - WIDGET_SCALE_STEP);
      applyWidgetScale();
    }
    
    function applyWidgetScale() {
      const widgets = document.querySelectorAll('.fs-widget');
      widgets.forEach(widget => {
        const widgetId = widget.id;
        const state = widgetState[widgetId];
        
        // Set transform origin based on widget position
        // For dragged widgets, use top-left since we position with top/left
        // For non-dragged widgets, use their corner position
        if (state && state.dragged) {
          widget.style.transformOrigin = 'top left';
        } else if (widgetId === 'video-telemetry-overlay') {
          widget.style.transformOrigin = 'top right';
        } else if (widgetId === 'video-leg-overlay') {
          widget.style.transformOrigin = 'bottom right';
        } else if (widgetId === 'video-minimap-overlay') {
          widget.style.transformOrigin = 'bottom left';
        } else if (widgetId === 'video-distance-overlay') {
          widget.style.transformOrigin = 'bottom center';
        }
        
        // Apply scale (or clear if default)
        if (widgetScale === 1.0) {
          // For dragged widgets, keep transform: none; for others, clear
          if (state && state.dragged) {
            widget.style.transform = 'none';
          } else if (widgetId === 'video-distance-overlay' && !widget.classList.contains('dragged')) {
            widget.style.transform = 'translateX(-50%)';
          } else {
            widget.style.transform = '';
          }
        } else {
          // Apply scale
          if (widgetId === 'video-distance-overlay' && !state?.dragged) {
            widget.style.transform = `translateX(-50%) scale(${widgetScale})`;
          } else {
            widget.style.transform = `scale(${widgetScale})`;
          }
        }
      });
      
      // CSS transform handles visual scaling - no need to re-render minimap
    }
    
    let draggedWidget = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    
    function toggleWidgetMinimize(widgetId) {
      const widget = document.getElementById(widgetId);
      if (!widget) return;
      
      widgetState[widgetId].minimized = !widgetState[widgetId].minimized;
      widget.classList.toggle('minimized', widgetState[widgetId].minimized);
      
      // Update button symbol (‚ñ≤ when minimized = click to show, ‚ñº when expanded = click to hide)
      const btn = widget.querySelector('.fs-minimize-btn');
      if (btn) {
        btn.textContent = widgetState[widgetId].minimized ? '‚ñ≤' : '‚ñº';
      }
    }
    
    function initWidgetDragging() {
      const widgets = document.querySelectorAll('.fs-widget');
      widgets.forEach(widget => {
        const header = widget.querySelector('.fs-widget-header');
        if (!header) return;
        
        // Remove existing listeners to avoid duplicates
        const newHeader = header.cloneNode(true);
        header.parentNode.replaceChild(newHeader, header);
        
        let dragStartTime = 0;
        let dragStartX = 0;
        let dragStartY = 0;
        
        newHeader.addEventListener('mousedown', (e) => {
          if (!(document.fullscreenElement || document.webkitFullscreenElement)) return;
          
          dragStartTime = Date.now();
          dragStartX = e.clientX;
          dragStartY = e.clientY;
          
          e.preventDefault();
          draggedWidget = widget;
          
          const rect = widget.getBoundingClientRect();
          dragOffsetX = e.clientX - rect.left;
          dragOffsetY = e.clientY - rect.top;
          
          widget.style.transition = 'none';
          // Set transform origin to top-left for dragged widgets
          widget.style.transformOrigin = 'top left';
        });
        
        // Touch events for mobile widget dragging
        newHeader.addEventListener('touchstart', (e) => {
          if (!(document.fullscreenElement || document.webkitFullscreenElement)) return;
          
          const touch = e.touches[0];
          if (!touch) return;
          
          dragStartTime = Date.now();
          dragStartX = touch.clientX;
          dragStartY = touch.clientY;
          
          e.preventDefault();
          draggedWidget = widget;
          
          const rect = widget.getBoundingClientRect();
          dragOffsetX = touch.clientX - rect.left;
          dragOffsetY = touch.clientY - rect.top;
          
          widget.style.transition = 'none';
          // Set transform origin to top-left for dragged widgets
          widget.style.transformOrigin = 'top left';
        }, { passive: false });
        
        newHeader.addEventListener('touchend', (e) => {
          // Only toggle if it was a tap (not a drag)
          const touch = e.changedTouches[0];
          if (!touch) return;
          
          const dragDuration = Date.now() - dragStartTime;
          const dragDistance = Math.sqrt(Math.pow(touch.clientX - dragStartX, 2) + Math.pow(touch.clientY - dragStartY, 2));
          
          if (dragDuration < 200 && dragDistance < 10) {
            toggleWidgetMinimize(widget.id);
          }
          
          if (draggedWidget) {
            draggedWidget.style.transition = '';
            draggedWidget = null;
          }
        });
        
        newHeader.addEventListener('click', (e) => {
          // Only toggle if it was a click (not a drag)
          const dragDuration = Date.now() - dragStartTime;
          const dragDistance = Math.sqrt(Math.pow(e.clientX - dragStartX, 2) + Math.pow(e.clientY - dragStartY, 2));
          
          if (dragDuration < 200 && dragDistance < 5) {
            toggleWidgetMinimize(widget.id);
          }
        });
      });
      
      // Only add document-level listeners once
      if (!window._widgetDragListenersAdded) {
        window._widgetDragListenersAdded = true;
        
        document.addEventListener('mousemove', (e) => {
          if (!draggedWidget) return;
          
          const x = e.clientX - dragOffsetX;
          const y = e.clientY - dragOffsetY;
          
          // Add dragged class to override CSS default positions
          draggedWidget.classList.add('dragged');
          
          // Set new position
          draggedWidget.style.top = y + 'px';
          draggedWidget.style.left = x + 'px';
          draggedWidget.style.bottom = 'auto';
          draggedWidget.style.right = 'auto';
          
          // Use top-left origin for dragged widgets and preserve scale
          draggedWidget.style.transformOrigin = 'top left';
          if (widgetScale !== 1.0) {
            draggedWidget.style.transform = `scale(${widgetScale})`;
          } else {
            draggedWidget.style.transform = 'none';
          }
          
          // Save position and dragged state
          widgetState[draggedWidget.id] = widgetState[draggedWidget.id] || {};
          widgetState[draggedWidget.id].x = x;
          widgetState[draggedWidget.id].y = y;
          widgetState[draggedWidget.id].dragged = true;
        });
        
        document.addEventListener('mouseup', () => {
          if (draggedWidget) {
            draggedWidget.style.transition = '';
            draggedWidget = null;
          }
        });
        
        // Touch event handlers for mobile widget dragging
        document.addEventListener('touchmove', (e) => {
          if (!draggedWidget) return;
          
          const touch = e.touches[0];
          if (!touch) return;
          
          const x = touch.clientX - dragOffsetX;
          const y = touch.clientY - dragOffsetY;
          
          // Add dragged class to override CSS default positions
          draggedWidget.classList.add('dragged');
          
          // Set new position
          draggedWidget.style.top = y + 'px';
          draggedWidget.style.left = x + 'px';
          draggedWidget.style.bottom = 'auto';
          draggedWidget.style.right = 'auto';
          
          // Use top-left origin for dragged widgets and preserve scale
          draggedWidget.style.transformOrigin = 'top left';
          if (widgetScale !== 1.0) {
            draggedWidget.style.transform = `scale(${widgetScale})`;
          } else {
            draggedWidget.style.transform = 'none';
          }
          
          // Save position and dragged state
          widgetState[draggedWidget.id] = widgetState[draggedWidget.id] || {};
          widgetState[draggedWidget.id].x = x;
          widgetState[draggedWidget.id].y = y;
          widgetState[draggedWidget.id].dragged = true;
        }, { passive: true });
      }
    }
    
    function restoreWidgetPositions() {
      Object.keys(widgetState).forEach(widgetId => {
        const widget = document.getElementById(widgetId);
        const state = widgetState[widgetId];
        if (!widget || !state) return;
        
        if (state.dragged && state.x !== null && state.y !== null) {
          widget.classList.add('dragged');
          widget.style.top = state.y + 'px';
          widget.style.left = state.x + 'px';
          widget.style.bottom = 'auto';
          widget.style.right = 'auto';
          // Set transform origin to top-left for dragged widgets
          widget.style.transformOrigin = 'top left';
          // Preserve scale transform
          if (widgetScale !== 1.0) {
            widget.style.transform = `scale(${widgetScale})`;
          } else {
            widget.style.transform = 'none';
          }
        }
        
        widget.classList.toggle('minimized', state.minimized);
        
        // Update button symbol (‚ñ≤ when minimized, ‚ñº when expanded)
        const btn = widget.querySelector('.fs-minimize-btn');
        if (btn) {
          btn.textContent = state.minimized ? '‚ñ≤' : '‚ñº';
        }
      });
    }
    
    // Widget base sizes for scaling calculations
    const widgetBaseSizes = {
      'video-telemetry-overlay': { width: 180, height: 200, fontSize: 28 },
      'video-leg-overlay': { width: 180, height: 220, fontSize: 28 },
      'video-distance-overlay': { width: 320, height: 100, fontSize: 14 },
      'video-minimap-overlay': { width: 270, height: 200, fontSize: 14 }
    };
    
    let widgetResizeObserver = null;
    
    function initWidgetResizing() {
      // Disconnect existing observer
      if (widgetResizeObserver) {
        widgetResizeObserver.disconnect();
        widgetResizeObserver = null;
      }
      
      // Set up ResizeObserver for minimap to re-render SVG when resized
      const minimap = document.getElementById('video-minimap-overlay');
      if (minimap) {
        widgetResizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            if (entry.target.id === 'video-minimap-overlay') {
              // Save the new size to widget state
              const rect = entry.contentRect;
              widgetState['video-minimap-overlay'] = widgetState['video-minimap-overlay'] || {};
              widgetState['video-minimap-overlay'].width = rect.width;
              widgetState['video-minimap-overlay'].height = rect.height;
              
              // Scale leg2 telemetry font based on minimap height
              const leg2Panel = document.getElementById('minimap-leg2-telemetry');
              if (leg2Panel) {
                // Base font size 14px at height 200px, scale proportionally
                const scaleFactor = Math.max(0.7, Math.min(1.5, rect.height / 200));
                const fontSize = Math.round(14 * scaleFactor);
                const labelFontSize = Math.round(11 * scaleFactor);
                leg2Panel.style.fontSize = fontSize + 'px';
                const label = document.getElementById('telem-leg2-label');
                if (label) {
                  label.style.fontSize = labelFontSize + 'px';
                }
              }
              
              // Re-render minimap SVG with new dimensions
              renderVideoMinimap();
            }
          }
        });
        widgetResizeObserver.observe(minimap);
      }
    }
    
    function restoreWidgetSizes() {
      // Restore minimap size if it was resized
      const minimapState = widgetState['video-minimap-overlay'];
      const minimap = document.getElementById('video-minimap-overlay');
      if (minimap && minimapState && minimapState.width && minimapState.height) {
        minimap.style.width = minimapState.width + 'px';
        minimap.style.height = minimapState.height + 'px';
        
        // Also restore leg2 telemetry font size based on height
        const leg2Panel = document.getElementById('minimap-leg2-telemetry');
        if (leg2Panel) {
          const scaleFactor = Math.max(0.7, Math.min(1.5, minimapState.height / 200));
          const fontSize = Math.round(14 * scaleFactor);
          const labelFontSize = Math.round(11 * scaleFactor);
          leg2Panel.style.fontSize = fontSize + 'px';
          const label = document.getElementById('telem-leg2-label');
          if (label) {
            label.style.fontSize = labelFontSize + 'px';
          }
        }
      }
    }
    
    function clearWidgetInlineStyles() {
      // Clear inline styles that were set during fullscreen
      // In non-fullscreen mode, widgets should use default CSS positions
      Object.keys(widgetState).forEach(widgetId => {
        const widget = document.getElementById(widgetId);
        if (!widget) return;
        
        // Clear all inline position/size/transform styles
        widget.style.top = '';
        widget.style.left = '';
        widget.style.bottom = '';
        widget.style.right = '';
        widget.style.transform = '';
        widget.style.transformOrigin = '';
        widget.style.width = '';
        widget.style.height = '';
        
        // Remove classes - non-fullscreen uses CSS default positions
        widget.classList.remove('dragged', 'minimized');
        
        // Reset button symbol (‚ñº = expanded)
        const btn = widget.querySelector('.fs-minimize-btn');
        if (btn) {
          btn.textContent = '‚ñº';
        }
      });
      
      // Also clear leg2 telemetry font size
      const leg2Panel = document.getElementById('minimap-leg2-telemetry');
      if (leg2Panel) {
        leg2Panel.style.fontSize = '';
      }
      const leg2Label = document.getElementById('telem-leg2-label');
      if (leg2Label) {
        leg2Label.style.fontSize = '';
      }
    }
    
    // Change INSV video FPS
    function changeVideoFps(fpsValue) {
      const fps = parseFloat(fpsValue);
      if (current360Player && current360Player.setTargetFps) {
        current360Player.setTargetFps(fps);
        
        // Update selector to show current value
        const selector = document.getElementById('video-fps-selector');
        if (selector) {
          selector.value = fps.toString();
        }
        
        // Find closest matching level in quality ladder (keeping current texture quality)
        const currentTexture = current360Player.textureScale || 0.75;
        let bestMatch = 0;
        let bestDistance = Infinity;
        for (let i = 0; i < qualityLadder.length; i++) {
          const level = qualityLadder[i];
          // Calculate distance - prioritize FPS match, then texture
          const fpsDist = Math.abs(level.fps - fps) / 30;
          const texDist = Math.abs(level.texture - currentTexture);
          const distance = fpsDist * 2 + texDist;  // Weight FPS more since that's what changed
          if (distance < bestDistance) {
            bestDistance = distance;
            bestMatch = i;
          }
        }
        currentQualityLevel = bestMatch;
        currentQualityIndex = qualityLevels.indexOf(qualityLadder[currentQualityLevel].quality);
        console.log('FPS changed to', fps + ', quality ladder synced to level', currentQualityLevel, '(' + qualityLadder[currentQualityLevel].label + ')');
      }
    }
    
    // Change video render quality
    function changeVideoQuality(quality) {
      const qualitySettings = {
        'low': { render: 0.5, texture: 0.25 },
        'medium': { render: 0.75, texture: 0.5 },
        'high': { render: 1.0, texture: 0.75 },
        'ultra': { render: 1.0, texture: 1.0 }
      };
      
      const settings = qualitySettings[quality];
      if (!settings) {
        console.warn('Invalid quality:', quality);
        return;
      }
      
      console.log('Quality changed to:', quality, settings);
      
      // Update quality index for UI selector
      const idx = qualityLevels.indexOf(quality);
      if (idx >= 0) {
        currentQualityIndex = idx;
      }
      
      // Find closest matching level in quality ladder (keeping current FPS)
      const currentFps = current360Player ? current360Player.targetFps : 15;
      let bestMatch = 0;
      let bestDistance = Infinity;
      for (let i = 0; i < qualityLadder.length; i++) {
        const level = qualityLadder[i];
        if (level.quality === quality) {
          // Prefer levels with same quality, find closest FPS
          const fpsDist = Math.abs(level.fps - currentFps);
          if (fpsDist < bestDistance) {
            bestDistance = fpsDist;
            bestMatch = i;
          }
        }
      }
      currentQualityLevel = bestMatch;
      console.log('Quality ladder synced to level', currentQualityLevel, '(' + qualityLadder[currentQualityLevel].label + ')');
      
      // Update global settings for future video loads
      textureScale360 = settings.texture;
      renderQuality360 = settings.render;
      
      // Update texture scale (INSV player)
      if (current360Player && current360Player.setTextureScale) {
        current360Player.setTextureScale(settings.texture);
      }
      
      // Update render scale (Three.js)
      if (threeRenderer) {
        threeRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 1) * settings.render);
        console.log('Three.js pixel ratio updated:', threeRenderer.getPixelRatio());
      }
      
      // Update selector
      const selector = document.getElementById('video-quality-selector');
      if (selector) {
        selector.value = quality;
      }
    }
    
    // Sync timeline to video (video is wall-clock master)
    // This corrects drift between playbackTime (which advances independently) and video time
    function syncTimelineToVideo(videoTimeSec) {
      if (!currentActiveVideo) return;
      
      // Calculate what playbackTime should be based on video's currentTime
      const referenceStartMs = getFullStartTimeMs();
      const videoAbsoluteMs = currentActiveVideo.startTimestampMs + videoTimeSec * 1000;
      const newPlaybackTime = (videoAbsoluteMs - referenceStartMs) / 60000;
      
      // Calculate drift
      const diff = Math.abs(newPlaybackTime - playbackTime);
      const diffSeconds = diff * 60;
      
      // Only correct if drift exceeds threshold (0.3 seconds)
      // Small drifts are normal and don't need correction
      if (diff > 0.005) {  // 0.005 minutes = 0.3 seconds
        // Only log notable corrections (>0.5 second)
        if (diffSeconds > 0.5) {
          console.log('Syncing timeline to video: playbackTime', playbackTime.toFixed(3), '->', newPlaybackTime.toFixed(3), '(diff:', diffSeconds.toFixed(2) + 's)');
        }
        
        playbackTime = newPlaybackTime;
        
        // Only reset audio sync on LARGE jumps (>2 seconds) - indicates actual seek
        // Small drift corrections should NOT reset audio - audio has its own drift handling
        if (diffSeconds > 2.0 && current360Player && current360Player.audioScheduledUntil !== undefined) {
          console.log('Large timeline jump detected, resetting audio sync');
          current360Player.audioScheduledUntil = 0;
          current360Player.audioNextScheduleTime = 0;  // Force audio re-init
          current360Player.audioContextOffset = 0;   // Reset offset for recalculation
          current360Player.lastAudioSyncCheck = 0;   // Force immediate sync check
          current360Player.lastScheduledVideoTime = 0;  // Reset for audio sync detection
        }
      }
      
      // Update periodic sync tracking baseline
      if (current360Player && current360Player.lastReportedVideoTime !== undefined) {
        current360Player.lastReportedVideoTime = videoTimeSec;
      }
    }
    
    // Reduce video quality by one level (called when performance is poor)
    // Uses combined FPS+quality ladder for smooth degradation
    function reduceVideoQuality() {
      // Check if already at lowest level
      if (currentQualityLevel >= qualityLadder.length - 1) {
        console.log('Already at lowest quality level');
        showPerformanceNotification('At lowest settings');
        return;
      }
      
      // Move to next level in ladder
      currentQualityLevel++;
      const newLevel = qualityLadder[currentQualityLevel];
      
      console.log('Reducing to quality level', currentQualityLevel + ':', newLevel.label);
      
      // Apply FPS change
      if (current360Player && current360Player.setTargetFps) {
        current360Player.setTargetFps(newLevel.fps);
      }
      
      // Apply texture quality change
      textureScale360 = newLevel.texture;
      if (current360Player && current360Player.setTextureScale) {
        current360Player.setTextureScale(newLevel.texture);
      }
      
      // Update UI selectors to match
      const fpsSelector = document.getElementById('video-fps-selector');
      if (fpsSelector) {
        fpsSelector.value = newLevel.fps.toString();
      }
      
      const qualitySelector = document.getElementById('video-quality-selector');
      if (qualitySelector) {
        qualitySelector.value = newLevel.quality;
      }
      currentQualityIndex = qualityLevels.indexOf(newLevel.quality);
      
      showPerformanceNotification('Reducing ‚Üí ' + newLevel.label);
    }
    
    function increaseVideoQuality() {
      // Check if already at highest level
      if (currentQualityLevel <= 0) {
        console.log('Already at highest quality level');
        return;
      }
      
      // Move to previous (higher quality) level in ladder
      currentQualityLevel--;
      const newLevel = qualityLadder[currentQualityLevel];
      
      console.log('Increasing to quality level', currentQualityLevel + ':', newLevel.label);
      
      // Apply FPS change
      if (current360Player && current360Player.setTargetFps) {
        current360Player.setTargetFps(newLevel.fps);
      }
      
      // Apply texture quality change
      textureScale360 = newLevel.texture;
      if (current360Player && current360Player.setTextureScale) {
        current360Player.setTextureScale(newLevel.texture);
      }
      
      // Update UI selectors to match
      const fpsSelector = document.getElementById('video-fps-selector');
      if (fpsSelector) {
        fpsSelector.value = newLevel.fps.toString();
      }
      
      const qualitySelector = document.getElementById('video-quality-selector');
      if (qualitySelector) {
        qualitySelector.value = newLevel.quality;
      }
      currentQualityIndex = qualityLevels.indexOf(newLevel.quality);
      
      showPerformanceNotification('Improving ‚Üí ' + newLevel.label, 'green');
    }
    
    // Show performance notification for 5 seconds
    function showPerformanceNotification(message, color = 'red') {
      // Clear any existing notification timeout
      if (performanceNotificationTimeout) {
        clearTimeout(performanceNotificationTimeout);
      }
      
      // Get or create notification element
      let notification = document.getElementById('video-performance-notification');
      if (!notification) {
        const container = document.getElementById('video-overlays-container');
        if (!container) return;
        
        notification = document.createElement('div');
        notification.id = 'video-performance-notification';
        notification.style.cssText = 'position:absolute;bottom:50px;left:50%;transform:translateX(-50%);color:white;padding:4px 12px;border-radius:4px;font-size:11px;font-weight:500;z-index:200;pointer-events:none;text-align:center;opacity:0.85;';
        container.appendChild(notification);
      }
      
      // Set background color
      notification.style.background = color === 'green' ? 'rgba(34,197,94,0.9)' : 'rgba(239,68,68,0.9)';
      
      notification.textContent = message;
      notification.style.display = 'block';
      
      // Hide after 5 seconds
      performanceNotificationTimeout = setTimeout(() => {
        notification.style.display = 'none';
      }, 5000);
    }
    
    function showHotkeyHelp() {
      // Check if help popup already exists
      let helpPopup = document.getElementById('hotkey-help-popup');
      if (helpPopup) {
        helpPopup.remove();
        return;
      }
      
      // Create help popup
      helpPopup = document.createElement('div');
      helpPopup.id = 'hotkey-help-popup';
      helpPopup.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.92);color:white;padding:20px 28px;border-radius:12px;font-size:13px;z-index:10000;max-width:400px;box-shadow:0 8px 32px rgba(0,0,0,0.5);';
      
      helpPopup.innerHTML = `
        <div style="font-size:16px;font-weight:bold;margin-bottom:12px;border-bottom:1px solid #444;padding-bottom:8px;">Keyboard Shortcuts</div>
        <div style="display:grid;grid-template-columns:auto 1fr;gap:6px 16px;line-height:1.6;">
          <span style="color:#9ca3af;">Space</span><span>Play / Pause</span>
          <span style="color:#9ca3af;">F</span><span>Toggle fullscreen</span>
          <span style="color:#9ca3af;">‚Üê/‚Üí</span><span>Seek ¬±10 seconds</span>
          <span style="color:#9ca3af;">‚Üë/‚Üì</span><span>Seek ¬±1 second</span>
          <span style="color:#9ca3af;">1-8</span><span>Playback speed</span>
          <span style="color:#9ca3af;border-top:1px solid #333;padding-top:6px;">Q/W</span><span style="border-top:1px solid #333;padding-top:6px;">Tilt 1 (roll) ¬±0.5¬∞</span>
          <span style="color:#9ca3af;">A/S</span><span>Tilt 2 (pitch) ¬±0.5¬∞</span>
          <span style="color:#9ca3af;">0</span><span>Reset tilt corrections</span>
          <span style="color:#9ca3af;border-top:1px solid #333;padding-top:6px;">T</span><span style="border-top:1px solid #333;padding-top:6px;">Telemetry time offset</span>
          <span style="color:#9ca3af;">Z</span><span>Toggle quality widget</span>
          <span style="color:#9ca3af;">I</span><span>Show this help</span>
        </div>
        <div style="text-align:center;margin-top:14px;color:#666;font-size:11px;">Press I or click to close</div>
      `;
      
      // Close on click
      helpPopup.onclick = () => helpPopup.remove();
      
      getModalContainer().appendChild(helpPopup);
      
      // Auto-close after 10 seconds
      setTimeout(() => {
        if (document.getElementById('hotkey-help-popup')) {
          helpPopup.remove();
        }
      }, 10000);
    }
    
    function showTelemetryOffsetPopup() {
      // Check if popup already exists - if so, close it
      let popup = document.getElementById('telemetry-offset-popup');
      if (popup) {
        popup.remove();
        return;
      }
      
      // Create popup
      popup = document.createElement('div');
      popup.id = 'telemetry-offset-popup';
      popup.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.92);color:white;padding:20px 28px;border-radius:12px;font-size:13px;z-index:10000;min-width:280px;box-shadow:0 8px 32px rgba(0,0,0,0.5);';
      
      const updateDisplay = () => {
        const valueEl = popup.querySelector('#telem-offset-value');
        const descEl = popup.querySelector('#telem-offset-desc');
        if (valueEl) {
          const sign = telemetryOffsetSec >= 0 ? '+' : '';
          valueEl.textContent = `${sign}${telemetryOffsetSec.toFixed(1)}s`;
          valueEl.style.color = telemetryOffsetSec === 0 ? '#9ca3af' : (telemetryOffsetSec > 0 ? '#4ade80' : '#f87171');
        }
        if (descEl) {
          if (telemetryOffsetSec === 0) {
            descEl.textContent = 'No offset (synced)';
          } else if (telemetryOffsetSec > 0) {
            descEl.textContent = 'Telemetry shifted earlier';
          } else {
            descEl.textContent = 'Telemetry shifted later';
          }
        }
      };
      
      popup.innerHTML = `
        <div style="font-size:16px;font-weight:bold;margin-bottom:12px;border-bottom:1px solid #444;padding-bottom:8px;">Telemetry Time Offset</div>
        <div style="text-align:center;margin:16px 0;">
          <div id="telem-offset-value" style="font-size:32px;font-weight:bold;font-family:monospace;">+0.0s</div>
          <div id="telem-offset-desc" style="color:#9ca3af;font-size:11px;margin-top:4px;">No offset (synced)</div>
        </div>
        <div style="display:flex;justify-content:center;gap:8px;margin:16px 0;">
          <button id="telem-offset-minus1" style="background:#374151;border:none;color:white;padding:8px 16px;border-radius:6px;cursor:pointer;font-size:14px;">-1s</button>
          <button id="telem-offset-minus01" style="background:#374151;border:none;color:white;padding:8px 12px;border-radius:6px;cursor:pointer;font-size:14px;">-0.1s</button>
          <button id="telem-offset-reset" style="background:#4b5563;border:none;color:white;padding:8px 12px;border-radius:6px;cursor:pointer;font-size:14px;">Reset</button>
          <button id="telem-offset-plus01" style="background:#374151;border:none;color:white;padding:8px 12px;border-radius:6px;cursor:pointer;font-size:14px;">+0.1s</button>
          <button id="telem-offset-plus1" style="background:#374151;border:none;color:white;padding:8px 16px;border-radius:6px;cursor:pointer;font-size:14px;">+1s</button>
        </div>
        <div style="color:#6b7280;font-size:11px;text-align:center;margin-top:8px;">
          Use when video and telemetry are out of sync.<br>
          Positive = telemetry ahead, Negative = telemetry behind
        </div>
        <div style="text-align:center;margin-top:14px;color:#666;font-size:11px;">Press T or click outside to close</div>
      `;
      
      getModalContainer().appendChild(popup);
      updateDisplay();
      
      // Button handlers
      popup.querySelector('#telem-offset-minus1').onclick = (e) => {
        e.stopPropagation();
        telemetryOffsetSec = Math.max(-30, telemetryOffsetSec - 1);
        updateDisplay();
        updateVideoTelemetry();
      };
      popup.querySelector('#telem-offset-minus01').onclick = (e) => {
        e.stopPropagation();
        telemetryOffsetSec = Math.max(-30, Math.round((telemetryOffsetSec - 0.1) * 10) / 10);
        updateDisplay();
        updateVideoTelemetry();
      };
      popup.querySelector('#telem-offset-reset').onclick = (e) => {
        e.stopPropagation();
        telemetryOffsetSec = 0;
        updateDisplay();
        updateVideoTelemetry();
      };
      popup.querySelector('#telem-offset-plus01').onclick = (e) => {
        e.stopPropagation();
        telemetryOffsetSec = Math.min(30, Math.round((telemetryOffsetSec + 0.1) * 10) / 10);
        updateDisplay();
        updateVideoTelemetry();
      };
      popup.querySelector('#telem-offset-plus1').onclick = (e) => {
        e.stopPropagation();
        telemetryOffsetSec = Math.min(30, telemetryOffsetSec + 1);
        updateDisplay();
        updateVideoTelemetry();
      };
      
      // Close on click outside
      const closeHandler = (e) => {
        if (!popup.contains(e.target)) {
          popup.remove();
          document.removeEventListener('click', closeHandler);
        }
      };
      // Delay adding click handler to prevent immediate close
      setTimeout(() => {
        document.addEventListener('click', closeHandler);
      }, 100);
    }
    
    function toggleVideoFullscreen(event) {
      if (event) {
        event.stopPropagation();
      }
      const wrapper = document.getElementById('video-wrapper');
      if (!wrapper) return;
      
      if (document.fullscreenElement || document.webkitFullscreenElement) {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        }
      } else {
        // Copy race replay controls to fullscreen overlay with status bar
        const replaySection = document.getElementById('race-replay-section');
        const replayControls = document.getElementById('video-replay-controls');
        const timeText = document.getElementById('video-time-text');
        
        if (replaySection && replayControls) {
          // Build fullscreen controls with time above
          const statusHtml = `
            <div id="fullscreen-status-row" style="display:flex;justify-content:flex-end;align-items:center;padding:4px 16px;color:white;">
              <div id="fs-time-text" style="font-family:monospace;font-size:14px;">${timeText ? timeText.textContent : ''}</div>
            </div>
          `;
          replayControls.innerHTML = statusHtml + replaySection.innerHTML;
          replayControls.style.display = 'block';
          
          // Set initial status dot color based on current video state
          const fsStatusDot = replayControls.querySelector('.status-dot');
          if (fsStatusDot) {
            fsStatusDot.style.display = 'block';  // Force visible in fullscreen
            
            // Compute status directly from video state
            let dotColor = '#6b7280'; // gray - default/no video
            if (currentActiveVideo) {
              const referenceStartMs = getFullStartTimeMs();
              const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
              const videoTimeMs = currentAbsoluteMs - currentActiveVideo.startTimestampMs;
              const videoTimeSec = videoTimeMs / 1000;
              const effectiveDuration = currentActiveVideo.durationSec > 0 ? currentActiveVideo.durationSec : 60 * 60;
              
              if (currentActiveVideo.isWaiting && isPlaying) {
                dotColor = '#ef4444'; // red - LOADING
              } else if (videoTimeSec < 0 || videoTimeSec > effectiveDuration) {
                dotColor = '#6b7280'; // gray - Video not available
              } else {
                dotColor = '#22c55e'; // green - LIVE
              }
            }
            fsStatusDot.style.setProperty('background', dotColor, 'important');
          }
          
          // Re-attach timeline listeners for fullscreen
          const fsTimeline = replayControls.querySelector('.playback-timeline');
          const fsHandle = replayControls.querySelector('.playback-handle');
          const fsCoverageBar = replayControls.querySelector('.video-coverage-bar');
          if (fsTimeline) {
            fsTimeline.addEventListener('click', handleTimelineClick);
            if (fsHandle) {
              fsHandle.addEventListener('mousedown', handleTimelineDragStart);
            }
          }
          // Add click listener to fullscreen coverage bar
          if (fsCoverageBar) {
            fsCoverageBar.addEventListener('click', handleTimelineClick);
          }
          
          // Render video coverage in fullscreen - use FULL timeline (same as normal view)
          if (fsCoverageBar && loadedVideos.length > 0) {
            fsCoverageBar.innerHTML = '';
            let referenceStartMs = getFullStartTimeMs();
            let fullEndMs = getFullEndTimeMs();
            
            // If no telemetry data, use video timestamps
            if (referenceStartMs === 0 || referenceStartMs === Infinity || fullEndMs <= referenceStartMs) {
              const videoStarts = loadedVideos.map(v => v.startTimestampMs).filter(t => t > 0);
              const videoEnds = loadedVideos.map(v => v.endTimestampMs).filter(t => t > 0);
              if (videoStarts.length > 0) {
                referenceStartMs = Math.min(...videoStarts);
                fullEndMs = Math.max(...videoEnds, ...videoStarts.map((s, i) => s + (loadedVideos[i].durationSec || 1800) * 1000));
              }
            }
            
            const fullRangeMs = fullEndMs - referenceStartMs;
            const fullRangeMin = fullRangeMs / 60000;
            
            if (fullRangeMin > 0) {
              loadedVideos.forEach((v) => {
                const videoStartMin = (v.startTimestampMs - referenceStartMs) / 60000;
                const videoEndMin = (v.endTimestampMs - referenceStartMs) / 60000;
                
                const startPct = Math.max(0, Math.min(100, (videoStartMin / fullRangeMin) * 100));
                const endPct = Math.max(0, Math.min(100, (videoEndMin / fullRangeMin) * 100));
                const widthPct = endPct - startPct;
                
                if (widthPct > 0.1) {
                  const segment = document.createElement('div');
                  segment.className = 'video-coverage-segment';
                  segment.style.left = `${startPct}%`;
                  segment.style.width = `${widthPct}%`;
                  segment.title = v.filename;
                  fsCoverageBar.appendChild(segment);
                }
              });
            }
          }
        }
        // Request fullscreen with webkit fallback for iOS Safari
        if (wrapper.requestFullscreen) {
          wrapper.requestFullscreen().catch(err => {
            console.log('Fullscreen error:', err);
          });
        } else if (wrapper.webkitRequestFullscreen) {
          wrapper.webkitRequestFullscreen();
        } else if (wrapper.webkitEnterFullscreen) {
          wrapper.webkitEnterFullscreen();
        }
      }
    }
    
    // Helper function to check if in fullscreen (with webkit prefix support)
    function isInFullscreen() {
      return !!(document.fullscreenElement || document.webkitFullscreenElement);
    }
    
    // Get the right container for modals - in fullscreen, append to fullscreen element
    function getModalContainer() {
      if (isInFullscreen()) {
        const wrapper = document.getElementById('video-wrapper');
        if (wrapper) return wrapper;
      }
      return document.body;
    }
    
    // Fullscreen change handler
    function handleFullscreenChange() {
      const btn = document.getElementById('video-fullscreen-btn');
      const replayControls = document.getElementById('video-replay-controls');
      const wrapper = document.getElementById('video-wrapper');
      const inFullscreen = isInFullscreen();
      
      if (btn) {
        btn.textContent = inFullscreen ? '‚úï' : '‚õ∂';
      }
      if (replayControls && !inFullscreen) {
        replayControls.style.display = 'none';
      }
      if (inFullscreen) {
        // Focus on wrapper to capture keyboard events in fullscreen
        if (wrapper) {
          wrapper.setAttribute('tabindex', '-1');
          wrapper.focus();
        }
        // Init widget dragging, resizing and restore positions in fullscreen
        initWidgetDragging();
        initWidgetResizing();
        restoreWidgetPositions();
        restoreWidgetSizes();
        applyWidgetScale();
      } else {
        // Disconnect resize observer when exiting fullscreen
        if (widgetResizeObserver) {
          widgetResizeObserver.disconnect();
        }
        // Clear inline styles when exiting fullscreen so CSS works correctly next time
        clearWidgetInlineStyles();
      }
    }
    
    // Update fullscreen button icon based on state
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    
    // Update fullscreen status elements
    function updateFullscreenStatus() {
      const timeText = document.getElementById('video-time-text');
      const replayControls = document.getElementById('video-replay-controls');
      const fsTimeText = document.getElementById('fs-time-text');
      
      // Update status dot color in fullscreen controls based on video state
      if (replayControls) {
        const fsStatusDot = replayControls.querySelector('.status-dot');
        if (fsStatusDot) {
          fsStatusDot.style.display = 'block';  // Ensure visible
          
          // Compute status directly from video state
          let dotColor = '#6b7280'; // gray - default/no video
          if (currentActiveVideo) {
            const referenceStartMs = getFullStartTimeMs();
            const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
            const videoTimeMs = currentAbsoluteMs - currentActiveVideo.startTimestampMs;
            const videoTimeSec = videoTimeMs / 1000;
            const effectiveDuration = currentActiveVideo.durationSec > 0 ? currentActiveVideo.durationSec : 60 * 60;
            
            if (currentActiveVideo.isWaiting && isPlaying) {
              dotColor = '#ef4444'; // red - LOADING
            } else if (videoTimeSec < 0 || videoTimeSec > effectiveDuration) {
              dotColor = '#6b7280'; // gray - Video not available
            } else {
              dotColor = '#22c55e'; // green - LIVE
            }
          }
          fsStatusDot.style.setProperty('background', dotColor, 'important');
        }
      }
      if (fsTimeText && timeText) {
        fsTimeText.textContent = timeText.textContent;
      }
    }
    
    // Check if we need to switch to a different video
    function checkVideoSwitch() {
      const targetVideo = getCurrentOrNextVideo();
      if (targetVideo !== currentActiveVideo) {
        updateActiveVideoDisplay();
      }
    }
    
    async function playAllVideos() {
      if (!currentActiveVideo) return;
      
      const referenceStartMs = getFullStartTimeMs();
      const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
      const videoTimeMs = currentAbsoluteMs - currentActiveVideo.startTimestampMs;
      const videoTimeSec = videoTimeMs / 1000;
      const effectiveDuration = currentActiveVideo.durationSec > 0 ? currentActiveVideo.durationSec : 60 * 60;
      
      // Handle 360 videos
      if (currentActiveVideo.is360Video && current360Player) {
        if (videoTimeSec >= 0 && videoTimeSec < effectiveDuration) {
          // Set external target time for sync
          if (current360Player.setTargetTime) {
            current360Player.setTargetTime(videoTimeSec);
          }
          
          // Only seek if position differs significantly (> 0.5 seconds)
          // This allows instant resume when just pausing/playing without timeline changes
          const currentPlayerTime = current360Player.currentTime || 0;
          const timeDiff = Math.abs(videoTimeSec - currentPlayerTime);
          
          if (timeDiff > 0.5) {
            console.log('playAllVideos: seeking 360 video from', currentPlayerTime.toFixed(2), 'to', videoTimeSec.toFixed(2), '(diff:', timeDiff.toFixed(2) + 's)');
            await current360Player.seek(videoTimeSec);
          } else {
            console.log('playAllVideos: resuming 360 video at', currentPlayerTime.toFixed(2), '(target:', videoTimeSec.toFixed(2) + ', diff:', timeDiff.toFixed(2) + 's)');
          }
          
          current360Player.play();
        }
        return;
      }
      
      // Set playback rate and mute - disable pitch preservation for faster decoding
      currentActiveVideo.element.playbackRate = Math.min(playbackSpeed, 16);
      currentActiveVideo.element.muted = playbackSpeed > 2;
      currentActiveVideo.element.preservesPitch = false;
      
      // Only play if in range
      if (videoTimeSec >= 0 && videoTimeSec < effectiveDuration) {
        currentActiveVideo.element.currentTime = videoTimeSec;
        // Use play promise to catch and ignore autoplay errors
        const playPromise = currentActiveVideo.element.play();
        if (playPromise !== undefined) {
          playPromise.catch(() => {});
        }
      }
    }
    
    async function pauseAllVideos() {
      if (currentActiveVideo) {
        if (currentActiveVideo.is360Video && current360Player) {
          await current360Player.pause();
        } else {
          currentActiveVideo.element.pause();
        }
      }
    }
    
    function updateVideoPlaybackRate() {
      if (!currentActiveVideo) return;
      if (currentActiveVideo.is360Video && current360Player) {
        // LRV video - update muted state and playback rate
        const shouldMute = playbackSpeed > 2;
        if (current360Player.setMuted) {
          current360Player.setMuted(shouldMute);
        }
        // Get video element - either directly or via getter
        const videoEl = current360Player.video || (current360Player.getVideoElement ? current360Player.getVideoElement() : null);
        if (videoEl) {
          videoEl.playbackRate = Math.min(playbackSpeed, 16);
          videoEl.muted = shouldMute;
        }
      } else if (!currentActiveVideo.is360Video) {
        currentActiveVideo.element.muted = playbackSpeed > 2;
        currentActiveVideo.element.playbackRate = Math.min(playbackSpeed, 16);
        currentActiveVideo.element.preservesPitch = false;
      }
    }
    
    // ============ 360 VIDEO PLAYER ============
    
    // 360 video state
    let is360VideoActive = false;
    let current360Player = null;
    let currentOrientation360 = 'horizontal';
    let current360Format = 'insv'; // 'insv' for INSV, 'lrv' for LRV (swapped lenses), 'equirectangular' for stitched MP4
    let rollAngle360 = Math.PI / 2;
    let tiltCorrection360 = 0;  // Manual tilt correction in radians (roll axis)
    let tilt2Correction360 = 0;  // Second tilt correction in radians (perpendicular rotation)
    let viewMode360 = '360';
    let megaHFov = 200;  // Pannini horizontal FOV in degrees (160-300)
    let lon360 = 180, lat360 = 0;
    let isPointerDown360 = false;
    let startX360, startY360, startLon360, startLat360;
    
    // Saved view state for restoring when switching between videos on same timeline
    let savedViewState360 = {
      lon360: 180,
      lat360: 0,
      megaHFov: 200,
      viewMode360: '360',
      tiltCorrection360: 0,
      tilt2Correction360: 0,
      linearFov: 100
    };
    let hasUserViewState360 = false;  // Only restore after user has interacted or first video loaded
    
    // Quality settings for 360 video
    // renderQuality360: Three.js render resolution scale (0.5=low, 0.75=medium, 1.0=high)
    // textureScale360: Source texture resolution scale (0.25=low, 0.5=medium, 0.75=high, 1.0=ultra)
    let renderQuality360 = 1.0;
    let textureScale360 = 1.0;
    
    // Telemetry time offset for video sync correction (in seconds)
    // Positive = telemetry is ahead of video (shift telemetry earlier)
    // Negative = telemetry is behind video (shift telemetry later)
    let telemetryOffsetSec = 0;
    
    // Helper function to get telemetry-adjusted playback time (for display only)
    function getTelemetryDisplayTime() {
      return playbackTime + telemetryOffsetSec / 60;  // Convert seconds to minutes
    }
    
    // Performance-adaptive quality control - combined FPS + texture quality ladder
    // Each step reduces either FPS or quality (or both), balancing smoothness vs sharpness
    const qualityLadder = [
      { fps: 30, texture: 1.0,  quality: 'ultra',  label: '30fps Ultra' },   // 0 - Best quality
      { fps: 25, texture: 1.0,  quality: 'ultra',  label: '25fps Ultra' },   // 1
      { fps: 20, texture: 1.0,  quality: 'ultra',  label: '20fps Ultra' },   // 2 - Default
      { fps: 25, texture: 0.75, quality: 'high',   label: '25fps High' },    // 3
      { fps: 20, texture: 0.75, quality: 'high',   label: '20fps High' },    // 4
      { fps: 15, texture: 0.75, quality: 'high',   label: '15fps High' },    // 5
      { fps: 15, texture: 0.5,  quality: 'medium', label: '15fps Medium' },  // 6
      { fps: 10, texture: 0.5,  quality: 'medium', label: '10fps Medium' },  // 7
      { fps: 10, texture: 0.25, quality: 'low',    label: '10fps Low' },     // 8
      { fps: 7.5, texture: 0.25, quality: 'low',   label: '7.5fps Low' },    // 9 - Minimum
    ];
    const LARGE_VIDEO_DEFAULT_LEVEL = 2;  // 20fps Ultra for all videos
    let currentQualityLevel = 2;  // Start at 20fps Ultra
    
    // Legacy quality levels for UI selector compatibility
    const qualityLevels = ['ultra', 'high', 'medium', 'low'];
    let currentQualityIndex = 0;  // For UI selector
    let performanceNotificationTimeout = null;
    
    // Three.js objects
    let threeScene, threeCamera, threeRenderer, threeSphere, threeTexture;
    let orthoCamera, megaViewMesh, megaViewMaterial;
    
    // Shaders for dual-fisheye 360 rendering
    const vertexShader360 = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    
    const fragmentShader360 = `
      uniform sampler2D map;
      uniform float rollAngle;
      uniform float tilt2;
      varying vec2 vUv;
      #define PI 3.14159265359
      
      void main() {
        float longitude = vUv.x * 2.0 * PI - PI;
        float latitude = vUv.y * PI - PI * 0.5;
        
        vec3 dir = vec3(cos(latitude) * sin(longitude), sin(latitude), cos(latitude) * cos(longitude));
        
        // Apply tilt 2 FIRST (pitch correction around X axis)
        float ch = cos(tilt2);
        float sh = sin(tilt2);
        dir = vec3(dir.x, ch * dir.y - sh * dir.z, sh * dir.y + ch * dir.z);
        
        // Then apply roll rotation (tilt 1)
        float c = cos(rollAngle);
        float s = sin(rollAngle);
        dir = vec3(c * dir.x - s * dir.y, s * dir.x + c * dir.y, dir.z);
        
        vec2 uv;
        float theta, r, phi;
        vec2 radius = vec2(0.245, 0.49);
        
        if (dir.z >= 0.0) {
          theta = acos(dir.z);
          r = theta / (PI * 0.52);
          // Avoid atan(0,0) singularity at lens center
          if (r < 0.0001) {
            uv = vec2(0.25, 0.5);
          } else {
            phi = atan(dir.y, dir.x);
            uv = vec2(0.25, 0.5) + vec2(cos(phi), sin(phi)) * r * radius;
          }
        } else {
          theta = acos(-dir.z);
          r = theta / (PI * 0.52);
          // Avoid atan(0,0) singularity at lens center
          if (r < 0.0001) {
            uv = vec2(0.75, 0.5);
          } else {
            phi = atan(dir.y, -dir.x);
            uv = vec2(0.75, 0.5) + vec2(cos(phi), sin(phi)) * r * radius;
          }
        }
        
        gl_FragColor = texture2D(map, uv);
      }
    `;
    
    // Dual-fisheye shader for LRV files
    // Use same logic as INSV but flip UV.x and UV.y to correct orientation
    const fragmentShader360_LRV = `
      uniform sampler2D map;
      uniform float rollAngle;
      uniform float tilt2;
      varying vec2 vUv;
      #define PI 3.14159265359
      
      void main() {
        float longitude = vUv.x * 2.0 * PI - PI;
        float latitude = vUv.y * PI - PI * 0.5;
        
        vec3 dir = vec3(cos(latitude) * sin(longitude), sin(latitude), cos(latitude) * cos(longitude));
        
        // Apply tilt 2 FIRST (pitch correction around X axis)
        float ch = cos(tilt2);
        float sh = sin(tilt2);
        dir = vec3(dir.x, ch * dir.y - sh * dir.z, sh * dir.y + ch * dir.z);
        
        // Then apply roll rotation (tilt 1)
        float c = cos(rollAngle);
        float s = sin(rollAngle);
        dir = vec3(c * dir.x - s * dir.y, s * dir.x + c * dir.y, dir.z);
        
        vec2 uv;
        float theta, r, phi;
        vec2 radius = vec2(0.245, 0.49);
        
        // Same as INSV: front on LEFT (0.25), back on RIGHT (0.75)
        if (dir.z >= 0.0) {
          theta = acos(dir.z);
          r = theta / (PI * 0.52);
          // Avoid atan(0,0) singularity at lens center
          if (r < 0.0001) {
            uv = vec2(0.25, 0.5);
          } else {
            phi = atan(dir.y, dir.x);
            uv = vec2(0.25, 0.5) + vec2(cos(phi), sin(phi)) * r * radius;
          }
        } else {
          theta = acos(-dir.z);
          r = theta / (PI * 0.52);
          // Avoid atan(0,0) singularity at lens center
          if (r < 0.0001) {
            uv = vec2(0.75, 0.5);
          } else {
            phi = atan(dir.y, -dir.x);
            uv = vec2(0.75, 0.5) + vec2(cos(phi), sin(phi)) * r * radius;
          }
        }
        
        // Flip both axes to correct LRV orientation
        uv.x = 1.0 - uv.x;
        uv.y = 1.0 - uv.y;
        
        gl_FragColor = texture2D(map, uv);
      }
    `;
    
    // MegaView shader for LRV files - same as INSV but with UV.x and UV.y flip
    // ========== FISHEYE CYLINDRICAL MEGA VIEW SHADERS ==========
    // Creates a "behind the boat" wrap-around fisheye effect
    // Supports 160-300¬∞ horizontal FOV with curved boat hull at bottom
    
    const megaViewFragmentShader_LRV = `
      uniform sampler2D map;
      uniform float rollAngle;
      uniform float tilt2;
      uniform float yaw;
      uniform float pitch;
      uniform float hFov;      // Horizontal FOV in radians (160-300¬∞)
      uniform float panniniD;  // Vertical compression at edges (0.0-1.5)
      uniform float aspect;
      varying vec2 vUv;
      #define PI 3.14159265359
      
      vec4 sampleDualFisheye_LRV(vec3 dir) {
        vec2 uv;
        float theta, r, phi;
        vec2 radius = vec2(0.245, 0.49);
        
        if (dir.z >= 0.0) {
          theta = acos(clamp(dir.z, -1.0, 1.0));
          r = theta / (PI * 0.52);
          // Avoid atan(0,0) singularity at lens center
          if (r < 0.0001) {
            uv = vec2(0.25, 0.5);
          } else {
            phi = atan(dir.y, dir.x);
            uv = vec2(0.25, 0.5) + vec2(cos(phi), sin(phi)) * r * radius;
          }
        } else {
          theta = acos(clamp(-dir.z, -1.0, 1.0));
          r = theta / (PI * 0.52);
          // Avoid atan(0,0) singularity at lens center
          if (r < 0.0001) {
            uv = vec2(0.75, 0.5);
          } else {
            phi = atan(dir.y, -dir.x);
            uv = vec2(0.75, 0.5) + vec2(cos(phi), sin(phi)) * r * radius;
          }
        }
        
        uv.x = 1.0 - uv.x;
        uv.y = 1.0 - uv.y;
        
        return texture2D(map, uv);
      }
      
      void main() {
        vec2 screenPos = vUv * 2.0 - 1.0;
        
        float halfHFov = hFov * 0.5;
        float vFov = hFov / aspect * 0.5;
        
        // Horizontal: pure cylindrical
        float theta = screenPos.x * halfHFov;
        
        // Vertical: reduce FOV at edges to compensate for cylindrical stretching
        // At 260¬∞ FOV, edges are at ¬±130¬∞ where cos(theta) goes negative
        // causing extreme distortion. Reduce vertical range smoothly at edges.
        float absX = abs(screenPos.x);
        float edgeCompensation = 1.0 / (1.0 + panniniD * absX * absX);
        float phi = screenPos.y * vFov * edgeCompensation;
        
        // Build ray from cylindrical coordinates
        vec3 ray;
        ray.x = sin(theta);
        ray.y = sin(phi);
        ray.z = cos(theta) * cos(phi);
        ray = normalize(ray);
        
        // Apply view direction (pitch then yaw)
        float cp = cos(pitch);
        float sp = sin(pitch);
        ray = vec3(ray.x, cp * ray.y - sp * ray.z, sp * ray.y + cp * ray.z);
        
        float cy = cos(yaw);
        float sy = sin(yaw);
        ray = vec3(cy * ray.x + sy * ray.z, ray.y, -sy * ray.x + cy * ray.z);
        
        // Camera corrections: apply tilt2 FIRST, then roll
        float ch = cos(tilt2);
        float sh = sin(tilt2);
        ray = vec3(ray.x, ch * ray.y - sh * ray.z, sh * ray.y + ch * ray.z);
        
        float cr = cos(rollAngle);
        float sr = sin(rollAngle);
        ray = vec3(cr * ray.x - sr * ray.y, sr * ray.x + cr * ray.y, ray.z);
        
        // Sample from dual-fisheye texture
        gl_FragColor = sampleDualFisheye_LRV(ray);
      }
    `;
    
    // Equirectangular shader for stitched 360 videos (Insta360 MP4, LRV files)
    // Much simpler than dual fisheye - just longitude/latitude to UV mapping
    const fragmentShader360_Equirect = `
      uniform sampler2D map;
      uniform float rollAngle;
      uniform float tilt2;
      uniform float uOffset;  // Horizontal offset to adjust seam position
      varying vec2 vUv;
      #define PI 3.14159265359
      
      void main() {
        // Convert UV to spherical direction
        float longitude = vUv.x * 2.0 * PI - PI;
        float latitude = vUv.y * PI - PI * 0.5;
        
        // Create direction vector
        vec3 dir = vec3(
          cos(latitude) * sin(longitude),
          sin(latitude),
          cos(latitude) * cos(longitude)
        );
        
        // Apply tilt 2 FIRST (pitch correction around X axis)
        float ch = cos(tilt2);
        float sh = sin(tilt2);
        dir = vec3(dir.x, ch * dir.y - sh * dir.z, sh * dir.y + ch * dir.z);
        
        // Then apply roll rotation (tilt 1)
        float c = cos(rollAngle);
        float s = sin(rollAngle);
        dir = vec3(c * dir.x - s * dir.y, s * dir.x + c * dir.y, dir.z);
        
        // Convert back to equirectangular UV
        float lon = atan(dir.x, dir.z);
        float lat = asin(clamp(dir.y, -1.0, 1.0));
        
        // Map to UV coordinates with horizontal offset
        vec2 uv;
        uv.x = fract((lon / (2.0 * PI)) + 0.5 + uOffset);
        uv.y = (lat / PI) + 0.5;
        
        gl_FragColor = texture2D(map, uv);
      }
    `;
    
    const megaViewVertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position.xy, 0.0, 1.0);
      }
    `;
    
    // Pannini MEGA view for INSV dual-fisheye
    const megaViewFragmentShader = `
      uniform sampler2D map;
      uniform float rollAngle;
      uniform float tilt2;
      uniform float yaw;
      uniform float pitch;
      uniform float hFov;      // Horizontal FOV in radians (160-300¬∞)
      uniform float panniniD;  // Vertical compression at edges (0.0-1.5)
      uniform float aspect;
      varying vec2 vUv;
      #define PI 3.14159265359
      
      vec4 sampleDualFisheye(vec3 dir) {
        vec2 uv;
        float theta, r, phi;
        vec2 radius = vec2(0.245, 0.49);
        
        if (dir.z >= 0.0) {
          theta = acos(clamp(dir.z, -1.0, 1.0));
          r = theta / (PI * 0.52);
          // Avoid atan(0,0) singularity at lens center
          if (r < 0.0001) {
            uv = vec2(0.25, 0.5);
          } else {
            phi = atan(dir.y, dir.x);
            uv = vec2(0.25, 0.5) + vec2(cos(phi), sin(phi)) * r * radius;
          }
        } else {
          theta = acos(clamp(-dir.z, -1.0, 1.0));
          r = theta / (PI * 0.52);
          // Avoid atan(0,0) singularity at lens center
          if (r < 0.0001) {
            uv = vec2(0.75, 0.5);
          } else {
            phi = atan(dir.y, -dir.x);
            uv = vec2(0.75, 0.5) + vec2(cos(phi), sin(phi)) * r * radius;
          }
        }
        
        return texture2D(map, uv);
      }
      
      void main() {
        vec2 screenPos = vUv * 2.0 - 1.0;
        
        float halfHFov = hFov * 0.5;
        float vFov = hFov / aspect * 0.5;
        
        // Horizontal: pure cylindrical
        float theta = screenPos.x * halfHFov;
        
        // Vertical: reduce FOV at edges to compensate for cylindrical stretching
        float absX = abs(screenPos.x);
        float edgeCompensation = 1.0 / (1.0 + panniniD * absX * absX);
        float phi = screenPos.y * vFov * edgeCompensation;
        
        // Build ray from cylindrical coordinates
        vec3 ray;
        ray.x = sin(theta);
        ray.y = sin(phi);
        ray.z = cos(theta) * cos(phi);
        ray = normalize(ray);
        
        // Apply view direction (pitch then yaw)
        float cp = cos(pitch);
        float sp = sin(pitch);
        ray = vec3(ray.x, cp * ray.y - sp * ray.z, sp * ray.y + cp * ray.z);
        
        float cy = cos(yaw);
        float sy = sin(yaw);
        ray = vec3(cy * ray.x + sy * ray.z, ray.y, -sy * ray.x + cy * ray.z);
        
        // Camera corrections: apply tilt2 FIRST, then roll
        float ch = cos(tilt2);
        float sh = sin(tilt2);
        ray = vec3(ray.x, ch * ray.y - sh * ray.z, sh * ray.y + ch * ray.z);
        
        float cr = cos(rollAngle);
        float sr = sin(rollAngle);
        ray = vec3(cr * ray.x - sr * ray.y, sr * ray.x + cr * ray.y, ray.z);
        
        // Sample from dual-fisheye texture
        gl_FragColor = sampleDualFisheye(ray);
      }
    `;
    
    // Pannini MEGA view for equirectangular videos - Edge-aware vertical scaling
    const megaViewFragmentShader_Equirect = `
      uniform sampler2D map;
      uniform float rollAngle;
      uniform float tilt2;
      uniform float yaw;
      uniform float pitch;
      uniform float hFov;      // Horizontal FOV in radians
      uniform float panniniD;  // Vertical compression at edges (0.0-0.6)
      uniform float aspect;
      uniform float uOffset;
      varying vec2 vUv;
      #define PI 3.14159265359
      
      void main() {
        vec2 screenPos = vUv * 2.0 - 1.0;
        
        float halfHFov = hFov * 0.5;
        float vFov = hFov / aspect * 0.5;
        
        // Horizontal: pure cylindrical
        float theta = screenPos.x * halfHFov;
        
        // Vertical: reduce FOV at edges to compensate for cylindrical stretching
        // At 260¬∞ FOV, edges are at ¬±130¬∞ where cos(theta) goes negative
        // causing extreme distortion. Reduce vertical range smoothly at edges.
        float absX = abs(screenPos.x);
        float edgeCompensation = 1.0 / (1.0 + panniniD * absX * absX);
        float phi = screenPos.y * vFov * edgeCompensation;
        
        // Build ray from cylindrical coordinates
        vec3 ray;
        ray.x = sin(theta);
        ray.y = sin(phi);
        ray.z = cos(theta) * cos(phi);
        ray = normalize(ray);
        
        // Apply view direction (pitch then yaw)
        float cp = cos(pitch);
        float sp = sin(pitch);
        ray = vec3(ray.x, cp * ray.y - sp * ray.z, sp * ray.y + cp * ray.z);
        
        float cy = cos(yaw);
        float sy = sin(yaw);
        ray = vec3(cy * ray.x + sy * ray.z, ray.y, -sy * ray.x + cy * ray.z);
        
        // Camera corrections: apply tilt2 FIRST, then roll
        float ch = cos(tilt2);
        float sh = sin(tilt2);
        ray = vec3(ray.x, ch * ray.y - sh * ray.z, sh * ray.y + ch * ray.z);
        
        float cr = cos(rollAngle);
        float sr = sin(rollAngle);
        ray = vec3(cr * ray.x - sr * ray.y, sr * ray.x + cr * ray.y, ray.z);
        
        // Convert to equirectangular UV
        float lon = atan(ray.x, ray.z);
        float lat = asin(clamp(ray.y, -1.0, 1.0));
        
        vec2 uv;
        uv.x = fract((lon / (2.0 * PI)) + 0.5 + uOffset);
        uv.y = (lat / PI) + 0.5;
        
        gl_FragColor = texture2D(map, uv);
      }
    `;
    
    // === DUAL-TEXTURE SHADER VARIANTS FOR SINGLE-LENS OPTIMIZATION ===
    
    // Dual-texture shader: samples from separate front/back lens textures
    const fragmentShader360_DualTexture = `
      uniform sampler2D frontMap;
      uniform sampler2D backMap;
      uniform float rollAngle;
      uniform float tilt2;
      varying vec2 vUv;
      #define PI 3.14159265359
      
      void main() {
        float longitude = vUv.x * 2.0 * PI - PI;
        float latitude = vUv.y * PI - PI * 0.5;
        
        vec3 dir = vec3(cos(latitude) * sin(longitude), sin(latitude), cos(latitude) * cos(longitude));
        
        // Apply tilt 2 FIRST (pitch correction around X axis)
        float ch = cos(tilt2);
        float sh = sin(tilt2);
        dir = vec3(dir.x, ch * dir.y - sh * dir.z, sh * dir.y + ch * dir.z);
        
        // Then apply roll rotation (tilt 1)
        float c = cos(rollAngle);
        float s = sin(rollAngle);
        dir = vec3(c * dir.x - s * dir.y, s * dir.x + c * dir.y, dir.z);
        
        vec2 uv;
        float theta, r, phi;
        
        // Square canvas: equal radius in X and Y (0.49 to leave small margin)
        vec2 radius = vec2(0.49, 0.49);
        
        if (dir.z >= 0.0) {
          // Front lens
          theta = acos(dir.z);
          r = theta / (PI * 0.52);
          if (r < 0.0001) {
            uv = vec2(0.5, 0.5);
          } else {
            phi = atan(dir.y, dir.x);
            uv = vec2(0.5, 0.5) + vec2(cos(phi), sin(phi)) * r * radius;
          }
          gl_FragColor = texture2D(frontMap, uv);
        } else {
          // Back lens
          theta = acos(-dir.z);
          r = theta / (PI * 0.52);
          if (r < 0.0001) {
            uv = vec2(0.5, 0.5);
          } else {
            phi = atan(dir.y, -dir.x);
            uv = vec2(0.5, 0.5) + vec2(cos(phi), sin(phi)) * r * radius;
          }
          gl_FragColor = texture2D(backMap, uv);
        }
      }
    `;
    
    // Front lens only shader (no branch - optimized for single-lens viewing)
    const fragmentShader360_FrontOnly = `
      uniform sampler2D frontMap;
      uniform float rollAngle;
      uniform float tilt2;
      varying vec2 vUv;
      #define PI 3.14159265359
      
      void main() {
        float longitude = vUv.x * 2.0 * PI - PI;
        float latitude = vUv.y * PI - PI * 0.5;
        
        vec3 dir = vec3(cos(latitude) * sin(longitude), sin(latitude), cos(latitude) * cos(longitude));
        
        // Apply tilt 2 FIRST (pitch correction around X axis)
        float ch = cos(tilt2);
        float sh = sin(tilt2);
        dir = vec3(dir.x, ch * dir.y - sh * dir.z, sh * dir.y + ch * dir.z);
        
        // Then apply roll rotation (tilt 1)
        float c = cos(rollAngle);
        float s = sin(rollAngle);
        dir = vec3(c * dir.x - s * dir.y, s * dir.x + c * dir.y, dir.z);
        
        // Front lens only - for back-facing directions, show edge of front lens
        float theta = acos(clamp(dir.z, 0.0, 1.0));
        float r = theta / (PI * 0.52);
        
        // Square canvas: equal radius in X and Y (0.49 to leave small margin)
        vec2 radius = vec2(0.49, 0.49);
        vec2 uv;
        if (r < 0.0001) {
          uv = vec2(0.5, 0.5);
        } else {
          float phi = atan(dir.y, dir.x);
          uv = vec2(0.5, 0.5) + vec2(cos(phi), sin(phi)) * r * radius;
        }
        
        gl_FragColor = texture2D(frontMap, uv);
      }
    `;
    
    // Back lens only shader (no branch - optimized for single-lens viewing)
    const fragmentShader360_BackOnly = `
      uniform sampler2D backMap;
      uniform float rollAngle;
      uniform float tilt2;
      varying vec2 vUv;
      #define PI 3.14159265359
      
      void main() {
        float longitude = vUv.x * 2.0 * PI - PI;
        float latitude = vUv.y * PI - PI * 0.5;
        
        vec3 dir = vec3(cos(latitude) * sin(longitude), sin(latitude), cos(latitude) * cos(longitude));
        
        // Apply tilt 2 FIRST (pitch correction around X axis)
        float ch = cos(tilt2);
        float sh = sin(tilt2);
        dir = vec3(dir.x, ch * dir.y - sh * dir.z, sh * dir.y + ch * dir.z);
        
        // Then apply roll rotation (tilt 1)
        float c = cos(rollAngle);
        float s = sin(rollAngle);
        dir = vec3(c * dir.x - s * dir.y, s * dir.x + c * dir.y, dir.z);
        
        // Back lens only - for front-facing directions, show edge of back lens
        float theta = acos(clamp(-dir.z, 0.0, 1.0));
        float r = theta / (PI * 0.52);
        
        // Square canvas: equal radius in X and Y (0.49 to leave small margin)
        vec2 radius = vec2(0.49, 0.49);
        vec2 uv;
        if (r < 0.0001) {
          uv = vec2(0.5, 0.5);
        } else {
          float phi = atan(dir.y, -dir.x);
          uv = vec2(0.5, 0.5) + vec2(cos(phi), sin(phi)) * r * radius;
        }
        
        gl_FragColor = texture2D(backMap, uv);
      }
    `;
    
    // Global references for separate lens textures and materials
    let threeFrontTexture = null;
    let threeBackTexture = null;
    let materialDual = null;
    let materialFrontOnly = null;
    let materialBackOnly = null;
    let currentShaderMode = 'combined';  // 'combined', 'dual', 'front', 'back'
    let pendingModeSwitch = null;        // Target mode we're waiting for (e.g., 'dual' when waiting for dual-lens frames)
    
    // Detect orientation from metadata
    function detectOrientation360(data) {
      const marker = new TextEncoder().encode('standard');
      for (let i = 0; i < data.length - marker.length - 200; i++) {
        let match = true;
        for (let j = 0; j < marker.length; j++) {
          if (data[i + j] !== marker[j]) { match = false; break; }
        }
        if (match) {
          const value = data[i + 197];
          return value === 0 ? 'vertical' : 'horizontal';
        }
      }
      return 'horizontal';
    }
    
    // INSV Player class - Streaming version with audio (from advanced 360 player)
    class INSVPlayer360 {
      constructor(file) {
        this.file = file;
        this.mp4box = MP4Box.createFile();
        this.tracks = [];
        this.decoders = [];
        this.canvas0 = document.createElement('canvas');
        this.canvas1 = document.createElement('canvas');
        this.ctx0 = this.canvas0.getContext('2d');
        this.ctx1 = this.canvas1.getContext('2d');
        this.combinedCanvas = document.createElement('canvas');
        this.combinedCtx = this.combinedCanvas.getContext('2d');
        this.playing = false;
        this.currentTime = 0;
        this.duration = 0;
        this.frameRate = 30;
        this.targetFps = 20;  // Target playback FPS (default: 20fps ultra)
        this.frameSkip = 1;   // Average frames between kept frames (1 = keep all)
        this.lastKeptOutputIndex = -1;  // For non-integer frame skip tracking
        
        // Quality/optimization settings - use global defaults
        this.textureScale = typeof textureScale360 !== 'undefined' ? textureScale360 : 0.5;
        this.visibleLens = 2;     // 0=front only, 1=back only, 2=both
        this.viewLon = 0;         // Current view longitude for lens selection
        this.viewFov = 75;        // Field of view
        this.scaledWidth = 0;     // Set when video info is parsed
        this.scaledHeight = 0;
        
        // Single-lens optimization state
        this.activeDecoders = [true, true];     // Which decoders are actively decoding
        this.preWarmMode = false;               // In pre-warm zone near seam
        this.primaryLens = -1;                  // Primary lens when in pre-warm mode
        this.lensTransitionPending = false;     // Transition in progress
        this.lastVisibleLens = 2;               // Previous visible lens state
        this.forceFullDecode = true;            // Force both tracks during preview/seek (starts true)
        this.lastDecodeMode = 'both';           // Track decode mode changes for logging
        this.distToNearestSeam = 0;             // Distance to nearest seam in degrees
        this.dualModeHoldoffEnd = 0;            // Timestamp when dual mode holdoff expires
        this.dualModeHoldoffDuration = 10000;   // 10 seconds holdoff after exiting seam before switching to single lens
        this.lastGeometryRequires = 2;          // Previous frame's geometry requirement (start in dual)
        
        // Separate lens canvases for selective texture upload
        this.frontLensCanvas = document.createElement('canvas');
        this.backLensCanvas = document.createElement('canvas');
        this.frontLensCtx = this.frontLensCanvas.getContext('2d');
        this.backLensCtx = this.backLensCanvas.getContext('2d');
        this.frontLensUpdated = false;          // Flag: front lens texture needs upload
        this.backLensUpdated = false;           // Flag: back lens texture needs upload
        this.targetRenderMode = 'combined';     // Which texture mode is active (combined/front/back/dual)
        this.lastDrawnFrameIndex = -1;          // Track last drawn frame to avoid redundant uploads
        
        // Frame caching for paused video
        this.cachedRenderResult = null;         // Cache for paused frame rendering
        this.lastRenderLon = null;
        this.lastRenderLat = null;
        this.lastRenderFov = null;
        
        this.width = 0;
        this.height = 0;
        this.ready = false;
        
        // Track-specific codec info
        this.trackInfo = [{}, {}];
        this.avcCFound = 0;
        
        // Streaming: store only sample METADATA (not data)
        this.sampleMeta = [[], []];
        this.totalFrames = 0;
        this.currentFrame = 0;
        this.lastRenderTime = 0;
        
        // Frame buffer for decoded frames
        this.frameBuffer = [null, null];
        this.decoding = false;
        this.moovFound = false;
        this.needsExtraction = false;
        
        // Buffered playback
        this.decodedFrameBuffer = [];
        this.bufferFrameIndex = 0;
        this.bufferingActive = false;
        this.needsDecoderReset = false;  // Decoders are fresh after initDecoders(), only need reset after seek
        this.pendingFrames = [new Map(), new Map()];
        this.queueStuckCounter = 0;      // Track how long decoder queue has been full without output
        this.decoderResetTime = 0;       // Time of last decoder reset (for grace period)
        
        // FPS tracking
        this.fpsFrameCount = 0;
        this.fpsLastTime = 0;
        this.currentFps = 0;
        this.externalTargetTime = null;  // For sync with external timeline
        this.currentFps = 0;
        
        // Buffer settings for handling temporary load spikes
        this.maxBufferSize = 150;         // Maximum decoded frames to buffer (~5 sec at 30fps)
        this.minBufferTarget = 15;        // Minimum target for initial playback (~0.5 sec)
        this.comfortableBuffer = 30;      // Comfortable buffer level (~1 sec)
        
        // Playback sync
        this.playbackStartTime = null;
        this.renderStartTime = null;    // Strict timing reference
        this.renderStartFrame = 0;
        this.playbackStartFrame = 0;
        this.framesSkipped = 0;
        this.seekRecoveryFrames = 0;
        this.jumpingAhead = false;
        
        // Wall-clock driven playback (1 sec video = 1 sec real time)
        this.wallClockMode = true;      // Enable wall-clock driven playback
        this.wallClockStart = null;     // Wall clock time when playback started (performance.now())
        this.videoTimeAtStart = 0;      // Video time (seconds) when playback started
        this.lastRenderedFrameData = null; // Last frame data for repeat display when buffer empty
        this.framesDropped = 0;         // Counter for dropped frames (for diagnostics)
        
        // Performance monitoring (wall-clock mode - no drift possible)
        this.performanceCheckInterval = 5000;  // Check every 5 seconds
        this.lastPerformanceCheck = 0;
        this.lastDroppedCount = 0;            // For calculating drop rate per interval
        this.bufferUnderruns = 0;             // Count of buffer empty events
        this.performanceMonitoringStarted = false;  // Set true after grace period
        this.initialSyncDone = false;         // One-time initial timeline sync
        this.onSyncToVideo = null;            // Callback to sync timeline to video
        this.onQualityReduce = null;          // Callback to reduce quality
        this.onQualityIncrease = null;        // Callback to increase quality (recovery)
        this.consecutiveGoodChecks = 0;       // Track good performance for recovery
        
        // Periodic timeline sync checking (video ‚Üí telemetry/map)
        this.lastTimelineSyncCheck = 0;       // Last time we checked timeline sync
        this.timelineSyncCheckInterval = 1000; // Check sync every 1 second
        this.timelineSyncThreshold = 0.3;     // Resync if drift > 300ms (0.005 minutes)
        this.lastReportedVideoTime = 0;       // Last video time reported to timeline
        
        // Read-ahead cache (compressed data pre-fetch)
        this.dataCache = [new Map(), new Map()];
        this.cacheAheadCount = 90;        // Pre-fetch 90 chunks (~3 sec of compressed data)
        
        // Audio
        this.audioContext = null;
        this.audioTrack = null;
        this.audioDecoder = null;
        this.audioDescription = null;
        this.audioSampleMeta = [];
        this.audioBuffer = [];
        this.audioBufferIndex = 0;
        this.audioScheduledUntil = 0;
        this.audioNextScheduleTime = 0;
        this.audioGain = null;
        this.audioBufferingActive = false;
        this.audioContextStartTime = 0;
        this.audioVideoStartTime = 0;
        this.audioSyncVideoTime = 0;
        this.audioSyncContextTime = 0;
        this.lastAudioSpeed = 1;  // Track playback speed for audio sync
        this.lastAudioMuted = false;  // Track mute state for unmute resync
        this.audioTrackOffset = 0;  // Offset between audio and video track timestamps
        
        // Audio-Video sync tracking
        this.audioContextOffset = 0;      // Difference: audioContext.currentTime - videoTime at sync point
        this.lastAudioSyncCheck = 0;      // Last time we checked audio-video sync
        this.audioSyncCheckInterval = 500;   // Check sync every 500ms for responsive corrections
        this.audioSyncThreshold = 1.5;    // Hard resync threshold (for seeks/large discontinuities)
        this.lastScheduledVideoTime = 0;  // Video time of last scheduled audio chunk
        this.lastActualAudioDrift = 0;    // Actual audio-video drift (for diagnostics)
        this.audioNextScheduleTime = 0;   // Sequential tracking: exact time next batch should start
        
        // Direct audio position tracking (ground truth for sync detection)
        this.audioPositionRef = null;     // { playTime, videoTime } - reference point for tracking
        this.audioSchedulingLead = 0;     // How far ahead audio is scheduled
        this.scheduledAudioSources = [];  // Track scheduled sources to stop on seek
        
        // Callbacks
        this.loadingCallback = null;
        this.onStatusChange = null;
        this.isWaiting = false;
        this.playInProgress = false;
        this.seekInProgress = false;
        this.pendingSeekTime = null;
        this.renderLoopRunning = false;
        this.bufferLoopRunning = false;
        this.audioBufferLoopRunning = false;
        this.previewInProgress = false;
        
        // Preview cancellation - only latest preview should render
        this.previewVersion = 0;       // Incremented for each new preview
        this.activePreviewVersion = 0; // Version of currently rendering preview
        
        // Seek version tracking - prevents overlapping seeks from corrupting state
        this.seekVersion = 0;          // Incremented for each new seek
        
        // Decoder health tracking
        this.decodersCorrupted = false; // Set true on timeout, triggers recreation
        
        // Wake Lock and Visibility handling (prevent tab throttling)
        this.wakeLock = null;
        this.wasPlayingBeforeHidden = false;
        this.visibilityHandlerBound = null;
        this.setupVisibilityHandler();
      }
      
      // Set up visibility change handler to pause/resume on tab switch
      setupVisibilityHandler() {
        this.visibilityHandlerBound = () => {
          if (document.hidden) {
            // Tab hidden - remember if we were playing
            if (this.playing) {
              console.log('INSV: Tab hidden, pausing playback to prevent drift');
              this.wasPlayingBeforeHidden = true;
              this.pause();
            }
          } else {
            // Tab visible again - resume if we were playing
            if (this.wasPlayingBeforeHidden) {
              console.log('INSV: Tab visible, resuming playback');
              this.wasPlayingBeforeHidden = false;
              // Small delay to let browser stabilize
              setTimeout(() => {
                if (!this.playing && this.ready) {
                  this.play();
                }
              }, 100);
            }
          }
        };
        document.addEventListener('visibilitychange', this.visibilityHandlerBound);
      }
      
      // Request screen wake lock to prevent tab throttling
      async requestWakeLock() {
        if ('wakeLock' in navigator) {
          try {
            this.wakeLock = await navigator.wakeLock.request('screen');
            console.log('INSV: Wake lock acquired');
            
            // Re-acquire if released (e.g., on tab switch then return)
            this.wakeLock.addEventListener('release', () => {
              console.log('INSV: Wake lock released');
              // Only re-acquire if still playing
              if (this.playing && !document.hidden) {
                this.requestWakeLock();
              }
            });
          } catch (err) {
            console.log('INSV: Wake lock failed:', err.message);
          }
        }
      }
      
      // Release wake lock
      async releaseWakeLock() {
        if (this.wakeLock) {
          try {
            await this.wakeLock.release();
            this.wakeLock = null;
            console.log('INSV: Wake lock released manually');
          } catch (err) {
            console.log('INSV: Wake lock release failed:', err.message);
          }
        }
      }
      
      setLoadingCallback(cb) {
        this.loadingCallback = cb;
      }
      
      _updateLoading(msg) {
        if (this.loadingCallback) this.loadingCallback(msg);
      }
      
      async load() {
        this._updateLoading('Indexing file...');
        
        return new Promise((resolve, reject) => {
          this.loadResolve = resolve;
          this.loadReject = reject;
          
          this.mp4box.onReady = (info) => {
            console.log('MP4Box ready:', info);
            this.onMP4Ready(info);
          };
          
          this.mp4box.onError = (e) => {
            console.error('MP4Box error:', e);
            reject(new Error('Failed to parse file'));
          };
          
          this.mp4box.onSamples = (trackId, ref, samples) => {
            this.onSamples(trackId, samples);
          };
          
          this.streamFileToMP4Box();
        });
      }
      
      async streamFileToMP4Box() {
        const fileSize = this.file.size;
        const fileSizeGB = fileSize / (1024 * 1024 * 1024);
        
        console.log(`File size: ${fileSizeGB.toFixed(2)} GB`);
        
        try {
          this._updateLoading('Finding metadata...');
          const firstChunkSize = Math.min(1 * 1024 * 1024, fileSize);
          const firstChunk = await this.file.slice(0, firstChunkSize).arrayBuffer();
          
          firstChunk.fileStart = 0;
          this.mp4box.appendBuffer(firstChunk);
          
          await new Promise(r => setTimeout(r, 10));
          
          if (!this.moovFound) {
            const endChunkSize = Math.min(
              Math.floor(100 * 1024 * 1024 + fileSizeGB * 10 * 1024 * 1024),
              fileSize - firstChunkSize
            );
            const endOffset = fileSize - endChunkSize;
            
            this._updateLoading(`Reading metadata (${Math.round(endChunkSize/1024/1024)}MB)...`);
            console.log(`Reading last ${Math.round(endChunkSize/1024/1024)}MB for moov`);
            
            const endChunk = await this.file.slice(endOffset, fileSize).arrayBuffer();
            endChunk.fileStart = endOffset;
            this.mp4box.appendBuffer(endChunk);
            
            const parseWait = Math.min(500, 50 + fileSizeGB * 20);
            await new Promise(r => setTimeout(r, parseWait));
          }
          
          if (!this.moovFound) {
            console.warn('moov not found in first/last chunks');
            this._updateLoading('Metadata not found - checking file structure...');
            
            const extraChunkSize = Math.min(200 * 1024 * 1024, fileSize / 2);
            const extraOffset = fileSize - extraChunkSize;
            
            if (extraOffset > firstChunkSize) {
              const endChunkSize = Math.floor(100 * 1024 * 1024 + fileSizeGB * 10 * 1024 * 1024);
              const extraChunk = await this.file.slice(extraOffset, fileSize - endChunkSize).arrayBuffer();
              extraChunk.fileStart = extraOffset;
              this.mp4box.appendBuffer(extraChunk);
              await new Promise(r => setTimeout(r, 100));
            }
          }
          
          this.mp4box.flush();
          
          if (!this.moovFound) {
            this.loadReject(new Error('Could not find video metadata. File may be corrupted or still recording.'));
          }
        } catch (e) {
          console.error('Error reading file:', e);
          this.loadReject(new Error('Failed to read file'));
        }
      }
      
      async onMP4Ready(info) {
        this.moovFound = true;
        
        const videoTracks = info.tracks.filter(t => t.type === 'video');
        console.log('Found video tracks:', videoTracks.length);
        
        if (videoTracks.length < 2) {
          this.loadReject(new Error('INSV file must have 2 video tracks'));
          return;
        }
        
        this.tracks = videoTracks.slice(0, 2);
        this.duration = info.duration / info.timescale;
        this.width = this.tracks[0].video.width;
        this.height = this.tracks[0].video.height;
        this.frameRate = this.tracks[0].nb_samples / this.duration;
        this.totalFrames = this.tracks[0].nb_samples;
        
        console.log(`Video: ${this.width}x${this.height} @ ${this.frameRate.toFixed(1)}fps, ${this.totalFrames} frames`);
        
        // Default: 20fps Ultra for all video sizes
        // Large dual-stream videos (2880x2880+) use same defaults - quality is user-adjustable
        const pixelCount = this.width * this.height * 2;  // Both tracks
        this.targetFps = 20;
        this.frameSkip = Math.max(1, Math.round(this.frameRate / this.targetFps));
        console.log(`Video detected (${(pixelCount/1000000).toFixed(1)}M pixels), starting at ${this.targetFps}fps Ultra (frameSkip: ${this.frameSkip})`);
        
        // Setup canvases - use scaled resolution for better performance
        // Source canvases at full resolution for VideoFrame drawing
        this.canvas0.width = this.width;
        this.canvas0.height = this.height;
        this.canvas1.width = this.width;
        this.canvas1.height = this.height;
        
        // Combined canvas at scaled resolution for texture upload
        this.scaledWidth = Math.round(this.width * this.textureScale);
        this.scaledHeight = Math.round(this.height * this.textureScale);
        this.combinedCanvas.width = this.scaledWidth * 2;
        this.combinedCanvas.height = this.scaledHeight;
        
        // Initialize separate lens canvases for selective texture upload
        this.frontLensCanvas.width = this.scaledWidth;
        this.frontLensCanvas.height = this.scaledHeight;
        this.backLensCanvas.width = this.scaledWidth;
        this.backLensCanvas.height = this.scaledHeight;
        
        console.log(`Combined canvas: ${this.combinedCanvas.width}x${this.combinedCanvas.height} (${Math.round(this.textureScale * 100)}% scale)`);
        console.log(`Texture memory: ${((this.combinedCanvas.width * this.combinedCanvas.height * 4) / 1024 / 1024).toFixed(1)}MB`);
        
        // Extract codec info
        for (let i = 0; i < 2; i++) {
          const track = this.tracks[i];
          const trak = this.mp4box.getTrackById(track.id);
          
          let codecInfo = null;
          let isHEVC = false;
          const codecString = track.codec || '';
          
          if (trak && trak.mdia && trak.mdia.minf && trak.mdia.minf.stbl && trak.mdia.minf.stbl.stsd) {
            const stsd = trak.mdia.minf.stbl.stsd;
            if (stsd.entries && stsd.entries[0]) {
              const entry = stsd.entries[0];
              const codecType = entry.type;
              
              if (codecType === 'hvc1' || codecType === 'hev1' || codecString.startsWith('hvc1') || codecString.startsWith('hev1')) {
                isHEVC = true;
                codecInfo = entry.hvcC;
              } else {
                isHEVC = false;
                codecInfo = entry.avcC;
              }
            }
          }
          
          if (codecInfo) {
            this.trackInfo[i].isHEVC = isHEVC;
            this.trackInfo[i].naluLengthSize = (codecInfo.lengthSizeMinusOne || 3) + 1;
            
            if (codecInfo.data) {
              this.trackInfo[i].description = new Uint8Array(codecInfo.data);
            }
            
            if (isHEVC) {
              const naluArrays = codecInfo.nalu_arrays;
              if (naluArrays && naluArrays.length >= 3) {
                if (naluArrays[0]?.[0]?.data) this.trackInfo[i].vps = new Uint8Array(naluArrays[0][0].data);
                if (naluArrays[1]?.[0]?.data) this.trackInfo[i].sps = new Uint8Array(naluArrays[1][0].data);
                if (naluArrays[2]?.[0]?.data) this.trackInfo[i].pps = new Uint8Array(naluArrays[2][0].data);
                this.avcCFound++;
              }
            } else {
              if (codecInfo.SPS?.[0]) this.trackInfo[i].sps = new Uint8Array(codecInfo.SPS[0].nalu);
              if (codecInfo.PPS?.[0]) this.trackInfo[i].pps = new Uint8Array(codecInfo.PPS[0].nalu);
              if (this.trackInfo[i].sps && this.trackInfo[i].pps) this.avcCFound++;
            }
          }
        }
        
        // Extract video sample metadata
        this._updateLoading('Indexing video tracks...');
        await new Promise(r => setTimeout(r, 0));
        
        for (let i = 0; i < 2; i++) {
          const track = this.tracks[i];
          const trak = this.mp4box.getTrackById(track.id);
          
          if (trak && trak.samples && trak.samples.length > 0) {
            const totalSamples = trak.samples.length;
            this.sampleMeta[i] = new Array(totalSamples);
            
            for (let j = 0; j < totalSamples; j++) {
              const sample = trak.samples[j];
              this.sampleMeta[i][j] = {
                offset: sample.offset,
                size: sample.size,
                is_sync: sample.is_sync,
                cts: sample.cts,
                dts: sample.dts,
                duration: sample.duration,
                timescale: track.timescale
              };
              
              if (j % 10000 === 0 && j > 0) {
                this._updateLoading(`Indexing track ${i+1}: ${Math.round(j/totalSamples*100)}%`);
                await new Promise(r => setTimeout(r, 0));
              }
            }
            console.log(`Track ${i}: ${this.sampleMeta[i].length} samples indexed`);
          } else {
            this.needsExtraction = true;
          }
        }
        
        // Find and setup audio track
        this._updateLoading('Indexing audio...');
        await new Promise(r => setTimeout(r, 0));
        
        const audioTracks = info.tracks.filter(t => t.type === 'audio');
        if (audioTracks.length > 0) {
          this.audioTrack = audioTracks[0];
          console.log(`Audio track found: ${this.audioTrack.codec}, ${this.audioTrack.audio.sample_rate}Hz, ${this.audioTrack.audio.channel_count}ch`);
          
          const audioTrak = this.mp4box.getTrackById(this.audioTrack.id);
          if (audioTrak && audioTrak.samples && audioTrak.samples.length > 0) {
            const totalSamples = audioTrak.samples.length;
            this.audioSampleMeta = new Array(totalSamples);
            
            for (let j = 0; j < totalSamples; j++) {
              const sample = audioTrak.samples[j];
              this.audioSampleMeta[j] = {
                offset: sample.offset,
                size: sample.size,
                cts: sample.cts,
                dts: sample.dts,
                duration: sample.duration,
                timescale: this.audioTrack.timescale
              };
            }
            console.log(`Audio: ${this.audioSampleMeta.length} samples indexed`);
            
            // DIAGNOSTIC: Log first and last audio sample timestamps to detect track offset
            if (this.audioSampleMeta.length > 0) {
              const first = this.audioSampleMeta[0];
              const last = this.audioSampleMeta[this.audioSampleMeta.length - 1];
              const firstTime = first.cts / this.audioTrack.timescale;
              const lastTime = last.cts / this.audioTrack.timescale;
              console.log('INSV AUDIO DIAG: audio timestamps range: ' + firstTime.toFixed(3) + 
                         's to ' + lastTime.toFixed(3) + 
                         's (timescale=' + this.audioTrack.timescale + 
                         ', first.cts=' + first.cts + ', first.dts=' + first.dts + ')');
              
              // Compare with video track
              if (this.sampleMeta[0] && this.sampleMeta[0].length > 0) {
                const vFirst = this.sampleMeta[0][0];
                const vTimescale = this.tracks[0].timescale;
                const vFirstTime = vFirst.cts / vTimescale;
                const trackOffset = firstTime - vFirstTime;
                console.log('INSV AUDIO DIAG: video first timestamp: ' + vFirstTime.toFixed(3) + 
                           's (timescale=' + vTimescale + ', cts=' + vFirst.cts + ')' +
                           ' | audio-video offset: ' + (trackOffset * 1000).toFixed(0) + 'ms');
                if (Math.abs(trackOffset) > 0.1) {
                  console.warn('INSV AUDIO DIAG: SIGNIFICANT audio-video track offset detected: ' + 
                              (trackOffset * 1000).toFixed(0) + 'ms');
                  // Store offset for compensation during scheduling
                  this.audioTrackOffset = trackOffset;
                }
              }
            }
          }
        } else {
          console.log('No audio track found');
        }
        
        const hasCodecConfig = this.avcCFound >= 2;
        const hasSamples = this.sampleMeta[0].length > 0 && this.sampleMeta[1].length > 0;
        
        if (hasCodecConfig && hasSamples) {
          await this.initDecoders();
        } else if (this.needsExtraction) {
          for (let i = 0; i < 2; i++) {
            this.mp4box.setExtractionOptions(this.tracks[i].id, null, { nbSamples: Infinity });
          }
          this.mp4box.start();
        } else {
          this.loadReject(new Error('Could not extract codec info or sample metadata'));
        }
      }
      
      onSamples(trackId, samples) {
        if (!this.needsExtraction) return;
        const trackIndex = this.tracks.findIndex(t => t.id === trackId);
        if (trackIndex === -1) return;
        
        for (const sample of samples) {
          this.sampleMeta[trackIndex].push({
            offset: sample.offset,
            size: sample.size,
            is_sync: sample.is_sync,
            cts: sample.cts,
            dts: sample.dts,
            duration: sample.duration,
            timescale: sample.timescale
          });
        }
        
        if (this.sampleMeta[0].length > 0 && this.sampleMeta[1].length > 0 && !this.ready) {
          this.initDecoders();
        }
      }
      
      async initDecoders() {
        this._updateLoading('Initializing decoders...');
        console.log('INSV initDecoders:', this.tracks.length, 'tracks');
        
        for (let i = 0; i < 2; i++) {
          const track = this.tracks[i];
          const info = this.trackInfo[i];
          
          const config = {
            codec: track.codec,
            codedWidth: track.video.width,
            codedHeight: track.video.height,
            hardwareAcceleration: 'prefer-hardware',
          };
          
          if (info.description) {
            config.description = info.description;
          }
          
          console.log(`INSV decoder ${i}: ${config.codec} ${config.codedWidth}x${config.codedHeight}`);
          
          try {
            const support = await VideoDecoder.isConfigSupported(config);
            if (!support.supported) {
              this.loadReject(new Error(`Codec ${track.codec} not supported. HEVC requires hardware support.`));
              return;
            }
          } catch (e) {
            this.loadReject(e);
            return;
          }
          
          const decoder = new VideoDecoder({
            output: (frame) => this.onFrame(i, frame),
            error: (e) => {
              console.error(`Decoder ${i} error:`, e);
              this.decodersCorrupted = true;  // Trigger recreation on next buffer cycle
            }
          });
          
          decoder.configure(config);
          this.decoders.push(decoder);
        }
        
        console.log('INSV decoders ready');
        
        // Initialize audio if available
        if (this.audioTrack && this.audioSampleMeta.length > 0) {
          await this.initAudio();
        }
        
        this.ready = true;
        this._updateLoading('Ready');
        this.loadResolve();
      }
      
      // Recreate video decoders from scratch when they get into corrupted state
      // This is expensive but guarantees recovery
      async recreateVideoDecoders() {
        console.log('INSV recreateVideoDecoders: destroying and recreating decoders');
        
        // Close existing decoders
        for (let i = 0; i < 2; i++) {
          if (this.decoders[i]) {
            try {
              if (this.decoders[i].state !== 'closed') {
                this.decoders[i].close();
              }
            } catch (e) {
              // Ignore close errors
            }
          }
        }
        
        // Clear decoder array
        this.decoders = [];
        
        // Clear all pending frames
        for (const framePair of this.decodedFrameBuffer) {
          if (framePair.frame0) framePair.frame0.close();
          if (framePair.frame1) framePair.frame1.close();
        }
        this.decodedFrameBuffer = [];
        for (const [ts, frame] of this.pendingFrames[0]) frame.close();
        for (const [ts, frame] of this.pendingFrames[1]) frame.close();
        this.pendingFrames = [new Map(), new Map()];
        
        // Recreate decoders
        for (let i = 0; i < 2; i++) {
          const track = this.tracks[i];
          const info = this.trackInfo[i];
          
          const config = {
            codec: track.codec,
            codedWidth: track.video.width,
            codedHeight: track.video.height,
            hardwareAcceleration: 'prefer-hardware',
          };
          
          if (info.description) {
            config.description = info.description;
          }
          
          const decoder = new VideoDecoder({
            output: (frame) => this.onFrame(i, frame),
            error: (e) => {
              console.error(`Decoder ${i} error:`, e);
              this.decodersCorrupted = true;  // Trigger recreation on next buffer cycle
            }
          });
          
          decoder.configure(config);
          this.decoders.push(decoder);
        }
        
        this.decodersCorrupted = false;
        this.needsDecoderReset = true;  // Will need reset to keyframe
        console.log('INSV video decoders recreated successfully');
      }
      
      async initAudio() {
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          this.audioGain = this.audioContext.createGain();
          this.audioGain.connect(this.audioContext.destination);
          
          const audioTrak = this.mp4box.getTrackById(this.audioTrack.id);
          let audioDescription = null;
          
          if (audioTrak?.mdia?.minf?.stbl?.stsd?.entries?.[0]) {
            const entry = audioTrak.mdia.minf.stbl.stsd.entries[0];
            if (entry.esds?.esd?.descs?.[0]?.descs?.[0]?.data) {
              audioDescription = new Uint8Array(entry.esds.esd.descs[0].descs[0].data);
              console.log(`Audio description: ${audioDescription.length} bytes`);
            }
          }
          
          // Store audio description for reconfiguration after seek
          this.audioDescription = audioDescription;
          
          const audioConfig = {
            codec: this.audioTrack.codec,
            sampleRate: this.audioTrack.audio.sample_rate,
            numberOfChannels: this.audioTrack.audio.channel_count,
          };
          
          if (audioDescription) {
            audioConfig.description = audioDescription;
          }
          
          console.log('Audio config:', audioConfig);
          
          const support = await AudioDecoder.isConfigSupported(audioConfig);
          if (!support.supported) {
            console.warn('Audio codec not supported:', this.audioTrack.codec);
            return;
          }
          
          this.audioDecoder = new AudioDecoder({
            output: (audioData) => this.onAudioData(audioData),
            error: (e) => console.error('Audio decoder error:', e)
          });
          
          this.audioDecoder.configure(audioConfig);
          console.log('Audio decoder initialized');
          
        } catch (e) {
          console.error('Audio init error:', e);
          this.audioDecoder = null;
        }
      }
      
      onAudioData(audioData) {
        const numberOfChannels = audioData.numberOfChannels;
        const numberOfFrames = audioData.numberOfFrames;
        const sampleRate = audioData.sampleRate;
        
        // Log first few chunks to confirm size
        if (this.audioBuffer.length < 3) {
          const durationMs = (numberOfFrames / sampleRate * 1000).toFixed(1);
          console.log('INSV audio chunk: ' + numberOfFrames + ' frames @ ' + sampleRate + 'Hz = ' + durationMs + 'ms, ' + numberOfChannels + 'ch');
        }
        
        const audioBuffer = this.audioContext.createBuffer(numberOfChannels, numberOfFrames, sampleRate);
        
        for (let ch = 0; ch < numberOfChannels; ch++) {
          const dest = audioBuffer.getChannelData(ch);
          audioData.copyTo(dest, { planeIndex: ch });
        }
        
        // Calculate video time for this audio chunk (timestamp is in microseconds)
        // Apply audioTrackOffset compensation if audio and video tracks have different start times
        const rawVideoTime = audioData.timestamp / 1000000;
        const videoTime = rawVideoTime - (this.audioTrackOffset || 0);
        
        this.audioBuffer.push({
          buffer: audioBuffer,
          timestamp: audioData.timestamp,
          duration: audioData.duration,
          videoTime: videoTime  // Track which video position this audio is for
        });
        
        audioData.close();
      }
      
      async decodeAudioForTime(startTime, duration) {
        if (!this.audioDecoder || this.audioSampleMeta.length === 0) return;
        
        if (this.audioDecoder.state === 'closed') {
          this.recreateAudioDecoder();
          if (!this.audioDecoder) return;
        }
        
        if (this.audioDecoder.state !== 'configured') return;
        
        const timescale = this.audioTrack.timescale;
        const endTime = startTime + duration;
        
        let decoded = 0;
        while (this.audioBufferIndex < this.audioSampleMeta.length && decoded < 50) {
          const meta = this.audioSampleMeta[this.audioBufferIndex];
          const sampleTime = meta.cts / timescale;
          
          if (sampleTime > endTime + 1) break;
          
          if (sampleTime < startTime - 0.5) {
            this.audioBufferIndex++;
            continue;
          }
          
          try {
            const data = await this.file.slice(meta.offset, meta.offset + meta.size).arrayBuffer();
            
            const chunk = new EncodedAudioChunk({
              type: 'key',
              timestamp: meta.cts * 1000000 / timescale,
              duration: meta.duration * 1000000 / timescale,
              data: new Uint8Array(data)
            });
            
            if (this.audioDecoder.state === 'configured') {
              this.audioDecoder.decode(chunk);
              decoded++;
            }
          } catch (e) {
            console.error('Audio decode error:', e);
          }
          
          this.audioBufferIndex++;
        }
      }
      
      scheduleAudio() {
        const audioStart = performance.now();
        if (!this.audioContext) return;
        if (this.audioContext.state !== 'running') return;
        
        // Don't start audio scheduling until video wall-clock has started
        // This ensures currentTime is being updated before we sync audio
        if (!this.wallClockStart) return;
        
        // Log when buffer is empty during playback (potential audio starvation)
        if (this.audioBuffer.length === 0) {
          const currentLead = this.audioScheduledUntil - (this.audioContext ? this.audioContext.currentTime : 0);
          if (this.playing && currentLead < 0.5) {
            if (!this._lastEmptyBufLog || audioStart - this._lastEmptyBufLog > 500) {
              this._lastEmptyBufLog = audioStart;
              console.warn('INSV AUDIO: buffer empty during playback, lead=' + (currentLead * 1000).toFixed(0) + 
                          'ms, bufIdx=' + this.audioBufferIndex + '/' + this.audioSampleMeta.length +
                          ', decoderState=' + (this.audioDecoder ? this.audioDecoder.state : 'null'));
            }
          }
          return;
        }
        
        const effectiveSpeed = typeof playbackSpeed !== 'undefined' ? playbackSpeed : 1;
        const isMuted = effectiveSpeed > 2;
        
        // Track mute state transitions for proper audio resync
        const wasMuted = this.lastAudioMuted || false;
        this.lastAudioMuted = isMuted;
        
        // Mute audio at high speeds (>2x) - use smooth gain transition to avoid clicks
        if (isMuted) {
          if (this.audioGain.gain.value !== 0) {
            this.audioGain.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.015);
          }
          // Still consume audio buffer to prevent it from growing
          while (this.audioBuffer.length > 100) {
            this.audioBuffer.shift();
          }
          // Update lastAudioSpeed even when muted so we track changes
          this.lastAudioSpeed = effectiveSpeed;
          return;
        } else {
          // Smooth unmute transition to avoid clicks
          if (this.audioGain.gain.value < 0.99) {
            this.audioGain.gain.setTargetAtTime(1, this.audioContext.currentTime, 0.015);
          }
        }
        
        const currentAudioTime = this.audioContext.currentTime;
        const currentVideoTime = this.currentTime;
        const now = performance.now();
        
        // Force reinitialization when unmuting (transitioning from >2x to <=2x speed)
        const needsReinit = wasMuted && !isMuted;
        
        // Initialize on first call, after seek (audioScheduledUntil reset to 0), or after unmute
        if (this.audioScheduledUntil === 0 || needsReinit) {
          if (needsReinit) {
            console.log('INSV audio: reinitializing after unmute (speed now', effectiveSpeed + 'x)');
            // Clear any stale scheduled sources
            if (this.scheduledAudioSources && this.scheduledAudioSources.length > 0) {
              for (const scheduled of this.scheduledAudioSources) {
                try { if (scheduled.source) scheduled.source.stop(); } catch (e) {}
              }
              this.scheduledAudioSources = [];
            }
          }
          
          // Calculate offset: audioContext.currentTime when video is at currentVideoTime
          this.audioContextOffset = currentAudioTime - currentVideoTime;
          this.audioScheduledUntil = currentAudioTime;
          this.audioSyncVideoTime = currentVideoTime;
          this.audioSyncContextTime = currentAudioTime;
          this.lastAudioSpeed = effectiveSpeed;
          this.lastAudioSyncCheck = now;
          this.audioPositionRef = null;
          // Reset sequential tracking for concatenated scheduling
          this.audioNextScheduleTime = currentAudioTime;
          
          // CRITICAL: Discard any audio chunks that are too far behind current video position
          // This ensures we start playing audio that matches the current video frame
          const maxBehind = 0.15;  // Allow audio to be at most 150ms behind video
          let discardedCount = 0;
          while (this.audioBuffer.length > 0) {
            const chunk = this.audioBuffer[0];
            if (chunk.videoTime !== undefined) {
              const behind = currentVideoTime - chunk.videoTime;
              if (behind > maxBehind) {
                this.audioBuffer.shift();
                discardedCount++;
              } else {
                break;  // This chunk is close enough, keep it and all following
              }
            } else {
              break;  // No videoTime info, keep it
            }
          }
          
          if (discardedCount > 0) {
            console.log('INSV audio init: discarded ' + discardedCount + ' stale chunks to sync with video at ' + currentVideoTime.toFixed(2) + 's');
          }
          
          // DIAGNOSTIC: Log first chunk's videoTime vs currentVideoTime to detect track offset
          if (this.audioBuffer.length > 0 && this.audioBuffer[0].videoTime !== undefined) {
            const firstChunkVT = this.audioBuffer[0].videoTime;
            const offset = firstChunkVT - currentVideoTime;
            console.log('INSV AUDIO DIAG init: firstChunk.videoTime=' + firstChunkVT.toFixed(3) + 
                       's, currentVideoTime=' + currentVideoTime.toFixed(3) + 
                       's, offset=' + (offset * 1000).toFixed(0) + 'ms' +
                       ', buffer=' + this.audioBuffer.length + ' chunks' +
                       ', audioBufferIndex=' + this.audioBufferIndex);
            if (Math.abs(offset) > 0.5) {
              console.warn('INSV AUDIO DIAG: LARGE offset between audio and video timestamps! (' + (offset * 1000).toFixed(0) + 'ms)');
            }
          }
          
          console.log('INSV audio sync initialized: videoTime=' + currentVideoTime.toFixed(2) + 
                      's, audioContextTime=' + currentAudioTime.toFixed(2) + 
                      's, offset=' + this.audioContextOffset.toFixed(2) + 's' +
                      ', buffered=' + this.audioBuffer.length + ' chunks');
        }
        
        // Detect speed change - need to resync
        if (this.lastAudioSpeed !== effectiveSpeed) {
          console.log('INSV audio speed changed:', this.lastAudioSpeed, '->', effectiveSpeed);
          
          // Reset debug flag for new speed
          this._loggedSpeedSchedule = false;
          
          // Cancel currently scheduled audio sources since they have wrong playback rate
          if (this.scheduledAudioSources && this.scheduledAudioSources.length > 0) {
            console.log('INSV audio: cancelling', this.scheduledAudioSources.length, 'scheduled sources for speed change');
            for (const scheduled of this.scheduledAudioSources) {
              try {
                if (scheduled.source) scheduled.source.stop();
              } catch (e) { /* Already stopped */ }
            }
            this.scheduledAudioSources = [];
          }
          
          this.lastAudioSpeed = effectiveSpeed;
          // Recalculate offset for new speed
          this.audioContextOffset = currentAudioTime - currentVideoTime;
          this.audioSyncVideoTime = currentVideoTime;
          this.audioSyncContextTime = currentAudioTime;
          this.lastAudioSyncCheck = now;
          // Reset scheduling position to allow fresh scheduling
          this.audioScheduledUntil = currentAudioTime;
          this.audioNextScheduleTime = currentAudioTime;
          this.audioPositionRef = null;
        }
        
        // Periodic sync check: find the CURRENTLY PLAYING audio chunk and compare
        // its expected video position with actual video position.
        // This is ground truth - no separate position reference needed.
        if (this.scheduledAudioSources && this.scheduledAudioSources.length > 0 && 
            now - this.lastAudioSyncCheck > this.audioSyncCheckInterval) {
          this.lastAudioSyncCheck = now;
          
          // Find the chunk currently being played by the audio hardware
          let playingChunk = null;
          for (const s of this.scheduledAudioSources) {
            if (s.startTime <= currentAudioTime && currentAudioTime < s.endTime && s.videoTime !== null) {
              if (!playingChunk || s.startTime > playingChunk.startTime) {
                playingChunk = s;
              }
            }
          }
          
          if (playingChunk) {
            // Calculate where in the video the audio THINKS we are
            const elapsedInChunk = currentAudioTime - playingChunk.startTime;
            const audioNowVideoTime = playingChunk.videoTime + elapsedInChunk * effectiveSpeed;
            const actualDrift = audioNowVideoTime - currentVideoTime;
            const schedulingLead = this.audioScheduledUntil - currentAudioTime;
            
            // Store for UI display
            this.lastActualAudioDrift = actualDrift;
            this.audioSchedulingLead = schedulingLead;
            
            const absDrift = Math.abs(actualDrift);
            
            // THREE-TIER DRIFT HANDLING:
            // Tier 1 (<300ms): ignore ‚Äî normal clock jitter and scheduling variance
            // Tier 2 (300ms-1.5s): SOFT CORRECTION ‚Äî nudge scheduling timeline
            // Tier 3 (>1.5s): HARD RESYNC ‚Äî stop audio and restart from current position
            
            if (absDrift > this.audioSyncThreshold) {
              // TIER 3: HARD RESYNC
              console.log('INSV audio HARD resync: drift=' + (actualDrift * 1000).toFixed(0) + 'ms' +
                         ', playing chunk vt=' + playingChunk.videoTime.toFixed(2) +
                         ', videoTime=' + currentVideoTime.toFixed(2));
              
              this.audioContextOffset = currentAudioTime - currentVideoTime;
              this.audioScheduledUntil = currentAudioTime;
              this.audioNextScheduleTime = currentAudioTime;
              this.audioSyncVideoTime = currentVideoTime;
              this.audioSyncContextTime = currentAudioTime;
              this.lastScheduledVideoTime = 0;
              this.audioPositionRef = null;
              
              // Stop all scheduled audio sources
              for (const scheduled of this.scheduledAudioSources) {
                try { if (scheduled.endTime > currentAudioTime) scheduled.source.stop(); } catch (e) {}
              }
              this.scheduledAudioSources = [];
              
              // Filter buffer to usable range
              const minVT = currentVideoTime - 0.15;
              const maxVT = currentVideoTime + 2.0;
              this.audioBuffer = this.audioBuffer.filter(c => 
                c.videoTime !== undefined && c.videoTime >= minVT && c.videoTime <= maxVT
              );
              
              // Reset decoder for large time jumps
              if (this.audioDecoder && this.audioDecoder.state === 'configured') {
                try {
                  this.audioDecoder.reset();
                  const audioConfig = {
                    codec: this.audioTrack.codec,
                    sampleRate: this.audioTrack.audio.sample_rate,
                    numberOfChannels: this.audioTrack.audio.channel_count,
                  };
                  if (this.audioDescription) audioConfig.description = this.audioDescription;
                  this.audioDecoder.configure(audioConfig);
                } catch (e) { console.error('Audio decoder reset error:', e); }
              }
              
              // Reposition decode index
              if (this.audioBuffer.length < 10 && this.audioTrack && this.audioSampleMeta.length > 0) {
                const timescale = this.audioTrack.timescale;
                const targetCts = currentVideoTime * timescale;
                let lo = 0, hi = this.audioSampleMeta.length - 1;
                while (lo < hi) {
                  const mid = Math.floor((lo + hi) / 2);
                  if (this.audioSampleMeta[mid].cts < targetCts) lo = mid + 1;
                  else hi = mid;
                }
                this.audioBufferIndex = Math.max(0, lo - 5);
              }
              
              // Fall through to scheduling ‚Äî don't return!
              
            } else if (absDrift > 0.3) {
              // TIER 2: SOFT CORRECTION ‚Äî nudge scheduling timeline without stopping audio
              const correction = actualDrift * 0.4;
              const correctionRealTime = correction / effectiveSpeed;
              
              this.audioNextScheduleTime -= correctionRealTime;
              this.audioScheduledUntil -= correctionRealTime;
              
              if (!this._lastSoftCorrLog || now - this._lastSoftCorrLog > 3000) {
                console.log('INSV audio soft correction: drift=' + (actualDrift * 1000).toFixed(0) + 
                           'ms, correction=' + (correctionRealTime * 1000).toFixed(0) + 'ms' +
                           ', chunk vt=' + playingChunk.videoTime.toFixed(2));
                this._lastSoftCorrLog = now;
              }
            }
            // Tier 1: drift <= 300ms ‚Äî no action needed
          }
        }

        
        // =====================================================================
        // CHUNK CONCATENATION + SEQUENTIAL SCHEDULING
        // Instead of scheduling each ~21ms decoded chunk as a separate AudioBufferSourceNode
        // (which causes clicks at every boundary), we concatenate consecutive chunks into
        // larger ~300ms buffers and schedule those. This reduces source boundaries from
        // ~47/sec to ~3/sec, virtually eliminating inter-chunk artifacts.
        // =====================================================================
        
        const CONCAT_TARGET_DURATION = 0.3;  // Target ~300ms concatenated buffers
        const MAX_SCHEDULE_LEAD = 1.5;       // Schedule up to 1.5s ahead
        const sampleRate = this.audioTrack ? this.audioTrack.audio.sample_rate : 48000;
        const numChannels = this.audioTrack ? this.audioTrack.audio.channel_count : 1;
        
        // Collect chunks to concatenate
        let _staleDiscarded = 0;
        let _batchesScheduled = 0;
        while (this.audioBuffer.length > 0) {
          // First, filter out stale/future chunks
          const peekChunk = this.audioBuffer[0];
          if (peekChunk.videoTime !== undefined) {
            // Skip audio chunks that are TOO FAR BEHIND current video position
            if (peekChunk.videoTime < currentVideoTime - 0.15) {
              this.audioBuffer.shift();
              _staleDiscarded++;
              continue;
            }
            // Stop if chunks are TOO FAR AHEAD
            if (peekChunk.videoTime > currentVideoTime + 3.0) {
              break;
            }
          }
          
          // Calculate where this batch should start playing
          // Use sequential tracking: start where the last batch ended
          // This ensures sample-accurate gapless playback between batches
          let batchStartTime = this.audioNextScheduleTime || this.audioScheduledUntil;
          
          // For the first batch (no position ref yet), use video-time alignment
          if (peekChunk.videoTime !== undefined && this.audioPositionRef === null) {
            const videoTimeDelta = peekChunk.videoTime - currentVideoTime;
            const realTimeDelta = videoTimeDelta / effectiveSpeed;
            const videoBasedStart = currentAudioTime + realTimeDelta;
            // Use video-based time if sequential tracking diverged by >150ms
            if (Math.abs(batchStartTime - videoBasedStart) > 0.15) {
              batchStartTime = videoBasedStart;
            }
          }
          
          // Don't schedule in the past - but use a small lookback to avoid gaps
          batchStartTime = Math.max(batchStartTime, currentAudioTime - 0.005);
          
          // Don't schedule too far ahead
          if (batchStartTime > currentAudioTime + MAX_SCHEDULE_LEAD) {
            break;
          }
          
          // Collect consecutive chunks into a batch for concatenation
          const chunksToConcat = [];
          let totalFrames = 0;
          let batchVideoTimeStart = null;
          let batchVideoTimeEnd = null;
          
          while (this.audioBuffer.length > 0) {
            const chunk = this.audioBuffer[0];
            
            // Stop collecting if chunk is too far behind or ahead
            if (chunk.videoTime !== undefined) {
              if (chunk.videoTime < currentVideoTime - 0.15) {
                this.audioBuffer.shift();
                continue;  // Skip stale, keep collecting
              }
              if (chunk.videoTime > currentVideoTime + 3.0) {
                break;
              }
            }
            
            // Check if adding this chunk would exceed our schedule lead
            const chunkDurationAtSpeed = chunk.buffer.duration / effectiveSpeed;
            const projectedEnd = batchStartTime + (totalFrames / sampleRate) / effectiveSpeed + chunkDurationAtSpeed;
            if (projectedEnd > currentAudioTime + MAX_SCHEDULE_LEAD && chunksToConcat.length > 0) {
              break;  // Don't exceed lead, but always take at least one chunk
            }
            
            this.audioBuffer.shift();
            chunksToConcat.push(chunk);
            totalFrames += chunk.buffer.length;
            
            if (batchVideoTimeStart === null && chunk.videoTime !== undefined) {
              batchVideoTimeStart = chunk.videoTime;
            }
            if (chunk.videoTime !== undefined) {
              batchVideoTimeEnd = chunk.videoTime + chunk.buffer.duration;
            }
            
            // Stop when we've collected enough for our target duration
            const batchDuration = totalFrames / sampleRate;
            if (batchDuration >= CONCAT_TARGET_DURATION) {
              break;
            }
          }
          
          if (chunksToConcat.length === 0) break;
          
          try {
            // Concatenate all collected chunks into one AudioBuffer
            let concatBuffer;
            if (chunksToConcat.length === 1) {
              // Single chunk - no concatenation needed
              concatBuffer = chunksToConcat[0].buffer;
            } else {
              // Create concatenated buffer
              concatBuffer = this.audioContext.createBuffer(numChannels, totalFrames, sampleRate);
              let writeOffset = 0;
              for (const chunk of chunksToConcat) {
                for (let ch = 0; ch < numChannels; ch++) {
                  const destData = concatBuffer.getChannelData(ch);
                  const srcData = chunk.buffer.getChannelData(ch);
                  destData.set(srcData, writeOffset);
                }
                writeOffset += chunk.buffer.length;
              }
            }
            
            // Create and schedule the source
            const source = this.audioContext.createBufferSource();
            source.buffer = concatBuffer;
            source.playbackRate.value = effectiveSpeed;
            source.connect(this.audioGain);
            
            // Use sequential schedule time for gapless playback
            const scheduleTime = Math.max(batchStartTime, currentAudioTime);
            source.start(scheduleTime);
            _batchesScheduled++;
            
            // Calculate end time precisely for sequential chaining
            const realDuration = concatBuffer.duration / effectiveSpeed;
            const endTime = scheduleTime + realDuration;
            
            // Update sequential tracking - next batch starts exactly where this one ends
            this.audioNextScheduleTime = endTime;
            this.audioScheduledUntil = endTime;
            
            // Track scheduled source for cleanup on seek
            this.scheduledAudioSources.push({ 
              source, 
              startTime: scheduleTime,
              endTime,
              videoTime: batchVideoTimeStart
            });
            
            // Set position reference (used as "first batch" flag for video-time alignment)
            // Since drift detection now uses scheduledAudioSources directly,
            // this ref is only needed to prevent re-alignment on every scheduling call
            if (batchVideoTimeStart !== null && !this.audioPositionRef) {
              this.audioPositionRef = {
                playTime: scheduleTime,
                videoTime: batchVideoTimeStart
              };
            }
            
            // Clean up finished sources (limit array size)
            if (this.scheduledAudioSources.length > 20) {
              this.scheduledAudioSources = this.scheduledAudioSources.filter(
                s => s.endTime > currentAudioTime
              );
            }
            
            // Track video time of scheduled audio for drift detection
            if (batchVideoTimeEnd !== null) {
              this.lastScheduledVideoTime = batchVideoTimeEnd;
            }
            
            // Track scheduling lead (how far ahead we've scheduled)
            this.audioSchedulingLead = this.audioScheduledUntil - currentAudioTime;
            
            // COMPREHENSIVE DIAGNOSTICS: Log every second
            if (!this._lastAudioDiagLog || now - this._lastAudioDiagLog > 1000) {
              this._lastAudioDiagLog = now;
              this._audioBatchesScheduled = (this._audioBatchesScheduled || 0) + 1;
              
              // Find what chunk is currently PLAYING
              let playingChunkInfo = 'none';
              let playingDrift = null;
              for (const s of this.scheduledAudioSources) {
                if (s.startTime <= currentAudioTime && currentAudioTime < s.endTime && s.videoTime !== null) {
                  const elapsed = currentAudioTime - s.startTime;
                  const audioVideoPos = s.videoTime + elapsed * effectiveSpeed;
                  playingDrift = audioVideoPos - currentVideoTime;
                  playingChunkInfo = 'vt=' + s.videoTime.toFixed(2) + ' audioPos=' + audioVideoPos.toFixed(2);
                }
              }
              
              console.log('INSV AUDIO DIAG: videoTime=' + currentVideoTime.toFixed(2) + 
                         ', batch.videoTime=' + (batchVideoTimeStart || 0).toFixed(2) +
                         ', schedAt=' + scheduleTime.toFixed(2) +
                         ', audioCtx=' + currentAudioTime.toFixed(2) +
                         ', lead=' + (this.audioSchedulingLead * 1000).toFixed(0) + 'ms' +
                         ', buf=' + this.audioBuffer.length +
                         ', sources=' + this.scheduledAudioSources.length +
                         ', playing=[' + playingChunkInfo + ']' +
                         ', playDrift=' + (playingDrift !== null ? (playingDrift * 1000).toFixed(0) + 'ms' : 'N/A') +
                         ', bufIdx=' + this.audioBufferIndex +
                         ', speed=' + effectiveSpeed);
            }
            
            // Debug: log first concatenated schedule
            if (!this._loggedConcatSchedule) {
              console.log('INSV audio concat: ' + chunksToConcat.length + ' chunks -> ' + 
                         (concatBuffer.duration * 1000).toFixed(0) + 'ms buffer, scheduled at ' +
                         scheduleTime.toFixed(3) + 's, lead=' + (this.audioSchedulingLead * 1000).toFixed(0) + 'ms' +
                         ', chunk.videoTime=' + (batchVideoTimeStart || 0).toFixed(3) + 's');
              this._loggedConcatSchedule = true;
            }
          } catch (e) {
            console.error('Audio schedule error:', e);
          }
        }
        
        // Log if chunks were discarded (indicates potential sync issue)
        if (_staleDiscarded > 0) {
          console.log('INSV AUDIO: discarded ' + _staleDiscarded + ' stale chunks (videoTime < ' + 
                     (currentVideoTime - 0.15).toFixed(2) + 's), remaining buf=' + this.audioBuffer.length);
        }
        
        // CRITICAL: Warn if scheduling produced nothing and lead is low
        // This is the "audio about to go silent" condition
        const currentLead = this.audioScheduledUntil - currentAudioTime;
        if (_batchesScheduled === 0 && currentLead < 0.3 && this.playing) {
          if (!this._lastStarvationLog || now - this._lastStarvationLog > 500) {
            this._lastStarvationLog = now;
            console.warn('INSV AUDIO STARVATION: 0 batches scheduled, lead=' + (currentLead * 1000).toFixed(0) + 
                        'ms, buf=' + this.audioBuffer.length + 
                        ', staleDiscarded=' + _staleDiscarded +
                        ', nextScheduleTime=' + (this.audioNextScheduleTime - currentAudioTime).toFixed(3) + 's ahead' +
                        ', videoTime=' + currentVideoTime.toFixed(2) +
                        ', bufIdx=' + this.audioBufferIndex +
                        ', ref=' + (this.audioPositionRef ? 
                          'vt=' + this.audioPositionRef.videoTime.toFixed(2) + '@' + this.audioPositionRef.playTime.toFixed(2) : 'null'));
          }
        }
        
        // Track audio processing performance
        if (typeof perfMonitor !== 'undefined' && perfMonitor.enabled) {
          const elapsed = performance.now() - audioStart;
          const m = perfMonitor.metrics.audioProcess;
          if (m) { m.count++; m.totalMs += elapsed; if (elapsed > m.maxMs) m.maxMs = elapsed; }
        }
      }
      
      // Pre-schedule audio before starting wall-clock to ensure sync
      // Returns true if enough audio is scheduled ahead (lead >= targetLead)
      preScheduleAudio(videoStartTime, targetLead = 0.3) {
        if (!this.audioContext || !this.audioBuffer.length) {
          return false;
        }
        
        const currentAudioTime = this.audioContext.currentTime;
        
        // Initialize offset if not set: audio for videoTime V plays at audioContext time V + offset
        if (this.audioContextOffset === 0) {
          this.audioContextOffset = currentAudioTime - videoStartTime;
          this.audioScheduledUntil = currentAudioTime;
          this.audioNextScheduleTime = currentAudioTime;
          console.log('INSV audio pre-sync: offset=' + this.audioContextOffset.toFixed(2) + 
                      's, videoStart=' + videoStartTime.toFixed(2) + 's');
        }
        
        const effectiveSpeed = typeof playbackSpeed !== 'undefined' ? playbackSpeed : 1;
        const sampleRate = this.audioTrack ? this.audioTrack.audio.sample_rate : 48000;
        const numChannels = this.audioTrack ? this.audioTrack.audio.channel_count : 1;
        
        // Collect all chunks within range and concatenate into batches
        let scheduledCount = 0;
        
        while (this.audioBuffer.length > 0) {
          // Skip stale chunks
          const peek = this.audioBuffer[0];
          if (peek.videoTime !== undefined) {
            if (peek.videoTime < videoStartTime - 0.15) {
              this.audioBuffer.shift();
              continue;
            }
            if (peek.videoTime > videoStartTime + targetLead + 0.5) {
              break;
            }
          }
          
          // Collect chunks for this batch
          const chunksToConcat = [];
          let totalFrames = 0;
          let batchVideoTimeStart = null;
          
          while (this.audioBuffer.length > 0) {
            const chunk = this.audioBuffer[0];
            if (chunk.videoTime !== undefined) {
              if (chunk.videoTime < videoStartTime - 0.15) {
                this.audioBuffer.shift();
                continue;
              }
              if (chunk.videoTime > videoStartTime + targetLead + 0.5) {
                break;
              }
            }
            
            this.audioBuffer.shift();
            chunksToConcat.push(chunk);
            totalFrames += chunk.buffer.length;
            if (batchVideoTimeStart === null && chunk.videoTime !== undefined) {
              batchVideoTimeStart = chunk.videoTime;
            }
            
            // Target ~300ms batches
            if (totalFrames / sampleRate >= 0.3) break;
          }
          
          if (chunksToConcat.length === 0) break;
          
          try {
            // Concatenate chunks
            let concatBuffer;
            if (chunksToConcat.length === 1) {
              concatBuffer = chunksToConcat[0].buffer;
            } else {
              concatBuffer = this.audioContext.createBuffer(numChannels, totalFrames, sampleRate);
              let writeOffset = 0;
              for (const chunk of chunksToConcat) {
                for (let ch = 0; ch < numChannels; ch++) {
                  concatBuffer.getChannelData(ch).set(chunk.buffer.getChannelData(ch), writeOffset);
                }
                writeOffset += chunk.buffer.length;
              }
            }
            
            const source = this.audioContext.createBufferSource();
            source.buffer = concatBuffer;
            source.playbackRate.value = effectiveSpeed;
            source.connect(this.audioGain);
            
            // Use sequential scheduling for gapless playback
            const scheduleTime = Math.max(this.audioNextScheduleTime, currentAudioTime);
            
            if (scheduleTime > currentAudioTime + targetLead + 0.2) break;
            
            source.start(scheduleTime);
            
            const realDuration = concatBuffer.duration / effectiveSpeed;
            const endTime = scheduleTime + realDuration;
            this.audioScheduledUntil = endTime;
            this.audioNextScheduleTime = endTime;
            
            if (!this.scheduledAudioSources) this.scheduledAudioSources = [];
            this.scheduledAudioSources.push({ 
              source, startTime: scheduleTime, endTime,
              videoTime: batchVideoTimeStart
            });
            
            // Set position reference (first batch flag for alignment)
            if (batchVideoTimeStart !== null && !this.audioPositionRef) {
              this.audioPositionRef = { playTime: scheduleTime, videoTime: batchVideoTimeStart };
            }
            
            scheduledCount += chunksToConcat.length;
          } catch (e) {
            console.error('Audio pre-schedule error:', e);
          }
        }
        
        // Calculate current lead
        const lead = this.audioScheduledUntil - currentAudioTime;
        this.audioSchedulingLead = lead;
        
        if (scheduledCount > 0) {
          console.log('INSV audio pre-scheduled:', scheduledCount, 'chunks (concatenated), lead:', (lead * 1000).toFixed(0) + 'ms');
        }
        
        return lead >= targetLead;
      }
      
      recreateAudioDecoder() {
        if (!this.audioTrack) return;
        
        console.log('Recreating audio decoder...');
        
        try {
          if (this.audioDecoder && this.audioDecoder.state !== 'closed') {
            this.audioDecoder.close();
          }
          
          this.audioDecoder = new AudioDecoder({
            output: (audioData) => this.onAudioData(audioData),
            error: (e) => console.error('Audio decoder error:', e)
          });
          
          const audioConfig = {
            codec: this.audioTrack.codec,
            sampleRate: this.audioTrack.audio.sample_rate,
            numberOfChannels: this.audioTrack.audio.channel_count,
          };
          
          if (this.audioDescription) {
            audioConfig.description = this.audioDescription;
          }
          
          this.audioDecoder.configure(audioConfig);
          console.log('Audio decoder recreated successfully');
          
        } catch (e) {
          console.error('Failed to recreate audio decoder:', e);
          this.audioDecoder = null;
        }
      }
      
      async readSampleData(trackIndex, frameIndex) {
        if (this.dataCache[trackIndex].has(frameIndex)) {
          return this.dataCache[trackIndex].get(frameIndex);
        }
        
        const meta = this.sampleMeta[trackIndex][frameIndex];
        if (!meta) return null;
        
        const chunk = await this.file.slice(meta.offset, meta.offset + meta.size).arrayBuffer();
        const data = new Uint8Array(chunk);
        
        this.dataCache[trackIndex].set(frameIndex, data);
        return data;
      }
      
      prefetchFrames(startFrame, count) {
        const endFrame = Math.min(startFrame + count, this.totalFrames);
        
        // OPTIMIZATION: Only prefetch for active lens(es) based on render mode
        const { needTrack0, needTrack1 } = this.getRequiredTracks();
        
        for (let f = startFrame; f < endFrame; f++) {
          if (needTrack0 && !this.dataCache[0].has(f)) this.readSampleData(0, f);
          if (needTrack1 && !this.dataCache[1].has(f)) this.readSampleData(1, f);
        }
        
        const minFrame = Math.max(0, startFrame - 10);
        for (const [idx] of this.dataCache[0]) {
          if (idx < minFrame) this.dataCache[0].delete(idx);
        }
        for (const [idx] of this.dataCache[1]) {
          if (idx < minFrame) this.dataCache[1].delete(idx);
        }
      }
      
      avccToAnnexB(trackIndex, data, isKeyframe) {
        const info = this.trackInfo[trackIndex];
        
        // When description (avcC/hvcC) is provided in decoder config,
        // the decoder expects AVCC format (length-prefixed NALUs), so return as-is
        if (info.description) return data;
        
        // Otherwise convert to Annex B format with start codes
        const startCode = new Uint8Array([0, 0, 0, 1]);
        const chunks = [];
        let totalLength = 0;
        
        if (isKeyframe) {
          if (info.isHEVC && info.vps) {
            chunks.push(startCode, info.vps);
            totalLength += 4 + info.vps.length;
          }
          if (info.sps) {
            chunks.push(startCode, info.sps);
            totalLength += 4 + info.sps.length;
          }
          if (info.pps) {
            chunks.push(startCode, info.pps);
            totalLength += 4 + info.pps.length;
          }
        }
        
        let offset = 0;
        const naluLengthSize = info.naluLengthSize || 4;
        
        while (offset < data.length) {
          let naluLength = 0;
          for (let j = 0; j < naluLengthSize; j++) {
            naluLength = (naluLength << 8) | data[offset + j];
          }
          offset += naluLengthSize;
          
          if (naluLength > 0 && offset + naluLength <= data.length) {
            chunks.push(startCode, data.subarray(offset, offset + naluLength));
            totalLength += 4 + naluLength;
          }
          offset += naluLength;
        }
        
        const result = new Uint8Array(totalLength);
        let pos = 0;
        for (const chunk of chunks) {
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
      
      onFrame(trackIndex, frame) {
        const timestamp = frame.timestamp;
        if (this.pendingFrames[trackIndex].has(timestamp)) {
          this.pendingFrames[trackIndex].get(timestamp).close();
        }
        this.pendingFrames[trackIndex].set(timestamp, frame);
        this.matchFramePairs();
      }
      
      matchFramePairs() {
        const track0Frames = this.pendingFrames[0];
        const track1Frames = this.pendingFrames[1];
        
        // Get current playback target time (for stale frame detection)
        let currentTargetTime = null;
        if (this.playing && this.wallClockStart) {
          const effectiveSpeed = typeof playbackSpeed !== 'undefined' ? playbackSpeed : 1;
          const elapsedSec = (performance.now() - this.wallClockStart) / 1000 * effectiveSpeed;
          currentTargetTime = this.videoTimeAtStart + elapsedSec;
        }
        
        // During preview/seek or initial buffering, always use dual-lens mode
        // This ensures frame pairing works correctly
        const { needTrack0, needTrack1 } = this.getRequiredTracks();
        
        // SINGLE-LENS MODE: Process frames from active decoder only (no pairing needed)
        // Only when single track is needed
        if (!needTrack0 && needTrack1) {
          // Front lens only (track 1) - process track 1 frames without waiting for track 0
          this.processSingleLensFrames(1, track1Frames, currentTargetTime);
          // Clear any stale track 0 frames since we're not using them
          this.clearStaleFrames(track0Frames);
          return;
        }
        
        if (needTrack0 && !needTrack1) {
          // Back lens only (track 0) - process track 0 frames without waiting for track 1
          this.processSingleLensFrames(0, track0Frames, currentTargetTime);
          // Clear any stale track 1 frames since we're not using them
          this.clearStaleFrames(track1Frames);
          return;
        }
        
        // DUAL-LENS MODE: Original pairing logic - wait for both tracks
        for (const timestamp of track0Frames.keys()) {
          if (track1Frames.has(timestamp)) {
            const frame0 = track0Frames.get(timestamp);
            const frame1 = track1Frames.get(timestamp);
            
            const frameIndex = Math.round(timestamp / 1000000);
            const meta = this.sampleMeta[0][frameIndex];
            const time = meta ? meta.cts / meta.timescale : frameIndex / this.frameRate;
            
            // Check if frame is already stale (behind current playback position)
            // Skip stale frames during playback to save memory and avoid buffer bloat
            const staleTolerance = 1.0 / this.frameRate;  // Allow 1 frame tolerance
            const isStale = currentTargetTime !== null && time < currentTargetTime - staleTolerance;
            
            // Frame skipping for performance: only keep frames at target FPS
            // (decoder must decode all frames for H.264, but we discard some)
            const shouldKeep = !isStale && (
                              this.shouldKeepFrame(frameIndex) || 
                              (this.decodedFrameBuffer.length < 3));  // Always keep if buffer is low
            
            if (shouldKeep) {
              this.decodedFrameBuffer.push({ frame0, frame1, frameIndex, time, mode: 'dual' });
            } else {
              // Discard this frame pair (stale or not needed for FPS target)
              if (frame0) frame0.close();
              if (frame1) frame1.close();
              if (isStale) {
                this.framesDropped++;
              }
            }
            
            track0Frames.delete(timestamp);
            track1Frames.delete(timestamp);
          }
        }
        
        if (this.decodedFrameBuffer.length % 100 === 0 && this.decodedFrameBuffer.length > 0) {
          const latestFrame = this.decodedFrameBuffer[this.decodedFrameBuffer.length - 1].frameIndex;
          const cutoff = (latestFrame - 60) * 1000000;
          
          for (const [ts, frame] of track0Frames) {
            if (ts < cutoff) { frame.close(); track0Frames.delete(ts); }
          }
          for (const [ts, frame] of track1Frames) {
            if (ts < cutoff) { frame.close(); track1Frames.delete(ts); }
          }
        }
      }
      
      // Process frames from a single lens without pairing
      processSingleLensFrames(trackIndex, frames, currentTargetTime) {
        for (const [timestamp, frame] of frames) {
          const frameIndex = Math.round(timestamp / 1000000);
          const meta = this.sampleMeta[trackIndex][frameIndex];
          const time = meta ? meta.cts / meta.timescale : frameIndex / this.frameRate;
          
          const staleTolerance = 1.0 / this.frameRate;
          const isStale = currentTargetTime !== null && time < currentTargetTime - staleTolerance;
          const shouldKeep = !isStale && (this.shouldKeepFrame(frameIndex) || this.decodedFrameBuffer.length < 3);
          
          if (shouldKeep) {
            // Store with null for inactive lens
            const framePair = {
              frame0: trackIndex === 0 ? frame : null,
              frame1: trackIndex === 1 ? frame : null,
              frameIndex,
              time,
              mode: 'single',
              activeLens: trackIndex
            };
            this.decodedFrameBuffer.push(framePair);
          } else {
            frame.close();
            if (isStale) this.framesDropped++;
          }
          
          frames.delete(timestamp);
        }
      }
      
      // Clear frames from inactive decoder
      clearStaleFrames(frames) {
        for (const [timestamp, frame] of frames) {
          frame.close();
        }
        frames.clear();
      }
      
      async play() {
        console.log('=== INSV play() ===', {
          ready: this.ready, 
          playing: this.playing, 
          bufferingActive: this.bufferingActive,
          bufferLength: this.decodedFrameBuffer.length,
          playInProgress: this.playInProgress,
          previewInProgress: this.previewInProgress,
          seekInProgress: this.seekInProgress,
          needsDecoderReset: this.needsDecoderReset
        });
        
        if (!this.ready) return;
        
        // SIMPLE RESUME: If buffer is intact and no seek happened, just continue
        // This is the common case for pause/play without timeline changes
        if (!this.playing && 
            !this.seekInProgress && 
            !this.previewInProgress && 
            !this.needsDecoderReset &&
            this.decodedFrameBuffer.length > 0) {
          
          const bufferFrame = this.decodedFrameBuffer[0]?.frameIndex;
          const inSync = bufferFrame !== undefined && Math.abs(bufferFrame - this.currentFrame) <= 5;
          
          if (inSync) {
            console.log('INSV simple resume from frame', this.currentFrame, 
                       'buffer:', this.decodedFrameBuffer.length, 
                       'audio:', this.audioBuffer.length,
                       'hasPausedState:', !!this.pausedWallClockState);
            
            this.playing = true;
            this.requestWakeLock();
            
            // Resume audio context if suspended
            if (this.audioContext?.state === 'suspended') {
              await this.audioContext.resume();
              console.log('Audio context resumed, currentTime:', this.audioContext.currentTime);
            }
            
            // SMOOTH RESUME: Restore wall clock state with time adjustment
            const now = performance.now();
            const effectiveSpeed = typeof playbackSpeed !== 'undefined' ? playbackSpeed : 1;
            
            if (this.pausedWallClockState && this.pausedWallClockState.wallClockStart) {
              // Calculate how much video time should have elapsed
              const videoTimeSincePause = this.currentTime - this.pausedWallClockState.currentTime;
              
              // Only restore if pause was recent (less than 1 second of video time drift)
              if (Math.abs(videoTimeSincePause) < 1.0) {
                // Adjust wall clock start to account for pause duration
                // Calculate new wall clock start that makes currentTime correct
                this.wallClockStart = now - ((this.currentTime - this.pausedWallClockState.videoTimeAtStart) / effectiveSpeed * 1000);
                this.videoTimeAtStart = this.pausedWallClockState.videoTimeAtStart;
                
                // Recalculate audio scheduling based on resumed audioContext time
                // The audioContext.currentTime has advanced during suspend/resume cycle
                // So we need to reset audioScheduledUntil to current audioContext time
                // and let scheduleAudio re-sync properly
                const currentAudioCtxTime = this.audioContext ? this.audioContext.currentTime : 0;
                this.audioScheduledUntil = currentAudioCtxTime;
                this.audioContextOffset = currentAudioCtxTime - this.currentTime;
                this.audioPositionRef = null;  // Let scheduleAudio create new reference
                
                console.log('INSV audio state adjusted for resume, audioCtxTime:', currentAudioCtxTime.toFixed(2),
                           'videoTime:', this.currentTime.toFixed(2));
              } else {
                // Pause was too long, reset wall clock (audio will re-init)
                this.wallClockStart = null;
                this.audioScheduledUntil = 0;
          this.audioNextScheduleTime = 0;  // Force full audio re-init
                console.log('INSV pause too long, resetting wall clock');
              }
              this.pausedWallClockState = null;
            } else {
              // No pause state, reset wall clock
              this.wallClockStart = null;
              this.audioScheduledUntil = 0;
          this.audioNextScheduleTime = 0;  // Force full audio re-init
            }
            
            // Ensure buffer loops are running
            if (!this.bufferLoopRunning) {
              this.startBuffering();
            }
            if (this.audioDecoder && !this.audioBufferLoopRunning) {
              this.startAudioBuffering();
            }
            
            this.isWaiting = false;
            if (this.onStatusChange) this.onStatusChange('playing');
            this.renderLoop();
            return;
          }
        }
        
        // Wait for any in-progress seek to complete (includes preview render)
        if (this.seekInProgress) {
          console.log('INSV play() waiting for seek to complete...');
          const waitStart = performance.now();
          while (this.seekInProgress && performance.now() - waitStart < 2000) {
            await new Promise(r => setTimeout(r, 20));
          }
          console.log('INSV play() seek complete, buffer:', this.decodedFrameBuffer.length);
        }
        
        // Request wake lock to prevent tab throttling during playback
        this.requestWakeLock();
        
        // If preview is in progress, abort it and start fresh
        if (this.previewInProgress) {
          console.log('INSV aborting preview for playback');
          this.playing = true;  // This will cause preview to abort
          // Wait for preview to actually exit
          const abortStart = performance.now();
          while (this.previewInProgress && performance.now() - abortStart < 500) {
            await new Promise(r => setTimeout(r, 10));
          }
          // After preview abort, clear state and start fresh from current position
          for (const framePair of this.decodedFrameBuffer) {
            if (framePair.frame0) framePair.frame0.close();
            if (framePair.frame1) framePair.frame1.close();
          }
          this.decodedFrameBuffer = [];
          for (const [ts, frame] of this.pendingFrames[0]) frame.close();
          for (const [ts, frame] of this.pendingFrames[1]) frame.close();
          this.pendingFrames = [new Map(), new Map()];
          this.bufferFrameIndex = this.currentFrame;  // Reset to current position
          this.needsDecoderReset = true;
          console.log('INSV preview aborted, reset to frame', this.currentFrame);
        }
        
        // If already playing and has frames, just ensure render loop is running
        if (this.playing && this.decodedFrameBuffer.length > 0 && !this.previewInProgress) {
          console.log('INSV already playing with frames, ensuring render loop');
          if (!this.renderLoopRunning) {
            this.renderLoop();
          }
          return;
        }
        
        // Fast resume after seek: we have preview frame, start immediately
        if (!this.previewInProgress && this.decodedFrameBuffer.length >= 1) {
          console.log('INSV fast resume with', this.decodedFrameBuffer.length, 'preview frames');
          this.playing = true;
          this.playbackStartTime = null;
          this.wallClockStart = null;    // Reset wall-clock timing for resume
          this.framesDropped = 0;        // Reset dropped frame counter
          
          // Reset performance monitoring
          this.lastPerformanceCheck = 0;
          this.lastDroppedCount = 0;
          this.bufferUnderruns = 0;
          this.initialSyncDone = false;
          this.performanceMonitoringStarted = false;
          this.lastTimelineSyncCheck = 0;
          this.lastReportedVideoTime = 0;
          
          // Sync to external timeline if available
          if (this.externalTargetTime !== null && this.externalTargetTime !== undefined) {
            this.currentFrame = Math.floor(this.externalTargetTime * this.frameRate);
            this.currentTime = this.externalTargetTime;
          }
          
          // Reset audio timing for proper sync
          this.audioScheduledUntil = 0;
          this.audioNextScheduleTime = 0;
          this.audioContextStartTime = 0;
          this.audioVideoStartTime = 0;
          this.audioContextOffset = 0;
          this.lastAudioSyncCheck = 0;
          this.lastScheduledVideoTime = 0;
          this.audioPositionRef = null;
          
          if (this.audioContext && this.audioContext.state === 'suspended') {
            await this.audioContext.resume();
          }
          
          // Start buffer loops (will reset decoders in background if needed)
          if (!this.bufferLoopRunning) {
            this.startBuffering();
          }
          if (this.audioDecoder && !this.audioBufferLoopRunning) {
            this.startAudioBuffering();
          }
          
          this.isWaiting = false;
          if (this.onStatusChange) this.onStatusChange('playing');
          this.renderLoop();
          return;
        }
        
        // Prevent multiple simultaneous play attempts
        if (this.playInProgress) {
          console.log('INSV play() already in progress');
          return;
        }
        
        this.playInProgress = true;
        this.playing = true;
        this.lastRenderTime = performance.now();
        this.fpsLastTime = performance.now();
        this.fpsFrameCount = 0;
        this.playbackStartTime = null;  // Reset for proper sync
        this.renderStartTime = null;    // Reset strict timing
        this.wallClockStart = null;     // Reset wall-clock timing (will be set in renderLoop)
        this.framesDropped = 0;         // Reset dropped frame counter
        
        // Reset performance monitoring
        this.lastPerformanceCheck = 0;
        this.lastDroppedCount = 0;
        this.bufferUnderruns = 0;
        this.initialSyncDone = false;
        this.performanceMonitoringStarted = false;
        this.lastTimelineSyncCheck = 0;
        this.lastReportedVideoTime = 0;
        
        // Reset audio timing for proper sync
        this.audioScheduledUntil = 0;
          this.audioNextScheduleTime = 0;
        this.audioContextStartTime = 0;
        this.audioVideoStartTime = 0;
        this.audioContextOffset = 0;
        this.lastAudioSyncCheck = 0;
        this.lastScheduledVideoTime = 0;
        this.audioPositionRef = null;
        
        // Resume audio context (required for user gesture)
        if (this.audioContext && this.audioContext.state === 'suspended') {
          await this.audioContext.resume();
          console.log('Audio context resumed');
        }
        
        this.isWaiting = true;
        if (this.onStatusChange) this.onStatusChange('waiting');
        
        // Start video buffering if not already running
        if (!this.bufferLoopRunning) {
          this.startBuffering();
        }
        
        // Start audio buffering
        if (this.audioDecoder && !this.audioBufferLoopRunning) {
          this.startAudioBuffering();
        }
        
        this._updateLoading('Buffering...');
        const waitStart = performance.now();
        let lastLogTime = 0;
        const minVideoFrames = 5;
        const minAudioChunks = 10;  // Wait for decoded audio chunks before starting
        
        // Wait for minimum video frames AND audio buffer
        while (performance.now() - waitStart < 10000 && this.playing) {
          const videoReady = this.decodedFrameBuffer.length >= minVideoFrames;
          const audioReady = !this.audioDecoder || this.audioBuffer.length >= minAudioChunks;
          
          if (videoReady && audioReady) {
            break;
          }
          
          const now = performance.now();
          if (now - lastLogTime > 1000) {
            console.log('INSV buffering:', {
              frames: this.decodedFrameBuffer.length,
              audioChunks: this.audioBuffer.length,
              pendingT0: this.pendingFrames[0].size,
              pendingT1: this.pendingFrames[1].size,
              bufferIndex: this.bufferFrameIndex,
              currentFrame: this.currentFrame,
              decoder0State: this.decoders[0]?.state,
              decoder1State: this.decoders[1]?.state,
              decoder0Queue: this.decoders[0]?.decodeQueueSize,
              decoder1Queue: this.decoders[1]?.decodeQueueSize,
              bufferingActive: this.bufferingActive,
              bufferLoopRunning: this.bufferLoopRunning
            });
            lastLogTime = now;
          }
          this._updateLoading(`Buffering: ${this.decodedFrameBuffer.length} video, ${this.audioBuffer.length} audio`);
          await new Promise(r => setTimeout(r, 50));
        }
        
        // Resume audio context (required for user gesture) but DON'T schedule audio yet
        // Audio will be scheduled when wall-clock starts in renderLoop
        if (this.audioContext && this.audioContext.state === 'suspended') {
          await this.audioContext.resume();
          console.log('INSV audio context resumed, waiting for playback start');
        }
        
        console.log('INSV buffer wait complete:', {
          frames: this.decodedFrameBuffer.length,
          audioChunks: this.audioBuffer.length,
          pendingT0: this.pendingFrames[0].size,
          pendingT1: this.pendingFrames[1].size,
          stillPlaying: this.playing
        });
        
        this.playInProgress = false;
        
        // Handle any pending seek that was requested during initial buffering
        if (this.pendingSeekTime !== null) {
          const seekTime = this.pendingSeekTime;
          this.pendingSeekTime = null;
          console.log('Processing deferred seek to:', seekTime);
          await this.seek(seekTime);
          // Need to re-buffer after seek
          if (this.decodedFrameBuffer.length === 0 && this.playing) {
            const rebufferStart = performance.now();
            while (this.decodedFrameBuffer.length < 5 && performance.now() - rebufferStart < 3000 && this.playing) {
              await new Promise(r => setTimeout(r, 50));
            }
          }
        }
        
        if (!this.playing) {
          console.log('INSV playback stopped during buffering');
          return;
        }
        
        if (this.decodedFrameBuffer.length > 0) {
          this._updateLoading('');
          this.isWaiting = false;
          if (this.onStatusChange) this.onStatusChange('playing');
          this.renderLoop();
        } else {
          console.error('Failed to buffer initial frames');
          this._updateLoading('Buffer failed - codec may not be supported');
        }
      }
      
      async pause() {
        console.log('INSV pause()', {
          bufferLength: this.decodedFrameBuffer.length,
          pendingT0: this.pendingFrames[0].size,
          pendingT1: this.pendingFrames[1].size,
          playInProgress: this.playInProgress
        });
        
        this.playing = false;
        this.renderLoopRunning = false;
        this.playbackStartTime = null;
        this.renderStartTime = null;  // Reset strict timing
        
        // PRESERVE wall clock and audio state for smooth resume
        // Store current state instead of clearing it
        this.pausedWallClockState = {
          wallClockStart: this.wallClockStart,
          videoTimeAtStart: this.videoTimeAtStart,
          currentTime: this.currentTime,
          audioScheduledUntil: this.audioScheduledUntil,
          audioContextOffset: this.audioContextOffset,
          audioPositionRef: this.audioPositionRef,
          audioContextTime: this.audioContext ? this.audioContext.currentTime : 0
        };
        this.wallClockStart = null;   // Mark as paused (will restore on resume)
        
        // Stop all scheduled audio sources - they become invalid after suspend
        if (this.scheduledAudioSources && this.scheduledAudioSources.length > 0) {
          for (const scheduled of this.scheduledAudioSources) {
            try { if (scheduled.source) scheduled.source.stop(); } catch (e) {}
          }
          this.scheduledAudioSources = [];
        }
        
        // DON'T clear the buffer - keep decoded frames for instant resume
        // DON'T stop buffering - continue pre-buffering during pause
        // Buffer loop will detect playing=false and switch to idle mode
        
        // Clear loading status
        this._updateLoading('');
        this.isWaiting = false;
        
        // Notify status change to paused
        if (this.onStatusChange) this.onStatusChange('paused');
        
        // Suspend audio (but keep video buffer) - AWAIT to ensure complete
        if (this.audioContext && this.audioContext.state === 'running') {
          try {
            await this.audioContext.suspend();
            console.log('INSV audio context suspended');
          } catch (e) {
            console.warn('INSV audio context suspend error:', e);
          }
        }
        
        // Stop audio buffering (we'll restart on play)
        this.audioBufferingActive = false;
        
        // Release wake lock when pausing
        this.releaseWakeLock();
      }
      
      // Full stop with cleanup - use when switching videos or closing
      stop() {
        console.log('INSV stop() - full cleanup');
        
        this.playing = false;
        this.renderLoopRunning = false;
        this.bufferingActive = false;
        this.audioBufferingActive = false;
        this.playbackStartTime = null;
        this.renderStartTime = null;
        this.wallClockStart = null;  // Reset wall-clock timing
        
        // Clean up decoded frame buffer to prevent VideoFrame leaks
        while (this.decodedFrameBuffer.length > 0) {
          const framePair = this.decodedFrameBuffer.shift();
          if (framePair.frame0) framePair.frame0.close();
          if (framePair.frame1) framePair.frame1.close();
        }
        
        // Clean up pending frames
        for (const [ts, frame] of this.pendingFrames[0]) {
          frame.close();
        }
        for (const [ts, frame] of this.pendingFrames[1]) {
          frame.close();
        }
        this.pendingFrames = [new Map(), new Map()];
        
        // Clear loading status
        this._updateLoading('');
        this.isWaiting = false;
        
        if (this.onStatusChange) this.onStatusChange('stopped');
        
        // Close audio context
        if (this.audioContext) {
          this.audioContext.close().catch(() => {});
        }
        
        // Release wake lock and clean up visibility handler
        this.releaseWakeLock();
        if (this.visibilityHandlerBound) {
          document.removeEventListener('visibilitychange', this.visibilityHandlerBound);
          this.visibilityHandlerBound = null;
        }
      }
      
      startAudioBuffering() {
        if (this.audioBufferLoopRunning) {
          console.log('INSV audio buffer loop already running');
          return;
        }
        this.audioBufferingActive = true;
        this.audioBufferLoopRunning = true;
        this.audioBufferLoop();
      }
      
      async audioBufferLoop() {
        // Use shorter interval (50ms) for smoother audio
        // Audio at 48kHz with ~1024 sample chunks = ~21ms per chunk
        // At 50ms interval we can keep up with 2-3 chunks per cycle
        const AUDIO_LOOP_INTERVAL = 50;
        
        while (this.audioBufferingActive && this.playing) {
          try {
            const bufBefore = this.audioBuffer.length;
            const idxBefore = this.audioBufferIndex;
            // Decode more audio ahead to build comfortable buffer
            await this.decodeAudioForTime(this.currentTime, 3);
            const bufAfter = this.audioBuffer.length;
            const idxAfter = this.audioBufferIndex;
            
            // Log decode results periodically
            if (!this._lastDecodeLog || performance.now() - this._lastDecodeLog > 2000) {
              this._lastDecodeLog = performance.now();
              const firstVT = this.audioBuffer.length > 0 && this.audioBuffer[0].videoTime !== undefined ? 
                              this.audioBuffer[0].videoTime.toFixed(2) : 'N/A';
              const lastVT = this.audioBuffer.length > 0 && this.audioBuffer[this.audioBuffer.length-1].videoTime !== undefined ? 
                             this.audioBuffer[this.audioBuffer.length-1].videoTime.toFixed(2) : 'N/A';
              console.log('INSV AUDIO decode: currentTime=' + this.currentTime.toFixed(2) + 
                         ', buf ' + bufBefore + '->' + bufAfter +
                         ', idx ' + idxBefore + '->' + idxAfter + '/' + this.audioSampleMeta.length +
                         ', buf range=[' + firstVT + ',' + lastVT + ']' +
                         ', lead=' + (this.audioSchedulingLead * 1000).toFixed(0) + 'ms');
            }
            
            this.scheduleAudio();
          } catch (e) {
            console.error('Audio buffer loop error:', e);
          }
          await new Promise(r => setTimeout(r, AUDIO_LOOP_INTERVAL));
        }
        this.audioBufferLoopRunning = false;
      }
      
      startBuffering() {
        // Don't start buffering during seek or preview (preview handles decoding)
        if (this.seekInProgress || this.previewInProgress) {
          console.log('INSV startBuffering skipped -', this.seekInProgress ? 'seek' : 'preview', 'in progress');
          return;
        }
        
        console.log('INSV startBuffering from frame', this.bufferFrameIndex, 'loopRunning:', this.bufferLoopRunning);
        
        // If buffer loop is actually running, don't start another
        if (this.bufferLoopRunning) {
          console.log('INSV buffer loop already running');
          return;
        }
        
        this.bufferingActive = true;
        this.bufferLoopRunning = true;
        this.bufferFrames();
      }
      
      async bufferFrames() {
        const MAX_QUEUE_SIZE = 20;
        let loopCount = 0;
        
        // Continue buffering while active, even when paused (for pre-buffering)
        while (this.bufferingActive) {
          // Exit immediately if seek or preview is in progress (preview will handle decoding)
          if (this.seekInProgress || this.previewInProgress) {
            console.log('INSV bufferFrames loop: exiting for', this.seekInProgress ? 'seek' : 'preview');
            break;
          }
          
          loopCount++;
          const bufferedCount = this.decodedFrameBuffer.length;
          const isPaused = !this.playing;
          
          // When paused: buffer up to maxBufferSize then stop
          // When playing: use adaptive target based on current buffer level
          if (isPaused && bufferedCount >= this.maxBufferSize) {
            // Buffer is full while paused - sleep longer
            await new Promise(r => setTimeout(r, 100));
            continue;
          }
          
          // Adaptive buffer target:
          // - When buffer is low (<comfortableBuffer): fill quickly to minBufferTarget
          // - When buffer is comfortable: fill to maxBufferSize using spare capacity
          // This allows building a large buffer during idle time for spike protection
          const currentBufferTarget = bufferedCount < this.comfortableBuffer 
            ? this.comfortableBuffer   // Fast fill to comfortable level
            : this.maxBufferSize;       // Then fill to max using spare cycles
          
          // Log periodically (less frequently when paused)
          const logInterval = isPaused ? 500 : 100;
          if (loopCount % logInterval === 1) {
            const queueSizeForLog = Math.max(
              this.decoders[0]?.decodeQueueSize || 0,
              this.decoders[1]?.decodeQueueSize || 0
            );
            console.log('INSV bufferFrames loop:', {
              buffered: bufferedCount,
              target: currentBufferTarget,
              paused: isPaused,
              bufferIndex: this.bufferFrameIndex,
              totalFrames: this.totalFrames,
              queueSize: queueSizeForLog,
              queueT0: this.decoders[0]?.decodeQueueSize,
              queueT1: this.decoders[1]?.decodeQueueSize,
              pendingT0: this.pendingFrames[0].size,
              pendingT1: this.pendingFrames[1].size,
              decoderState0: this.decoders[0]?.state,
              decoderState1: this.decoders[1]?.state,
              needsReset: this.needsDecoderReset
            });
          }
          
          if (this.bufferFrameIndex < this.totalFrames) {
            this.prefetchFrames(this.bufferFrameIndex, this.cacheAheadCount);
          }
          
          const queueSize = Math.max(
            this.decoders[0]?.decodeQueueSize || 0,
            this.decoders[1]?.decodeQueueSize || 0
          );
          
          // Only update waiting status when playing
          if (!isPaused) {
            if (bufferedCount < 5 && !this.isWaiting) {
              this.isWaiting = true;
              if (this.onStatusChange) this.onStatusChange('waiting');
            } else if (bufferedCount >= 10 && this.isWaiting) {
              this.isWaiting = false;
              if (this.onStatusChange) this.onStatusChange('playing');
            }
          }
          
          if (bufferedCount < currentBufferTarget && this.bufferFrameIndex < this.totalFrames && queueSize < MAX_QUEUE_SIZE) {
            try {
              // Grace period after decoder reset - feed frames slowly to let decoders warm up
              const timeSinceReset = performance.now() - (this.decoderResetTime || 0);
              const inGracePeriod = timeSinceReset < 500;  // 500ms grace period
              
              // Feed more frames when buffer is low, fewer when building reserve or paused
              // During grace period, feed only 1 frame at a time
              let urgency;
              if (inGracePeriod) {
                urgency = 1;  // Single frame at a time during grace period
              } else if (isPaused) {
                urgency = 2;
              } else {
                urgency = bufferedCount < this.comfortableBuffer ? 5 : 3;
              }
              
              const framesToFeed = Math.min(MAX_QUEUE_SIZE - queueSize, this.totalFrames - this.bufferFrameIndex, urgency);
              for (let i = 0; i < framesToFeed; i++) {
                // Exit immediately if preview starts
                if (this.previewInProgress || this.seekInProgress || !this.bufferingActive) {
                  break;
                }
                await this.decodeNextFrame();
                // During grace period, add small delay between frames
                if (inGracePeriod && i < framesToFeed - 1) {
                  await new Promise(r => setTimeout(r, 10));
                }
              }
            } catch (e) {
              console.error('Buffer decode error:', e);
              await new Promise(r => setTimeout(r, 10));
            }
          } else if (queueSize >= MAX_QUEUE_SIZE) {
            // Decoder queue is full - wait for it to drain
            // But if stuck for too long (buffer not growing), force a reset
            
            // IMPORTANT: When playback is paused, queue being full is EXPECTED
            // because frames aren't being consumed. Don't count this as "stuck".
            // Track buffer high-water mark - if buffer EVER grew during wait, not stuck.
            if (!isPaused) {
              if (!this.queueStuckCounter) {
                this.queueStuckCounter = 0;
                this.stuckBufferHighWater = bufferedCount;
              }
              
              // Update high water mark
              if (bufferedCount > this.stuckBufferHighWater) {
                this.stuckBufferHighWater = bufferedCount;
                // Buffer grew! Reset stuck counter
                this.queueStuckCounter = 0;
              } else {
                // Buffer hasn't exceeded high water mark
                this.queueStuckCounter++;
              }
            } else {
              // Reset stuck counter when paused - not stuck, just not consuming
              this.queueStuckCounter = 0;
              this.stuckBufferHighWater = null;
            }
            
            // Check if we're in grace period after a recent reset
            const timeSinceReset = performance.now() - (this.decoderResetTime || 0);
            const inGracePeriod = timeSinceReset < 5000;  // 5 second grace period for stuck detection
            
            // FIXED: Only trigger stuck reset when buffer is CRITICALLY LOW
            // If buffer >= 5 frames, playback is fine even if not growing (decoder keeping up)
            // Stuck detection only matters when we're starving for frames
            const bufferCriticallyLow = bufferedCount < 5;
            
            // If queue has been full for 3000+ iterations (~3s) with no buffer growth
            // AND buffer is critically low (actual playback problem), force reset
            // BUT not during grace period - give decoders time to warm up
            // AND not when paused - paused means frames aren't being consumed
            if (this.queueStuckCounter > 3000 && bufferCriticallyLow && !isPaused && !inGracePeriod) {
              console.log('INSV buffer queue stuck (no growth for 3s, buffer critically low: ' + bufferedCount + '), forcing decoder reset');
              this.stuckBufferHighWater = null;
              await this.resetDecoders();
              continue;  // Retry immediately after reset
            }
            
            // DIAGNOSTIC: Log when stuck waiting for decoder queue (only when playing)
            if (loopCount % 1000 === 1 && !isPaused) {
              console.log('INSV buffer WAITING for decoder queue:', {
                queueSize: queueSize,
                maxQueue: MAX_QUEUE_SIZE,
                buffered: bufferedCount,
                highWater: this.stuckBufferHighWater,
                pendingT0: this.pendingFrames[0].size,
                pendingT1: this.pendingFrames[1].size,
                stuckCounter: this.queueStuckCounter,
                inGracePeriod: inGracePeriod
              });
            }
            await new Promise(r => setTimeout(r, 1));
          } else {
            // Reset stuck counter and high water mark when not blocked by queue
            this.queueStuckCounter = 0;
            this.stuckBufferHighWater = null;
            
            // DIAGNOSTIC: Log why we're not decoding
            if (loopCount % 1000 === 1 && isPaused && bufferedCount < currentBufferTarget) {
              console.log('INSV buffer NOT DECODING:', {
                reason: bufferedCount >= currentBufferTarget ? 'buffer full' : 
                        this.bufferFrameIndex >= this.totalFrames ? 'end of video' : 'unknown',
                buffered: bufferedCount,
                target: currentBufferTarget,
                bufferIndex: this.bufferFrameIndex,
                totalFrames: this.totalFrames,
                queueSize: queueSize
              });
            }
            // Buffer is full or at target - sleep longer to save CPU
            // Sleep even longer when paused
            const sleepTime = isPaused ? 50 : (bufferedCount >= this.maxBufferSize ? 50 : 5);
            await new Promise(r => setTimeout(r, sleepTime));
          }
        }
        
        // Mark loop as stopped
        this.bufferLoopRunning = false;
        console.log('INSV bufferFrames loop exited, playing:', this.playing, 'bufferingActive:', this.bufferingActive);
      }
      
      // Reset video decoders - used after seek or when decoders are stuck
      async resetDecoders() {
        const frameIndex = this.bufferFrameIndex;
        
        // If decoders are corrupted, recreate them from scratch
        if (this.decodersCorrupted) {
          console.log('INSV resetDecoders: decoders corrupted, recreating...');
          await this.recreateVideoDecoders();
        }
        
        // Find nearest keyframe
        let keyFrameIndex = frameIndex;
        for (let i = frameIndex; i >= 0; i--) {
          if (this.sampleMeta[0][i]?.is_sync) { keyFrameIndex = i; break; }
        }
        
        console.log('INSV resetDecoders at frame', frameIndex, '-> keyframe', keyFrameIndex);
        
        // Clear any pending frames from old decoder state
        for (const [ts, frame] of this.pendingFrames[0]) frame.close();
        for (const [ts, frame] of this.pendingFrames[1]) frame.close();
        this.pendingFrames = [new Map(), new Map()];
        
        // Reset decoders
        for (let t = 0; t < 2; t++) {
          if (this.decoders[t] && this.decoders[t].state !== 'closed') {
            try {
              this.decoders[t].reset();
              const config = {
                codec: this.tracks[t].codec,
                codedWidth: this.width,
                codedHeight: this.height,
                hardwareAcceleration: 'prefer-hardware',
              };
              if (this.trackInfo[t].description) config.description = this.trackInfo[t].description;
              this.decoders[t].configure(config);
            } catch (e) {
              console.error('Decoder reset error:', e);
              // Mark as corrupted for next attempt
              this.decodersCorrupted = true;
            }
          }
        }
        
        this.needsDecoderReset = false;
        this.bufferFrameIndex = keyFrameIndex;
        this.queueStuckCounter = 0;
        
        // Reset audio to match new video position
        if (this.audioTrack && this.audioSampleMeta.length > 0) {
          const targetTime = keyFrameIndex / this.frameRate;
          const timescale = this.audioTrack.timescale;
          
          // Binary search for audio position
          let lo = 0, hi = this.audioSampleMeta.length - 1;
          while (lo < hi) {
            const mid = Math.floor((lo + hi) / 2);
            if (this.audioSampleMeta[mid].cts / timescale < targetTime) {
              lo = mid + 1;
            } else {
              hi = mid;
            }
          }
          this.audioBufferIndex = Math.max(0, lo - 5);
          
          // Clear stale audio buffer
          this.audioBuffer = [];
          this.audioScheduledUntil = 0;
          this.audioNextScheduleTime = 0;
          this.audioContextOffset = 0;
          this.audioPositionRef = null;  // Clear drift detection reference
          this.lastAudioSyncCheck = 0;   // Allow immediate resync check
          
          // Stop all scheduled audio sources to prevent old audio playing
          if (this.scheduledAudioSources && this.scheduledAudioSources.length > 0) {
            const currentTime = this.audioContext ? this.audioContext.currentTime : 0;
            for (const scheduled of this.scheduledAudioSources) {
              try {
                // Stop sources that haven't finished yet
                if (scheduled.endTime > currentTime) {
                  scheduled.source.stop();
                }
              } catch (e) {
                // Source may already be stopped
              }
            }
            this.scheduledAudioSources = [];
          }
          
          // Reset audio decoder to clear any in-flight chunks
          if (this.audioDecoder && this.audioDecoder.state === 'configured') {
            try {
              this.audioDecoder.reset();
              const audioConfig = {
                codec: this.audioTrack.codec,
                sampleRate: this.audioTrack.audio.sample_rate,
                numberOfChannels: this.audioTrack.audio.channel_count,
              };
              if (this.audioDescription) audioConfig.description = this.audioDescription;
              this.audioDecoder.configure(audioConfig);
            } catch (e) {
              console.error('Audio reset during decoder reset:', e);
            }
          }
        }
        
        // Set grace period after reset - limits frame feeding to let decoders warm up
        this.decoderResetTime = performance.now();
        
        // Small delay to let hardware decoders wake up (especially when paused)
        await new Promise(r => setTimeout(r, 50));
      }
      
      async decodeNextFrame() {
        const decodeStart = performance.now();
        const frameIndex = this.bufferFrameIndex;
        if (frameIndex >= this.totalFrames) return;
        
        // Only reset decoders when we actually need to (after a seek to a new position)
        if (this.needsDecoderReset) {
          await this.resetDecoders();
        }
        
        // OPTIMIZATION: Only decode tracks needed for current render mode
        // Uses targetRenderMode (shader selection) and visibleLens (viewport direction)
        // Track 0 = back lens, Track 1 = front lens
        const { needTrack0, needTrack1 } = this.getRequiredTracks();
        
        // Read only needed track data
        const [data0, data1] = await Promise.all([
          needTrack0 ? this.readSampleData(0, this.bufferFrameIndex) : Promise.resolve(null),
          needTrack1 ? this.readSampleData(1, this.bufferFrameIndex) : Promise.resolve(null)
        ]);
        
        const meta0 = this.sampleMeta[0][this.bufferFrameIndex];
        const meta1 = this.sampleMeta[1][this.bufferFrameIndex];
        
        // Decode track 0 (back lens) only if needed
        if (needTrack0 && data0 && meta0 && this.decoders[0] && this.decoders[0].state === 'configured') {
          const processed0 = this.avccToAnnexB(0, data0, meta0.is_sync);
          const chunk0 = new EncodedVideoChunk({
            type: meta0.is_sync ? 'key' : 'delta',
            timestamp: this.bufferFrameIndex * 1000000,
            duration: meta0.duration * 1000000 / meta0.timescale,
            data: processed0
          });
          this.decoders[0].decode(chunk0);
          this.activeDecoders[0] = true;
        } else {
          this.activeDecoders[0] = false;
        }
        
        // Decode track 1 (front lens) only if needed
        if (needTrack1 && data1 && meta1 && this.decoders[1] && this.decoders[1].state === 'configured') {
          const processed1 = this.avccToAnnexB(1, data1, meta1.is_sync);
          const chunk1 = new EncodedVideoChunk({
            type: meta1.is_sync ? 'key' : 'delta',
            timestamp: this.bufferFrameIndex * 1000000,
            duration: meta1.duration * 1000000 / meta1.timescale,
            data: processed1
          });
          this.decoders[1].decode(chunk1);
          this.activeDecoders[1] = true;
        } else {
          this.activeDecoders[1] = false;
        }
        
        this.bufferFrameIndex++;
        
        // Track decode performance
        if (typeof perfMonitor !== 'undefined' && perfMonitor.enabled) {
          const elapsed = performance.now() - decodeStart;
          const m = perfMonitor.metrics.videoDecode;
          if (m) { m.count++; m.totalMs += elapsed; if (elapsed > m.maxMs) m.maxMs = elapsed; }
        }
      }
      
      renderLoop() {
        if (!this.playing) {
          this.renderLoopRunning = false;
          return;
        }
        
        // If seek or preview is in progress, stop this loop - seek() will restart it
        if (this.seekInProgress || this.previewInProgress) {
          this.renderLoopRunning = false;
          // DON'T reschedule - seek() will call renderLoop() when ready
          return;
        }
        
        // Check if this is a stale callback from before a seek
        // If wallClockStart was cleared by seek, we need fresh initialization
        // but only ONE callback should do it
        if (!this.renderLoopRunning) {
          // First callback after seek - mark as running
          this.renderLoopRunning = true;
        }
        
        const now = performance.now();
        const effectiveSpeed = typeof playbackSpeed !== 'undefined' ? playbackSpeed : 1;
        
        // Initialize wall-clock timing on first frame
        if (!this.wallClockStart) {
          this.wallClockStart = now;
          // Start from first buffered frame or current position
          if (this.decodedFrameBuffer.length > 0) {
            this.videoTimeAtStart = this.decodedFrameBuffer[0].time;
          } else {
            this.videoTimeAtStart = this.currentTime || 0;
          }
          // Reset stuck frame detection on fresh playback start
          this.lastFrameAdvanceCheck = null;
          this.stuckFrameWarnings = 0;
          console.log('INSV wall-clock playback started at videoTime:', this.videoTimeAtStart.toFixed(2) + 's');
        }
        
        // Calculate target video time from wall clock (THIS IS THE KEY!)
        // Wall clock always advances at real-time rate, so video time must match
        const elapsedSec = (now - this.wallClockStart) / 1000 * effectiveSpeed;
        const targetVideoTime = this.videoTimeAtStart + elapsedSec;
        const targetFrame = Math.floor(targetVideoTime * this.frameRate);
        
        // Update currentTime FIRST from wall clock (ensures telemetry sync)
        this.currentTime = targetVideoTime;
        
        // Check for buffer underrun - but still advance time
        if (this.decodedFrameBuffer.length < 2 && this.bufferFrameIndex < this.totalFrames) {
          // Buffer is low, ensure buffer loop is running (but NOT during seek/preview)
          if (!this.bufferLoopRunning && !this.seekInProgress && !this.previewInProgress) {
            console.log('INSV renderLoop: buffer low, restarting buffer loop');
            this.startBuffering();
          }
          
          // Show waiting status but DON'T pause wall clock
          if (!this.isWaiting) {
            this.isWaiting = true;
            if (this.onStatusChange) this.onStatusChange('waiting');
            this._updateLoading(`Rebuffering: ${this.decodedFrameBuffer.length} frames`);
          }
          
          // Continue with whatever frames we have (may repeat last frame)
        }
        
        // Ensure audio buffer loop is running during playback
        if (this.audioDecoder && !this.audioBufferLoopRunning && this.playing) {
          this.startAudioBuffering();
        }
        
        // Buffer is OK, clear waiting state
        if (this.isWaiting && this.decodedFrameBuffer.length >= 5) {
          this.isWaiting = false;
          if (this.onStatusChange) this.onStatusChange('playing');
          this._updateLoading('');
        }
        
        // Seek recovery: consume frames quickly after seek
        if (this.seekRecoveryFrames > 0 && this.decodedFrameBuffer.length > 0) {
          this.decodedFrameBuffer.sort((a, b) => a.frameIndex - b.frameIndex);
          const framePair = this.decodedFrameBuffer.shift();
          this.drawFramePair(framePair);
          if (framePair.frame0) framePair.frame0.close();
          if (framePair.frame1) framePair.frame1.close();
          this.currentFrame = framePair.frameIndex;
          this.seekRecoveryFrames--;
          
          if (this.seekRecoveryFrames === 0) {
            // Reset wall-clock start to current position
            this.wallClockStart = now;
            this.videoTimeAtStart = framePair.time;
          }
          
          requestAnimationFrame(() => this.renderLoop());
          return;
        }
        
        // WALL-CLOCK DRIVEN FRAME SELECTION
        if (this.decodedFrameBuffer.length > 0) {
          // Sort buffer by frame index if needed
          if (this.decodedFrameBuffer.length > 1 && 
              this.decodedFrameBuffer[0].frameIndex > this.decodedFrameBuffer[1].frameIndex) {
            this.decodedFrameBuffer.sort((a, b) => a.frameIndex - b.frameIndex);
          }
          
          // Find best frame: closest to targetVideoTime without being too far in future
          // Drop all frames that are older than targetVideoTime - tolerance
          const tolerance = 0.5 / this.frameRate;  // Half a frame tolerance
          let bestFrameIndex = -1;
          let framesToDrop = 0;
          
          for (let i = 0; i < this.decodedFrameBuffer.length; i++) {
            const frame = this.decodedFrameBuffer[i];
            if (frame.time <= targetVideoTime + tolerance) {
              bestFrameIndex = i;
            }
            // Count frames that are too old (more than 2 frames behind)
            if (frame.time < targetVideoTime - (2 / this.frameRate)) {
              framesToDrop++;
            }
          }
          
          // Drop stale frames (keep at least one for display)
          if (framesToDrop > 0 && this.decodedFrameBuffer.length > framesToDrop) {
            for (let i = 0; i < framesToDrop; i++) {
              const dropped = this.decodedFrameBuffer.shift();
              if (dropped.frame0) dropped.frame0.close();
              if (dropped.frame1) dropped.frame1.close();
              this.framesDropped++;
            }
            // Adjust bestFrameIndex after dropping
            bestFrameIndex -= framesToDrop;
          }
          
          // Render the best frame if found
          if (bestFrameIndex >= 0 && bestFrameIndex < this.decodedFrameBuffer.length) {
            // Remove frames up to and including the best frame
            for (let i = 0; i < bestFrameIndex; i++) {
              const skipped = this.decodedFrameBuffer.shift();
              if (skipped.frame0) skipped.frame0.close();
              if (skipped.frame1) skipped.frame1.close();
              this.framesDropped++;
            }
            
            const framePair = this.decodedFrameBuffer.shift();
            if (typeof perfMonitor !== 'undefined' && perfMonitor.enabled) {
              const start = performance.now();
              this.drawFramePair(framePair);
              const elapsed = performance.now() - start;
              const m = perfMonitor.metrics.videoRender;
              if (m) { m.count++; m.totalMs += elapsed; if (elapsed > m.maxMs) m.maxMs = elapsed; }
            } else {
              this.drawFramePair(framePair);
            }
            
            // Store for potential repeat display
            this.lastRenderedFrameData = {
              frameIndex: framePair.frameIndex,
              time: framePair.time
            };
            
            // Close frames (null check for single-lens mode)
            if (framePair.frame0) framePair.frame0.close();
            if (framePair.frame1) framePair.frame1.close();
            
            this.currentFrame = framePair.frameIndex;
            this.fpsFrameCount++;
          }
          // If no suitable frame found, lastRenderedFrameData stays on screen (implicit repeat)
        }
        
        // WALL-CLOCK MODE: Performance monitoring (no drift possible - both clocks are wall time)
        // Initial sync: sync timeline to video once after playback stabilizes
        if (!this.initialSyncDone && this.currentTime > 1.0 && this.decodedFrameBuffer.length >= 3) {
          this.initialSyncDone = true;
          this.lastTimelineSyncCheck = now;
          this.lastReportedVideoTime = this.currentTime;
          if (this.onSyncToVideo) {
            console.log('INSV initial timeline sync at videoTime:', this.currentTime.toFixed(2) + 's');
            this.onSyncToVideo(this.currentTime);
          }
        }
        
        // Periodic timeline sync check: ensure telemetry/map stays synced with video
        // Check every 1 second after initial sync is done
        // syncTimelineToVideo will determine if actual correction is needed
        if (this.initialSyncDone && now - this.lastTimelineSyncCheck >= this.timelineSyncCheckInterval) {
          this.lastTimelineSyncCheck = now;
          
          // Report current video time to timeline
          // syncTimelineToVideo will compare with playbackTime and correct if drifted
          if (this.onSyncToVideo) {
            this.onSyncToVideo(this.currentTime);
          }
          this.lastReportedVideoTime = this.currentTime;
        }
        
        // Performance check every 5 seconds (with 3-second grace period after play/seek)
        const timeSincePlayStart = now - this.wallClockStart;
        const gracePeriodMs = 3000;  // Don't check performance for first 3 seconds
        
        // Reset counters when exiting grace period (first time timeSincePlayStart > gracePeriodMs)
        if (timeSincePlayStart > gracePeriodMs && !this.performanceMonitoringStarted) {
          this.performanceMonitoringStarted = true;
          this.lastPerformanceCheck = now;
          this.lastDroppedCount = this.framesDropped;  // Start counting from NOW
          this.bufferUnderruns = 0;
          
          console.log('INSV performance monitoring started after grace period, dropped baseline:', this.framesDropped);
        }
        
        // Single-lens optimization: enable after buffer is stable
        // This check runs every cycle (not just once) so it re-enables after seeks
        if (this.performanceMonitoringStarted && this.forceFullDecode && this.decodedFrameBuffer.length >= 5) {
          this.forceFullDecode = false;
          console.log('INSV single-lens optimization ENABLED (buffer stable:', this.decodedFrameBuffer.length + ')');
        }
        
        if (this.performanceMonitoringStarted && now - this.lastPerformanceCheck >= this.performanceCheckInterval) {
          const intervalDrops = this.framesDropped - this.lastDroppedCount;
          const intervalFrames = this.targetFps * (this.performanceCheckInterval / 1000);
          const dropRate = intervalDrops / intervalFrames;
          const fpsRatio = (this.currentFps || 0) / this.targetFps;
          
          // Performance is problematic if:
          // - Drop rate > 30% OR
          // - FPS < 70% of target (only if FPS has been measured) OR  
          // - Buffer critically low (<2 frames) frequently (>10 times in interval)
          const fpsProblematic = this.currentFps > 0 && fpsRatio < 0.7;
          const performanceProblematic = dropRate > 0.3 || fpsProblematic || this.bufferUnderruns > 10;
          
          // Performance is GOOD if: drop rate < 5% AND FPS >= 95% AND buffer stable
          const performanceGood = dropRate < 0.05 && fpsRatio >= 0.95 && this.bufferUnderruns < 3;
          
          if (performanceProblematic) {
            console.log('INSV performance issue: dropRate=' + (dropRate * 100).toFixed(0) + 
                       '%, fps=' + (fpsRatio * 100).toFixed(0) + '%, bufferUnderruns=' + this.bufferUnderruns +
                       ', total dropped=' + this.framesDropped);
            this.consecutiveGoodChecks = 0;  // Reset good counter
            if (this.onQualityReduce) {
              this.onQualityReduce();
            }
          } else {
            console.log('INSV performance OK: dropRate=' + (dropRate * 100).toFixed(0) + 
                       '%, fps=' + (fpsRatio * 100).toFixed(0) + '%, buffer=' + this.decodedFrameBuffer.length +
                       ', total dropped=' + this.framesDropped);
            
            // Track consecutive good checks for quality recovery
            if (performanceGood) {
              this.consecutiveGoodChecks++;
              // After 6 consecutive good checks (30 seconds), try increasing quality
              if (this.consecutiveGoodChecks >= 6 && this.onQualityIncrease) {
                console.log('INSV performance excellent for 30s, requesting quality increase');
                this.consecutiveGoodChecks = 0;  // Reset after increase attempt
                this.onQualityIncrease();
              }
            } else {
              // Performance is OK but not excellent - don't increase
              this.consecutiveGoodChecks = 0;
            }
          }
          
          // Reset counters for next interval
          this.lastPerformanceCheck = now;
          this.lastDroppedCount = this.framesDropped;
          this.bufferUnderruns = 0;
        }
        
        // Track buffer underruns (only after grace period to ignore initial buffering)
        if (this.performanceMonitoringStarted && this.decodedFrameBuffer.length < 2) {
          this.bufferUnderruns++;
        }
        
        // Detect stuck playback (frame not advancing while buffer is being filled)
        // This catches decoder errors that don't get properly flagged
        if (!this.lastFrameAdvanceCheck) {
          this.lastFrameAdvanceCheck = { frame: this.currentFrame, time: now };
        } else if (this.currentFrame !== this.lastFrameAdvanceCheck.frame) {
          this.lastFrameAdvanceCheck = { frame: this.currentFrame, time: now };
          this.stuckFrameWarnings = 0;
        } else if (now - this.lastFrameAdvanceCheck.time > 3000 && this.bufferFrameIndex > this.currentFrame + 100) {
          // Frame stuck for 3+ seconds while buffer index has advanced significantly
          this.stuckFrameWarnings = (this.stuckFrameWarnings || 0) + 1;
          if (this.stuckFrameWarnings >= 2) {
            console.warn('INSV: playback stuck, frame not advancing - forcing decoder recovery');
            this.decodersCorrupted = true;
            this.needsDecoderReset = true;
            this.lastFrameAdvanceCheck = { frame: this.currentFrame, time: now };
            this.stuckFrameWarnings = 0;
          }
        }
        
        // Log status periodically (frame vs target shows wall-clock alignment)
        if (!this.lastSyncLog || now - this.lastSyncLog > 2000) {
          const frameDiff = this.currentFrame - targetFrame;
          console.log('INSV: frame:', this.currentFrame, 'target:', targetFrame,
                     'diff:', frameDiff, 'buffer:', this.decodedFrameBuffer.length,
                     'fps:', this.currentFps || 0, 'dropped:', this.framesDropped);
          this.lastSyncLog = now;
        }
        
        // Calculate FPS every second
        if (now - this.fpsLastTime >= 1000) {
          this.currentFps = this.fpsFrameCount;
          this.fpsFrameCount = 0;
          this.fpsLastTime = now;
        }
        
        // Loop at end
        if (this.bufferFrameIndex >= this.totalFrames && this.decodedFrameBuffer.length === 0) {
          this.bufferFrameIndex = 0;
          this.needsDecoderReset = true;
          this.wallClockStart = null;  // Reset wall clock for loop
          for (const [ts, frame] of this.pendingFrames[0]) frame.close();
          for (const [ts, frame] of this.pendingFrames[1]) frame.close();
          this.pendingFrames = [new Map(), new Map()];
          this.dataCache = [new Map(), new Map()];
          
          // Reset audio on loop
          this.audioBuffer = [];
          this.audioBufferIndex = 0;
          this.audioScheduledUntil = 0;
          this.audioNextScheduleTime = 0;
          this.audioContextOffset = 0;
          this.lastAudioSyncCheck = 0;
          this.lastScheduledVideoTime = 0;
        }
        
        requestAnimationFrame(() => this.renderLoop());
      }
      
      // Helper to draw a frame pair to the combined canvas and separate lens canvases
      drawFramePair(framePair) {
        // Reset update flags
        this.frontLensUpdated = false;
        this.backLensUpdated = false;
        
        // Track frame ID to avoid redundant texture uploads
        this.lastDrawnFrameIndex = framePair.frameIndex;
        
        // Determine which canvases we actually need to draw to
        // This avoids redundant CPU work - we only draw to canvases that will be uploaded
        const needFront = this.targetRenderMode === 'front' || this.targetRenderMode === 'dual';
        const needBack = this.targetRenderMode === 'back' || this.targetRenderMode === 'dual';
        const needCombined = this.targetRenderMode === 'combined' || !this.targetRenderMode;
        
        // Handle single-lens mode
        if (framePair.mode === 'single') {
          if (framePair.activeLens === 0) {
            // Back lens only (track 0)
            if (needBack) {
              this.backLensCtx.drawImage(framePair.frame0,
                0, 0, this.width, this.height,
                0, 0, this.scaledWidth, this.scaledHeight);
              this.backLensUpdated = true;
            }
            // Combined canvas for backward compatibility (only if needed)
            if (needCombined) {
              this.combinedCtx.drawImage(framePair.frame0,
                0, 0, this.width, this.height,
                this.scaledWidth, 0, this.scaledWidth, this.scaledHeight);
              this.backLensUpdated = true;
            }
          } else {
            // Front lens only (track 1)
            if (needFront) {
              this.frontLensCtx.drawImage(framePair.frame1,
                0, 0, this.width, this.height,
                0, 0, this.scaledWidth, this.scaledHeight);
              this.frontLensUpdated = true;
            }
            // Combined canvas for backward compatibility (only if needed)
            if (needCombined) {
              this.combinedCtx.drawImage(framePair.frame1,
                0, 0, this.width, this.height,
                0, 0, this.scaledWidth, this.scaledHeight);
              this.frontLensUpdated = true;
            }
          }
          return;
        }
        
        // Dual-lens mode: visibleLens: 0=front, 1=back, 2=both
        // frame1 = front lens (left half), frame0 = back lens (right half)
        if (this.visibleLens !== 1 && framePair.frame1) {
          if (needFront) {
            this.frontLensCtx.drawImage(framePair.frame1,
              0, 0, this.width, this.height,
              0, 0, this.scaledWidth, this.scaledHeight);
            this.frontLensUpdated = true;
          }
          // Combined canvas (only if needed)
          if (needCombined) {
            this.combinedCtx.drawImage(framePair.frame1, 
              0, 0, this.width, this.height,
              0, 0, this.scaledWidth, this.scaledHeight);
            this.frontLensUpdated = true;
          }
        }
        if (this.visibleLens !== 0 && framePair.frame0) {
          if (needBack) {
            this.backLensCtx.drawImage(framePair.frame0,
              0, 0, this.width, this.height,
              0, 0, this.scaledWidth, this.scaledHeight);
            this.backLensUpdated = true;
          }
          // Combined canvas (only if needed)
          if (needCombined) {
            this.combinedCtx.drawImage(framePair.frame0,
              0, 0, this.width, this.height,
              this.scaledWidth, 0, this.scaledWidth, this.scaledHeight);
            this.backLensUpdated = true;
          }
        }
      }
      
      // Force redraw current frame to ALL canvases regardless of visibleLens
      // Used when switching render modes to ensure target canvas has current data
      // Returns true only if the required frames for targetMode are available
      forceRedrawToAllCanvases(targetMode = 'dual') {
        if (this.decodedFrameBuffer.length === 0) {
          console.log('INSV forceRedraw: buffer empty');
          return false;
        }
        
        const framePair = this.decodedFrameBuffer[0];
        if (!framePair) {
          console.log('INSV forceRedraw: no framePair');
          return false;
        }
        
        // Check if we have the required frames for the target mode
        const needsFront = targetMode === 'front' || targetMode === 'dual' || targetMode === 'combined';
        const needsBack = targetMode === 'back' || targetMode === 'dual' || targetMode === 'combined';
        
        // If we need a frame that's missing, return false - don't upload garbage
        if (needsFront && !framePair.frame1) {
          console.log('INSV forceRedraw: missing front frame for mode', targetMode, 
            'framePair:', { frameIndex: framePair.frameIndex, mode: framePair.mode });
          return false;
        }
        if (needsBack && !framePair.frame0) {
          console.log('INSV forceRedraw: missing back frame for mode', targetMode,
            'framePair:', { frameIndex: framePair.frameIndex, mode: framePair.mode });
          return false;
        }
        
        // Draw front lens to frontLensCanvas if available
        if (framePair.frame1) {
          this.frontLensCtx.drawImage(framePair.frame1,
            0, 0, this.width, this.height,
            0, 0, this.scaledWidth, this.scaledHeight);
          this.combinedCtx.drawImage(framePair.frame1,
            0, 0, this.width, this.height,
            0, 0, this.scaledWidth, this.scaledHeight);
          this.frontLensUpdated = true;
        }
        
        // Draw back lens to backLensCanvas if available
        if (framePair.frame0) {
          this.backLensCtx.drawImage(framePair.frame0,
            0, 0, this.width, this.height,
            0, 0, this.scaledWidth, this.scaledHeight);
          this.combinedCtx.drawImage(framePair.frame0,
            0, 0, this.width, this.height,
            this.scaledWidth, 0, this.scaledWidth, this.scaledHeight);
          this.backLensUpdated = true;
        }
        
        return true;
      }
      
      async seek(time) {
        // If initial buffering is in progress, just set the target and let it complete
        if (this.playInProgress) {
          console.log('INSV seek called during initial buffering, deferring');
          this.pendingSeekTime = time;
          return;
        }
        
        // Increment seek version - this will cancel any previous seek
        const mySeekVersion = ++this.seekVersion;
        this.seekInProgress = true;
        this.lastFrameAdvanceCheck = null;  // Reset stuck frame detection
        this.stuckFrameWarnings = 0;
        
        // Helper to check if this seek has been superseded
        const isSeekCancelled = () => this.seekVersion !== mySeekVersion;
        
        try {
          const targetFrame = Math.floor(time * this.frameRate);
          const clampedFrame = Math.max(0, Math.min(targetFrame, this.totalFrames - 1));
          
          // OPTIMIZATION: Find keyframe FIRST - we'll start playback from keyframe
          // This eliminates refinement decode latency entirely
          let keyFrameIndex = clampedFrame;
          for (let i = clampedFrame; i >= 0; i--) {
            if (this.sampleMeta[0][i]?.is_sync) { keyFrameIndex = i; break; }
          }
          
          // Calculate keyframe time - this is our actual playback start point
          const keyframeMeta = this.sampleMeta[0][keyFrameIndex];
          const keyframeTime = keyframeMeta ? keyframeMeta.cts / keyframeMeta.timescale : keyFrameIndex / this.frameRate;
          const frameDelta = clampedFrame - keyFrameIndex;
          
          console.log('INSV seek v' + mySeekVersion + ' to time:', time.toFixed(2) + 's',
                     '(target frame:', clampedFrame + ', keyframe:', keyFrameIndex + ', delta:', frameDelta + ')');
          
          // Stop render loop immediately
          this.renderLoopRunning = false;
          this.wallClockStart = null;
          
          // Stop buffer loops - CRITICAL: Stop audio buffering FIRST to prevent race condition
          this.audioBufferingActive = false;
          this.bufferingActive = false;
          
          // Clear decoded frames
          for (const framePair of this.decodedFrameBuffer) {
            if (framePair.frame0) framePair.frame0.close();
            if (framePair.frame1) framePair.frame1.close();
          }
          this.decodedFrameBuffer = [];
        
          // Reset timing references
          this.renderStartTime = null;
          this.playbackStartTime = null;
        
          for (const [ts, frame] of this.pendingFrames[0]) frame.close();
          for (const [ts, frame] of this.pendingFrames[1]) frame.close();
          this.pendingFrames = [new Map(), new Map()];
        
          // DON'T clear dataCache entirely - keep it for nearby seeks
          // Only clear if seeking far (>5 seconds)
          const currentCacheFrame = this.bufferFrameIndex || 0;
          if (Math.abs(keyFrameIndex - currentCacheFrame) > this.frameRate * 5) {
            this.dataCache = [new Map(), new Map()];
          }
        
          // Reset audio state - use KEYFRAME time for sync
          this.audioBuffer = [];
          this.audioScheduledUntil = 0;
          this.audioNextScheduleTime = 0;
          this.audioContextStartTime = 0;
          this.audioVideoStartTime = 0;
          this.audioSyncVideoTime = 0;
          this.audioSyncContextTime = 0;
          this.audioContextOffset = 0;
          this.lastAudioSyncCheck = 0;
          this.lastScheduledVideoTime = 0;
          this.audioPositionRef = null;
        
          // Reset performance monitoring for fresh start after seek
          this.lastPerformanceCheck = 0;
          this.bufferUnderruns = 0;
          this.initialSyncDone = false;
          this.performanceMonitoringStarted = false;
          
          // Force full decode during seek to ensure both tracks ready for preview
          this.forceFullDecode = true;
        
          // Find correct audio position for KEYFRAME time (not target time)
          if (this.audioTrack && this.audioSampleMeta.length > 0) {
            const timescale = this.audioTrack.timescale;
          
            let lo = 0, hi = this.audioSampleMeta.length - 1;
            while (lo < hi) {
              const mid = Math.floor((lo + hi) / 2);
              const sampleTime = this.audioSampleMeta[mid].cts / timescale;
              if (sampleTime < keyframeTime) {
                lo = mid + 1;
              } else {
                hi = mid;
              }
            }
            this.audioBufferIndex = Math.max(0, lo - 5);
            
            // Stop all scheduled audio sources
            if (this.scheduledAudioSources && this.scheduledAudioSources.length > 0) {
              const currentTime = this.audioContext ? this.audioContext.currentTime : 0;
              for (const scheduled of this.scheduledAudioSources) {
                try {
                  if (scheduled.endTime > currentTime) {
                    scheduled.source.stop();
                  }
                } catch (e) {}
              }
              this.scheduledAudioSources = [];
            }
          }
        
          // Re-initialize audio decoder if needed
          if (this.audioDecoder) {
            try {
              if (this.audioDecoder.state === 'configured') {
                this.audioDecoder.reset();
              }
              if (this.audioDecoder.state === 'unconfigured') {
                const audioConfig = {
                  codec: this.audioTrack.codec,
                  sampleRate: this.audioTrack.audio.sample_rate,
                  numberOfChannels: this.audioTrack.audio.channel_count,
                };
                if (this.audioDescription) {
                  audioConfig.description = this.audioDescription;
                }
                this.audioDecoder.configure(audioConfig);
              }
            } catch (e) {
              console.error('Audio decoder reset error:', e);
              this.recreateAudioDecoder();
            }
          }
        
          // Set position to KEYFRAME (not target frame) - playback starts from keyframe
          this.bufferFrameIndex = keyFrameIndex;
          this.currentFrame = keyFrameIndex;
          this.currentTime = keyframeTime;
          this.needsDecoderReset = true;
          this.queueStuckCounter = 0;
          this.playbackStartTime = null;
          this.seekRecoveryFrames = 0;  // No recovery needed - we start from keyframe
        
          // Check if superseded before doing preview
          if (isSeekCancelled()) {
            console.log('INSV seek v' + mySeekVersion + ' cancelled before preview');
            return;
          }
        
          const wasPlaying = this.playing;
        
          // FAST PREVIEW: Always use keyframe-only preview for minimum latency
          // Both playing and paused seeks show keyframe immediately
          await this.renderFastKeyframePreview(keyFrameIndex, mySeekVersion);
          
          // Check if superseded after preview
          if (isSeekCancelled()) {
            console.log('INSV seek v' + mySeekVersion + ' cancelled after preview');
            return;
          }
        
          if (wasPlaying) {
            this.seekInProgress = false;
            this.previewInProgress = false;
          
            console.log('INSV seek v' + mySeekVersion + ' restarting from keyframe', keyFrameIndex, 
                       'bufferLoopRunning:', this.bufferLoopRunning);
          
            // Restart buffer loop from keyframe
            if (!this.bufferLoopRunning) {
              this.startBuffering();
            }
          
            // Short wait - we already have keyframe decoded
            const bufferWaitStart = performance.now();
            while (this.decodedFrameBuffer.length < 2 && 
                   performance.now() - bufferWaitStart < 200 && 
                   this.playing &&
                   !isSeekCancelled()) {
              await new Promise(r => setTimeout(r, 10));
            }
          
            console.log('INSV seek v' + mySeekVersion + ' complete, buffer:', this.decodedFrameBuffer.length);
          
            if (isSeekCancelled()) {
              console.log('INSV seek v' + mySeekVersion + ' cancelled during buffer wait');
              return;
            }
          
            // Start render loop - wall clock will start from keyframe time
            this.wallClockStart = null;
            this.renderLoop();
          
          } else {
            this.seekInProgress = false;
            this.previewInProgress = false;
            console.log('INSV seek v' + mySeekVersion + ' complete (paused at keyframe ' + keyFrameIndex + ')');
          }
        } finally {
          if (this.seekVersion === mySeekVersion) {
            this.seekInProgress = false;
          }
        }
      }
      
      // FAST keyframe-only preview for playing seeks - minimal latency
      async renderFastKeyframePreview(keyFrameIndex, seekVersion) {
        const isCancelled = () => this.seekVersion !== seekVersion;
        
        // Stop buffer loop
        this.bufferingActive = false;
        const stopWaitStart = performance.now();
        while (this.bufferLoopRunning && performance.now() - stopWaitStart < 150) {
          if (isCancelled()) return;
          await new Promise(r => setTimeout(r, 5));
        }
        
        if (isCancelled()) return;
        
        // Clear leftover frames
        for (const framePair of this.decodedFrameBuffer) {
          if (framePair.frame0) framePair.frame0.close();
          if (framePair.frame1) framePair.frame1.close();
        }
        this.decodedFrameBuffer = [];
        for (const [ts, frame] of this.pendingFrames[0]) frame.close();
        for (const [ts, frame] of this.pendingFrames[1]) frame.close();
        this.pendingFrames = [new Map(), new Map()];
        
        // Reset decoders - we MUST decode both tracks for preview even if single-lens viewing
        // (to avoid texture corruption at seams)
        for (let t = 0; t < 2; t++) {
          if (this.decoders[t] && this.decoders[t].state !== 'closed') {
            try {
              this.decoders[t].reset();
              const config = {
                codec: this.tracks[t].codec,
                codedWidth: this.width,
                codedHeight: this.height,
                hardwareAcceleration: 'prefer-hardware',
              };
              if (this.trackInfo[t].description) config.description = this.trackInfo[t].description;
              this.decoders[t].configure(config);
            } catch (e) {
              console.error('Fast preview decoder reset error:', e);
              await this.recreateVideoDecoders();
              break;
            }
          }
        }
        
        if (isCancelled()) return;
        
        // Read keyframe data - parallel I/O for both tracks
        const readStart = performance.now();
        const [keyData0, keyData1] = await Promise.all([
          this.readSampleData(0, keyFrameIndex),
          this.readSampleData(1, keyFrameIndex)
        ]);
        const readTime = performance.now() - readStart;
        
        if (isCancelled()) return;
        
        const keyMeta0 = this.sampleMeta[0][keyFrameIndex];
        const keyMeta1 = this.sampleMeta[1][keyFrameIndex];
        
        // Decode both keyframes
        const decodeStart = performance.now();
        if (keyData0 && keyMeta0 && this.decoders[0]?.state === 'configured') {
          const processed0 = this.avccToAnnexB(0, keyData0, true);
          const chunk0 = new EncodedVideoChunk({
            type: 'key',
            timestamp: keyFrameIndex * 1000000,
            duration: keyMeta0.duration * 1000000 / keyMeta0.timescale,
            data: processed0
          });
          this.decoders[0].decode(chunk0);
        }
        
        if (keyData1 && keyMeta1 && this.decoders[1]?.state === 'configured') {
          const processed1 = this.avccToAnnexB(1, keyData1, true);
          const chunk1 = new EncodedVideoChunk({
            type: 'key',
            timestamp: keyFrameIndex * 1000000,
            duration: keyMeta1.duration * 1000000 / keyMeta1.timescale,
            data: processed1
          });
          this.decoders[1].decode(chunk1);
        }
        
        // Flush to get decoded frames
        try {
          await Promise.all([
            this.decoders[0]?.flush().catch(() => {}),
            this.decoders[1]?.flush().catch(() => {})
          ]);
        } catch (e) {}
        
        const decodeTime = performance.now() - decodeStart;
        
        // Wait for frame
        let waitStart = performance.now();
        while (this.decodedFrameBuffer.length < 1 && performance.now() - waitStart < 200) {
          if (isCancelled()) return;
          await new Promise(r => setTimeout(r, 5));
        }
        
        // Render keyframe
        if (this.decodedFrameBuffer.length > 0) {
          const framePair = this.decodedFrameBuffer[0];
          
          // Draw to combined canvas for Three.js combined texture
          if (framePair.frame1) {
            this.combinedCtx.drawImage(framePair.frame1,
              0, 0, this.width, this.height,
              0, 0, this.scaledWidth, this.scaledHeight);
          }
          if (framePair.frame0) {
            this.combinedCtx.drawImage(framePair.frame0,
              0, 0, this.width, this.height,
              this.scaledWidth, 0, this.scaledWidth, this.scaledHeight);
          }
          
          // CRITICAL: Also draw to separate lens canvases for optimized single-lens textures
          // Without this, threeFrontTexture and threeBackTexture show garbage after preview
          if (framePair.frame1) {
            this.frontLensCtx.drawImage(framePair.frame1,
              0, 0, this.width, this.height,
              0, 0, this.scaledWidth, this.scaledHeight);
          }
          if (framePair.frame0) {
            this.backLensCtx.drawImage(framePair.frame0,
              0, 0, this.width, this.height,
              0, 0, this.scaledWidth, this.scaledHeight);
          }
          
          // Signal Three.js that textures need update
          this.frontLensUpdated = true;
          this.backLensUpdated = true;
          
          console.log('INSV fast preview: keyframe', keyFrameIndex, 
                     'read:', readTime.toFixed(0) + 'ms', 
                     'decode:', decodeTime.toFixed(0) + 'ms',
                     'total:', (performance.now() - stopWaitStart).toFixed(0) + 'ms');
        }
        
        // Set buffer to continue from keyframe+1
        this.bufferFrameIndex = keyFrameIndex + 1;
        this.needsDecoderReset = true;  // Need reset after flush
      }
      
      // Decode and render a single frame for preview (when paused)
      async renderPreviewFrame() {
        // Don't start preview if playback is active
        if (this.playing) {
          console.log('INSV preview skipped - playing');
          return;
        }
        
        // Increment version - this cancels any previous preview
        const myVersion = ++this.previewVersion;
        
        // If another preview is running, it will see version mismatch and abort
        this.previewInProgress = true;
        const targetFrame = this.currentFrame;
        console.log('INSV renderPreviewFrame at frame', targetFrame, 'v' + myVersion);
        
        try {
          await this._decodeAndRenderPreview(targetFrame, true, myVersion);  // checkPlaying = true
        } catch (e) {
          console.error('INSV preview error:', e);
        } finally {
          // Only clear previewInProgress if we're still the active version
          if (this.previewVersion === myVersion) {
            this.previewInProgress = false;
          }
        }
      }
      
      // Render immediate preview during seek - blocks until frame is visible
      // Does NOT check this.playing so it works during playback seeks
      async renderImmediatePreview(targetFrame) {
        // Increment version - this cancels any previous preview
        const myVersion = ++this.previewVersion;
        
        this.previewInProgress = true;
        console.log('INSV renderImmediatePreview at frame', targetFrame, 'v' + myVersion);
        
        try {
          await this._decodeAndRenderPreview(targetFrame, false, myVersion);  // checkPlaying = false
        } catch (e) {
          console.error('INSV immediate preview error:', e);
        } finally {
          // Only clear previewInProgress if we're still the active version
          if (this.previewVersion === myVersion) {
            this.previewInProgress = false;
          }
        }
      }
      
      // Internal: decode frames and render preview
      // checkPlaying: if true, abort when playback starts (for paused preview)
      //               if false, continue regardless (for seek preview during playback)
      // version: preview version number for cancellation detection
      async _decodeAndRenderPreview(targetFrame, checkPlaying, version) {
        // Helper to check if this preview has been superseded
        const isCancelled = () => this.previewVersion !== version;
        
        // CRITICAL: Stop buffer loop to prevent decoder conflicts
        this.bufferingActive = false;
        
        // Wait for buffer loop to actually exit - check both flags
        const stopWaitStart = performance.now();
        while (this.bufferLoopRunning && performance.now() - stopWaitStart < 300) {
          if (isCancelled()) {
            console.log('INSV preview v' + version + ' cancelled during buffer wait');
            return;
          }
          await new Promise(r => setTimeout(r, 10));
        }
        
        // Extra safety delay to ensure any in-flight decoder operations complete
        await new Promise(r => setTimeout(r, 20));
        
        if (isCancelled()) {
          console.log('INSV preview v' + version + ' cancelled');
          return;
        }
        
        // Find keyframe
        let keyFrameIndex = targetFrame;
        for (let i = targetFrame; i >= 0; i--) {
          if (this.sampleMeta[0][i]?.is_sync) { keyFrameIndex = i; break; }
        }
        
        const framesToDecode = targetFrame - keyFrameIndex;
        console.log('INSV preview: keyframe', keyFrameIndex, '-> target', targetFrame, '(' + framesToDecode + ' frames)');
        
        // If decoders are corrupted or missing, recreate them first
        if (this.decodersCorrupted || !this.decoders[0] || !this.decoders[1]) {
          console.log('INSV preview v' + version + ': decoders need recreation');
          await this.recreateVideoDecoders();
          if (isCancelled()) return;
        }
        
        // Reset decoders for clean state - use reset+configure which is reliable
        console.log('INSV preview v' + version + ': resetting decoders for clean state');
        
        // Clear any leftover frames first
        for (const framePair of this.decodedFrameBuffer) {
          if (framePair.frame0) framePair.frame0.close();
          if (framePair.frame1) framePair.frame1.close();
        }
        this.decodedFrameBuffer = [];
        for (const [ts, frame] of this.pendingFrames[0]) frame.close();
        for (const [ts, frame] of this.pendingFrames[1]) frame.close();
        this.pendingFrames = [new Map(), new Map()];
        
        // Reset and reconfigure decoders (this is the reliable way)
        for (let t = 0; t < 2; t++) {
          if (this.decoders[t] && this.decoders[t].state !== 'closed') {
            try {
              this.decoders[t].reset();
              const config = {
                codec: this.tracks[t].codec,
                codedWidth: this.width,
                codedHeight: this.height,
                hardwareAcceleration: 'prefer-hardware',
              };
              if (this.trackInfo[t].description) config.description = this.trackInfo[t].description;
              this.decoders[t].configure(config);
            } catch (e) {
              console.error('Preview decoder reset error:', e);
              // If reset fails, recreate decoders
              await this.recreateVideoDecoders();
              // Do reset+configure on fresh decoders too
              for (let t2 = 0; t2 < 2; t2++) {
                if (this.decoders[t2]) {
                  this.decoders[t2].reset();
                  const cfg = {
                    codec: this.tracks[t2].codec,
                    codedWidth: this.width,
                    codedHeight: this.height,
                    hardwareAcceleration: 'prefer-hardware',
                  };
                  if (this.trackInfo[t2].description) cfg.description = this.trackInfo[t2].description;
                  this.decoders[t2].configure(cfg);
                }
              }
              break;
            }
          }
        }
        
        console.log('INSV preview v' + version + ': decoders ready');
        
        if (isCancelled()) return;
        
        console.log('INSV preview v' + version + ': reading keyframe data');
        
        // FAST PATH: Decode ONLY the keyframe first for instant preview
        // Then continue to exact frame if needed
        const [keyData0, keyData1] = await Promise.all([
          this.readSampleData(0, keyFrameIndex),
          this.readSampleData(1, keyFrameIndex)
        ]);
        
        if (isCancelled()) return;
        
        const keyMeta0 = this.sampleMeta[0][keyFrameIndex];
        const keyMeta1 = this.sampleMeta[1][keyFrameIndex];
        
        console.log('INSV preview v' + version + ': decoding keyframe, data0:', !!keyData0, 'data1:', !!keyData1, 
                   'decoder0:', this.decoders[0]?.state, 'decoder1:', this.decoders[1]?.state);
        
        if (keyData0 && keyMeta0 && this.decoders[0]?.state === 'configured') {
          const processed0 = this.avccToAnnexB(0, keyData0, true);
          const chunk0 = new EncodedVideoChunk({
            type: 'key',
            timestamp: keyFrameIndex * 1000000,
            duration: keyMeta0.duration * 1000000 / keyMeta0.timescale,
            data: processed0
          });
          this.decoders[0].decode(chunk0);
        }
        
        if (keyData1 && keyMeta1 && this.decoders[1]?.state === 'configured') {
          const processed1 = this.avccToAnnexB(1, keyData1, true);
          const chunk1 = new EncodedVideoChunk({
            type: 'key',
            timestamp: keyFrameIndex * 1000000,
            duration: keyMeta1.duration * 1000000 / keyMeta1.timescale,
            data: processed1
          });
          this.decoders[1].decode(chunk1);
        }
        
        // FIXED: Decode ALL frames (keyframe + deltas) BEFORE flushing
        // Flush resets decoder state to require keyframe, so we must decode all in one batch
        
        // If target is close to keyframe (within 15 frames ~0.5s), decode delta frames now
        // For paused scrubbing, accuracy matters more than speed
        const REFINEMENT_THRESHOLD = 15;  // Increased from 5 for better accuracy
        const needsRefinement = framesToDecode > 0 && framesToDecode <= REFINEMENT_THRESHOLD;
        
        if (needsRefinement) {
          console.log('INSV preview v' + version + ': decoding ' + framesToDecode + ' delta frames for refinement');
          
          // OPTIMIZATION: Batch prefetch ALL delta frame data in parallel before decoding
          // This eliminates sequential I/O latency (50-100ms per frame)
          const deltaFrameIndices = [];
          for (let i = keyFrameIndex + 1; i <= targetFrame; i++) {
            deltaFrameIndices.push(i);
          }
          
          // Parallel I/O for all delta frames
          const deltaDataPromises = deltaFrameIndices.map(frameIdx => 
            Promise.all([
              this.readSampleData(0, frameIdx),
              this.readSampleData(1, frameIdx),
              frameIdx  // Keep track of which frame this is
            ])
          );
          
          const deltaDataResults = await Promise.all(deltaDataPromises);
          
          if (isCancelled()) {
            console.log('INSV preview v' + version + ' cancelled after prefetch');
            return;
          }
          
          // Now decode sequentially (H.264 requires sequential decode)
          for (const [data0, data1, frameIdx] of deltaDataResults) {
            if (checkPlaying && this.playing) {
              console.log('INSV preview aborted during refinement decode');
              break;
            }
            if (isCancelled()) {
              console.log('INSV preview v' + version + ' cancelled during refinement decode');
              break;
            }
            
            const meta0 = this.sampleMeta[0][frameIdx];
            const meta1 = this.sampleMeta[1][frameIdx];
            
            if (data0 && meta0 && this.decoders[0]?.state === 'configured') {
              const processed0 = this.avccToAnnexB(0, data0, false);
              const chunk0 = new EncodedVideoChunk({
                type: 'delta',
                timestamp: frameIdx * 1000000,
                duration: meta0.duration * 1000000 / meta0.timescale,
                data: processed0
              });
              this.decoders[0].decode(chunk0);
            }
            
            if (data1 && meta1 && this.decoders[1]?.state === 'configured') {
              const processed1 = this.avccToAnnexB(1, data1, false);
              const chunk1 = new EncodedVideoChunk({
                type: 'delta',
                timestamp: frameIdx * 1000000,
                duration: meta1.duration * 1000000 / meta1.timescale,
                data: processed1
              });
              this.decoders[1].decode(chunk1);
            }
          }
        }
        
        // NOW flush decoders to output all decoded frames (keyframe + any deltas)
        console.log('INSV preview v' + version + ': flushing decoders to get ' + (needsRefinement ? 'all frames' : 'keyframe'));
        try {
          await Promise.all([
            this.decoders[0]?.flush().catch(() => {}),
            this.decoders[1]?.flush().catch(() => {})
          ]);
        } catch (e) {
          console.warn('INSV preview flush error:', e);
        }
        
        console.log('INSV preview v' + version + ': flush complete, checking for frames...');
        
        // Wait for frames to decode - expect 1 (keyframe only) or framesToDecode+1 (with refinement)
        // Timeout scales with expected frames: 500ms base + 50ms per extra frame
        const expectedFrames = needsRefinement ? framesToDecode + 1 : 1;
        const waitTimeout = 500 + (needsRefinement ? framesToDecode * 50 : 0);
        let waitStart = performance.now();
        while (this.decodedFrameBuffer.length < expectedFrames && performance.now() - waitStart < waitTimeout) {
          if (checkPlaying && this.playing) {
            console.log('INSV preview aborted during frame wait');
            return;
          }
          if (isCancelled()) {
            console.log('INSV preview v' + version + ' cancelled during frame wait');
            return;
          }
          await new Promise(r => setTimeout(r, 5));
        }
        
        // Log result
        if (this.decodedFrameBuffer.length === 0) {
          console.warn('INSV preview decode timeout - no frames after 500ms, states:', 
            this.decoders[0]?.state, this.decoders[1]?.state,
            'pending:', this.pendingFrames[0].size, this.pendingFrames[1].size);
        } else {
          console.log('INSV preview v' + version + ': got ' + this.decodedFrameBuffer.length + ' frames (expected ' + expectedFrames + ')');
        }
        
        // Only render if we're still the active preview version
        if (isCancelled()) {
          console.log('INSV preview v' + version + ' cancelled before render');
          return;
        }
        
        // Render best frame (last one if we have multiple, since it's closest to target)
        if (this.decodedFrameBuffer.length > 0) {
          // Sort by frame index to get the one closest to target
          this.decodedFrameBuffer.sort((a, b) => a.frameIndex - b.frameIndex);
          const bestFrame = this.decodedFrameBuffer[this.decodedFrameBuffer.length - 1];
          
          if (this.visibleLens !== 1) {
            this.combinedCtx.drawImage(bestFrame.frame1,
              0, 0, this.width, this.height,
              0, 0, this.scaledWidth, this.scaledHeight);
          }
          if (this.visibleLens !== 0) {
            this.combinedCtx.drawImage(bestFrame.frame0,
              0, 0, this.width, this.height,
              this.scaledWidth, 0, this.scaledWidth, this.scaledHeight);
          }
          console.log('INSV preview rendered frame:', bestFrame.frameIndex, 
                     '(target:', targetFrame + ', delta:', targetFrame - bestFrame.frameIndex + ')');
        }
        
        // Update buffer frame index for when play() starts
        this.bufferFrameIndex = this.decodedFrameBuffer.length > 0 
          ? keyFrameIndex + this.decodedFrameBuffer.length
          : keyFrameIndex;
        // After flush(), decoder always needs a keyframe, so always set needsDecoderReset
        this.needsDecoderReset = true;
        
        console.log('INSV preview v' + version + ' complete, bufferFrameIndex:', this.bufferFrameIndex, 'buffered:', this.decodedFrameBuffer.length);
        
        // DON'T restart buffer loop here - let play() handle it
        // This prevents conflicts during rapid scrubbing
      }
      
      renderCombined(frameIndex) {
        if (this.decodedFrameBuffer.length > 0) {
          const framePair = this.decodedFrameBuffer[0];
          
          // Reset update flags
          this.frontLensUpdated = false;
          this.backLensUpdated = false;
          
          // Handle single-lens mode
          if (framePair.mode === 'single') {
            if (framePair.activeLens === 0 && framePair.frame0) {
              this.backLensCtx.drawImage(framePair.frame0,
                0, 0, this.width, this.height,
                0, 0, this.scaledWidth, this.scaledHeight);
              this.backLensUpdated = true;
              this.combinedCtx.drawImage(framePair.frame0,
                0, 0, this.width, this.height,
                this.scaledWidth, 0, this.scaledWidth, this.scaledHeight);
            } else if (framePair.activeLens === 1 && framePair.frame1) {
              this.frontLensCtx.drawImage(framePair.frame1,
                0, 0, this.width, this.height,
                0, 0, this.scaledWidth, this.scaledHeight);
              this.frontLensUpdated = true;
              this.combinedCtx.drawImage(framePair.frame1,
                0, 0, this.width, this.height,
                0, 0, this.scaledWidth, this.scaledHeight);
            }
            return true;
          }
          
          // Dual-lens mode: frame1 = front lens, frame0 = back lens
          if (this.visibleLens !== 1 && framePair.frame1) {
            this.frontLensCtx.drawImage(framePair.frame1,
              0, 0, this.width, this.height,
              0, 0, this.scaledWidth, this.scaledHeight);
            this.frontLensUpdated = true;
            this.combinedCtx.drawImage(framePair.frame1,
              0, 0, this.width, this.height,
              0, 0, this.scaledWidth, this.scaledHeight);
          }
          if (this.visibleLens !== 0 && framePair.frame0) {
            this.backLensCtx.drawImage(framePair.frame0,
              0, 0, this.width, this.height,
              0, 0, this.scaledWidth, this.scaledHeight);
            this.backLensUpdated = true;
            this.combinedCtx.drawImage(framePair.frame0,
              0, 0, this.width, this.height,
              this.scaledWidth, 0, this.scaledWidth, this.scaledHeight);
          }
          return true;
        }
        return false;
      }
      
      get paused() {
        return !this.playing;
      }
      
      // Set external target time for sync correction
      setTargetTime(time) {
        this.externalTargetTime = time;
      }
      
      // Check if a frame should be kept based on target FPS
      // Works for both integer and non-integer frame skip ratios
      shouldKeepFrame(frameIndex) {
        // Calculate which "output frame slot" this frame belongs to
        // Output slot = floor(frameIndex * targetFps / sourceFrameRate)
        const currentSlot = Math.floor(frameIndex * this.targetFps / this.frameRate);
        const prevSlot = Math.floor((frameIndex - 1) * this.targetFps / this.frameRate);
        
        // Keep this frame if it starts a new output slot
        return frameIndex === 0 || currentSlot > prevSlot;
      }
      
      // Set target FPS at runtime
      setTargetFps(fps) {
        const validFps = [7.5, 10, 15, 20, 25, 30];
        if (!validFps.includes(fps)) {
          console.warn('Invalid FPS:', fps, 'Valid options:', validFps);
          return;
        }
        
        const oldFps = this.targetFps;
        this.targetFps = fps;
        this.frameSkip = this.frameRate / fps;  // Can be fractional (e.g., 1.5 for 20fps)
        
        // Reset timing to apply new FPS smoothly
        this.renderStartTime = null;
        this.lastKeptOutputIndex = -1;
        
        // CRITICAL: Reset performance monitoring grace period after FPS change
        // Otherwise fpsRatio will be wrong (old fps / new target) triggering false quality drops
        this.performanceMonitoringStarted = false;
        this.lastPerformanceCheck = performance.now();
        this.lastDroppedCount = this.framesDropped;
        this.bufferUnderruns = 0;
        // Reset FPS measurement to avoid stale value triggering false quality drop
        this.currentFps = fps;  // Assume target FPS until measured
        this.fpsFrameCount = 0;
        this.fpsLastTime = performance.now();
        
        console.log('INSV FPS changed:', oldFps, '->', fps, 'frameSkip:', this.frameSkip.toFixed(2));
      }
      
      // Set texture quality scale (0.25 to 1.0)
      setTextureScale(scale) {
        const validScales = [0.25, 0.5, 0.75, 1.0];
        if (!validScales.includes(scale)) {
          console.warn('Invalid texture scale:', scale, 'Valid options:', validScales);
          return;
        }
        
        if (scale === this.textureScale) return;
        
        const oldScale = this.textureScale;
        this.textureScale = scale;
        this.scaledWidth = Math.round(this.width * scale);
        this.scaledHeight = Math.round(this.height * scale);
        
        // Resize combined canvas
        this.combinedCanvas.width = this.scaledWidth * 2;
        this.combinedCanvas.height = this.scaledHeight;
        
        // Resize separate lens canvases
        this.frontLensCanvas.width = this.scaledWidth;
        this.frontLensCanvas.height = this.scaledHeight;
        this.backLensCanvas.width = this.scaledWidth;
        this.backLensCanvas.height = this.scaledHeight;
        
        // Invalidate cache
        this.invalidateCache();
        
        // Reset performance monitoring grace period after quality change
        this.performanceMonitoringStarted = false;
        this.lastPerformanceCheck = performance.now();
        this.lastDroppedCount = this.framesDropped;
        this.bufferUnderruns = 0;
        // Reset FPS measurement to avoid stale value
        this.fpsFrameCount = 0;
        this.fpsLastTime = performance.now();
        
        console.log('INSV texture scale changed:', oldScale, '->', scale,
          'canvas:', this.combinedCanvas.width + 'x' + this.combinedCanvas.height,
          'memory:', ((this.combinedCanvas.width * this.combinedCanvas.height * 4) / 1024 / 1024).toFixed(1) + 'MB');
      }
      
      // Get FPS and buffer status for display
      getStats() {
        let syncOffset = null;
        if (this.externalTargetTime !== null && this.externalTargetTime !== undefined) {
          syncOffset = this.currentTime - this.externalTargetTime;
        }
        
        // Calculate actual audio drift by finding the currently playing audio chunk
        let audioDrift = null;
        let audioLead = null;
        if (this.playing && this.audioContext && this.scheduledAudioSources && this.scheduledAudioSources.length > 0) {
          const currentAudioTime = this.audioContext.currentTime;
          const effectiveSpeed = typeof playbackSpeed !== 'undefined' ? playbackSpeed : 1;
          
          // Find the chunk that is currently playing
          // A chunk is "currently playing" if startTime <= currentAudioTime < endTime
          let currentChunk = null;
          for (const chunk of this.scheduledAudioSources) {
            if (chunk.startTime <= currentAudioTime && currentAudioTime < chunk.endTime && chunk.videoTime !== null) {
              // Prefer the chunk that started most recently
              if (!currentChunk || chunk.startTime > currentChunk.startTime) {
                currentChunk = chunk;
              }
            }
          }
          
          if (currentChunk) {
            // Calculate how far into the chunk we are
            const timeSinceChunkStart = currentAudioTime - currentChunk.startTime;
            // Extrapolate the current video time based on how far into chunk we are
            const audioNowVideoTime = currentChunk.videoTime + (timeSinceChunkStart * effectiveSpeed);
            // Drift = where audio thinks video should be - where video actually is
            audioDrift = audioNowVideoTime - this.currentTime;
            
            // Log drift diagnostics periodically
            if (!this._lastDriftLog || currentAudioTime - this._lastDriftLog > 5) {
              this._lastDriftLog = currentAudioTime;
              console.log('INSV audio drift debug: chunk.start=' + currentChunk.startTime.toFixed(2) +
                          ', chunk.videoTime=' + currentChunk.videoTime.toFixed(2) +
                          ', currentAudioTime=' + currentAudioTime.toFixed(2) +
                          ', timeSinceStart=' + timeSinceChunkStart.toFixed(2) +
                          ', audioNowVideoTime=' + audioNowVideoTime.toFixed(2) +
                          ', videoTime=' + this.currentTime.toFixed(2) +
                          ', drift=' + (audioDrift * 1000).toFixed(0) + 'ms' +
                          ', speed=' + effectiveSpeed +
                          ', trackOffset=' + ((this.audioTrackOffset || 0) * 1000).toFixed(0) + 'ms' +
                          ', chunks=' + this.scheduledAudioSources.length);
            }
          }
          
          audioLead = this.audioScheduledUntil - currentAudioTime;
        }
        
        // Lens mode description
        const lensModeDesc = this.visibleLens === 0 ? 'front' : 
                            this.visibleLens === 1 ? 'back' : 
                            (this.preWarmMode ? 'both(prewarm)' : 'both');
        
        // Calculate holdoff remaining time
        const now = performance.now();
        const holdoffRemaining = Math.max(0, this.dualModeHoldoffEnd - now);
        
        return {
          fps: this.currentFps || 0,
          targetFps: this.targetFps,
          bufferLength: this.decodedFrameBuffer.length,
          bufferTarget: this.maxBufferSize,
          bufferRunway: (this.decodedFrameBuffer.length / this.targetFps).toFixed(1) + 's',
          currentTime: this.currentTime,
          currentFrame: this.currentFrame,
          totalFrames: this.totalFrames,
          syncOffset: syncOffset,
          audioDrift: audioDrift,
          audioLead: audioLead,
          framesDropped: this.framesDropped || 0,
          visibleLens: this.visibleLens,
          lensMode: lensModeDesc,
          activeDecoders: `T0:${this.activeDecoders[0]?'on':'off'} T1:${this.activeDecoders[1]?'on':'off'}`,
          preWarmMode: this.preWarmMode,
          forceFullDecode: this.forceFullDecode,
          distToNearestSeam: this.distToNearestSeam,
          dualModeHoldoff: holdoffRemaining > 0,
          dualModeHoldoffRemaining: (holdoffRemaining / 1000).toFixed(1),
          textureScale: this.textureScale,
          textureSize: `${this.combinedCanvas.width}x${this.combinedCanvas.height}`,
          frontLensUpdated: this.frontLensUpdated,
          backLensUpdated: this.backLensUpdated,
          currentFrameMode: this.decodedFrameBuffer[0]?.mode || '--',
          bufferDualCount: this.decodedFrameBuffer.filter(f => f.mode === 'dual').length,
          bufferSingleCount: this.decodedFrameBuffer.filter(f => f.mode === 'single').length
        };
      }
      
      // Update which lens is visible based on view angle
      // lon: longitude in degrees, 180 = forward in Three.js coords
      // fov: field of view in degrees
      updateViewport(lon, fov) {
        this.viewLon = lon;
        this.viewFov = fov || 75;
        
        // Normalize to 0-360
        let normLon = ((lon % 360) + 360) % 360;
        
        // Calculate view edges
        const halfFov = this.viewFov / 2;
        const leftEdge = ((normLon - halfFov) + 360) % 360;
        const rightEdge = (normLon + halfFov) % 360;
        
        // In Three.js coords: lon=180 is forward, lon=0/360 is backward
        // Front lens (frame1, left half) covers view when lon is near 180
        // Back lens (frame0, right half) covers view when lon is near 0/360
        const seam1 = 90, seam2 = 270;
        
        // Skip all single-lens optimization logic when forceFullDecode is true
        // This ensures stable playback by always decoding both tracks
        if (this.forceFullDecode) {
          this.visibleLens = 2;
          this.preWarmMode = false;
          return; // Skip all lens switching logic
        }
        
        // Calculate distance to nearest seam for pre-warm logic
        const distToSeam1 = Math.min(
          Math.abs(normLon - seam1),
          Math.abs(normLon - seam1 + 360),
          Math.abs(normLon - seam1 - 360)
        );
        const distToSeam2 = Math.min(
          Math.abs(normLon - seam2),
          Math.abs(normLon - seam2 + 360),
          Math.abs(normLon - seam2 - 360)
        );
        const distToNearestSeam = Math.min(distToSeam1, distToSeam2);
        this.distToNearestSeam = Math.round(distToNearestSeam);  // Store for stats display
        
        // PRE-WARM ZONE: Start other decoder when within 30¬∞ of seam
        const preWarmThreshold = 30;
        const inPreWarmZone = distToNearestSeam < preWarmThreshold + halfFov;
        
        // Check if view crosses a seam
        const crossesSeam1 = (leftEdge < seam1 && rightEdge > seam1) || 
                            (leftEdge > rightEdge && (rightEdge > seam1 || leftEdge < seam1));
        const crossesSeam2 = (leftEdge < seam2 && rightEdge > seam2) ||
                            (leftEdge > rightEdge && (rightEdge > seam2 || leftEdge < seam2));
        
        // Store previous state for transition detection
        const previousLens = this.visibleLens;
        
        // Determine what lens mode the view geometry requires
        let geometryRequires;
        if (crossesSeam1 || crossesSeam2) {
          geometryRequires = 2; // Both lenses needed at seams
        } else if (inPreWarmZone) {
          geometryRequires = 2; // Pre-warm zone
        } else if (normLon >= 90 && normLon < 270) {
          geometryRequires = 0; // Front lens only
        } else {
          geometryRequires = 1; // Back lens only
        }
        
        // Apply 10-second holdoff: stay in dual mode after FOV exits the seam
        // This prevents rapid switching when user is panning near seams
        const now = performance.now();
        
        // Track if geometry requirement changed from dual to single
        const wasRequiringDual = this.lastGeometryRequires === 2;
        const nowRequiresSingle = geometryRequires !== 2;
        
        if (geometryRequires === 2) {
          // Geometry requires dual mode - use it, clear any holdoff
          this.visibleLens = 2;
          this.preWarmMode = inPreWarmZone && !crossesSeam1 && !crossesSeam2;
          if (inPreWarmZone) {
            this.primaryLens = (normLon >= 90 && normLon < 270) ? 0 : 1;
          }
          this.dualModeHoldoffEnd = 0;  // Clear holdoff when in dual zone
        } else if (wasRequiringDual && nowRequiresSingle) {
          // Just exited dual zone - START the holdoff timer
          this.dualModeHoldoffEnd = now + this.dualModeHoldoffDuration;
          this.visibleLens = 2;  // Stay in dual during holdoff
          this.preWarmMode = false;
        } else if (this.dualModeHoldoffEnd > now) {
          // Holdoff is still active - stay in dual
          this.visibleLens = 2;
          this.preWarmMode = false;
        } else {
          // No holdoff or holdoff expired - can switch to single lens
          this.visibleLens = geometryRequires;
          this.preWarmMode = false;
        }
        
        // Track geometry requirement for next frame
        this.lastGeometryRequires = geometryRequires;
        
        // Handle lens mode transitions
        if (previousLens !== this.visibleLens) {
          console.log('INSV visible lens changed:', previousLens, '->', this.visibleLens);
          
          if (previousLens !== 2 && this.visibleLens === 2) {
            // Transitioning FROM single-lens TO dual-lens mode
            // The inactive decoder is stale, but we DON'T clear the buffer
            // 
            // OPTION B: Keep existing single-lens frames playing
            // - Brief visual glitch at seam (stale texture on one half)
            // - New dual-lens frames will replace them naturally
            // - Avoids buffer underrun and quality degradation
            
            console.log('INSV lens transition: single->dual, keeping buffer (will catch up)');
            
            // Force both tracks to be decoded from now on
            this.forceFullDecode = true;
            
            // Mark that decoders need reset (will seek to keyframe on next buffer cycle)
            this.needsDecoderReset = true;
            
            // DON'T clear buffer - keep playing existing single-lens frames
            // DON'T reset bufferFrameIndex - continue from current position
            // Result: brief glitch at seam, but no underrun
            
            // WHEN PAUSED: Do a mini-seek to refresh preview with both lenses
            // This ensures the user sees correct dual-lens view while paused
            // and prepares proper buffer for when play() is called
            if (!this.playing && this.currentTime !== undefined) {
              console.log('INSV lens transition while paused: refreshing preview at', this.currentTime.toFixed(2) + 's');
              
              // Use async IIFE to handle seek and restart buffering
              const player = this;
              (async () => {
                try {
                  await player.seek(player.currentTime);
                  
                  // After seek completes, restart buffering to pre-fill buffer
                  // This ensures instant resume when play() is called
                  if (!player.playing && !player.bufferLoopRunning) {
                    console.log('INSV post-seek: restarting buffer loop for pre-fill');
                    player.startBuffering();
                  }
                } catch (e) {
                  console.error('INSV lens transition seek error:', e);
                }
              })();
            }
            
          } else if (previousLens === 2 && this.visibleLens !== 2) {
            // Transitioning FROM dual-lens TO single-lens mode
            // Dual-lens frames work fine in single-lens mode (we just ignore one lens)
            // No special handling needed
            console.log('INSV lens mode: dual -> single (' + (this.visibleLens === 0 ? 'front' : 'back') + ')');
          }
          
          this.lastVisibleLens = previousLens;
          
          // Invalidate frame cache when lens mode changes
          this.cachedRenderResult = null;
        }
      }
      
      // Helper: Determine which tracks need decoding based on targetRenderMode and visibleLens
      // Returns { needTrack0: bool, needTrack1: bool }
      // Track 0 = back lens, Track 1 = front lens
      getRequiredTracks() {
        // During preview/seek, always need both for correct frame pairing
        if (this.forceFullDecode) {
          return { needTrack0: true, needTrack1: true };
        }
        
        const mode = this.targetRenderMode || 'combined';
        let needTrack0, needTrack1, decodeMode;
        
        if (mode === 'front') {
          // Front-only shader: only need front lens (track 1)
          needTrack0 = false;
          needTrack1 = true;
          decodeMode = 'front-only';
        } else if (mode === 'back') {
          // Back-only shader: only need back lens (track 0)
          needTrack0 = true;
          needTrack1 = false;
          decodeMode = 'back-only';
        } else if (mode === 'dual') {
          // Dual shader: use visibleLens for viewport-based optimization
          // visibleLens: 0=front only, 1=back only, 2=both
          needTrack0 = this.visibleLens !== 0;  // Back lens (when not front-only view)
          needTrack1 = this.visibleLens !== 1;  // Front lens (when not back-only view)
          decodeMode = (needTrack0 && needTrack1) ? 'both' : (needTrack0 ? 'back-only' : 'front-only');
        } else {
          // Combined mode: ALWAYS need both lenses - they're stitched into one texture
          // Single-lens optimization NOT possible here because canvas has both halves
          needTrack0 = true;
          needTrack1 = true;
          decodeMode = 'both';
        }
        
        // Log when decode mode changes
        if (decodeMode !== this.lastDecodeMode) {
          console.log('INSV decode mode changed:', this.lastDecodeMode, '->', decodeMode, 
                      '(renderMode:', mode, 'visibleLens:', this.visibleLens + ')');
          this.lastDecodeMode = decodeMode;
        }
        
        return { needTrack0, needTrack1 };
      }
      
      // Check if cached render can be reused (paused video, same view)
      canUseCachedRender(lon, lat, fov) {
        if (!this.cachedRenderResult) return false;
        if (this.playing) return false;
        
        return this.cachedRenderResult.frameIndex === this.currentFrame &&
               Math.abs(lon - this.lastRenderLon) < 0.1 &&
               Math.abs(fov - this.lastRenderFov) < 0.1;
      }
      
      // Cache current render state for paused video optimization
      cacheRenderResult(lon, lat, fov) {
        if (this.playing) return;
        
        this.cachedRenderResult = {
          frameIndex: this.currentFrame,
          timestamp: performance.now()
        };
        this.lastRenderLon = lon;
        this.lastRenderLat = lat;
        this.lastRenderFov = fov;
      }
      
      // Invalidate cached render
      invalidateCache() {
        this.cachedRenderResult = null;
      }
    }

    // LRV Player class (standard video with 360 rendering)
    class LRVPlayer360 {
      constructor(file) {
        this.file = file;
        this.video = document.createElement('video');
        this.video.muted = true;
        this.video.loop = false;
        this.video.playsInline = true;
        this.video.crossOrigin = 'anonymous';
        this.video.preload = 'auto';
        this.duration = 0;
        this.playing = false;
        this._ready = false;
        this.isWaiting = false;  // For status indicator
        this.onStatusChange = null;  // Callback for status updates
      }
      
      async load() {
        return new Promise((resolve, reject) => {
          // Set up status event listeners
          this.video.addEventListener('waiting', () => {
            this.isWaiting = true;
            console.log('LRV: waiting/buffering');
            if (this.onStatusChange) this.onStatusChange('waiting');
          });
          
          this.video.addEventListener('stalled', () => {
            this.isWaiting = true;
            console.log('LRV: stalled');
            if (this.onStatusChange) this.onStatusChange('stalled');
          });
          
          this.video.addEventListener('playing', () => {
            this.isWaiting = false;
            console.log('LRV: playing');
            if (this.onStatusChange) this.onStatusChange('playing');
          });
          
          this.video.addEventListener('canplay', () => {
            this.isWaiting = false;
            if (this.onStatusChange) this.onStatusChange('canplay');
          });
          
          this.video.onloadeddata = () => {
            this.duration = this.video.duration;
            console.log('LRV video loaded, duration:', this.duration);
            
            // Play briefly to get first frame for texture, then PAUSE
            this.video.play().then(() => {
              console.log('LRV video playing briefly for first frame');
              // Wait for first frame to render, then pause
              setTimeout(() => {
                this.video.pause();
                this.video.currentTime = 0;
                this._ready = true;
                this.playing = false;
                this.isWaiting = false;
                console.log('LRV video paused at start, ready for playback');
                resolve();
              }, 100);
            }).catch(err => {
              console.warn('LRV autoplay blocked:', err);
              // Try muted playback
              this.video.muted = true;
              this.video.play().then(() => {
                setTimeout(() => {
                  this.video.pause();
                  this.video.currentTime = 0;
                  this._ready = true;
                  this.playing = false;
                  this.isWaiting = false;
                  resolve();
                }, 100);
              }).catch(err2 => {
                console.error('LRV play failed even muted:', err2);
                // Still resolve so we can at least show something
                this._ready = true;
                resolve();
              });
            });
          };
          
          this.video.onerror = (e) => {
            console.error('LRV video error:', e, this.video.error);
            reject(new Error('Could not load LRV video: ' + (this.video.error?.message || 'unknown error')));
          };
          
          const blobUrl = URL.createObjectURL(this.file);
          console.log('Loading LRV from blob:', blobUrl);
          this.video.src = blobUrl;
          this.video.load();
        });
      }
      
      play() {
        this.playing = true;
        // Unmute unless high speed playback (muted > 2x required for speed)
        const shouldMute = playbackSpeed > 2;
        this.video.muted = shouldMute;
        this.video.playbackRate = Math.min(playbackSpeed, 16);
        console.log('LRV play: muted=', shouldMute, 'speed=', playbackSpeed);
        
        this.video.play().catch(err => {
          console.warn('LRV play failed, trying muted:', err);
          // Browser may require user interaction for unmuted playback
          this.video.muted = true;
          this.video.play().catch(err2 => {
            console.error('LRV play failed even muted:', err2);
          });
        });
      }
      
      pause() {
        this.playing = false;
        this.video.pause();
      }
      
      // Alias for consistency with INSVPlayer360
      stop() {
        this.pause();
      }
      
      seek(time) {
        this.video.currentTime = time;
      }
      
      setMuted(muted) {
        this.video.muted = muted;
      }
      
      get currentTime() {
        return this.video.currentTime;
      }
      
      get paused() {
        return this.video.paused;
      }
      
      getVideoElement() {
        return this.video;
      }
      
      getStats() {
        return {
          fps: Math.round((this.video.playbackRate || 1) * 30),
          currentTime: this.video.currentTime,
          duration: this.video.duration
        };
      }
    }
    
    // Initialize Three.js 360 display
    function init360VideoDisplay(containerEl, videoSource) {
      console.log('init360VideoDisplay called');
      console.log('Container:', containerEl);
      console.log('Video source type:', videoSource instanceof HTMLVideoElement ? 'video' : 'canvas');
      
      if (videoSource instanceof HTMLVideoElement) {
        console.log('Video state: readyState=', videoSource.readyState, 'paused=', videoSource.paused, 
                    'size=', videoSource.videoWidth, 'x', videoSource.videoHeight);
      } else if (videoSource instanceof HTMLCanvasElement) {
        console.log('Canvas size:', videoSource.width, 'x', videoSource.height);
      }
      
      // Clean up existing renderer
      if (threeRenderer) {
        threeRenderer.dispose();
        if (threeRenderer.domElement && threeRenderer.domElement.parentNode) {
          threeRenderer.domElement.parentNode.removeChild(threeRenderer.domElement);
        }
      }
      
      // Clean up existing textures
      if (threeFrontTexture) { threeFrontTexture.dispose(); threeFrontTexture = null; }
      if (threeBackTexture) { threeBackTexture.dispose(); threeBackTexture = null; }
      if (materialDual) { materialDual.dispose(); materialDual = null; }
      if (materialFrontOnly) { materialFrontOnly.dispose(); materialFrontOnly = null; }
      if (materialBackOnly) { materialBackOnly.dispose(); materialBackOnly = null; }
      
      const rect = containerEl.getBoundingClientRect();
      const width = rect.width || 640;
      const height = rect.height || 360;
      
      console.log('Container dimensions:', width, 'x', height);
      
      threeScene = new THREE.Scene();
      threeCamera = new THREE.PerspectiveCamera(100, width / height, 1, 1100);
      threeCamera.target = new THREE.Vector3(0, 0, 0);
      
      // Check if we have an INSV player with separate lens canvases
      const hasSeperateLenses = current360Player && 
                                current360Player.frontLensCanvas && 
                                current360Player.backLensCanvas;
      
      // Use VideoTexture for video elements, CanvasTexture for canvas
      if (videoSource instanceof HTMLVideoElement) {
        threeTexture = new THREE.VideoTexture(videoSource);
        console.log('Created VideoTexture');
      } else {
        threeTexture = new THREE.CanvasTexture(videoSource);
        console.log('Created CanvasTexture');
      }
      threeTexture.minFilter = THREE.LinearFilter;
      threeTexture.magFilter = THREE.LinearFilter;
      
      // Create separate lens textures for INSV players
      if (hasSeperateLenses) {
        threeFrontTexture = new THREE.CanvasTexture(current360Player.frontLensCanvas);
        threeFrontTexture.minFilter = THREE.LinearFilter;
        threeFrontTexture.magFilter = THREE.LinearFilter;
        
        threeBackTexture = new THREE.CanvasTexture(current360Player.backLensCanvas);
        threeBackTexture.minFilter = THREE.LinearFilter;
        threeBackTexture.magFilter = THREE.LinearFilter;
        
        console.log('Created separate lens textures for INSV optimization');
      }
      
      // Create sphere for 360 view
      const geometry = new THREE.SphereGeometry(500, 60, 40);
      geometry.scale(-1, 1, 1);
      
      // Determine shader type based on format flag
      // 'insv' = dual-fisheye with front left, back right
      // 'lrv' = dual-fisheye with back left, front right (swapped)
      // 'equirectangular' = stitched video
      const isEquirectangular = current360Format === 'equirectangular';
      const isLRV = current360Format === 'lrv';
      
      console.log('360 format:', current360Format, 'isEquirectangular:', isEquirectangular, 'isLRV:', isLRV);
      
      // Original material using combined texture
      // Choose appropriate shader based on format
      let material;
      if (isEquirectangular) {
        material = new THREE.ShaderMaterial({
          uniforms: {
            map: { value: threeTexture },
            rollAngle: { value: 0 },  // Equirectangular doesn't need 90¬∞ roll
            tilt2: { value: tilt2Correction360 },
            uOffset: { value: 0 }
          },
          vertexShader: vertexShader360,
          fragmentShader: fragmentShader360_Equirect,
          side: THREE.DoubleSide
        });
        console.log('Using equirectangular shader for stitched video');
      } else if (isLRV) {
        material = new THREE.ShaderMaterial({
          uniforms: {
            map: { value: threeTexture },
            rollAngle: { value: rollAngle360 },
            tilt2: { value: tilt2Correction360 }
          },
          vertexShader: vertexShader360,
          fragmentShader: fragmentShader360_LRV,
          side: THREE.DoubleSide
        });
        console.log('Using LRV dual-fisheye shader (swapped lenses)');
      } else {
        material = new THREE.ShaderMaterial({
          uniforms: {
            map: { value: threeTexture },
            rollAngle: { value: rollAngle360 },
            tilt2: { value: tilt2Correction360 }
          },
          vertexShader: vertexShader360,
          fragmentShader: fragmentShader360,
          side: THREE.DoubleSide
        });
        console.log('Using INSV dual-fisheye shader');
      }
      
      // Create optimized materials for INSV players
      if (hasSeperateLenses) {
        // Dual-texture material (for viewing at seams)
        materialDual = new THREE.ShaderMaterial({
          uniforms: {
            frontMap: { value: threeFrontTexture },
            backMap: { value: threeBackTexture },
            rollAngle: { value: rollAngle360 },
            tilt2: { value: tilt2Correction360 }
          },
          vertexShader: vertexShader360,
          fragmentShader: fragmentShader360_DualTexture,
          side: THREE.DoubleSide
        });
        
        // Front lens only material (optimized - no branch)
        materialFrontOnly = new THREE.ShaderMaterial({
          uniforms: {
            frontMap: { value: threeFrontTexture },
            rollAngle: { value: rollAngle360 },
            tilt2: { value: tilt2Correction360 }
          },
          vertexShader: vertexShader360,
          fragmentShader: fragmentShader360_FrontOnly,
          side: THREE.DoubleSide
        });
        
        // Back lens only material (optimized - no branch)
        materialBackOnly = new THREE.ShaderMaterial({
          uniforms: {
            backMap: { value: threeBackTexture },
            rollAngle: { value: rollAngle360 },
            tilt2: { value: tilt2Correction360 }
          },
          vertexShader: vertexShader360,
          fragmentShader: fragmentShader360_BackOnly,
          side: THREE.DoubleSide
        });
        
        currentShaderMode = 'combined';
        console.log('Created optimized single-lens materials');
      }
      
      threeSphere = new THREE.Mesh(geometry, material);
      threeScene.add(threeSphere);
      
      // MegaView setup with Pannini projection
      orthoCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
      orthoCamera.position.z = 1;
      
      const megaViewGeometry = new THREE.PlaneGeometry(2, 2);
      
      // Helper function to calculate Pannini d parameter from FOV
      // d=0.8 at 160¬∞, d=1.0 at 180¬∞, d=1.47 at 260¬∞
      function calculatePanniniD(hFovDeg) {
        return 0.8 + (hFovDeg - 160) * 0.0067;
      }
      
      const initialHFov = THREE.MathUtils.degToRad(megaHFov);
      const initialD = calculatePanniniD(megaHFov);
      
      // Use appropriate megaView shader based on format
      if (isEquirectangular) {
        megaViewMaterial = new THREE.ShaderMaterial({
          uniforms: {
            map: { value: threeTexture },
            rollAngle: { value: 0 },  // Equirectangular doesn't need 90¬∞ roll
            tilt2: { value: tilt2Correction360 },
            yaw: { value: 0 },
            pitch: { value: 0 },
            hFov: { value: initialHFov },
            panniniD: { value: 0.8 },  // Edge vertical compression: 0=none, 0.8=moderate, 1.5=strong
            aspect: { value: width / height },
            uOffset: { value: 0.5 }  // 180¬∞ offset to match 360¬∞ sphere view direction
          },
          vertexShader: megaViewVertexShader,
          fragmentShader: megaViewFragmentShader_Equirect
        });
        console.log('Using Pannini equirectangular megaView shader');
      } else if (isLRV) {
        megaViewMaterial = new THREE.ShaderMaterial({
          uniforms: {
            map: { value: threeTexture },
            rollAngle: { value: rollAngle360 },
            tilt2: { value: tilt2Correction360 },
            yaw: { value: 0 },
            pitch: { value: 0 },
            hFov: { value: initialHFov },
            panniniD: { value: 0.8 },  // Edge vertical compression: same as equirectangular
            aspect: { value: width / height }
          },
          vertexShader: megaViewVertexShader,
          fragmentShader: megaViewFragmentShader_LRV
        });
        console.log('Using Pannini LRV megaView shader');
      } else {
        megaViewMaterial = new THREE.ShaderMaterial({
          uniforms: {
            map: { value: threeTexture },
            rollAngle: { value: rollAngle360 },
            tilt2: { value: tilt2Correction360 },
            yaw: { value: 0 },
            pitch: { value: 0 },
            hFov: { value: initialHFov },
            panniniD: { value: 0.8 },  // Edge vertical compression: same as equirectangular
            aspect: { value: width / height }
          },
          vertexShader: megaViewVertexShader,
          fragmentShader: megaViewFragmentShader
        });
        console.log('Using Pannini INSV megaView shader');
      }
      megaViewMesh = new THREE.Mesh(megaViewGeometry, megaViewMaterial);
      megaViewMesh.visible = false;
      threeScene.add(megaViewMesh);
      
      threeRenderer = new THREE.WebGLRenderer({ antialias: false });  // Disable antialias for perf
      // Use reduced pixel ratio for better performance
      const renderScale = typeof renderQuality360 !== 'undefined' ? renderQuality360 : 0.75;
      threeRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 1) * renderScale);
      threeRenderer.setSize(width, height);
      threeRenderer.domElement.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;cursor:grab;';
      containerEl.appendChild(threeRenderer.domElement);
      
      // Handle WebGL context loss/restoration
      threeRenderer.domElement.addEventListener('webglcontextlost', (e) => {
        console.warn('WebGL context lost - pausing render');
        e.preventDefault();  // Allow context restoration
        // Mark video player for recovery
        if (current360Player) {
          current360Player.decodersCorrupted = true;
        }
      });
      
      threeRenderer.domElement.addEventListener('webglcontextrestored', () => {
        console.log('WebGL context restored - resuming render');
        // Recreate textures after context restoration
        if (current360Player && current360Player.combinedCanvas) {
          threeTexture = new THREE.CanvasTexture(current360Player.combinedCanvas);
          threeTexture.minFilter = THREE.LinearFilter;
          threeTexture.magFilter = THREE.LinearFilter;
          if (combinedMaterial) combinedMaterial.map = threeTexture;
        }
      });
      
      console.log('Three.js renderer created, renderScale:', renderScale, 'effectivePixelRatio:', threeRenderer.getPixelRatio());
      
      // Mouse/touch controls
      threeRenderer.domElement.onpointerdown = e => {
        isPointerDown360 = true;
        startX360 = e.clientX;
        startY360 = e.clientY;
        startLon360 = lon360;
        startLat360 = lat360;
        threeRenderer.domElement.style.cursor = 'grabbing';
      };
      
      threeRenderer.domElement.onpointermove = e => {
        if (!isPointerDown360) return;
        lon360 = (startX360 - e.clientX) * 0.2 + startLon360;
        lat360 = (e.clientY - startY360) * 0.2 + startLat360;
        lat360 = Math.max(-85, Math.min(85, lat360));
      };
      
      threeRenderer.domElement.onpointerup = () => {
        isPointerDown360 = false;
        threeRenderer.domElement.style.cursor = 'grab';
      };
      
      threeRenderer.domElement.onwheel = e => {
        e.preventDefault();
        if (viewMode360 === 'megaview') {
          // Pannini MEGA view: adjust horizontal FOV 160-300¬∞
          megaHFov = THREE.MathUtils.clamp(megaHFov + e.deltaY * 0.15, 160, 300);
          // Update shader uniforms
          if (megaViewMaterial && megaViewMaterial.uniforms) {
            megaViewMaterial.uniforms.hFov.value = THREE.MathUtils.degToRad(megaHFov);
            // Keep fixed panniniD for edge compensation
          }
          updateViewModeTag360();  // Update display to show current FOV
        } else {
          // Standard 360 spherical view
          threeCamera.fov = THREE.MathUtils.clamp(threeCamera.fov + e.deltaY * 0.05, 30, 100);
          threeCamera.updateProjectionMatrix();
          updateViewModeTag360();  // Update display to show current FOV
        }
      };
      
      threeRenderer.domElement.ondblclick = togglePlayback;
      
      return threeRenderer;
    }
    
    let animate360FrameCount = 0;
    let lastAnimate360Time = 0;
    let animate360ForceTextureFrames = 0;  // Force texture updates for first N frames
    
    // Dynamic render interval - matches video FPS for smooth playback
    function getAnimate360MinInterval() {
      if (current360Player && current360Player.targetFps) {
        return 1000 / current360Player.targetFps;
      }
      return 1000 / 30; // Default 30fps when no video
    }
    
    function animate360() {
      if (!threeRenderer || !is360VideoActive) {
        console.log('animate360 stopped: renderer=', !!threeRenderer, 'active=', is360VideoActive);
        return;
      }
      
      requestAnimationFrame(animate360);
      
      // Throttle Three.js rendering to match video FPS
      const now = performance.now();
      const minInterval = getAnimate360MinInterval();
      if (now - lastAnimate360Time < minInterval) {
        return; // Skip this frame
      }
      lastAnimate360Time = now;
      
      // Track frame timing for GPU monitoring (only for frames that actually render)
      perfMonitor.trackFrame();
      
      // Update viewport for INSV player (viewport-only rendering)
      if (current360Player && current360Player.updateViewport) {
        current360Player.updateViewport(lon360, threeCamera ? threeCamera.fov : 100);
      }
      
      // Compute target render mode based on CURRENT visibleLens (not stale currentShaderMode)
      // NOTE: forceFullDecode only affects which tracks to DECODE, not which material to RENDER with
      // We always choose render mode based on visibleLens, regardless of decode mode
      let targetMode = 'combined';
      if (current360Player && viewMode360 === '360') {
        const visibleLens = current360Player.visibleLens;
        if (visibleLens === 0 && materialFrontOnly) {
          targetMode = 'front';
        } else if (visibleLens === 1 && materialBackOnly) {
          targetMode = 'back';
        } else if (visibleLens === 2 && materialDual) {
          targetMode = 'dual';
        }
      } else if (current360Player && viewMode360 === 'megaview' && materialDual) {
        // MEGA view: always use dual mode for INSV to keep both lenses active
        targetMode = 'dual';
      }
      
      // Tell INSV player which render mode we're using so it can skip unnecessary canvas draws
      // This MUST happen before drawFramePair is called in the player's render loop
      if (current360Player) {
        current360Player.targetRenderMode = targetMode;
      }
      
      // === OPTIMIZED TEXTURE UPDATES FOR INSV PLAYERS ===
      const hasOptimizedTextures = threeFrontTexture && threeBackTexture && current360Player;
      
      if (hasOptimizedTextures) {
        // Check if we can use cached render (paused video, same view)
        // CRITICAL: Never use cache if a mode switch is needed
        const needsModeSwitch = targetMode !== currentShaderMode;
        const canUseCache = !needsModeSwitch && 
            current360Player.canUseCachedRender && 
            current360Player.canUseCachedRender(lon360, lat360, threeCamera.fov);
        
        if (canUseCache) {
          // Skip texture updates - just render with cached state
          // Still need to render in case window resized
        } else {
          // OPTIMIZATION: Only upload the texture that's actually being rendered
          // CRITICAL: Use targetMode (not currentShaderMode) for texture upload decision
          // This ensures textures are uploaded BEFORE the material switch happens
          // Without this, switching from front‚Üídual would show garbage on back lens
          
          const needsFrontUpdate = current360Player.frontLensUpdated;
          const needsBackUpdate = current360Player.backLensUpdated;
          
          // Force texture updates for first N frames after loading a new video
          // This ensures the texture is populated even if the player flags aren't set yet
          const forceInitialUpdate = animate360ForceTextureFrames > 0;
          if (forceInitialUpdate) {
            animate360ForceTextureFrames--;
          }
          
          // Also upload textures if we're about to switch modes (they may be stale)
          let switchingModes = targetMode !== currentShaderMode;
          
          // Check if we're waiting for frames for a pending mode switch
          // If target matches pending, we're still waiting - don't spam logs
          const alreadyWaitingForThisMode = pendingModeSwitch === targetMode;
          
          // Debug log mode switch attempts (only first time, not repeated attempts)
          if (switchingModes && !alreadyWaitingForThisMode) {
            console.log('animate360 mode switch:', currentShaderMode, '->', targetMode);
          }
          
          // CRITICAL: When switching modes, force redraw to all canvases
          // The previous render mode may have only drawn to some canvases,
          // leaving others stale. This ensures fresh data before texture upload.
          // If redraw fails (buffer has single-lens frames), DON'T switch modes - stay on current
          let redrawSuccess = true;
          if (switchingModes && current360Player.forceRedrawToAllCanvases) {
            redrawSuccess = current360Player.forceRedrawToAllCanvases(targetMode);
            if (!redrawSuccess) {
              // Only log once when we start waiting
              if (!alreadyWaitingForThisMode) {
                console.log('animate360: waiting for', targetMode, 'frames, staying on', currentShaderMode);
                pendingModeSwitch = targetMode;
              }
              // Buffer doesn't have required frames for target mode
              // Stay on current mode until dual-lens frames arrive
              switchingModes = false;
              // Also revert targetMode for texture upload logic
              targetMode = currentShaderMode;
            } else {
              // Redraw succeeded - clear pending flag if it was set
              if (pendingModeSwitch) {
                console.log('animate360: pending mode switch to', pendingModeSwitch, 'completed');
                pendingModeSwitch = null;
              }
            }
          }
          
          // Clear pending mode switch if user changed view away from the pending target
          if (pendingModeSwitch && !switchingModes && targetMode !== pendingModeSwitch) {
            console.log('animate360: cancelled pending switch to', pendingModeSwitch, '(now targeting', targetMode + ')');
            pendingModeSwitch = null;
          }
          
          // Re-check update flags after potential redraw
          const finalNeedsFront = current360Player.frontLensUpdated || needsFrontUpdate || forceInitialUpdate;
          const finalNeedsBack = current360Player.backLensUpdated || needsBackUpdate || forceInitialUpdate;
          
          // Skip if no canvas was updated AND we're not switching modes AND not forcing initial
          if (!finalNeedsFront && !finalNeedsBack && !switchingModes && !forceInitialUpdate) {
            // No new frame drawn and no mode switch - skip texture upload entirely
          } else if (targetMode === 'front') {
            // Front-only mode: only front texture needed
            if (finalNeedsFront || switchingModes || forceInitialUpdate) {
              threeFrontTexture.needsUpdate = true;
              perfMonitor.trackTextureUpload();
            }
          } else if (targetMode === 'back') {
            // Back-only mode: only back texture needed
            if (finalNeedsBack || switchingModes || forceInitialUpdate) {
              threeBackTexture.needsUpdate = true;
              perfMonitor.trackTextureUpload();
            }
          } else if (targetMode === 'dual') {
            // Dual mode: need both separate textures
            // When switching TO dual mode, force both textures to update
            if (finalNeedsFront || switchingModes || forceInitialUpdate) {
              threeFrontTexture.needsUpdate = true;
              perfMonitor.trackTextureUpload();
            }
            if (finalNeedsBack || switchingModes || forceInitialUpdate) {
              threeBackTexture.needsUpdate = true;
              perfMonitor.trackTextureUpload();
            }
          } else {
            // Combined mode (default): only combined texture needed
            if (threeTexture && (finalNeedsFront || finalNeedsBack || switchingModes || forceInitialUpdate)) {
              threeTexture.needsUpdate = true;
              perfMonitor.trackTextureUpload();
            }
          }
          
          // Clear update flags after processing
          current360Player.frontLensUpdated = false;
          current360Player.backLensUpdated = false;
          
          // Cache this render state for paused video optimization
          if (current360Player.cacheRenderResult) {
            current360Player.cacheRenderResult(lon360, lat360, threeCamera.fov);
          }
        }
        
        // === MATERIAL SWITCHING BASED ON VISIBLE LENS ===
        // targetMode was already computed above based on visibleLens
        // Switch material if needed
        if (targetMode !== currentShaderMode && threeSphere) {
          // Material switch - texture uploads already happened above using targetMode
          switch (targetMode) {
            case 'front':
              threeSphere.material = materialFrontOnly;
              currentShaderMode = 'front';
              break;
            case 'back':
              threeSphere.material = materialBackOnly;
              currentShaderMode = 'back';
              break;
            case 'dual':
              threeSphere.material = materialDual;
              currentShaderMode = 'dual';
              break;
            default:
              // Keep combined (original) material
              currentShaderMode = 'combined';
              break;
          }
          
          // Update roll angle on new material
          const baseRoll1 = current360Format === 'equirectangular' ? 0 : rollAngle360;
          if (threeSphere.material.uniforms && threeSphere.material.uniforms.rollAngle) {
            threeSphere.material.uniforms.rollAngle.value = baseRoll1 + tiltCorrection360;
          }
        }
        
        // Update roll angle on all materials (in case it changed)
        const baseRoll2 = current360Format === 'equirectangular' ? 0 : rollAngle360;
        if (materialDual && materialDual.uniforms.rollAngle) {
          materialDual.uniforms.rollAngle.value = baseRoll2 + tiltCorrection360;
        }
        if (materialFrontOnly && materialFrontOnly.uniforms.rollAngle) {
          materialFrontOnly.uniforms.rollAngle.value = baseRoll2 + tiltCorrection360;
        }
        if (materialBackOnly && materialBackOnly.uniforms.rollAngle) {
          materialBackOnly.uniforms.rollAngle.value = baseRoll2 + tiltCorrection360;
        }
        
      } else {
        // Non-INSV player: use original combined texture approach
        if (threeTexture) {
          threeTexture.needsUpdate = true;
          perfMonitor.trackTextureUpload();
        }
      }
      
      animate360FrameCount++;
      if (animate360FrameCount <= 5) {
        console.log('animate360 frame', animate360FrameCount, 'mode:', currentShaderMode);
      }
      
      if (viewMode360 === '360') {
        const phi = THREE.MathUtils.degToRad(90 - lat360);
        const theta = THREE.MathUtils.degToRad(lon360);
        
        threeCamera.target.x = 500 * Math.sin(phi) * Math.cos(theta);
        threeCamera.target.y = 500 * Math.cos(phi);
        threeCamera.target.z = 500 * Math.sin(phi) * Math.sin(theta);
        threeCamera.lookAt(threeCamera.target);
        threeCamera.position.set(0, 0, 0);
        
        threeSphere.visible = true;
        if (megaViewMesh) megaViewMesh.visible = false;
        
        perfMonitor.track('threeJsRender', () => threeRenderer.render(threeScene, threeCamera));
      } else {
        if (megaViewMaterial) {
          // LRV UV flip mirrors the view, needs 180¬∞ offset
          // INSV also needs 180¬∞ offset, Equirect needs 0¬∞
          const yawOffset = current360Format === 'equirectangular' ? 0 : 180;
          const yawRad = THREE.MathUtils.degToRad(lon360 + yawOffset);
          const pitchRad = THREE.MathUtils.degToRad(-lat360);
          
          megaViewMaterial.uniforms.yaw.value = yawRad;
          megaViewMaterial.uniforms.pitch.value = pitchRad;
          // hFov and panniniD are updated by wheel handler, no need to set here
        }
        
        threeSphere.visible = false;
        if (megaViewMesh) megaViewMesh.visible = true;
        
        perfMonitor.track('threeJsRender', () => threeRenderer.render(threeScene, orthoCamera));
      }
    }
    
    function toggle360ViewMode() {
      // MEGA view is disabled for INSV dual-fisheye videos
      if (current360Format === 'insv') {
        console.log('MEGA view not available for INSV dual-fisheye videos');
        return;
      }
      
      if (viewMode360 === '360') {
        viewMode360 = 'megaview';
        megaHFov = 200;  // Default MEGA FOV
        
        // Preserve current view direction for all formats
        // (removed special pitch-down for dual-fisheye)
        
        // Update shader uniforms
        if (megaViewMaterial && megaViewMaterial.uniforms) {
          megaViewMaterial.uniforms.hFov.value = THREE.MathUtils.degToRad(megaHFov);
          // Use fixed panniniD for edge compensation (same algorithm for all formats)
          megaViewMaterial.uniforms.panniniD.value = 0.8;
        }
      } else {
        viewMode360 = '360';
        // Preserve view direction for all formats
        threeCamera.fov = 100;
        threeCamera.updateProjectionMatrix();
      }
      updateViewModeTag360();
    }
    
    function toggle360Orientation() {
      currentOrientation360 = currentOrientation360 === 'horizontal' ? 'vertical' : 'horizontal';
      
      // For dual-fisheye formats, toggle between horizontal (œÄ/2) and vertical (0)
      // For equirectangular, orientation doesn't apply the same way - always use 0 base
      if (current360Format !== 'equirectangular') {
        rollAngle360 = currentOrientation360 === 'horizontal' ? Math.PI / 2 : 0;
      }
      
      // Calculate base roll based on format
      const baseRoll = current360Format === 'equirectangular' ? 0 : rollAngle360;
      
      if (threeSphere && threeSphere.material && threeSphere.material.uniforms) {
        threeSphere.material.uniforms.rollAngle.value = baseRoll + tiltCorrection360;
      }
      if (megaViewMaterial && megaViewMaterial.uniforms) {
        megaViewMaterial.uniforms.rollAngle.value = baseRoll + tiltCorrection360;
      }
      
      // Update roll angle on all optimized materials
      if (materialDual && materialDual.uniforms && materialDual.uniforms.rollAngle) {
        materialDual.uniforms.rollAngle.value = baseRoll + tiltCorrection360;
      }
      if (materialFrontOnly && materialFrontOnly.uniforms && materialFrontOnly.uniforms.rollAngle) {
        materialFrontOnly.uniforms.rollAngle.value = baseRoll + tiltCorrection360;
      }
      if (materialBackOnly && materialBackOnly.uniforms && materialBackOnly.uniforms.rollAngle) {
        materialBackOnly.uniforms.rollAngle.value = baseRoll + tiltCorrection360;
      }
      
      updateOrientationTag360();
    }
    
    function updateOrientationTag360() {
      const tag = document.getElementById('orient-tag-360');
      if (tag) {
        tag.textContent = currentOrientation360.toUpperCase();
        tag.className = 'orient-tag ' + currentOrientation360;
      }
    }
    
    function updateViewModeTag360() {
      const tag = document.getElementById('view-mode-tag-360');
      if (tag) {
        let text;
        if (viewMode360 === '360') {
          const linearFov = threeCamera ? Math.round(threeCamera.fov) : 100;
          text = `Linear ${linearFov}¬∞`;
        } else {
          text = `MEGA ${Math.round(megaHFov)}¬∞`;
        }
        // Show corrections if non-zero
        if (Math.abs(tiltCorrection360) > 0.001 || Math.abs(tilt2Correction360) > 0.001) {
          const t1 = (tiltCorrection360 * 180 / Math.PI).toFixed(1);
          const t2 = (tilt2Correction360 * 180 / Math.PI).toFixed(1);
          text += ` T1:${t1} T2:${t2}`;
        }
        tag.textContent = text;
        
        // Hide toggle click for INSV (MEGA not available)
        if (current360Format === 'insv') {
          tag.style.cursor = 'default';
          tag.style.opacity = '0.7';
          tag.title = 'MEGA view not available for INSV';
        } else {
          tag.style.cursor = 'pointer';
          tag.style.opacity = '1';
          tag.title = 'Click to toggle Linear/MEGA view';
        }
      }
    }
    
    async function load360Video(file, videoData, loadGeneration = null) {
      const isINSV = isINSVFile(file.name);
      const isInsta360MP4 = isInsta360MP4File(file.name);
      const isLRV = file.name.toLowerCase().endsWith('.lrv');
      console.log('[load360Video] gen=' + loadGeneration + ' file:', file.name, 'isINSV:', isINSV, 'isLRV:', isLRV, 'isInsta360MP4:', isInsta360MP4);
      console.log('[load360Video] file object:', file, 'instanceof File:', file instanceof File, 'size:', file?.size);
      
      if (!file || !(file instanceof File || file instanceof Blob)) {
        console.error('[load360Video] Invalid file passed:', file);
        throw new Error('Invalid file object - file may have been garbage collected');
      }
      
      // Helper to check if this load is still valid
      const isLoadValid = () => {
        if (loadGeneration !== null && loadGeneration !== videoLoadGeneration) {
          console.log('[load360Video] gen=' + loadGeneration + ' superseded by gen=' + videoLoadGeneration);
          return false;
        }
        return true;
      };
      
      // Detect orientation from file metadata
      const fileSize = file.size;
      const readSize = Math.min(10 * 1024, fileSize);
      const chunk = await file.slice(fileSize - readSize, fileSize).arrayBuffer();
      
      // Check if still valid after async operation
      if (!isLoadValid()) return;
      
      const orientation = detectOrientation360(new Uint8Array(chunk));
      
      currentOrientation360 = orientation;
      rollAngle360 = orientation === 'horizontal' ? Math.PI / 2 : 0;
      tiltCorrection360 = 0;  // Reset tilt correction for new video
      tilt2Correction360 = 0;  // Reset tilt 2 correction for new video
      // LRV looks forward by default (0), INSV looks backward (180)
      lon360 = isINSV ? 180 : 0;
      lat360 = 0;
      
      console.log('[load360Video] gen=' + loadGeneration + ' orientation:', orientation);
      
      // Show loading overlay
      const loadingOverlay = document.getElementById('video-360-loading');
      const loadingText = document.getElementById('video-360-loading-text');
      if (loadingOverlay) loadingOverlay.style.display = 'flex';
      
      try {
        if (isINSV) {
          // Check WebCodecs support
          if (typeof VideoDecoder === 'undefined') {
            throw new Error('WebCodecs API not supported. Please use Chrome or Edge.');
          }
          
          // INSV files use standard dual-fisheye layout (front left, back right)
          current360Format = 'insv';
          
          current360Player = new INSVPlayer360(file);
          current360Player.setLoadingCallback((msg) => {
            if (loadingText) loadingText.textContent = msg;
          });
          
          // Set up status callback for Live indicator (same as LRV)
          current360Player.onStatusChange = (status) => {
            if (currentActiveVideo && currentActiveVideo.is360Video) {
              if (status === 'waiting' || status === 'stalled') {
                videoStalled = true;
                currentActiveVideo.isWaiting = true;
              } else {
                videoStalled = false;
                currentActiveVideo.isWaiting = false;
              }
              updateVideoStatusIndicator();
            }
          };
          
          // Set up wall-clock sync and performance callbacks
          current360Player.onSyncToVideo = (videoTimeSec) => {
            syncTimelineToVideo(videoTimeSec);
          };
          
          current360Player.onQualityReduce = () => {
            reduceVideoQuality();
          };
          
          current360Player.onQualityIncrease = () => {
            increaseVideoQuality();
          };
          
          // load() waits for moov parsing and decoder init
          await current360Player.load();
          
          // Check if this load was superseded while waiting
          if (!isLoadValid()) {
            console.log('[load360Video] gen=' + loadGeneration + ' invalidated after load(), stopping old player');
            if (current360Player && current360Player.stop) {
              current360Player.stop();
            }
            // Hide loading overlay since this load was cancelled
            if (loadingOverlay) loadingOverlay.style.display = 'none';
            return;
          }
          
          // CRITICAL: Sync quality level with actual INSV settings
          // Find the best matching level in our quality ladder
          const actualTextureScale = current360Player.textureScale;
          const actualFps = current360Player.targetFps;
          
          // Find closest matching level in ladder
          let bestMatch = 0;
          let bestDistance = Infinity;
          for (let i = 0; i < qualityLadder.length; i++) {
            const level = qualityLadder[i];
            // Calculate distance - weight FPS and texture equally
            const fpsDist = Math.abs(level.fps - actualFps) / 30;  // Normalize to 0-1
            const texDist = Math.abs(level.texture - actualTextureScale);
            const distance = fpsDist + texDist;
            if (distance < bestDistance) {
              bestDistance = distance;
              bestMatch = i;
            }
          }
          currentQualityLevel = bestMatch;
          const matchedLevel = qualityLadder[currentQualityLevel];
          currentQualityIndex = qualityLevels.indexOf(matchedLevel.quality);
          
          console.log('Quality level synced to INSV settings:', actualFps + 'fps/' + actualTextureScale + ' -> level', currentQualityLevel, '(' + matchedLevel.label + ')');
          
          // Update UI selectors to show current values
          const qualitySelector = document.getElementById('video-quality-selector');
          if (qualitySelector) {
            qualitySelector.value = matchedLevel.quality;
          }
          const fpsSelector = document.getElementById('video-fps-selector');
          if (fpsSelector) {
            fpsSelector.value = actualFps.toString();
          }
          
          // Show fps/quality controls for INSV
          const fpsContainer = document.getElementById('video-fps-selector-container');
          if (fpsContainer) {
            fpsContainer.style.display = 'block';
            fpsContainer.classList.add('insv-controls');  // Enable fullscreen styling
          }
          
          console.log('[load360Video] gen=' + loadGeneration + ' INSV loaded, duration:', current360Player.duration, 'totalFrames:', current360Player.totalFrames,
                     'targetFps:', current360Player.targetFps, 'canvas:', current360Player.combinedCanvas.width + 'x' + current360Player.combinedCanvas.height);
          
          // Initialize 360 display with combined canvas
          const container = document.getElementById('active-video-element');
          if (container) {
            // CRITICAL: Verify container is still valid and belongs to our expected video
            if (!container.isConnected) {
              console.warn('[load360Video] gen=' + loadGeneration + ' Container disconnected from DOM, aborting init');
              return;
            }
            
            // Force decode of first frame before initializing display
            // This ensures the canvas has content to show
            if (current360Player.seek) {
              try {
                await current360Player.seek(0);
                console.log('[load360Video] gen=' + loadGeneration + ' First frame decoded');
              } catch (seekErr) {
                console.warn('[load360Video] gen=' + loadGeneration + ' Initial seek failed:', seekErr);
              }
            }
            
            // Re-check validity after async seek
            if (!isLoadValid()) {
              console.log('[load360Video] gen=' + loadGeneration + ' invalidated after initial seek');
              return;
            }
            
            init360VideoDisplay(container, current360Player.combinedCanvas);
            is360VideoActive = true;
            animate360FrameCount = 0;
            animate360ForceTextureFrames = 60;  // Force texture updates for first 60 frames (~2 seconds at 30fps)
            animate360();
            
            console.log('[load360Video] gen=' + loadGeneration + ' 360 display initialized and animation started');
          } else {
            console.error('[load360Video] gen=' + loadGeneration + ' Container not found!');
          }
          
          videoData.durationSec = current360Player.duration;
          videoData.endTimestampMs = videoData.startTimestampMs + current360Player.duration * 1000;
          
        } else {
          // LRV file or Insta360 MP4
          current360Player = new LRVPlayer360(file);
          if (loadingText) {
            loadingText.textContent = isInsta360MP4 ? 'Loading Insta360 MP4...' : 'Loading LRV video...';
          }
          
          // Set up status callback for Live indicator
          current360Player.onStatusChange = (status) => {
            if (currentActiveVideo && currentActiveVideo.is360Video) {
              if (status === 'waiting' || status === 'stalled') {
                videoStalled = true;
                currentActiveVideo.isWaiting = true;
              } else {
                videoStalled = false;
                currentActiveVideo.isWaiting = false;
              }
              updateVideoStatusIndicator();
            }
          };
          
          await current360Player.load();
          
          const videoWidth = current360Player.video.videoWidth;
          const videoHeight = current360Player.video.videoHeight;
          const aspectRatio = videoWidth / videoHeight;
          
          // LRV files are ALWAYS dual-fisheye format
          // Only Insta360 MP4 files use aspect ratio detection
          if (isLRV) {
            // LRV is always dual-fisheye regardless of aspect ratio
            current360Format = 'lrv';
            console.log('LRV file - using dual-fisheye format (aspect ratio:', aspectRatio.toFixed(2) + ')');
          } else if (isInsta360MP4) {
            // Insta360 MP4: check aspect ratio
            // Equirectangular (stitched): exactly 2:1 aspect ratio
            // Dual-fisheye (raw export): typically 1:1
            if (Math.abs(aspectRatio - 2.0) < 0.1) {
              current360Format = 'equirectangular';
              console.log('Insta360 MP4 - detected equirectangular format (aspect ratio:', aspectRatio.toFixed(2) + ')');
            } else {
              current360Format = 'lrv';  // Use LRV shader for dual-fisheye MP4
              console.log('Insta360 MP4 - detected dual-fisheye format (aspect ratio:', aspectRatio.toFixed(2) + ')');
            }
          }
          
          const fileType = isInsta360MP4 ? 'Insta360 MP4' : 'LRV';
          console.log(fileType + ' loaded, duration:', current360Player.duration, 'video size:', videoWidth, 'x', videoHeight, 'format:', current360Format);
          
          // All formats default to Linear view
          // (MEGA view is still available for LRV/equirectangular via toggle)
          viewMode360 = '360';
          
          // Hide fps/quality controls for LRV (only works for INSV)
          const fpsContainer = document.getElementById('video-fps-selector-container');
          if (fpsContainer) {
            fpsContainer.style.display = 'none';
            fpsContainer.classList.remove('insv-controls');  // Remove fullscreen styling class
          }
          
          // Video is paused at start, ready for playback
          const container = document.getElementById('active-video-element');
          if (container) {
            init360VideoDisplay(container, current360Player.video);
            console.log('Created 360 display for', fileType);
            is360VideoActive = true;  // Set BEFORE animate360!
            animate360FrameCount = 0;
            animate360ForceTextureFrames = 60;  // Force texture updates for first 60 frames
            animate360();
          }
          
          videoData.durationSec = current360Player.duration;
          videoData.endTimestampMs = videoData.startTimestampMs + current360Player.duration * 1000;
        }
        
        console.log('360 video loaded, duration:', videoData.durationSec, 'endTimestampMs:', videoData.endTimestampMs);
        
        updateOrientationTag360();
        updateViewModeTag360();
        updateWizardState({ videoLoaded: true });  // Update wizard
        
      } catch (err) {
        console.error('[load360Video] gen=' + loadGeneration + ' Error loading 360 video:', err);
        alert('Error loading 360 video: ' + err.message);
        is360VideoActive = false;
      } finally {
        if (loadingOverlay) loadingOverlay.style.display = 'none';
      }
      
      return videoData;
    }
    
    function sync360VideoToPlayback() {
      if (!is360VideoActive || !current360Player || !currentActiveVideo) return;
      
      const referenceStartMs = getFullStartTimeMs();
      const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
      const videoTimeMs = currentAbsoluteMs - currentActiveVideo.startTimestampMs;
      const videoTimeSec = videoTimeMs / 1000;
      
      if (videoTimeSec >= 0 && videoTimeSec <= currentActiveVideo.durationSec) {
        current360Player.seek(videoTimeSec);
      }
    }
    
    function play360Video() {
      if (!current360Player) return;
      current360Player.play();
    }
    
    function pause360Video() {
      if (!current360Player) return;
      current360Player.pause();
    }
    
    function resize360Renderer() {
      if (!threeRenderer || !is360VideoActive) return;
      
      const container = document.getElementById('active-video-element');
      if (!container) return;
      
      const rect = container.getBoundingClientRect();
      const width = rect.width || 640;
      const height = rect.height || 360;
      
      threeCamera.aspect = width / height;
      threeCamera.updateProjectionMatrix();
      threeRenderer.setSize(width, height);
      
      if (megaViewMaterial) {
        megaViewMaterial.uniforms.aspect.value = width / height;
      }
    }
    
    window.addEventListener('resize', resize360Renderer);
    
    // ==================== WIZARD STATE MANAGEMENT ====================
    let wizardState = { trackLoaded: false, videoLoaded: false };
    
    function updateWizardState(state) {
      Object.assign(wizardState, state);
      
      const step1 = document.getElementById('wizard-step-1');
      const step2 = document.getElementById('wizard-step-2');
      const step3 = document.getElementById('wizard-step-3');
      
      if (!step1 || !step2 || !step3) return;
      
      // Reset all steps
      [step1, step2, step3].forEach(s => {
        s.classList.remove('active', 'completed');
      });
      
      if (wizardState.trackLoaded && wizardState.videoLoaded) {
        // All done - step 3 active, 1&2 completed
        step1.classList.add('completed');
        step2.classList.add('completed');
        step3.classList.add('active');
      } else if (wizardState.trackLoaded) {
        // Track loaded - step 2 active, 1 completed
        step1.classList.add('completed');
        step2.classList.add('active');
      } else {
        // Nothing loaded - step 1 active
        step1.classList.add('active');
      }
    }
    
    function resetWizardState() {
      wizardState = { trackLoaded: false, videoLoaded: false };
      updateWizardState({});
    }
  </script>
</body>
</html>
