<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sailing Steering Analysis Dashboard</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f3f4f6; min-height: 100vh; padding: 16px; }
    
    /* GPU-accelerated video rendering with performance hints */
    video {
      transform: translateZ(0);
      will-change: transform, contents;
      backface-visibility: hidden;
      -webkit-transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      contain: strict;
      content-visibility: auto;
    }
    
    /* Video container isolation for better performance */
    #video-container {
      contain: layout style;
      isolation: isolate;
      max-width: 100%;
    }
    
    /* Fullscreen video styles */
    #video-wrapper:fullscreen {
      width: 100vw;
      height: 100vh;
      background: #000 !important;
      border-radius: 0 !important;
      display: flex;
      flex-direction: column;
    }
    
    #video-wrapper:fullscreen #active-video-element {
      flex: 1;
      width: 100%;
      aspect-ratio: auto;
      max-height: none;
      position: relative;
    }
    
    #video-wrapper:fullscreen video {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    
    #video-wrapper:fullscreen #video-unavailable-overlay {
      pointer-events: auto !important;
      background: rgba(0,0,0,0.85) !important;
    }
    
    #video-wrapper:fullscreen #video-unavailable-overlay > div {
      font-size: 20px !important;
    }
    
    #video-wrapper:fullscreen #video-unavailable-overlay > div > div:last-child {
      font-size: 18px !important;
      padding: 12px 24px !important;
    }
    
    #video-wrapper:fullscreen #video-countdown {
      font-size: 18px !important;
    }
    
    /* Fullscreen widget controls */
    .fs-widget {
      transition: opacity 0.2s;
    }
    
    .fs-widget-header {
      display: none;
      cursor: move;
      padding: 2px 4px;
      margin: -6px -10px 4px -10px;
      border-bottom: 1px solid rgba(255,255,255,0.2);
      font-size: 10px;
      color: #9ca3af;
      user-select: none;
    }
    
    .fs-widget-header .fs-minimize-btn {
      cursor: pointer;
      float: right;
      opacity: 0.7;
      font-size: 12px;
      margin-left: 8px;
    }
    
    .fs-widget-header .fs-minimize-btn:hover {
      opacity: 1;
    }
    
    .fs-widget.minimized .fs-widget-content {
      display: none !important;
    }
    
    .fs-widget.minimized {
      padding: 4px 8px !important;
      min-width: auto !important;
      width: auto !important;
      height: auto !important;
    }
    
    .fs-widget.minimized .fs-widget-header {
      margin: 0 !important;
      padding: 0 !important;
      border: none !important;
    }
    
    #video-wrapper:fullscreen .fs-widget-header {
      display: block;
    }
    
    #video-wrapper:fullscreen #video-overlays-container {
      overflow: visible !important;
    }
    
    #video-wrapper:fullscreen .fs-widget {
      pointer-events: auto;
      overflow: hidden;
    }
    
    #video-wrapper:fullscreen .fs-widget.dragged {
      top: auto;
      bottom: auto;
      left: auto;
      right: auto;
      /* transform handled by JS to preserve scale */
    }
    
    /* Minimized state - keep corner positions */
    #video-wrapper:fullscreen .fs-widget.minimized .fs-widget-content {
      display: none !important;
    }
    
    /* Non-fullscreen widget positions */
    #video-telemetry-overlay:not(.dragged) {
      top: 8px;
      right: 8px;
    }
    
    #video-leg-overlay:not(.dragged) {
      bottom: 40px;
      right: 8px;
    }
    
    #video-distance-overlay:not(.dragged) {
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
    }
    
    #video-wrapper:fullscreen #video-telemetry-overlay {
      padding: 12px 20px !important;
    }
    
    #video-wrapper:fullscreen #video-telemetry-overlay .fs-widget-content {
      font-size: 28px !important;
    }
    
    #video-wrapper:fullscreen #video-telemetry-overlay:not(.dragged) {
      top: 15%;
      right: 8px;
    }
    
    #video-wrapper:fullscreen #video-telemetry-overlay .fs-widget-header {
      margin: -12px -20px 8px -20px;
      padding: 4px 8px;
      font-size: 14px;
    }
    
    #video-wrapper:fullscreen #video-leg-overlay {
      padding: 12px 20px !important;
    }
    
    #video-wrapper:fullscreen #video-leg-overlay .fs-widget-content {
      font-size: 28px !important;
    }
    
    #video-wrapper:fullscreen #video-leg-overlay:not(.dragged) {
      bottom: 15%;
      right: 8px;
    }
    
    #video-wrapper:fullscreen #video-leg-overlay.minimized:not(.dragged) {
      bottom: 15%;
      right: 8px;
      top: auto;
    }
    
    #video-wrapper:fullscreen #video-leg-overlay .fs-widget-header {
      margin: -12px -20px 8px -20px;
      padding: 4px 8px;
      font-size: 14px;
    }
    
    #minimap-leg2-telemetry {
      display: none;
    }
    
    /* Only show boat 2 telemetry in fullscreen when there are 2+ boats (controlled via JS) */
    #video-wrapper:fullscreen #minimap-leg2-telemetry {
      font-size: 14px !important;
      min-width: 70px;
      max-width: 120px;
      width: 30%;
      flex-shrink: 0;
    }
    
    #video-wrapper:fullscreen #minimap-leg2-telemetry.show-boat2 {
      display: flex !important;
    }
    
    #video-wrapper:fullscreen #telem-leg2-label {
      font-size: 11px !important;
      margin-bottom: 4px !important;
    }
    
    #video-wrapper:fullscreen #video-distance-overlay {
      padding: 12px 24px !important;
    }
    
    #video-wrapper:fullscreen #video-distance-overlay .fs-widget-content {
      font-size: 28px !important;
    }
    
    #video-wrapper:fullscreen #video-distance-overlay:not(.dragged) {
      bottom: 15%;
      left: 50%;
      transform: translateX(-50%);
    }
    
    #video-wrapper:fullscreen #video-distance-overlay.minimized:not(.dragged) {
      bottom: 15%;
      left: 50%;
      transform: translateX(-50%);
      top: auto;
    }
    
    #video-wrapper:fullscreen #video-distance-overlay .fs-widget-header {
      margin: -12px -24px 8px -24px;
      padding: 4px 8px;
      font-size: 14px;
    }
    
    #video-minimap-overlay {
      display: none;
      position: relative;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay {
      display: block !important;
      position: absolute !important;
      width: 270px;
      height: 200px;
      min-width: 150px;
      min-height: 120px;
      max-width: 600px;
      max-height: 500px;
      background: rgba(0,0,0,0.7) !important;
      border-radius: 8px !important;
      padding: 8px !important;
      box-sizing: border-box !important;
      resize: both;
      overflow: hidden;
    }
    
    /* Resize handle indicator */
    #video-wrapper:fullscreen #video-minimap-overlay::after {
      content: '';
      position: absolute;
      right: 2px;
      bottom: 2px;
      width: 12px;
      height: 12px;
      background: linear-gradient(135deg, transparent 50%, rgba(255,255,255,0.3) 50%);
      border-radius: 0 0 6px 0;
      pointer-events: none;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay.single-boat {
      width: 180px;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay:not(.dragged) {
      bottom: 15%;
      left: 8px;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay.minimized:not(.dragged) {
      bottom: 15%;
      left: 8px;
      top: auto;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay .fs-widget-header {
      margin: -8px -8px 4px -8px;
      padding: 2px 6px;
      font-size: 14px;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay.minimized {
      width: auto !important;
      height: auto !important;
      min-width: auto !important;
      min-height: auto !important;
      resize: none !important;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay.minimized::after {
      display: none;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay.minimized .fs-widget-content {
      display: none !important;
      height: 0 !important;
    }
    
    #video-wrapper:fullscreen #video-minimap-overlay .fs-widget-content {
      height: calc(100% - 24px);
    }
    
    #video-wrapper:fullscreen #video-minimap-svg {
      flex: 1;
      height: 100% !important;
      min-width: 0;
    }
    
    #video-wrapper:fullscreen #video-time-display {
      display: none !important;
    }
    
    #video-wrapper:fullscreen #video-status-badge {
      display: none !important;
    }
    
    #video-wrapper:fullscreen #video-fullscreen-btn {
      font-size: 22px !important;
    }
    
    #video-wrapper:fullscreen .fs-overlay-btn {
      display: inline-block !important;
    }
    
    #video-wrapper:fullscreen #video-replay-controls {
      position: fixed !important;
      bottom: 0 !important;
      left: 0 !important;
      right: 0 !important;
      width: 100% !important;
      padding: 0;
      box-sizing: border-box;
      pointer-events: auto;
      background: #000;
      z-index: 100;
    }
    
    #video-wrapper:fullscreen #fullscreen-status-row {
      padding: 4px 16px;
      background: #000;
    }
    
    #video-wrapper:fullscreen #video-replay-controls .race-replay-container {
      background: #000 !important;
      border: none !important;
      border-radius: 0 !important;
      padding: 8px 16px !important;
    }
    
    #video-wrapper:fullscreen #video-replay-controls .playback-time {
      color: white !important;
    }
    
    #video-wrapper:fullscreen #video-replay-controls .btn-play {
      background: rgba(34,197,94,0.3);
      color: white;
      border: 1px solid rgba(34,197,94,0.5);
    }
    
    #video-wrapper:fullscreen #video-replay-controls .btn-play.playing {
      background: rgba(239,68,68,0.3);
      border-color: rgba(239,68,68,0.5);
    }
    
    #video-wrapper:fullscreen #video-replay-controls .speed-btn {
      background: transparent;
      color: rgba(255,255,255,0.7);
      border-color: rgba(255,255,255,0.3);
    }
    
    #video-wrapper:fullscreen #video-replay-controls .speed-btn.active {
      background: transparent;
      color: white;
      border-color: #22c55e;
    }
    
    #video-wrapper:fullscreen #video-replay-controls .timeline-wrapper {
      flex: 1;
      min-width: 150px;
    }
    
    #video-wrapper:fullscreen #video-replay-controls .playback-timeline {
      background: rgba(255,255,255,0.2);
    }
    
    #video-wrapper:fullscreen #video-replay-controls .video-coverage-bar {
      background: rgba(255,255,255,0.1);
    }
    
    #video-wrapper:fullscreen #video-replay-controls .video-coverage-segment {
      background: #3b82f6;
    }
    
    #video-wrapper:fullscreen #video-replay-controls .btn-exit-replay {
      display: none;
    }
    
    #video-wrapper:fullscreen #video-replay-controls .status-dot {
      display: block !important;
    }
    
    #video-wrapper:fullscreen #video-replay-controls .race-replay-title {
      display: none;
    }
    
    /* Responsive video section */
    #video-replay-section {
      max-width: 100%;
      overflow: hidden;
    }
    
    /* Map and content flex container - no wrap to keep side-by-side layout */
    #map-and-content-card > .flex {
      flex-wrap: nowrap;
      overflow: visible;
    }
    
    /* Make map and video sections shrink proportionally */
    #map-container {
      flex: 0 0 auto;
      width: 500px;
      min-width: 350px;
      position: relative;
      overflow: visible;
    }
    
    #race-replay-right-column {
      flex: 1 1 auto;
      min-width: 300px;
    }
    
    .container { max-width: 1400px; margin: 0 auto; }
    .card { background: white; border-radius: 12px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); padding: 16px; margin-bottom: 16px; }
    h1 { font-size: 1.5rem; color: #1f2937; }
    h3 { font-size: 1.1rem; color: #374151; margin-bottom: 8px; }
    .subtitle { color: #6b7280; font-size: 0.875rem; }
    .flex { display: flex; gap: 16px; flex-wrap: wrap; }
    .flex-1 { flex: 1; min-width: 200px; }
    .grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; }
    .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
    .grid-6 { display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; }
    .stat-box { background: #f9fafb; border-radius: 8px; padding: 12px; border-left: 4px solid #3b82f6; }
    .stat-label { font-size: 0.7rem; color: #6b7280; text-transform: uppercase; }
    .stat-value { font-size: 1.25rem; font-weight: bold; }
    .stat-sub { font-size: 0.75rem; color: #9ca3af; }
    .tabs { display: flex; gap: 8px; margin-bottom: 16px; }
    .tab { padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 500; background: white; color: #4b5563; border: none; transition: all 0.2s; }
    .tab.active { background: #3b82f6; color: white; box-shadow: 0 2px 4px rgba(59,130,246,0.3); }
    .tab:hover:not(.active) { background: #f3f4f6; }
    table { width: 100%; border-collapse: collapse; font-size: 0.875rem; }
    th, td { padding: 8px 12px; text-align: left; border-bottom: 1px solid #e5e7eb; }
    th { background: #f9fafb; font-weight: 600; position: sticky; top: 0; }
    tr:hover { background: #f3f4f6; }
    tr.selected { background: #ede9fe; }
    tr { cursor: pointer; }
    .badge { display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; font-weight: 600; }
    .badge-up { background: #dcfce7; color: #166534; }
    .badge-reach { background: #dbeafe; color: #1e40af; }
    .badge-down { background: #fef3c7; color: #92400e; }
    .badge-tack { background: #d1fae5; color: #065f46; }
    .badge-gybe { background: #fef3c7; color: #92400e; }
    .chart-container { height: 160px; position: relative; }
    .legend { display: flex; gap: 12px; font-size: 0.75rem; margin-bottom: 8px; flex-wrap: wrap; }
    .legend-item { display: flex; align-items: center; gap: 4px; }
    .legend-dot { width: 8px; height: 8px; border-radius: 50%; }
    .upload-zone { border: 2px dashed #d1d5db; border-radius: 12px; padding: 40px; text-align: center; cursor: pointer; transition: all 0.2s; }
    .upload-zone:hover { border-color: #3b82f6; background: #eff6ff; }
    .upload-zone.dragover { border-color: #3b82f6; background: #dbeafe; }
    .upload-icon { font-size: 3rem; color: #9ca3af; margin-bottom: 8px; }
    .btn { padding: 8px 16px; border-radius: 8px; border: none; cursor: pointer; font-weight: 500; transition: all 0.2s; }
    .btn-primary { background: #3b82f6; color: white; }
    .btn-primary:hover { background: #2563eb; }
    .btn-sm { padding: 4px 8px; font-size: 0.75rem; }
    .text-green { color: #16a34a; }
    .text-blue { color: #2563eb; }
    .text-amber { color: #d97706; }
    .text-red { color: #dc2626; }
    .text-purple { color: #7c3aed; }
    .text-xs { font-size: 0.75rem; }
    .text-sm { font-size: 0.875rem; }
    .mt-2 { margin-top: 8px; }
    .mt-4 { margin-top: 16px; }
    .mb-2 { margin-bottom: 8px; }
    .hidden { display: none; }
    .scroll-table { max-height: 600px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 8px; }
    .detail-box { background: #faf5ff; border: 1px solid #e9d5ff; border-radius: 8px; padding: 12px; }
    .detail-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .detail-title { font-weight: 600; color: #7c3aed; }
    .maneuver-banner { padding: 8px; border-radius: 6px; text-align: center; font-weight: 500; margin-top: 8px; }
    .maneuver-tack { background: #d1fae5; color: #065f46; }
    .maneuver-gybe { background: #fef3c7; color: #92400e; }
    #map { border: 1px solid #e5e7eb; border-radius: 8px; background: #eff6ff; display: block; max-width: 100%; }
    .pos-breakdown { background: #f9fafb; border-radius: 8px; padding: 16px; }
    .pos-title { font-weight: 600; margin-bottom: 8px; }
    .pos-stat { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #e5e7eb; }
    .pos-stat:last-child { border-bottom: none; }
    .filter-row { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
    select { padding: 6px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 0.875rem; }
    .clear-btn { background: #faf5ff; color: #7c3aed; padding: 4px 12px; border-radius: 9999px; font-size: 0.875rem; display: flex; align-items: center; gap: 4px; cursor: pointer; border: none; }
    .loading { text-align: center; padding: 40px; }
    .spinner { width: 40px; height: 40px; border: 3px solid #e5e7eb; border-top-color: #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 16px; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .scatter-dot { cursor: pointer; transition: all 0.15s; }
    .scatter-dot:hover { transform: scale(1.3); }
    .zoom-btn { width: 28px; height: 28px; border: 1px solid #d1d5db; border-radius: 4px; background: white; cursor: pointer; font-size: 16px; font-weight: bold; color: #4b5563; display: flex; align-items: center; justify-content: center; }
    .zoom-btn:hover { background: #f3f4f6; }
    #map { cursor: grab; }
    #map:active { cursor: grabbing; }
    .timeline-handle:hover { fill: #6d28d9; }
    .timeline-milestone:hover { transform: scale(1.2); transform-origin: center; }
    .timeline-range:hover { cursor: grab; }
    .timeline-range:active { cursor: grabbing; }
    .timeline-track { background: #f3f4f6; border-radius: 8px; padding: 8px 12px; margin-bottom: 8px; transition: all 0.2s; }
    .timeline-track.active { background: #faf5ff; border: 1px solid #e9d5ff; }
    .timeline-track.inactive { opacity: 0.6; }
    .timeline-track.inactive:hover { opacity: 0.8; }
    #timeline-content.collapsed { display: none; }
    #timeline-fold-icon.collapsed { transform: rotate(-90deg); }
    
    /* Race Replay Mode */
    .race-replay-container { background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 8px; padding: 8px 12px; }
    .race-replay-header { display: flex; align-items: center; gap: 8px; }
    .race-replay-title { font-size: 0.85rem; font-weight: 600; color: #166534; display: flex; align-items: center; gap: 4px; white-space: nowrap; }
    .btn-exit-replay { background: #f3f4f6; color: #374151; border: 1px solid #d1d5db; padding: 2px 8px; font-size: 11px; }
    .btn-exit-replay:hover { background: #e5e7eb; }
    .playback-row { display: flex; align-items: center; gap: 8px; flex-wrap: nowrap; }
    .timeline-wrapper { flex: 1; min-width: 150px; display: flex; flex-direction: column; gap: 2px; }
    .video-coverage-bar { height: 4px; background: #e5e7eb; border-radius: 2px; position: relative; overflow: hidden; cursor: pointer; }
    .video-coverage-segment { position: absolute; height: 100%; background: #3b82f6; opacity: 0.7; }
    .playback-timeline { width: 100%; height: 8px; background: #e5e7eb; border-radius: 4px; cursor: pointer; position: relative; }
    .playback-progress { height: 100%; background: #22c55e; border-radius: 4px; pointer-events: none; }
    .playback-handle { position: absolute; top: 50%; width: 14px; height: 14px; background: #22c55e; border: 2px solid white; border-radius: 50%; transform: translate(-50%, -50%); cursor: grab; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    .playback-handle:hover { background: #16a34a; }
    .btn-play { min-width: 70px; background: #22c55e; color: white; font-size: 0.8rem; padding: 4px 8px; }
    .btn-play:hover { background: #16a34a; }
    .btn-play.playing { background: #ef4444; }
    .btn-play.playing:hover { background: #dc2626; }
    .speed-btn { padding: 2px 6px; border: 1px solid #d1d5db; border-radius: 4px; background: white; cursor: pointer; font-size: 11px; }
    .speed-btn:hover { background: #f3f4f6; }
    .speed-btn.active { background: #22c55e; color: white; border-color: #22c55e; }
    .playback-time { font-size: 11px; color: #374151; min-width: 80px; text-align: center; font-family: monospace; font-weight: 500; }
    .boat-info-panel { background: white; border-radius: 8px; padding: 12px; border: 1px solid #e5e7eb; }
    .boat-info-row { display: flex; align-items: center; gap: 10px; padding: 8px 0; border-bottom: 1px solid #f3f4f6; }
    .boat-info-row:last-child { border-bottom: none; }
    .boat-marker { width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 12px; }
    .boat-name { font-weight: 500; min-width: 100px; }
    .boat-stats { display: flex; gap: 12px; font-size: 12px; color: #6b7280; }
    .boat-stat { display: flex; flex-direction: column; align-items: center; }
    .boat-stat-value { font-weight: 600; color: #374151; font-size: 14px; }
    .boat-stat-label { font-size: 10px; text-transform: uppercase; }
    .current-leg-panel { background: white; border-radius: 8px; padding: 12px; border: 1px solid #e5e7eb; margin-top: 12px; }
    .current-leg-header { font-weight: 600; color: #374151; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
    .session-select-row { display: flex; align-items: center; gap: 8px; padding: 4px 0; }
    .session-select-row input[type="checkbox"] { width: 16px; height: 16px; cursor: pointer; }
    .btn-start-replay { background: #22c55e; color: white; padding: 8px 16px; }
    .btn-start-replay:hover { background: #16a34a; }
    .btn-start-replay:disabled { background: #9ca3af; cursor: not-allowed; }
    
    /* Mobile-specific styles */
    @media (max-width: 768px) {
      .container { padding: 8px; }
      .card { padding: 12px; margin-bottom: 12px; }
      
      /* Larger touch targets for buttons */
      button, .speed-btn, .btn { min-height: 44px; min-width: 44px; }
      .speed-btn { padding: 8px 12px; font-size: 14px; }
      
      /* Upload zone improvements */
      .upload-zone { padding: 24px 16px; }
      .upload-icon { font-size: 36px; }
      
      /* Playback controls for mobile */
      .playback-controls { gap: 6px; padding: 8px; flex-wrap: wrap; }
      .playback-handle { width: 20px; height: 20px; }
      .playback-timeline { height: 12px; }
      
      /* Video panel adjustments */
      #video-panel { min-height: 200px; }
      
      /* Better spacing for checkboxes */
      .session-select-row input[type="checkbox"] { width: 24px; height: 24px; }
      
      /* Tab navigation */
      .tabs { flex-wrap: wrap; gap: 4px; }
      .tab { padding: 8px 12px; font-size: 12px; }
      
      /* Hide folder picker on mobile - webkitdirectory not supported */
      #video-folder-input { display: none !important; }
      label[title="Select folder with videos"] { display: none !important; }
      
      /* CRITICAL: Make map/video layout stack vertically on mobile */
      #map-and-content-card > .flex {
        flex-wrap: wrap !important;
        flex-direction: column !important;
      }
      
      #map-container {
        width: 100% !important;
        max-width: 100% !important;
        min-width: 0 !important;
        flex: 0 0 auto !important;
      }
      
      #map-container svg {
        width: 100% !important;
        height: auto !important;
        max-height: 350px;
      }
      
      #race-replay-right-column {
        min-width: 0 !important;
        width: 100% !important;
        max-width: 100% !important;
      }
      
      #stats-panel {
        width: 100% !important;
        min-width: 0 !important;
      }
      
      #video-replay-section {
        width: 100% !important;
      }
      
      /* Grid adjustments for mobile */
      .grid-2, .grid-3, .grid-6 {
        grid-template-columns: repeat(2, 1fr) !important;
      }
    }
    
    /* Fullscreen mobile adjustments */
    @media (max-width: 768px) {
      #video-wrapper:fullscreen .fs-widget {
        font-size: 14px !important;
      }
      
      #video-wrapper:fullscreen #video-telemetry-overlay .fs-widget-content,
      #video-wrapper:fullscreen #video-leg-overlay .fs-widget-content {
        font-size: 20px !important;
      }
      
      #video-wrapper:fullscreen #video-distance-overlay .fs-widget-content {
        font-size: 22px !important;
      }
      
      #video-wrapper:fullscreen #video-minimap-overlay {
        width: 200px;
        height: 150px;
      }
      
      #video-wrapper:fullscreen #minimap-leg2-telemetry {
        font-size: 11px !important;
        min-width: 60px;
        max-width: 80px;
      }
      
      #video-wrapper:fullscreen #video-replay-controls {
        padding: 8px !important;
      }
      
      #video-wrapper:fullscreen .speed-btn {
        padding: 6px 10px;
        font-size: 12px;
      }
      
      #video-wrapper:fullscreen .fs-overlay-btn {
        min-height: 36px;
        min-width: 36px;
        font-size: 14px !important;
      }
    }
    
    /* Prevent text selection during drag on touch devices */
    .fs-widget-header {
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }
    
    /* Improve touch scrolling in panels */
    .analysis-panel, .tabs-content {
      -webkit-overflow-scrolling: touch;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Upload Section -->
    <div id="upload-section" class="card">
      <h1 style="margin-bottom: 16px;">‚õµ Sailing Steering Analysis Dashboard</h1>
      <div id="upload-zone" class="upload-zone">
        <div class="upload-icon">üìÅ</div>
        <p style="font-size: 1.1rem; color: #374151; margin-bottom: 8px;">Drop your sailing data files here or click to browse</p>
        <p class="text-sm" style="color: #6b7280;">Supports Vakaros VKX, Garmin FIT, and GPX files ‚Ä¢ .vkx, .fit, .gpx, .gz</p>
        <input type="file" id="file-input" multiple style="display: none;">
      </div>
      <div id="loading" class="loading hidden">
        <div class="spinner"></div>
        <p>Processing telemetry data...</p>
      </div>
    </div>

    <!-- Dashboard Section (hidden until file loaded) -->
    <div id="dashboard" class="hidden">
      <!-- Header -->
      <div class="card">
        <div class="flex" style="justify-content: space-between; align-items: center;">
          <div>
            <h1 id="session-title">Steering Analysis</h1>
            <p class="subtitle" id="session-subtitle"></p>
          </div>
          <div class="filter-row">
            <div id="selected-leg-badge" class="hidden">
              <button class="clear-btn" onclick="clearSelection()">
                <span id="selected-leg-text">Leg #1</span>
                <span style="font-weight: bold;">√ó</span>
              </button>
            </div>
            <select id="pos-filter" onchange="applyFilter()">
              <option value="all">All Points of Sail</option>
              <option value="upwind">Upwind Only</option>
              <option value="reaching">Reaching Only</option>
              <option value="downwind">Downwind Only</option>
            </select>
            <button class="btn btn-sm" id="add-files-btn" onclick="resetDashboard()">Add More Files</button>
            <button class="btn btn-sm hidden" id="back-to-sessions-header-btn" onclick="exitRaceReplay()" style="background:#f3f4f6;color:#374151;border:1px solid #d1d5db;">‚Üê Back to Sessions</button>
          </div>
        </div>
      </div>

      <!-- Multi-file Comparison (hidden if single file) -->
      <div id="comparison-section" class="card hidden"></div>

      <!-- Timeline Selection (Foldable) -->
      <div id="timeline-section" class="card">
        <div style="display:flex;justify-content:space-between;align-items:center;cursor:pointer;" onclick="toggleTimelineSection()">
          <div style="display:flex;align-items:center;gap:8px;">
            <span id="timeline-fold-icon" style="font-size:12px;transition:transform 0.2s;">‚ñº</span>
            <h3 style="margin:0;">Timeline Selection</h3>
            <span class="text-xs" style="color:#6b7280;" id="timeline-summary"></span>
          </div>
          <div style="display:flex;gap:8px;align-items:center;" onclick="event.stopPropagation();">
            <label class="text-xs" style="display:flex;align-items:center;gap:4px;color:#6b7280;cursor:pointer;">
              <input type="checkbox" id="auto-trim-checkbox" checked onchange="toggleAutoTrim()" style="cursor:pointer;">
              Auto-trim
            </label>
            <button class="btn btn-sm" onclick="resetAllTimelines()" id="reset-all-btn" style="display:none;">Reset All</button>
          </div>
        </div>
        <div id="timeline-content" style="margin-top:12px;">
          <p class="text-xs" style="color:#6b7280;margin-bottom:8px;">Drag handles to select analysis range. Click milestones to snap. Auto-trim removes marina transit legs.</p>
          <div id="all-timelines-container"></div>
        </div>
      </div>

      <!-- Map and Stats/Race Replay wrapper -->
      <div class="card" id="map-and-content-card">
        <div class="flex">
          <!-- Map container (always visible, on left) -->
          <div id="map-container">
            <svg id="map" width="500" height="500"></svg>
            <!-- Legend overlay (fixed position, not affected by zoom) -->
            <div id="map-legend" style="position: absolute; top: 8px; left: 8px; font-size: 11px; pointer-events: auto; background: rgba(255,255,255,0.9); padding: 8px 12px; border-radius: 6px;"></div>
            <!-- Wind indicator overlay (fixed position) -->
            <div id="map-wind" style="position: absolute; top: 8px; right: 8px; text-align: center; pointer-events: none; background: rgba(255,255,255,0.85); padding: 4px; border-radius: 4px;"></div>
            <!-- Projection toggle -->
            <div style="position: absolute; bottom: 45px; left: 10px; font-size: 8px; display: flex; align-items: center; gap: 4px; background: rgba(255,255,255,0.85); padding: 3px 6px; border-radius: 4px;">
              <span id="proj-label" style="color: #666;" title="Compass: angles as sailed. Geo: true geography">Compass</span>
              <label style="position: relative; display: inline-block; width: 28px; height: 14px; cursor: pointer;">
                <input type="checkbox" id="proj-toggle" onchange="toggleProjection()" style="opacity: 0; width: 0; height: 0;">
                <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; border-radius: 14px; transition: .2s;"></span>
                <span id="proj-slider" style="position: absolute; height: 10px; width: 10px; left: 2px; bottom: 2px; background-color: white; border-radius: 50%; transition: .2s; box-shadow: 0 1px 3px rgba(0,0,0,0.3);"></span>
              </label>
            </div>
            <!-- Hide gray toggle -->
            <div style="position: absolute; bottom: 65px; left: 10px; font-size: 8px; display: flex; align-items: center; gap: 4px; background: rgba(255,255,255,0.85); padding: 3px 6px; border-radius: 4px;">
              <span id="hide-gray-label" style="color: #666;" title="Hide past and future track portions">Hide gray</span>
              <label style="position: relative; display: inline-block; width: 28px; height: 14px; cursor: pointer;">
                <input type="checkbox" id="hide-gray-tracks-map" onchange="toggleHideGrayTracksMap()" style="opacity: 0; width: 0; height: 0;">
                <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; border-radius: 14px; transition: .2s;"></span>
                <span id="hide-gray-slider" style="position: absolute; height: 10px; width: 10px; left: 2px; bottom: 2px; background-color: white; border-radius: 50%; transition: .2s; box-shadow: 0 1px 3px rgba(0,0,0,0.3);"></span>
              </label>
            </div>
            <!-- Zoom indicator -->
            <div id="map-zoom-indicator" style="position: absolute; bottom: 45px; right: 12px; font-size: 9px; color: #666;"></div>
            <div style="position: absolute; bottom: 10px; right: 10px; display: flex; flex-direction: column; gap: 4px;">
              <button class="zoom-btn" onclick="zoomMap(1.5)" title="Zoom In">+</button>
              <button class="zoom-btn" onclick="zoomMap(1/1.5)" title="Zoom Out">‚àí</button>
              <button class="zoom-btn" onclick="resetMapZoom()" title="Reset">‚ü≤</button>
            </div>
            <div style="position: absolute; bottom: 10px; left: 10px; font-size: 9px; color: #9ca3af;">Scroll to zoom ‚Ä¢ Drag to pan</div>
          </div>
          <!-- Stats panel (visible in normal mode) -->
          <div class="flex-1" id="stats-panel">
            <div class="grid-2">
              <div class="stat-box" style="border-color: #3b82f6;">
                <div class="stat-label">Avg Spd / VMG</div>
                <div><span class="stat-value text-green" id="speed-up">-</span><span class="stat-sub"> Up</span> <span class="stat-value text-amber" id="speed-down">-</span><span class="stat-sub"> Dn</span></div>
              </div>
              <div class="stat-box" id="heel-box" style="border-color: #eab308;">
                <div class="stat-label">Avg Heel</div>
                <div><span class="stat-value text-green" id="heel-up">-</span><span class="stat-sub"> Up</span> <span class="stat-value text-amber" id="heel-down">-</span><span class="stat-sub"> Dn</span></div>
              </div>
              <div class="stat-box" style="border-color: #a855f7;">
                <div class="stat-label">COG Corridor</div>
                <div><span class="stat-value text-green" id="corr-up">-</span><span class="stat-sub"> Up</span> <span class="stat-value text-amber" id="corr-down">-</span><span class="stat-sub"> Dn</span></div>
              </div>
              <div class="stat-box" id="mag-box" style="border-color: #8b5cf6;">
                <div class="stat-label">MAG 70/90</div>
                <div><span class="stat-value text-green" id="mag70-up">-</span>/<span class="stat-value text-green" id="mag-up">-</span><span class="stat-sub"> Up</span></div>
                <div><span class="stat-value text-amber" id="mag70-down">-</span>/<span class="stat-value text-amber" id="mag-down">-</span><span class="stat-sub"> Dn</span></div>
              </div>
              <div class="stat-box" style="border-color: #06b6d4;">
                <div class="stat-label">Line Dev</div>
                <div><span class="stat-value text-green" id="linedev-up">-</span><span class="stat-sub"> Up</span> <span class="stat-value text-amber" id="linedev-down">-</span><span class="stat-sub"> Dn</span></div>
              </div>
              <div class="stat-box" style="border-color: #ef4444;">
                <div class="stat-label">Steer Rate</div>
                <div><span class="stat-value text-green" id="rate-up">-</span><span class="stat-sub"> Up</span> <span class="stat-value text-amber" id="rate-down">-</span><span class="stat-sub"> Dn</span></div>
              </div>
              <div class="stat-box" style="border-color: #10b981;">
                <div class="stat-label">Tacks</div>
                <div><span class="stat-value" id="tack-count">-</span> <span class="stat-sub">avg</span> <span class="stat-value" id="tack-angle">-</span></div>
              </div>
              <div class="stat-box" style="border-color: #f59e0b;">
                <div class="stat-label">Gybes</div>
                <div><span class="stat-value" id="gybe-count">-</span> <span class="stat-sub">avg</span> <span class="stat-value" id="gybe-angle">-</span></div>
              </div>
            </div>
          </div>
          <!-- Right column for race replay mode -->
          <div id="race-replay-right-column" style="display:none;flex-direction:column;gap:12px;min-width:0;max-width:100%;overflow:hidden;">
            <!-- Video Replay Section (next to map) -->
            <div id="video-replay-section" style="min-width:0;width:100%;max-width:100%;flex-shrink:1;">
              <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">
                <div style="display:flex;align-items:center;gap:8px;">
                  <span style="font-weight:600;font-size:14px;">üé¨ Video Replay</span>
                  <span id="video-buffer-status"></span>
                </div>
                <div style="display:flex;align-items:center;gap:4px;">
                  <div style="position:relative;display:inline-block;">
                    <span class="btn btn-sm" style="background:#3b82f6;color:white;cursor:pointer;display:inline-block;" title="Select video files">
                      üìÑ Files
                    </span>
                    <input type="file" id="video-file-input" multiple style="position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer;font-size:0;" onchange="handleVideoFiles(event)">
                  </div>
                  <label class="btn btn-sm" style="background:#8b5cf6;color:white;cursor:pointer;" title="Select folder with videos">
                    üìÅ Folder
                    <input type="file" id="video-folder-input" webkitdirectory style="display:none;" onchange="handleVideoFiles(event)">
                  </label>
                  <button class="btn btn-sm" onclick="removeAllVideos()" id="remove-videos-btn" style="display:none;">‚úï Remove All</button>
                </div>
              </div>
              <div id="video-container" style="width:100%;max-width:100%;min-width:0;box-sizing:border-box;">
                <div id="video-placeholder" style="color:#9ca3af;text-align:center;padding:20px;width:100%;font-size:12px;">No videos loaded. Add MP4 files with timestamp in filename (e.g., VID_20251130_142618_00_015.mp4)</div>
              </div>
            </div>
            <!-- Race Replay Panel (timeline controls) -->
            <div id="race-replay-section"></div>
          </div>
        </div>
      </div>

      <!-- Legs Comparison Section (visible only in race replay mode, below map) -->
      <div id="legs-comparison-section" class="card hidden" style="min-height:280px;max-width:none;width:100%;box-sizing:border-box;">
        <div class="current-leg-header" style="margin-bottom:8px;">üìä Legs Comparison</div>
        <div id="current-legs-content" style="min-height:240px;width:100%;box-sizing:border-box;">Move the playback slider to see leg details</div>
      </div>

      <!-- Tabs section (hidden in race replay mode) -->
      <div id="stats-and-tabs-section">
      <div class="tabs">
        <button class="tab active" data-tab="legs" onclick="switchTab('legs')">Legs Analysis</button>
        <button class="tab" data-tab="steering" onclick="switchTab('steering')">1-Min Intervals</button>
        <button class="tab" data-tab="pos" onclick="switchTab('pos')">Point of Sail</button>
      </div>

      <!-- Tab Content -->
      <div class="card">
        <!-- Legs Tab -->
        <div id="tab-legs" class="tab-content">
          <div class="flex" style="justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
            <div>
              <h3>Sailing Legs Analysis</h3>
              <p class="text-xs" style="color: #6b7280;">Select leg to see details and highlighted intervals.</p>
            </div>
            <div class="text-sm" style="text-align: right;">
              <div id="legs-summary"></div>
              <div>Best COG: <span id="best-corridor" class="text-green" style="font-weight: bold;">-</span></div>
            </div>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
            <div>
              <div class="scroll-table" id="legs-scroll-container">
                <table id="legs-table">
                  <thead>
                    <tr>
                      <th>#</th>
                      <th>POS</th>
                      <th style="text-align: right;">Dur</th>
                      <th style="text-align: right;">Rate</th>
                      <th style="text-align: right;">COG</th>
                      <th style="text-align: right;">Dev</th>
                      <th style="text-align: right;">MAG70/90</th>
                      <th style="text-align: right;">Heel</th>
                      <th style="text-align: right;">Spd/VMG</th>
                      <th>Next</th>
                    </tr>
                  </thead>
                  <tbody id="legs-tbody"></tbody>
                </table>
              </div>
            </div>
            <div style="max-height: 600px; overflow-y: auto;" id="leg-detail">
              <div style="color: #6b7280; text-align: center; padding: 40px;">
                Select a leg to view details
              </div>
            </div>
          </div>
        </div>

        <!-- Steering Tab -->
        <div id="tab-steering" class="tab-content hidden">
          <div class="flex" style="justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
            <div>
              <h3>1-Minute Interval Analysis</h3>
              <p class="text-xs" id="interval-help" style="color: #6b7280;">Click dots to select leg on map.</p>
            </div>
            <div class="text-sm" style="text-align: right;">
              <div>Best Rate: <span id="best-rate" style="font-weight: bold;">-</span></div>
              <div>Best Corridor: <span id="best-int-corridor" style="font-weight: bold;">-</span></div>
            </div>
          </div>
          
          <div style="border: 1px solid #e5e7eb; border-radius: 8px; padding: 12px; margin-bottom: 16px;">
            <h4 style="font-weight: 500; margin-bottom: 8px;">Steering Rate</h4>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background: #22c55e;"></div>Expert ‚â§1.5</div>
              <div class="legend-item"><div class="legend-dot" style="background: #3b82f6;"></div>Club 1.5-3</div>
              <div class="legend-item"><div class="legend-dot" style="background: #f59e0b;"></div>Rec 3-5</div>
              <div class="legend-item"><div class="legend-dot" style="background: #ef4444;"></div>Learning &gt;5</div>
              <div class="legend-item" id="legend-selected-rate" style="display: none;"><div class="legend-dot" style="background: #a855f7;"></div><span id="legend-leg-rate">Leg #1</span></div>
            </div>
            <div id="rate-pct" style="font-size: 11px; color: #6b7280; margin-bottom: 8px;"></div>
            <div class="chart-container">
              <canvas id="rate-scatter"></canvas>
            </div>
          </div>

          <div style="border: 1px solid #e5e7eb; border-radius: 8px; padding: 12px;">
            <h4 style="font-weight: 500; margin-bottom: 8px;">COG Corridor (¬±)</h4>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background: #22c55e;"></div>Excellent ‚â§¬±8¬∞</div>
              <div class="legend-item"><div class="legend-dot" style="background: #3b82f6;"></div>Good ¬±8-12¬∞</div>
              <div class="legend-item"><div class="legend-dot" style="background: #f59e0b;"></div>Fair ¬±12-18¬∞</div>
              <div class="legend-item"><div class="legend-dot" style="background: #ef4444;"></div>Needs Work &gt;¬±18¬∞</div>
              <div class="legend-item" id="legend-selected-corr" style="display: none;"><div class="legend-dot" style="background: #a855f7;"></div><span id="legend-leg-corr">Leg #1</span></div>
            </div>
            <div id="corr-pct" style="font-size: 11px; color: #6b7280; margin-bottom: 8px;"></div>
            <div class="chart-container">
              <canvas id="corridor-scatter"></canvas>
            </div>
          </div>

          <div id="mag-corridor-chart-container" style="border: 1px solid #e5e7eb; border-radius: 8px; padding: 12px;">
            <h4 style="font-weight: 500; margin-bottom: 8px;">MAG Corridor (¬±)</h4>
            <div class="legend">
              <div class="legend-item"><div class="legend-dot" style="background: #22c55e;"></div>Excellent ‚â§¬±5¬∞</div>
              <div class="legend-item"><div class="legend-dot" style="background: #3b82f6;"></div>Good ¬±5-8¬∞</div>
              <div class="legend-item"><div class="legend-dot" style="background: #f59e0b;"></div>Fair ¬±8-12¬∞</div>
              <div class="legend-item"><div class="legend-dot" style="background: #ef4444;"></div>Needs Work &gt;¬±12¬∞</div>
              <div class="legend-item" id="legend-selected-mag" style="display: none;"><div class="legend-dot" style="background: #a855f7;"></div><span id="legend-leg-mag">Leg #1</span></div>
            </div>
            <div id="mag-pct" style="font-size: 11px; color: #6b7280; margin-bottom: 8px;"></div>
            <div class="chart-container">
              <canvas id="mag-corridor-scatter"></canvas>
            </div>
          </div>
        </div>

        <!-- POS Tab -->
        <div id="tab-pos" class="tab-content hidden">
          <h3>Point of Sail Breakdown</h3>
          <div class="grid-3 mt-4" id="pos-breakdown"></div>
        </div>
      </div>
      </div><!-- end stats-and-tabs-section -->
    </div>
  </div>

  <script>
    // ===== PLATFORM DETECTION =====
    // Mobile detection for file input handling (mobile has issues with accept filters)
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    const isAndroid = /Android/i.test(navigator.userAgent);
    const isMobile = isIOS || isAndroid;
    
    // ===== VKX PARSER =====
    const ROW_DEFINITIONS = {
      0xFF: [7, 'page_header'],
      0xFE: [2, 'page_terminator'],
      0x02: [44, 'position_velocity'],
      0x03: [20, 'declination'],
      0x04: [13, 'race_timer'],
      0x05: [17, 'line_position'],
      0x06: [18, 'shift_angle'],
      0x08: [13, 'device_config'],
      0x0A: [16, 'wind'],
      0x0B: [16, 'speed_through_water'],
      0x0C: [12, 'depth'],
      0x10: [12, 'temperature'],
      0x0F: [16, 'load'],
      0x01: [32, 'internal'],
      0x07: [12, 'internal'],
      0x0E: [16, 'internal'],
      0x20: [13, 'internal'],
      0x21: [52, 'internal'],
    };

    // Lazy load pako for gzip decompression
    let pakoLib = null;
    async function loadPako() {
      if (pakoLib) return pakoLib;
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js';
        script.onload = () => {
          pakoLib = window.pako;
          resolve(pakoLib);
        };
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }

    function quaternionToEuler(w, x, y, z) {
      const sinr = 2 * (w * x + y * z);
      const cosr = 1 - 2 * (x * x + y * y);
      const roll = Math.atan2(sinr, cosr);
      
      let pitch;
      const sinp = 2 * (w * y - z * x);
      if (Math.abs(sinp) >= 1) pitch = Math.sign(sinp) * Math.PI / 2;
      else pitch = Math.asin(sinp);
      
      const siny = 2 * (w * z + x * y);
      const cosy = 1 - 2 * (y * y + z * z);
      const yaw = Math.atan2(siny, cosy);
      
      return [roll * 180 / Math.PI, pitch * 180 / Math.PI, yaw * 180 / Math.PI];
    }

    function parseVKX(arrayBuffer) {
      const data = new Uint8Array(arrayBuffer);
      const view = new DataView(arrayBuffer);
      const records = [];
      let pos = 0;

      while (pos < data.length) {
        const key = data[pos];
        pos++;

        if (!ROW_DEFINITIONS[key]) continue;
        const [payloadSize, parserName] = ROW_DEFINITIONS[key];
        if (pos + payloadSize > data.length) break;

        if (parserName === 'position_velocity') {
          const ts = Number(view.getBigUint64(pos, true));
          const latRaw = view.getInt32(pos + 8, true);
          const lonRaw = view.getInt32(pos + 12, true);
          const sog = view.getFloat32(pos + 16, true);
          const cog = view.getFloat32(pos + 20, true);
          const alt = view.getFloat32(pos + 24, true);
          const qw = view.getFloat32(pos + 28, true);
          const qx = view.getFloat32(pos + 32, true);
          const qy = view.getFloat32(pos + 36, true);
          const qz = view.getFloat32(pos + 40, true);

          const lat = latRaw / 1e7;
          const lon = lonRaw / 1e7;
          let cogDeg = cog * 180 / Math.PI;
          if (cogDeg < 0) cogDeg += 360;
          const sogKnots = sog * 1.94384;
          const [roll, pitch, heading] = quaternionToEuler(qw, qx, qy, qz);
          let hdgNorm = heading;
          if (hdgNorm < 0) hdgNorm += 360;

          records.push({
            timestamp_ms: ts,
            lat, lon,
            sog_knots: sogKnots,
            cog_deg: cogDeg,
            heading_deg: hdgNorm,
            roll_deg: roll,
            pitch_deg: pitch
          });
        }
        pos += payloadSize;
      }
      return records;
    }

    function parseFIT(arrayBuffer) {
      const buf = new Uint8Array(arrayBuffer);
      const view = new DataView(arrayBuffer);
      
      // Check FIT signature
      const signature = String.fromCharCode(buf[8], buf[9], buf[10], buf[11]);
      if (signature !== '.FIT') {
        throw new Error('Invalid FIT file signature');
      }
      
      const headerSize = buf[0];
      const dataSize = view.getUint32(4, true);
      const dataEnd = headerSize + dataSize;
      
      let offset = headerSize;
      const definitions = {};
      const gpsRecords = [];
      
      function readValue(offset, baseType, size) {
        if (baseType === 133 || baseType === 134 || baseType === 139) {
          return view.getInt32(offset, true);
        } else if (baseType === 131 || baseType === 132) {
          return view.getInt16(offset, true);
        } else if (baseType === 136) {
          return view.getFloat32(offset, true);
        }
        if (size === 4) return view.getUint32(offset, true);
        if (size === 2) return view.getUint16(offset, true);
        return buf[offset];
      }
      
      // FIT epoch: Dec 31, 1989 00:00:00 UTC
      const fitEpoch = Date.UTC(1989, 11, 31, 0, 0, 0);
      
      while (offset < dataEnd && offset < buf.length - 2) {
        const recordHeader = buf[offset++];
        const isDefinition = (recordHeader & 0x40) !== 0;
        const localMessageType = recordHeader & 0x0F;
        
        if (isDefinition) {
          offset++; // reserved
          offset++; // architecture
          const globalMsgNum = view.getUint16(offset, true);
          offset += 2;
          const numFields = buf[offset++];
          
          const fields = [];
          for (let i = 0; i < numFields; i++) {
            fields.push({
              fieldDefNum: buf[offset++],
              size: buf[offset++],
              baseType: buf[offset++]
            });
          }
          definitions[localMessageType] = { globalMsgNum, fields };
        } else {
          const def = definitions[localMessageType];
          if (!def) break;
          
          const record = {};
          for (const field of def.fields) {
            record[field.fieldDefNum] = readValue(offset, field.baseType, field.size);
            offset += field.size;
          }
          
          // Record message (20) = GPS data
          if (def.globalMsgNum === 20) {
            const lat = record[0] * (180 / Math.pow(2, 31));
            const lon = record[1] * (180 / Math.pow(2, 31));
            const timestamp = record[253];
            const speedMmS = record[73] || record[6] || 0; // enhanced_speed or speed
            const speedKnots = speedMmS / 1000 * 1.94384;
            
            if (lat !== 0 && lon !== 0 && !isNaN(lat) && !isNaN(lon)) {
              gpsRecords.push({
                timestamp_ms: fitEpoch + timestamp * 1000,
                lat,
                lon,
                sog_knots: speedKnots,
                cog_deg: null, // Will be calculated from positions
                heading_deg: null, // Not available in Garmin
                roll_deg: 0 // Not available
              });
            }
          }
        }
      }
      
      // Calculate COG from consecutive positions
      for (let i = 1; i < gpsRecords.length; i++) {
        const p0 = gpsRecords[i - 1];
        const p1 = gpsRecords[i];
        const dLon = (p1.lon - p0.lon) * Math.PI / 180;
        const lat0 = p0.lat * Math.PI / 180;
        const lat1 = p1.lat * Math.PI / 180;
        
        const x = Math.sin(dLon) * Math.cos(lat1);
        const y = Math.cos(lat0) * Math.sin(lat1) - Math.sin(lat0) * Math.cos(lat1) * Math.cos(dLon);
        let cog = Math.atan2(x, y) * 180 / Math.PI;
        if (cog < 0) cog += 360;
        
        p1.cog_deg = cog;
      }
      
      // Set first record COG same as second
      if (gpsRecords.length > 1) {
        gpsRecords[0].cog_deg = gpsRecords[1].cog_deg;
      }
      
      // Apply speed-weighted COG smoothing for heading
      // This reduces noise from GPS position errors, especially at low speeds
      const minSpeedForCog = 1.5; // knots - below this, COG is unreliable
      
      // Adaptive smooth window: target ~5 seconds of data
      // At 1Hz: 5 samples, at 0.25Hz: ~2 samples
      const avgInterval = (gpsRecords[gpsRecords.length-1].timestamp_ms - gpsRecords[0].timestamp_ms) / (gpsRecords.length - 1);
      const targetWindowSec = 5; // seconds
      const smoothWindow = Math.max(2, Math.round(targetWindowSec * 1000 / avgInterval));
      console.log(`GPS smoothing: avgInterval=${(avgInterval/1000).toFixed(1)}s, smoothWindow=${smoothWindow} samples`);
      
      for (let i = 0; i < gpsRecords.length; i++) {
        const p = gpsRecords[i];
        
        // If speed is very low, COG is meaningless - will interpolate later
        if (p.sog_knots < minSpeedForCog) {
          p.heading_deg = null;
          continue;
        }
        
        // Speed-weighted circular average over window
        let sinSum = 0, cosSum = 0, weightSum = 0;
        for (let j = Math.max(0, i - smoothWindow); j <= Math.min(gpsRecords.length - 1, i + smoothWindow); j++) {
          const sample = gpsRecords[j];
          if (sample.sog_knots >= minSpeedForCog) {
            const weight = sample.sog_knots; // Weight by speed
            sinSum += Math.sin(sample.cog_deg * Math.PI / 180) * weight;
            cosSum += Math.cos(sample.cog_deg * Math.PI / 180) * weight;
            weightSum += weight;
          }
        }
        
        if (weightSum > 0) {
          let smoothedHdg = Math.atan2(sinSum, cosSum) * 180 / Math.PI;
          if (smoothedHdg < 0) smoothedHdg += 360;
          p.heading_deg = smoothedHdg;
        } else {
          p.heading_deg = p.cog_deg;
        }
      }
      
      // Interpolate heading for low-speed gaps
      let lastValidIdx = -1;
      for (let i = 0; i < gpsRecords.length; i++) {
        if (gpsRecords[i].heading_deg !== null) {
          // Fill gap from lastValidIdx+1 to i-1
          if (lastValidIdx >= 0 && i - lastValidIdx > 1) {
            const startHdg = gpsRecords[lastValidIdx].heading_deg;
            const endHdg = gpsRecords[i].heading_deg;
            let diff = endHdg - startHdg;
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;
            
            for (let j = lastValidIdx + 1; j < i; j++) {
              const t = (j - lastValidIdx) / (i - lastValidIdx);
              let interpHdg = startHdg + diff * t;
              if (interpHdg < 0) interpHdg += 360;
              if (interpHdg >= 360) interpHdg -= 360;
              gpsRecords[j].heading_deg = interpHdg;
            }
          }
          lastValidIdx = i;
        }
      }
      
      // Fill any remaining nulls at start/end
      const firstValid = gpsRecords.find(p => p.heading_deg !== null);
      const lastValid = [...gpsRecords].reverse().find(p => p.heading_deg !== null);
      for (let i = 0; i < gpsRecords.length; i++) {
        if (gpsRecords[i].heading_deg === null) {
          gpsRecords[i].heading_deg = firstValid ? firstValid.heading_deg : gpsRecords[i].cog_deg;
        }
      }
      
      return gpsRecords;
    }

    function parseGPX(arrayBuffer) {
      // Convert ArrayBuffer to string
      const decoder = new TextDecoder('utf-8');
      const xmlString = decoder.decode(arrayBuffer);
      
      // Parse XML
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
      
      // Extract trackpoints
      const trkpts = xmlDoc.querySelectorAll('trkpt');
      const records = [];
      
      trkpts.forEach(trkpt => {
        const lat = parseFloat(trkpt.getAttribute('lat'));
        const lon = parseFloat(trkpt.getAttribute('lon'));
        const timeEl = trkpt.querySelector('time');
        
        if (!isNaN(lat) && !isNaN(lon) && timeEl) {
          const timestamp = new Date(timeEl.textContent).getTime();
          
          // Try to get elevation if available
          const eleEl = trkpt.querySelector('ele');
          const altitude = eleEl ? parseFloat(eleEl.textContent) : 0;
          
          records.push({
            timestamp_ms: timestamp,
            lat: lat,
            lon: lon,
            altitude_m: altitude,
            sog_knots: 0,  // Will calculate from position
            cog_deg: 0,    // Will calculate from position
            heading_deg: 0,
            roll_deg: 0
          });
        }
      });
      
      if (records.length < 2) {
        throw new Error('GPX file contains insufficient trackpoints');
      }
      
      // Sort by timestamp
      records.sort((a, b) => a.timestamp_ms - b.timestamp_ms);
      
      // Calculate speed (knots) and COG from position changes
      for (let i = 1; i < records.length; i++) {
        const p0 = records[i - 1];
        const p1 = records[i];
        const dt = (p1.timestamp_ms - p0.timestamp_ms) / 1000; // seconds
        
        if (dt > 0) {
          // Calculate distance using Haversine formula
          const R = 6371000; // Earth radius in meters
          const lat1 = p0.lat * Math.PI / 180;
          const lat2 = p1.lat * Math.PI / 180;
          const dLat = (p1.lat - p0.lat) * Math.PI / 180;
          const dLon = (p1.lon - p0.lon) * Math.PI / 180;
          
          const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1) * Math.cos(lat2) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
          const distanceM = R * c;
          
          // Speed in knots (1 knot = 0.514444 m/s)
          const speedMs = distanceM / dt;
          p1.sog_knots = speedMs / 0.514444;
          
          // Calculate bearing (COG)
          const y = Math.sin(dLon) * Math.cos(lat2);
          const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
          let cog = Math.atan2(y, x) * 180 / Math.PI;
          if (cog < 0) cog += 360;
          p1.cog_deg = cog;
          p1.heading_deg = cog;
        }
      }
      
      // Copy first point values from second point
      if (records.length > 1) {
        records[0].sog_knots = records[1].sog_knots;
        records[0].cog_deg = records[1].cog_deg;
        records[0].heading_deg = records[1].heading_deg;
      }
      
      // Apply COG smoothing (same as FIT parser)
      // Speed-weighted circular averaging over ¬±5 samples
      const windowRadius = 5;
      const lowSpeedThreshold = 1.5;
      const smoothedHeadings = [];
      
      for (let i = 0; i < records.length; i++) {
        let sinSum = 0, cosSum = 0, weightSum = 0;
        for (let j = Math.max(0, i - windowRadius); j <= Math.min(records.length - 1, i + windowRadius); j++) {
          const weight = records[j].sog_knots;
          if (weight > lowSpeedThreshold) {
            sinSum += weight * Math.sin(records[j].cog_deg * Math.PI / 180);
            cosSum += weight * Math.cos(records[j].cog_deg * Math.PI / 180);
            weightSum += weight;
          }
        }
        if (weightSum > 0) {
          let avgHdg = Math.atan2(sinSum, cosSum) * 180 / Math.PI;
          if (avgHdg < 0) avgHdg += 360;
          smoothedHeadings.push(avgHdg);
        } else {
          smoothedHeadings.push(null);
        }
      }
      
      // Apply smoothed headings and interpolate gaps
      let lastValidIdx = -1;
      for (let i = 0; i < records.length; i++) {
        if (smoothedHeadings[i] !== null) {
          if (lastValidIdx >= 0 && i - lastValidIdx > 1) {
            const startHdg = smoothedHeadings[lastValidIdx];
            const endHdg = smoothedHeadings[i];
            let diff = endHdg - startHdg;
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;
            for (let j = lastValidIdx + 1; j < i; j++) {
              const t = (j - lastValidIdx) / (i - lastValidIdx);
              let interpHdg = startHdg + diff * t;
              if (interpHdg < 0) interpHdg += 360;
              if (interpHdg >= 360) interpHdg -= 360;
              records[j].heading_deg = interpHdg;
            }
          }
          records[i].heading_deg = smoothedHeadings[i];
          lastValidIdx = i;
        }
      }
      
      // Fill remaining nulls
      const firstValid = records.find(p => smoothedHeadings[records.indexOf(p)] !== null);
      for (let i = 0; i < records.length; i++) {
        if (records[i].heading_deg === 0 || records[i].heading_deg === null) {
          records[i].heading_deg = firstValid ? firstValid.heading_deg : records[i].cog_deg;
        }
      }
      
      console.log(`GPX parsed: ${records.length} trackpoints`);
      return records;
    }

    function detectFileType(arrayBuffer) {
      const buf = new Uint8Array(arrayBuffer);
      // Check for FIT signature at byte 8-11
      if (buf.length > 12) {
        const sig = String.fromCharCode(buf[8], buf[9], buf[10], buf[11]);
        if (sig === '.FIT') return 'FIT';
      }
      // Check for GPX (XML file starting with <?xml or <gpx)
      if (buf.length > 10) {
        const start = String.fromCharCode(...buf.slice(0, 100)).toLowerCase();
        if (start.includes('<?xml') || start.includes('<gpx')) return 'GPX';
      }
      // Check for VKX - starts with row key
      if (buf[0] >= 0 && buf[0] < 20) return 'VKX';
      return 'UNKNOWN';
    }

    // ===== ANALYSIS ENGINE =====
    let DATA = null;
    let selectedLeg = null;
    let rateChart = null;
    let corridorChart = null;
    let magCorridorChart = null;
    
    // ===== RACE REPLAY STATE =====
    let raceReplayMode = false;
    let selectedSessionsForReplay = new Set();
    let isPlaying = false;
    let playbackSpeed = 1;
    let playbackTime = 0;  // Current playback time in minutes
    let playbackAnimationId = null;
    let playbackLastFrameTime = 0;
    let isDraggingPlayback = false;
    let videoStalled = false;  // True when active video is buffering/stalled
    let hideGrayTracks = false;  // When true, hide past and future track portions
    const BOAT_COLORS = ['#3b82f6', '#f59e0b', '#22c55e', '#ef4444', '#8b5cf6', '#ec4899'];

    // Get boat symbol from filename (first word before space, dash, or underscore)
    function getBoatSymbol(filename) {
      const cleaned = filename.replace(/\.(vkx|fit|gpx|gz)$/gi, '');
      const match = cleaned.match(/^([^\s_-]+)/);
      return match ? match[1] : cleaned.substring(0, 10);
    }

    function angleDiff(a, b) {
      let d = ((a - b + 180) % 360) - 180;
      if (d < -180) d += 360;
      return d;
    }

    function analyzeSession(records, startMinutes = null, endMinutes = null) {
      if (records.length < 100) throw new Error('Not enough telemetry data');

      console.log(`Analyzing ${records.length} telemetry records`);
      console.log('Sample records:', records.slice(0, 5));
      
      // Check for valid heading values
      const validHeadings = records.filter(r => r.heading_deg >= 0 && r.heading_deg < 360);
      console.log(`Valid heading records: ${validHeadings.length}/${records.length}`);
      
      // Apply time filtering if specified
      const originalFirstTs = records[0].timestamp_ms;
      let filteredRecords = records;
      
      if (startMinutes !== null && endMinutes !== null) {
        const startMs = originalFirstTs + startMinutes * 60000;
        const endMs = originalFirstTs + endMinutes * 60000;
        filteredRecords = records.filter(r => r.timestamp_ms >= startMs && r.timestamp_ms <= endMs);
        console.log(`Time filter applied: ${startMinutes.toFixed(1)}-${endMinutes.toFixed(1)} min, ${filteredRecords.length} records remaining`);
        
        if (filteredRecords.length < 100) throw new Error('Not enough data in selected time range');
      }
      
      // Downsample to ~4Hz if needed (but don't upsample sparse data)
      const targetHz = 4;
      const firstTs = filteredRecords[0].timestamp_ms;
      const lastTs = filteredRecords[filteredRecords.length - 1].timestamp_ms;
      const duration = (lastTs - firstTs) / 1000;
      const actualHz = filteredRecords.length / duration;
      const step = Math.max(1, Math.floor(actualHz / targetHz));
      const sampled = filteredRecords.filter((_, i) => i % step === 0);
      
      const sampledHz = sampled.length / duration;
      const isSparseData = sampledHz < 1; // Less than 1 Hz is considered sparse
      
      console.log(`Sampled to ${sampled.length} records (${actualHz.toFixed(1)}Hz ‚Üí ${sampledHz.toFixed(2)}Hz)${isSparseData ? ' [SPARSE DATA MODE]' : ''}`);

      // PHASE 1: Detect legs based on HEADING changes over a rolling window
      // Tacks/gybes show up as gradual heading changes, not instant jumps
      const prelimLegs = [];
      
      // Time-based parameters - for sparse data, use sample counts instead
      let windowSize, excludeBeforeSamples, excludeAfterSamples, mergeWindowSamples, minLegDur;
      
      if (isSparseData) {
        // For sparse GPS data (< 1 Hz), use fixed sample counts
        // This ensures meaningful rolling averages
        windowSize = Math.max(3, Math.round(sampled.length / 100)); // ~1% of data
        excludeBeforeSamples = Math.max(1, Math.round(windowSize * 0.3)); // Smaller exclusion for sparse data
        excludeAfterSamples = Math.max(2, Math.round(windowSize * 0.5));
        mergeWindowSamples = Math.max(3, windowSize); // Smaller merge window to keep maneuvers separate
        minLegDur = 15; // Allow shorter legs for sparse data (15 sec vs 30 sec)
        console.log(`Sparse data: window=${windowSize} samples, exclude ${excludeBeforeSamples}/${excludeAfterSamples}, merge=${mergeWindowSamples}, minLeg=${minLegDur}s`);
      } else {
        // Normal high-frequency data - time-based windows
        const windowTimeSec = 5;
        const excludeBeforeSec = 5;
        const excludeAfterSec = 10;
        const mergeWindowSec = 20;
        
        windowSize = Math.max(1, Math.round(windowTimeSec * sampledHz));
        excludeBeforeSamples = Math.round(excludeBeforeSec * sampledHz);
        excludeAfterSamples = Math.round(excludeAfterSec * sampledHz);
        mergeWindowSamples = Math.round(mergeWindowSec * sampledHz);
        minLegDur = 30; // seconds
      }
      
      // Lower threshold to catch gybes (which have smaller heading changes than tacks)
      // For sparse data, use slightly lower threshold to catch all maneuvers
      const maneuverThreshold = isSparseData ? 25 : 25;
      
      console.log(`Maneuver detection: window=${windowSize} samples, threshold=${maneuverThreshold}¬∞`);

      // Calculate rolling average heading
      const rollingHdg = [];
      for (let i = 0; i < sampled.length; i++) {
        if (i < windowSize) {
          rollingHdg.push(sampled[i].heading_deg);
        } else {
          // Circular mean over window
          let sinSum = 0, cosSum = 0;
          for (let j = i - windowSize; j < i; j++) {
            sinSum += Math.sin(sampled[j].heading_deg * Math.PI / 180);
            cosSum += Math.cos(sampled[j].heading_deg * Math.PI / 180);
          }
          let avgHdg = Math.atan2(sinSum, cosSum) * 180 / Math.PI;
          if (avgHdg < 0) avgHdg += 360;
          rollingHdg.push(avgHdg);
        }
      }

      // PASS 1: Detect ALL maneuvers (no duplicate prevention)
      const rawManeuvers = [];
      for (let i = windowSize * 2; i < sampled.length; i++) {
        const timeDiff = (sampled[i].timestamp_ms - sampled[i-1].timestamp_ms) / 1000;
        const hdgChange = Math.abs(angleDiff(rollingHdg[i], rollingHdg[i - windowSize]));
        
        // For sparse data, don't treat time gaps as maneuvers (irregular sampling is normal)
        // Only use heading change threshold
        const isManeuver = isSparseData 
          ? (hdgChange > maneuverThreshold)
          : (hdgChange > maneuverThreshold || timeDiff > 5);
        
        if (isManeuver) {
          rawManeuvers.push({
            idx: i - Math.floor(windowSize / 2), // Center of maneuver
            hdgChange
          });
        }
      }
      
      // PASS 2: Merge nearby maneuvers into exclusion zones
      const exclusionZones = [];
      let currentZone = null;
      
      rawManeuvers.forEach(m => {
        if (!currentZone) {
          currentZone = { start: m.idx, end: m.idx };
        } else if (m.idx - currentZone.end <= mergeWindowSamples) {
          // Extend current zone
          currentZone.end = m.idx;
        } else {
          // Save current zone and start new one
          exclusionZones.push(currentZone);
          currentZone = { start: m.idx, end: m.idx };
        }
      });
      if (currentZone) {
        exclusionZones.push(currentZone);
      }
      
      console.log(`Detected ${rawManeuvers.length} raw maneuvers, merged into ${exclusionZones.length} exclusion zones`);
      
      // Build legs between exclusion zones
      let prevEnd = 0;
      exclusionZones.forEach((zone) => {
        // Previous leg ends excludeBeforeSec before zone START
        const legEndIdx = Math.max(prevEnd, zone.start - excludeBeforeSamples);
        
        // Check if leg is long enough
        if (legEndIdx > prevEnd) {
          const legDur = (sampled[legEndIdx].timestamp_ms - sampled[prevEnd].timestamp_ms) / 1000;
          if (legDur >= minLegDur) {
            prelimLegs.push({ startIdx: prevEnd, endIdx: legEndIdx });
          }
        }
        
        // Next leg starts excludeAfterSec after zone END
        prevEnd = Math.min(sampled.length - 1, zone.end + excludeAfterSamples);
      });
      
      // Add final leg after last zone
      if (prevEnd < sampled.length - 1) {
        const finalDur = (sampled[sampled.length-1].timestamp_ms - sampled[prevEnd].timestamp_ms) / 1000;
        if (finalDur >= minLegDur) {
          prelimLegs.push({ startIdx: prevEnd, endIdx: sampled.length - 1 });
        }
      }
      
      // PASS 3: Filter out legs with excessive heading range (gradual turns)
      // and split legs with sudden heading changes
      // Use higher thresholds for sparse GPS data (COG-derived heading is noisier)
      const maxLegHdgChange = isSparseData ? 55 : 40; // Max sudden heading change allowed
      const maxLegHdgRange = isSparseData ? 50 : 35; // Max total heading range allowed in a leg
      const splitLegs = [];
      
      prelimLegs.forEach(leg => {
        const pts = sampled.slice(leg.startIdx, leg.endIdx + 1);
        if (pts.length < windowSize * 2) {
          splitLegs.push(leg);
          return;
        }
        
        // Check total heading range (to catch gradual turns)
        const headings = pts.map(p => p.heading_deg);
        let minDiff = 0, maxDiff = 0;
        headings.forEach(h => {
          const d = angleDiff(h, headings[0]);
          if (d < minDiff) minDiff = d;
          if (d > maxDiff) maxDiff = d;
        });
        const hdgRange = maxDiff - minDiff;
        
        // Also check average speed (exclude legs where boat is barely moving)
        const avgSpeed = pts.reduce((s, p) => s + p.sog_knots, 0) / pts.length;
        
        // Skip legs with excessive heading range or very low speed
        if (hdgRange > maxLegHdgRange || avgSpeed < 1.5) {
          // Don't include this leg at all
          return;
        }
        
        // Find max sudden heading change within this leg
        let maxChange = 0;
        let maxChangeIdx = -1;
        for (let i = windowSize; i < pts.length - windowSize; i++) {
          // Heading at position i vs i - windowSize
          let s0 = 0, c0 = 0, s1 = 0, c1 = 0;
          for (let j = 0; j < windowSize; j++) {
            s0 += Math.sin(pts[i - windowSize + j].heading_deg * Math.PI / 180);
            c0 += Math.cos(pts[i - windowSize + j].heading_deg * Math.PI / 180);
            s1 += Math.sin(pts[i + j].heading_deg * Math.PI / 180);
            c1 += Math.cos(pts[i + j].heading_deg * Math.PI / 180);
          }
          let h0 = Math.atan2(s0, c0) * 180 / Math.PI;
          let h1 = Math.atan2(s1, c1) * 180 / Math.PI;
          const change = Math.abs(angleDiff(h1, h0));
          if (change > maxChange) {
            maxChange = change;
            maxChangeIdx = i;
          }
        }
        
        if (maxChange > maxLegHdgChange && maxChangeIdx > 0) {
          // Split at the point of maximum change
          const splitPoint = leg.startIdx + maxChangeIdx;
          const beforeEnd = Math.max(leg.startIdx, splitPoint - excludeBeforeSamples);
          const afterStart = Math.min(leg.endIdx, splitPoint + excludeAfterSamples);
          
          const dur1 = (sampled[beforeEnd].timestamp_ms - sampled[leg.startIdx].timestamp_ms) / 1000;
          const dur2 = (sampled[leg.endIdx].timestamp_ms - sampled[afterStart].timestamp_ms) / 1000;
          
          if (dur1 >= minLegDur) {
            splitLegs.push({ startIdx: leg.startIdx, endIdx: beforeEnd });
          }
          if (dur2 >= minLegDur) {
            splitLegs.push({ startIdx: afterStart, endIdx: leg.endIdx });
          }
        } else {
          splitLegs.push(leg);
        }
      });
      
      // Replace prelimLegs with filtered version
      const originalCount = prelimLegs.length;
      prelimLegs.length = 0;
      splitLegs.forEach(l => prelimLegs.push(l));
      
      console.log(`Final leg count after filtering: ${prelimLegs.length} (removed ${originalCount - prelimLegs.length} with excessive heading range or low speed)`);

      // Calculate average heading and speed for each preliminary leg
      prelimLegs.forEach(leg => {
        const points = sampled.slice(leg.startIdx, leg.endIdx + 1);
        
        let avgHdg;
        if (isSparseData && points.length >= 2) {
          // For sparse GPS data: calculate bearing from start to end coordinates
          const startPt = points[0];
          const endPt = points[points.length - 1];
          const dLon = (endPt.lon - startPt.lon) * Math.PI / 180;
          const lat1 = startPt.lat * Math.PI / 180;
          const lat2 = endPt.lat * Math.PI / 180;
          const x = Math.sin(dLon) * Math.cos(lat2);
          const y = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
          avgHdg = Math.atan2(x, y) * 180 / Math.PI;
          if (avgHdg < 0) avgHdg += 360;
        } else {
          const sinSum = points.reduce((s, p) => s + Math.sin(p.heading_deg * Math.PI / 180), 0);
          const cosSum = points.reduce((s, p) => s + Math.cos(p.heading_deg * Math.PI / 180), 0);
          avgHdg = Math.atan2(sinSum, cosSum) * 180 / Math.PI;
          if (avgHdg < 0) avgHdg += 360;
        }
        
        leg.hdg = avgHdg;
        leg.speed = points.reduce((s, p) => s + p.sog_knots, 0) / points.length;
        leg.dur = (points[points.length-1].timestamp_ms - points[0].timestamp_ms) / 1000;
      });

      // PHASE 2: Detect tacks and gybes from heading changes between consecutive legs
      const maneuvers = [];
      console.log('Preliminary legs:', prelimLegs.length);
      
      for (let i = 0; i < prelimLegs.length - 1; i++) {
        const curr = prelimLegs[i];
        const next = prelimLegs[i + 1];
        const hdgChange = Math.abs(angleDiff(next.hdg, curr.hdg));
        
        console.log(`Leg ${i+1}‚Üí${i+2}: hdg ${curr.hdg.toFixed(0)}¬∞‚Üí${next.hdg.toFixed(0)}¬∞, change=${hdgChange.toFixed(0)}¬∞, speeds=${curr.speed.toFixed(1)}/${next.speed.toFixed(1)} kts`);
        
        // Tack: 60-130¬∞ heading change (relaxed from 70-120)
        if (hdgChange >= 60 && hdgChange <= 130 && curr.speed > 1.5 && next.speed > 1.5) {
          maneuvers.push({
            type: 'tack',
            hdg1: curr.hdg,
            hdg2: next.hdg,
            angle: hdgChange,
            avgSpeed: (curr.speed + next.speed) / 2
          });
          console.log(`  ‚Üí Detected TACK`);
        }
        // Gybe: 25-70¬∞ heading change (relaxed)
        else if (hdgChange >= 25 && hdgChange < 60 && curr.speed > 2 && next.speed > 2) {
          maneuvers.push({
            type: 'gybe',
            hdg1: curr.hdg,
            hdg2: next.hdg,
            angle: hdgChange,
            avgSpeed: (curr.speed + next.speed) / 2
          });
          console.log(`  ‚Üí Detected GYBE`);
        }
      }

      // PHASE 3: Calculate TWD from heading distribution
      // Find the two upwind tack headings (opposite heel signs, high heel magnitude)
      // Their bisector points directly at the wind source (TWD)
      let twd = 0;
      
      // Group headings into 10¬∞ bins (only when moving)
      const hdgHist = new Array(36).fill(0);
      const hdgHeelSum = new Array(36).fill(0);
      const hdgAbsHeelSum = new Array(36).fill(0);
      
      sampled.filter(r => r.sog_knots > 2).forEach(r => {
        const bin = Math.floor(r.heading_deg / 10) % 36;
        hdgHist[bin]++;
        hdgHeelSum[bin] += r.roll_deg;
        hdgAbsHeelSum[bin] += Math.abs(r.roll_deg);
      });
      
      // Get all bins sorted by count, with heel data
      const sortedBins = hdgHist
        .map((count, i) => ({
          bin: i * 10 + 5,
          count,
          avgHeel: count > 0 ? hdgHeelSum[i] / count : 0,
          avgAbsHeel: count > 0 ? hdgAbsHeelSum[i] / count : 0
        }))
        .filter(b => b.count > 100)
        .sort((a, b) => b.count - a.count);
      
      console.log('Top heading bins:', sortedBins.slice(0, 8).map(b => 
        `${b.bin}¬∞(${b.count}, heel=${b.avgHeel.toFixed(1)}¬∞)`).join(', '));
      
      if (sortedBins.length >= 2) {
        // Strategy: Find pairs with OPPOSITE heel signs first (true tack pairs)
        // Among opposite-heel pairs, pick one with highest combined heel magnitude
        // Fall back to highest count pair if no opposite-heel pairs exist
        
        let bestOppositeHeelPair = null;
        let bestOppositeHeelScore = 0;
        let bestCountPair = null;
        let bestCountScore = 0;
        
        for (let i = 0; i < Math.min(sortedBins.length, 15); i++) {
          for (let j = i + 1; j < Math.min(sortedBins.length, 15); j++) {
            const diff = Math.abs(angleDiff(sortedBins[i].bin, sortedBins[j].bin));
            if (diff >= 60 && diff <= 120) {
              const heel1 = sortedBins[i].avgHeel;
              const heel2 = sortedBins[j].avgHeel;
              const heelSignsOpposite = (heel1 * heel2) < 0;
              const combinedAbsHeel = sortedBins[i].avgAbsHeel + sortedBins[j].avgAbsHeel;
              const combinedCount = sortedBins[i].count + sortedBins[j].count;
              
              if (heelSignsOpposite) {
                // Prioritize by combined heel magnitude (higher heel = more likely upwind)
                if (combinedAbsHeel > bestOppositeHeelScore) {
                  bestOppositeHeelScore = combinedAbsHeel;
                  bestOppositeHeelPair = [sortedBins[i], sortedBins[j]];
                }
              }
              
              // Track best count pair as fallback
              if (combinedCount > bestCountScore) {
                bestCountScore = combinedCount;
                bestCountPair = [sortedBins[i], sortedBins[j]];
              }
            }
          }
        }
        
        // Use opposite-heel pair if found, otherwise fall back to count-based
        const bestPair = bestOppositeHeelPair || bestCountPair;
        
        if (bestPair) {
          const hdg1 = bestPair[0].bin;
          const hdg2 = bestPair[1].bin;
          const tackAngle = Math.abs(angleDiff(hdg1, hdg2));
          const heel1 = bestPair[0].avgHeel;
          const heel2 = bestPair[1].avgHeel;
          const absHeel1 = bestPair[0].avgAbsHeel;
          const absHeel2 = bestPair[1].avgAbsHeel;
          
          console.log(`Two main tacks: ${hdg1}¬∞ (heel ${heel1.toFixed(1)}¬∞) and ${hdg2}¬∞ (heel ${heel2.toFixed(1)}¬∞)`);
          console.log(`Selection method: ${bestOppositeHeelPair ? 'opposite-heel pair' : 'count-based fallback'}`);
          
          // Calculate bisector using circular mean
          const sin1 = Math.sin(hdg1 * Math.PI / 180);
          const cos1 = Math.cos(hdg1 * Math.PI / 180);
          const sin2 = Math.sin(hdg2 * Math.PI / 180);
          const cos2 = Math.cos(hdg2 * Math.PI / 180);
          let bisector = Math.atan2(sin1 + sin2, cos1 + cos2) * 180 / Math.PI;
          if (bisector < 0) bisector += 360;
          
          // Use heel data to determine if this pair is upwind or downwind
          const heelSignsOpposite = (heel1 * heel2) < 0;
          const pairAvgAbsHeel = (absHeel1 + absHeel2) / 2;
          
          // Find the opposite direction's heel (roughly 180¬∞ from bisector)
          const oppositeBin = sortedBins.find(b => {
            const diff = Math.abs(angleDiff(b.bin, (bisector + 180) % 360));
            return diff < 30;
          });
          const oppositeAbsHeel = oppositeBin ? oppositeBin.avgAbsHeel : 0;
          
          console.log(`Bisector: ${bisector.toFixed(0)}¬∞`);
          console.log(`Heel signs opposite: ${heelSignsOpposite}, pair avg heel: ${pairAvgAbsHeel.toFixed(1)}¬∞, opposite: ${oppositeAbsHeel.toFixed(1)}¬∞`);
          
          // Determine if this pair is upwind based on heel
          const isUpwindPair = heelSignsOpposite && (pairAvgAbsHeel > oppositeAbsHeel + 3);
          
          if (isUpwindPair) {
            // These are upwind headings, bisector = TWD
            twd = bisector;
            console.log(`TWD from upwind headings (heel confirmed): ${twd.toFixed(0)}¬∞`);
          } else if (heelSignsOpposite) {
            // Heel signs opposite but not clearly higher - check TWA
            const twa1 = Math.abs(angleDiff(hdg1, bisector));
            const twa2 = Math.abs(angleDiff(hdg2, bisector));
            if (twa1 < 90 && twa2 < 90) {
              twd = bisector;
              console.log(`TWD from upwind headings (TWA confirmed): ${twd.toFixed(0)}¬∞`);
            } else {
              twd = (bisector + 180) % 360;
              console.log(`TWD inverted based on TWA: ${twd.toFixed(0)}¬∞`);
            }
          } else {
            // Heel signs same - these are likely downwind, TWD is opposite
            twd = (bisector + 180) % 360;
            console.log(`TWD from downwind headings (same heel sign): ${twd.toFixed(0)}¬∞`);
          }
        } else {
          // No valid pair found, use top bin + 45¬∞
          twd = (sortedBins[0].bin + 45) % 360;
          console.log(`TWD from single heading: ${twd.toFixed(0)}¬∞`);
        }
      } else if (maneuvers.length >= 2) {
        // Fallback: use maneuver bisectors
        console.log('Using maneuver bisectors as fallback');
        const bisectors = maneuvers.filter(m => m.hdgChange >= 60 && m.hdgChange <= 130).map(m => {
          const sin1 = Math.sin(m.hdg1 * Math.PI / 180);
          const cos1 = Math.cos(m.hdg1 * Math.PI / 180);
          const sin2 = Math.sin(m.hdg2 * Math.PI / 180);
          const cos2 = Math.cos(m.hdg2 * Math.PI / 180);
          let bisector = Math.atan2(sin1 + sin2, cos1 + cos2) * 180 / Math.PI;
          if (bisector < 0) bisector += 360;
          return bisector;
        });
        
        if (bisectors.length > 0) {
          const sinSum = bisectors.reduce((s, b) => s + Math.sin(b * Math.PI / 180), 0);
          const cosSum = bisectors.reduce((s, b) => s + Math.cos(b * Math.PI / 180), 0);
          twd = Math.atan2(sinSum, cosSum) * 180 / Math.PI;
          if (twd < 0) twd += 360;
          console.log(`TWD from maneuver bisectors: ${twd.toFixed(0)}¬∞`);
        }
      }

      console.log(`TWD calculated: ${twd.toFixed(0)}¬∞`);

      // PHASE 4: Calculate TWA for each point with refined TWD
      sampled.forEach(r => {
        const rawTwa = angleDiff(r.cog_deg, twd);
        r.twa = Math.abs(rawTwa);
        r.twa_signed = rawTwa;
      });

      // PHASE 5: Re-detect legs using TWA-based rolling window
      // This gives us proper upwind/reaching/downwind classification
      const legs = [];
      legStart = 0;
      
      // Calculate rolling average TWA
      const rollingTwa = [];
      for (let i = 0; i < sampled.length; i++) {
        if (i < windowSize) {
          rollingTwa.push(sampled[i].twa);
        } else {
          let sum = 0;
          for (let j = i - windowSize; j < i; j++) {
            sum += sampled[j].twa;
          }
          rollingTwa.push(sum / windowSize);
        }
      }

      // Detect legs by TWA changes (tack = TWA stays similar but heading flips)
      // and heading changes (gybe = heading changes, TWA stays high)
      const twaChangeThreshold = 30;
      // For sparse GPS data, also check instantaneous heading changes (gybes get smoothed by rolling avg)
      const instantHdgThreshold = isSparseData ? 40 : 999; // Only for sparse data
      // Cooldown: after detecting a maneuver, wait before detecting another (rolling avg needs to stabilize)
      const cooldownSamples = isSparseData ? windowSize * 2 : 0;
      let cooldown = 0;
      
      for (let i = windowSize * 2; i < sampled.length; i++) {
        // Skip if in cooldown period
        if (cooldown > 0) {
          cooldown--;
          continue;
        }
        
        const timeDiff = (sampled[i].timestamp_ms - sampled[i-1].timestamp_ms) / 1000;
        const hdgChange = Math.abs(angleDiff(rollingHdg[i], rollingHdg[i - windowSize]));
        const twaChange = Math.abs(rollingTwa[i] - rollingTwa[i - windowSize]);
        // Instantaneous heading change (for catching gybes in sparse data)
        const instantHdgChange = Math.abs(angleDiff(sampled[i].heading_deg, sampled[i-1].heading_deg));
        
        // Detect maneuver: significant heading change OR significant TWA change
        // For sparse data: also check instantaneous heading change to catch gybes
        // For sparse data, don't use time gap detection (irregular sampling is normal)
        const isManeuver = isSparseData
          ? (hdgChange > maneuverThreshold || twaChange > twaChangeThreshold || instantHdgChange > instantHdgThreshold)
          : (hdgChange > maneuverThreshold || twaChange > twaChangeThreshold || timeDiff > 5);
        
        if (isManeuver) {
          const legDur = (sampled[i-1].timestamp_ms - sampled[legStart].timestamp_ms) / 1000;
          if (legDur >= minLegDur) {
            legs.push({ startIdx: legStart, endIdx: i - windowSize });
          }
          legStart = i;
          cooldown = cooldownSamples; // Start cooldown
        }
      }
      // Add final leg
      const finalLegDur = (sampled[sampled.length-1].timestamp_ms - sampled[legStart].timestamp_ms) / 1000;
      if (finalLegDur >= minLegDur) {
        legs.push({ startIdx: legStart, endIdx: sampled.length - 1 });
      }
      
      console.log(`PHASE 5: Re-detected ${legs.length} legs using TWA`);

      // PHASE 6: Process each leg with proper TWA-based classification
      const processedLegs = legs.map((leg, idx) => {
        const points = sampled.slice(leg.startIdx, leg.endIdx + 1);
        if (points.length === 0) return null;
        
        const dur = (points[points.length-1].timestamp_ms - points[0].timestamp_ms) / 1000;
        const startMin = (points[0].timestamp_ms - firstTs) / 60000;
        const endMin = (points[points.length-1].timestamp_ms - firstTs) / 60000;

        // Average values
        const avgTwa = points.reduce((s, p) => s + p.twa, 0) / points.length;
        const avgSpeed = points.reduce((s, p) => s + p.sog_knots, 0) / points.length;
        const avgHeel = points.reduce((s, p) => s + Math.abs(p.roll_deg), 0) / points.length;

        // POS classification based on TWA
        let pos;
        if (avgTwa < 75) pos = 'upwind';
        else if (avgTwa <= 112) pos = 'reaching';
        else pos = 'downwind';

        // Leg heading
        let legHdg;
        
        if (isSparseData && points.length >= 2) {
          // For sparse GPS data: calculate bearing from start to end coordinates
          // This gives the actual direction traveled from start to end of leg
          const startPt = points[0];
          const endPt = points[points.length - 1];
          const dLon = (endPt.lon - startPt.lon) * Math.PI / 180;
          const lat1 = startPt.lat * Math.PI / 180;
          const lat2 = endPt.lat * Math.PI / 180;
          const x = Math.sin(dLon) * Math.cos(lat2);
          const y = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
          legHdg = Math.atan2(x, y) * 180 / Math.PI;
          if (legHdg < 0) legHdg += 360;
          
          console.log(`  Leg ${idx+1} heading: ${legHdg.toFixed(0)}¬∞`);
        } else {
          // For high-frequency data: use circular mean of headings
          const sinSum = points.reduce((s, p) => s + Math.sin(p.heading_deg * Math.PI / 180), 0);
          const cosSum = points.reduce((s, p) => s + Math.cos(p.heading_deg * Math.PI / 180), 0);
          legHdg = Math.atan2(sinSum, cosSum) * 180 / Math.PI;
          if (legHdg < 0) legHdg += 360;
        }
        
        // Store endpoint headings (COG at start/end of leg)
        const hdgStart = points[0].heading_deg;
        const hdgEnd = points[points.length - 1].heading_deg;

        // Steering rate (¬∞/s)
        let totalHdgChange = 0;
        for (let i = 1; i < points.length; i++) {
          totalHdgChange += Math.abs(angleDiff(points[i].heading_deg, points[i-1].heading_deg));
        }
        const rate = totalHdgChange / dur;

        // COG corridor (5-95 percentile deviation)
        const cogDevs = points.map(p => angleDiff(p.cog_deg, legHdg));
        cogDevs.sort((a, b) => a - b);
        const p5 = cogDevs[Math.floor(cogDevs.length * 0.05)];
        const p95 = cogDevs[Math.floor(cogDevs.length * 0.95)];
        const corridor = Math.max(Math.abs(p5), Math.abs(p95));

        // Mag heading corridor (90% envelope: 5-95 percentile)
        const magDevs = points.map(p => angleDiff(p.heading_deg, legHdg));
        magDevs.sort((a, b) => a - b);
        const mp5 = magDevs[Math.floor(magDevs.length * 0.05)];
        const mp95 = magDevs[Math.floor(magDevs.length * 0.95)];
        const magCorridor = Math.max(Math.abs(mp5), Math.abs(mp95));
        
        // MAG70 (70% envelope: 15-85 percentile)
        const mp15 = magDevs[Math.floor(magDevs.length * 0.15)];
        const mp85 = magDevs[Math.floor(magDevs.length * 0.85)];
        const mag70 = Math.max(Math.abs(mp15), Math.abs(mp85));

        // Line Deviation (100% - straightness) and lost meters
        // Uses Haversine formula for accurate distance calculation
        const haversine = (lat1, lon1, lat2, lon2) => {
          const R = 6371000; // Earth radius in meters
          const dLat = (lat2 - lat1) * Math.PI / 180;
          const dLon = (lon2 - lon1) * Math.PI / 180;
          const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
          return R * c;
        };
        
        // Straight-line distance from start to end
        const straightDist = haversine(points[0].lat, points[0].lon, 
                                        points[points.length-1].lat, points[points.length-1].lon);
        
        // Total path length (sum of all segment distances)
        let totalPathLen = 0;
        for (let i = 1; i < points.length; i++) {
          totalPathLen += haversine(points[i-1].lat, points[i-1].lon, 
                                     points[i].lat, points[i].lon);
        }
        
        // Line deviation (how much extra distance was sailed)
        const lineDeviation = totalPathLen > 0 ? (totalPathLen - straightDist) / straightDist : 0;
        const lostMeters = totalPathLen - straightDist;

        // Timeseries for detail view (downsample)
        const tsStep = Math.max(1, Math.floor(points.length / 100));
        const ts = points.filter((_, i) => i % tsStep === 0).map(p => {
          // Calculate instantaneous TWA and VMG
          const instTwa = Math.abs(angleDiff(p.heading_deg, twd));
          const instVmg = Math.abs(p.sog_knots * Math.cos(instTwa * Math.PI / 180));
          return {
            t: (p.timestamp_ms - points[0].timestamp_ms) / 60000 + startMin,
            cog: p.cog_deg,
            hdg: p.heading_deg,
            dev: angleDiff(p.cog_deg, legHdg),
            mdev: angleDiff(p.heading_deg, legHdg),
            heel: p.roll_deg,
            spd: p.sog_knots,
            vmg: instVmg,
            rate: 0 // Will compute below
          };
        });

        // Compute instant rate for timeseries
        for (let i = 1; i < ts.length - 1; i++) {
          const dt = (ts[i+1].t - ts[i-1].t) * 60; // seconds
          const dh = Math.abs(angleDiff(ts[i+1].hdg, ts[i-1].hdg));
          ts[i].rate = dt > 0 ? dh / dt : 0;
        }
        if (ts.length > 0) ts[0].rate = ts.length > 1 ? ts[1].rate : 0;
        if (ts.length > 1) ts[ts.length-1].rate = ts[ts.length-2].rate;

        return {
          id: idx + 1,
          start: startMin,
          end: endMin,
          dur: Math.round(dur),
          pos,
          twa: Math.round(avgTwa),
          hdg: Math.round(legHdg),
          hdgStart: hdgStart,  // Heading at start of leg
          hdgEnd: hdgEnd,  // Heading at end of leg
          speed: avgSpeed.toFixed(1),
          heel: avgHeel.toFixed(1),
          rate,
          corridor,
          mag_corridor: magCorridor,
          mag70,
          lineDeviation,
          lostMeters,
          startLat: points[0].lat,
          startLon: points[0].lon,
          endLat: points[points.length-1].lat,
          endLon: points[points.length-1].lon,
          ts,
          next_maneuver: null
        };
      }).filter(leg => leg !== null);
      
      // Re-number legs after filtering
      processedLegs.forEach((leg, i) => leg.id = i + 1);
      
      console.log(`PHASE 6: Processed ${processedLegs.length} legs`);
      processedLegs.forEach(leg => {
        console.log(`  Leg ${leg.id}: ${leg.pos}, TWA=${leg.twa}¬∞, hdg=${leg.hdg}¬∞, ${leg.dur}s`);
      });

      // PHASE 7: Detect tacks and gybes based on heading changes
      // Use clustering to find consistent wind direction from maneuvers
      let finalTacks = 0, finalGybes = 0;
      
      // First pass: collect ALL potential maneuvers and their implied wind
      const potentialManeuvers = [];
      
      for (let i = 0; i < processedLegs.length - 1; i++) {
        const curr = processedLegs[i];
        const next = processedLegs[i + 1];
        
        // Use trimmed average headings for tack/gybe angle calculation
        const currHdg = curr.hdg;
        const nextHdg = next.hdg;
        const hdgChange = Math.abs(angleDiff(nextHdg, currHdg));
        
        if (isSparseData) {
          console.log(`  Maneuver check ${curr.id}->${next.id}: hdg ${currHdg}¬∞->${nextHdg}¬∞, change=${hdgChange.toFixed(0)}¬∞`);
        }
        
        // Skip if heading change is too small or too large
        if (hdgChange < 50 || hdgChange > 150) continue;
        
        // Calculate bisector
        const sin1 = Math.sin(currHdg * Math.PI / 180);
        const cos1 = Math.cos(currHdg * Math.PI / 180);
        const sin2 = Math.sin(nextHdg * Math.PI / 180);
        const cos2 = Math.cos(nextHdg * Math.PI / 180);
        let bisector = Math.atan2(sin1 + sin2, cos1 + cos2) * 180 / Math.PI;
        if (bisector < 0) bisector += 360;
        
        // For a tack, wind comes FROM bisector direction
        // For a gybe, wind comes FROM opposite of bisector
        potentialManeuvers.push({
          idx: i,
          curr, next,
          hdgChange,
          tackWind: bisector,  // If this is a tack, wind is from here
          gybeWind: (bisector + 180) % 360  // If this is a gybe, wind is from here
        });
      }
      
      console.log(`Found ${potentialManeuvers.length} potential maneuvers`);
      
      // Cluster the implied wind directions to find the dominant wind
      // Use 30¬∞ bins
      function findDominantWind(maneuvers, windKey) {
        const bins = {};
        maneuvers.forEach(m => {
          const bin = Math.round(m[windKey] / 30) * 30 % 360;
          if (!bins[bin]) bins[bin] = [];
          bins[bin].push(m);
        });
        
        // Find the bin with most maneuvers
        let maxBin = null, maxCount = 0;
        Object.entries(bins).forEach(([bin, list]) => {
          if (list.length > maxCount) {
            maxCount = list.length;
            maxBin = parseInt(bin);
          }
        });
        
        return { dominantBin: maxBin, count: maxCount, bins };
      }
      
      // Check if tacks or gybes give more consistent wind
      const tackAnalysis = findDominantWind(potentialManeuvers, 'tackWind');
      const gybeAnalysis = findDominantWind(potentialManeuvers, 'gybeWind');
      
      console.log(`Tack wind clusters: dominant bin ${tackAnalysis.dominantBin}¬∞ with ${tackAnalysis.count} maneuvers`);
      console.log(`Gybe wind clusters: dominant bin ${gybeAnalysis.dominantBin}¬∞ with ${gybeAnalysis.count} maneuvers`);
      
      // Build wind timeline from consistent maneuvers only
      const windTimeline = [];
      const windTolerance = 45; // Only accept maneuvers within 45¬∞ of dominant wind
      
      // Determine dominant wind direction from the most consistent cluster
      // BUT validate against heel-confirmed TWD from Phase 3
      let dominantWind;
      const tackDominant = tackAnalysis.dominantBin;
      const gybeDominant = gybeAnalysis.dominantBin;
      
      // Check which candidate is closer to our heel-validated TWD
      const tackDiff = Math.abs(angleDiff(tackDominant, twd));
      const gybeDiff = Math.abs(angleDiff(gybeDominant, twd));
      
      console.log(`Phase 3 TWD (heel-validated): ${twd}¬∞`);
      console.log(`Tack dominant: ${tackDominant}¬∞ (diff from TWD: ${tackDiff.toFixed(0)}¬∞)`);
      console.log(`Gybe dominant: ${gybeDominant}¬∞ (diff from TWD: ${gybeDiff.toFixed(0)}¬∞)`);
      
      // Use the cluster that's closest to heel-validated TWD, or fall back to Phase 3 TWD
      if (tackAnalysis.count >= 3 && tackDiff < 60) {
        dominantWind = tackDominant;
        console.log(`Using tack cluster (consistent with heel-validated TWD)`);
      } else if (gybeAnalysis.count >= 3 && gybeDiff < 60) {
        dominantWind = gybeDominant;
        console.log(`Using gybe cluster (consistent with heel-validated TWD)`);
      } else {
        dominantWind = twd; // Keep heel-validated TWD from Phase 3
        console.log(`Keeping heel-validated TWD from Phase 3`);
      }
      
      console.log(`Using dominant wind direction: ${dominantWind}¬∞`);
      
      for (const m of potentialManeuvers) {
        const tackWindDiff = Math.abs(angleDiff(m.tackWind, dominantWind));
        const gybeWindDiff = Math.abs(angleDiff(m.gybeWind, dominantWind));
        
        // Additional validation: tacks should be between upwind legs, gybes between downwind legs
        const bothUpwind = m.curr.pos === 'upwind' && m.next.pos === 'upwind';
        const bothDownwind = m.curr.pos === 'downwind' && m.next.pos === 'downwind';
        
        if (isSparseData) {
          // For sparse GPS data, use relaxed position validation and angle validation
          // (GPS-derived positions may be less accurate due to COG noise)
          const oneUpwind = m.curr.pos === 'upwind' || m.next.pos === 'upwind';
          const oneDownwind = m.curr.pos === 'downwind' || m.next.pos === 'downwind';
          const neitherReaching = m.curr.pos !== 'reaching' && m.next.pos !== 'reaching';
          
          // Angle validation: typical tack angles are 70-120¬∞, typical gybe angles are 40-110¬∞
          const validTackAngle = m.hdgChange >= 70 && m.hdgChange <= 120;
          const validGybeAngle = m.hdgChange >= 40 && m.hdgChange <= 110;
          
          // For tacks: allow if at least one leg is upwind AND neither is downwind
          const tackPosValid = oneUpwind && !bothDownwind;
          // For gybes: allow if at least one leg is downwind AND neither is reaching
          const gybePosValid = oneDownwind && neitherReaching;
          
          // Debug logging for sparse data
          console.log(`  Leg ${m.curr.id} (${m.curr.pos}) -> Leg ${m.next.id} (${m.next.pos}): hdgChange=${m.hdgChange.toFixed(0)}¬∞`);
          console.log(`    tackWindDiff=${tackWindDiff.toFixed(0)}¬∞, gybeWindDiff=${gybeWindDiff.toFixed(0)}¬∞`);
          console.log(`    tackPosValid=${tackPosValid}, gybePosValid=${gybePosValid}, validTack=${validTackAngle}, validGybe=${validGybeAngle}`);
          
          if (tackWindDiff <= windTolerance && tackWindDiff < gybeWindDiff && tackPosValid && validTackAngle) {
            m.curr.next_maneuver = { type: 'tack', angle: Math.round(m.hdgChange) };
            finalTacks++;
            windTimeline.push({ time: m.curr.end, wind: m.tackWind, type: 'tack' });
            console.log(`    => TACK ASSIGNED: ${Math.round(m.hdgChange)}¬∞`);
          } else if (gybeWindDiff <= windTolerance && gybePosValid && validGybeAngle) {
            m.curr.next_maneuver = { type: 'gybe', angle: Math.round(m.hdgChange) };
            finalGybes++;
            windTimeline.push({ time: m.curr.end, wind: m.gybeWind, type: 'gybe' });
            console.log(`    => GYBE ASSIGNED: ${Math.round(m.hdgChange)}¬∞`);
          } else {
            console.log(`    => NOT ASSIGNED`);
          }
        } else {
          // Original VKX logic - simpler validation based on wind direction only
          if (tackWindDiff <= windTolerance && tackWindDiff < gybeWindDiff) {
            m.curr.next_maneuver = { type: 'tack', angle: Math.round(m.hdgChange) };
            finalTacks++;
            windTimeline.push({ time: m.curr.end, wind: m.tackWind, type: 'tack' });
            console.log(`  TACK after Leg ${m.curr.id}: ${m.curr.hdg.toFixed(0)}¬∞‚Üí${m.next.hdg.toFixed(0)}¬∞ (${Math.round(m.hdgChange)}¬∞), wind=${m.tackWind.toFixed(0)}¬∞`);
          } else if (gybeWindDiff <= windTolerance) {
            m.curr.next_maneuver = { type: 'gybe', angle: Math.round(m.hdgChange) };
            finalGybes++;
            windTimeline.push({ time: m.curr.end, wind: m.gybeWind, type: 'gybe' });
            console.log(`  GYBE after Leg ${m.curr.id}: ${m.curr.hdg.toFixed(0)}¬∞‚Üí${m.next.hdg.toFixed(0)}¬∞ (${Math.round(m.hdgChange)}¬∞), wind=${m.gybeWind.toFixed(0)}¬∞`);
          }
        }
      }
      
      console.log(`PHASE 7: Final maneuvers - ${finalTacks} tacks, ${finalGybes} gybes`);
      console.log(`Wind timeline has ${windTimeline.length} points`);
      
      // Debug: Log which legs have next_maneuver set
      const legsWithManeuvers = processedLegs.filter(l => l.next_maneuver !== null);
      console.log(`Legs with next_maneuver after Phase 7: ${legsWithManeuvers.length}`);
      legsWithManeuvers.forEach(l => console.log(`  Leg ${l.id}: ${l.next_maneuver.type} ${l.next_maneuver.angle}¬∞`));
      
      // Update twd to dominantWind if we found valid clusters
      if (windTimeline.length >= 3) {
        twd = dominantWind;
        console.log(`Updated TWD to dominant wind: ${twd}¬∞`);
      }

      // PHASE 8: Recalculate TWA and VMG using time-varying wind
      // Sort wind timeline by time
      windTimeline.sort((a, b) => a.time - b.time);
      
      // Helper: interpolate wind at a given time
      function getWindAtTime(t) {
        if (windTimeline.length === 0) return twd; // Fallback to original TWD
        if (windTimeline.length === 1) return windTimeline[0].wind;
        
        // Find surrounding wind measurements
        let before = null, after = null;
        for (let i = 0; i < windTimeline.length; i++) {
          if (windTimeline[i].time <= t) before = windTimeline[i];
          if (windTimeline[i].time >= t && !after) after = windTimeline[i];
        }
        
        if (!before) return after.wind;
        if (!after) return before.wind;
        if (before.time === after.time) return before.wind;
        
        // Linear interpolation with circular handling
        const ratio = (t - before.time) / (after.time - before.time);
        let diff = angleDiff(after.wind, before.wind);
        let interpolated = before.wind + diff * ratio;
        if (interpolated < 0) interpolated += 360;
        if (interpolated >= 360) interpolated -= 360;
        return interpolated;
      }
      
      // Recalculate TWA and add VMG for each leg
      processedLegs.forEach(leg => {
        const midTime = (leg.start + leg.end) / 2;
        const localWind = getWindAtTime(midTime);
        leg.localWind = Math.round(localWind);
        
        // Recalculate TWA with local wind
        const newTwa = Math.abs(angleDiff(leg.hdg, localWind));
        leg.twa = Math.round(newTwa);
        
        // Recalculate POS based on new TWA
        if (newTwa < 75) {
          leg.pos = 'upwind';
        } else if (newTwa > 112) {
          leg.pos = 'downwind';
        } else {
          leg.pos = 'reaching';
        }
        
        // Calculate VMG (Velocity Made Good towards/away from wind)
        // VMG = Speed √ó cos(TWA)
        const speed = parseFloat(leg.speed);
        const vmg = Math.abs(speed * Math.cos(newTwa * Math.PI / 180));
        leg.vmg = vmg.toFixed(1);
        
        console.log(`  Leg ${leg.id}: wind=${leg.localWind}¬∞, TWA=${leg.twa}¬∞, VMG=${leg.vmg} kts`);
      });
      
      // Calculate typical (median) wind direction from time-varying data
      // Only use median if it's consistent with heel-validated TWD
      if (windTimeline.length > 0) {
        // Use circular median for angles
        const windAngles = windTimeline.map(w => w.wind);
        // Sort by angle (handling circular nature by finding cluster)
        const sorted = [...windAngles].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        const medianWind = sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
        
        // Only update TWD if median is within 60¬∞ of current (heel-validated) TWD
        const medianDiff = Math.abs(angleDiff(medianWind, twd));
        if (medianDiff < 60) {
          twd = Math.round(medianWind);
          console.log(`Typical wind (median of ${windTimeline.length} measurements): ${twd}¬∞ (consistent with heel validation)`);
        } else {
          console.log(`Median wind ${Math.round(medianWind)}¬∞ differs too much from heel-validated ${twd}¬∞, keeping original`);
        }
      }
      
      console.log(`PHASE 8: Recalculated TWA and VMG with time-varying wind`);

      // Calculate 1-minute intervals
      const intervals = [];
      processedLegs.forEach(leg => {
        const legPoints = sampled.filter(p => {
          const t = (p.timestamp_ms - firstTs) / 60000;
          return t >= leg.start && t <= leg.end;
        });

        // Group by minute
        const byMinute = {};
        legPoints.forEach(p => {
          const min = Math.floor((p.timestamp_ms - firstTs) / 60000);
          if (!byMinute[min]) byMinute[min] = [];
          byMinute[min].push(p);
        });

        Object.entries(byMinute).forEach(([min, pts]) => {
          if (pts.length < 10) return;

          // Calc steering rate for this minute
          let hdgChange = 0;
          for (let i = 1; i < pts.length; i++) {
            hdgChange += Math.abs(angleDiff(pts[i].heading_deg, pts[i-1].heading_deg));
          }
          const dur = (pts[pts.length-1].timestamp_ms - pts[0].timestamp_ms) / 1000;
          const rate = dur > 0 ? hdgChange / dur : 0;

          // Minute heading
          const sinSum = pts.reduce((s, p) => s + Math.sin(p.heading_deg * Math.PI / 180), 0);
          const cosSum = pts.reduce((s, p) => s + Math.cos(p.heading_deg * Math.PI / 180), 0);
          let minHdg = Math.atan2(sinSum, cosSum) * 180 / Math.PI;
          if (minHdg < 0) minHdg += 360;

          // COG corridor
          const devs = pts.map(p => angleDiff(p.cog_deg, minHdg));
          devs.sort((a, b) => a - b);
          const p5 = devs[Math.floor(devs.length * 0.05)] || devs[0];
          const p95 = devs[Math.floor(devs.length * 0.95)] || devs[devs.length-1];
          const corridor = Math.max(Math.abs(p5), Math.abs(p95));

          // MAG corridor (heading deviation from mean heading)
          const magDevs = pts.map(p => angleDiff(p.heading_deg, minHdg));
          magDevs.sort((a, b) => a - b);
          const mp5 = magDevs[Math.floor(magDevs.length * 0.05)] || magDevs[0];
          const mp95 = magDevs[Math.floor(magDevs.length * 0.95)] || magDevs[magDevs.length-1];
          const magCorridor = Math.max(Math.abs(mp5), Math.abs(mp95));

          intervals.push({
            minute: parseInt(min),
            leg_id: leg.id,
            pos: leg.pos,
            rate,
            corridor_pm: corridor,
            mag_corridor_pm: magCorridor
          });
        });
      });

      // Calculate overall stats
      // Filter out slow legs (< 2 kts) for speed/VMG stats - these are maneuvering/drifting
      const minSpeedForStats = 2.0;
      const upwindLegs = processedLegs.filter(l => l.pos === 'upwind');
      const downwindLegs = processedLegs.filter(l => l.pos === 'downwind');
      const reachingLegs = processedLegs.filter(l => l.pos === 'reaching');
      
      // For speed/VMG, exclude slow maneuvering legs
      const upwindLegsMoving = upwindLegs.filter(l => parseFloat(l.speed) >= minSpeedForStats);
      const downwindLegsMoving = downwindLegs.filter(l => parseFloat(l.speed) >= minSpeedForStats);
      const reachingLegsMoving = reachingLegs.filter(l => parseFloat(l.speed) >= minSpeedForStats);

      const weightedAvg = (legs, prop) => {
        const total = legs.reduce((s, l) => s + l.dur, 0);
        if (total === 0) return 0;
        return legs.reduce((s, l) => s + parseFloat(l[prop]) * l.dur, 0) / total;
      };

      const totalDur = processedLegs.reduce((s, l) => s + l.dur, 0);
      
      // Determine TWD source description
      let twdSource;
      if (finalTacks + finalGybes > 0) {
        twdSource = `time-varying from ${finalTacks + finalGybes} maneuvers`;
      } else if (tacks.length >= 1) {
        twdSource = `from ${tacks.length} tack${tacks.length > 1 ? 's' : ''}`;
      } else if (gybes.length >= 1) {
        twdSource = `from ${gybes.length} gybe${gybes.length > 1 ? 's' : ''}`;
      } else {
        twdSource = 'from heading analysis';
      }

      const stats = {
        d: new Date(firstTs).toLocaleDateString(),
        timestamp: firstTs, // Raw timestamp for sorting
        dur: Math.round(totalDur / 60),
        twd: Math.round(twd),
        twdSource,
        finalTacks,
        finalGybes,
        // Use moving legs (>2 kts) for all performance stats to exclude maneuvering
        speed_upwind: upwindLegsMoving.length ? weightedAvg(upwindLegsMoving, 'speed').toFixed(1) : '-',
        speed_downwind: downwindLegsMoving.length ? weightedAvg(downwindLegsMoving, 'speed').toFixed(1) : '-',
        vmg_upwind: upwindLegsMoving.length ? weightedAvg(upwindLegsMoving, 'vmg').toFixed(1) : '-',
        vmg_downwind: downwindLegsMoving.length ? weightedAvg(downwindLegsMoving, 'vmg').toFixed(1) : '-',
        heel_upwind: upwindLegsMoving.length ? weightedAvg(upwindLegsMoving, 'heel').toFixed(0) : '-',
        heel_downwind: downwindLegsMoving.length ? weightedAvg(downwindLegsMoving, 'heel').toFixed(0) : '-',
        corridor_upwind: upwindLegsMoving.length ? weightedAvg(upwindLegsMoving, 'corridor').toFixed(1) : '-',
        corridor_downwind: downwindLegsMoving.length ? weightedAvg(downwindLegsMoving, 'corridor').toFixed(1) : '-',
        mag_corridor_upwind: upwindLegsMoving.length ? weightedAvg(upwindLegsMoving, 'mag_corridor').toFixed(1) : '-',
        mag_corridor_downwind: downwindLegsMoving.length ? weightedAvg(downwindLegsMoving, 'mag_corridor').toFixed(1) : '-',
        mag70_upwind: upwindLegsMoving.length ? weightedAvg(upwindLegsMoving, 'mag70').toFixed(1) : '-',
        mag70_downwind: downwindLegsMoving.length ? weightedAvg(downwindLegsMoving, 'mag70').toFixed(1) : '-',
        rate_upwind: upwindLegsMoving.length ? weightedAvg(upwindLegsMoving, 'rate').toFixed(2) : '-',
        rate_downwind: downwindLegsMoving.length ? weightedAvg(downwindLegsMoving, 'rate').toFixed(2) : '-',
        linedev_upwind: upwindLegsMoving.length ? (weightedAvg(upwindLegsMoving, 'lineDeviation') * 100).toFixed(1) : '-',
        linedev_downwind: downwindLegsMoving.length ? (weightedAvg(downwindLegsMoving, 'lineDeviation') * 100).toFixed(1) : '-',
        lostm_upwind: upwindLegsMoving.length ? Math.round(upwindLegsMoving.reduce((s, l) => s + l.lostMeters, 0)) : '-',
        lostm_downwind: downwindLegsMoving.length ? Math.round(downwindLegsMoving.reduce((s, l) => s + l.lostMeters, 0)) : '-',
      };

      // POS breakdown
      const posBreakdown = {
        upwind: {
          time: upwindLegs.reduce((s, l) => s + l.dur, 0),
          pct: ((upwindLegs.reduce((s, l) => s + l.dur, 0) / totalDur) * 100).toFixed(0),
          speed: stats.speed_upwind,
          vmg: stats.vmg_upwind,
          corridor: stats.corridor_upwind,
          rate: stats.rate_upwind,
          heel: stats.heel_upwind,
          linedev: stats.linedev_upwind,
          lostm: stats.lostm_upwind
        },
        reaching: {
          time: reachingLegs.reduce((s, l) => s + l.dur, 0),
          pct: ((reachingLegs.reduce((s, l) => s + l.dur, 0) / totalDur) * 100).toFixed(0),
          speed: reachingLegsMoving.length ? weightedAvg(reachingLegsMoving, 'speed').toFixed(1) : '-',
          vmg: reachingLegsMoving.length ? weightedAvg(reachingLegsMoving, 'vmg').toFixed(1) : '-',
          corridor: reachingLegsMoving.length ? weightedAvg(reachingLegsMoving, 'corridor').toFixed(1) : '-',
          rate: reachingLegsMoving.length ? weightedAvg(reachingLegsMoving, 'rate').toFixed(2) : '-',
          heel: reachingLegsMoving.length ? weightedAvg(reachingLegsMoving, 'heel').toFixed(0) : '-',
          linedev: reachingLegsMoving.length ? (weightedAvg(reachingLegsMoving, 'lineDeviation') * 100).toFixed(1) : '-',
          lostm: reachingLegsMoving.length ? Math.round(reachingLegsMoving.reduce((s, l) => s + l.lostMeters, 0)) : '-'
        },
        downwind: {
          time: downwindLegs.reduce((s, l) => s + l.dur, 0),
          pct: ((downwindLegs.reduce((s, l) => s + l.dur, 0) / totalDur) * 100).toFixed(0),
          speed: stats.speed_downwind,
          vmg: stats.vmg_downwind,
          corridor: stats.corridor_downwind,
          rate: stats.rate_downwind,
          heel: stats.heel_downwind,
          linedev: stats.linedev_downwind,
          lostm: stats.lostm_downwind
        }
      };

      // Track points for map (store full resolution for adaptive rendering)
      // Include hdg, sog, cog, roll for race replay mode
      const track = sampled.map(p => ({
        lat: p.lat,
        lon: p.lon,
        t: (p.timestamp_ms - firstTs) / 60000,
        hdg: p.heading_deg || p.cog_deg || 0,
        sog: p.sog_knots || 0,
        cog: p.cog_deg || 0,
        roll_deg: p.roll_deg || 0
      }));

      return {
        s: stats,
        o: stats,
        legs: processedLegs,
        intervals,
        pos: posBreakdown,
        track
      };
    }

    // ===== UI FUNCTIONS =====
    function getRateColor(rate) {
      if (rate <= 1.5) return '#22c55e';
      if (rate <= 3) return '#3b82f6';
      if (rate <= 5) return '#f59e0b';
      return '#ef4444';
    }

    function getCorridorColor(c) {
      if (c <= 8) return '#22c55e';
      if (c <= 12) return '#3b82f6';
      if (c <= 18) return '#f59e0b';
      return '#ef4444';
    }

    function getMagCorridorColor(c) {
      if (c <= 5) return '#22c55e';   // Excellent: ‚â§¬±5¬∞
      if (c <= 8) return '#3b82f6';   // Good: ¬±5-8¬∞
      if (c <= 12) return '#f59e0b';  // Fair: ¬±8-12¬∞
      return '#ef4444';                // Needs work: >¬±12¬∞
    }

    function getLineDeviationColor(pct) {
      if (pct <= 1) return '#22c55e';   // Excellent: <= 1%
      if (pct <= 2) return '#3b82f6';   // Good: 1-2%
      if (pct <= 4) return '#f59e0b';   // Fair: 2-4%
      return '#ef4444';                  // Needs work: > 4%
    }

    function renderDashboard() {
      const filename = DATA.filename || 'Session';
      const shortName = filename.replace('.vkx', '').replace('.fit', '').replace('.gpx', '').replace('.gz', '').replace(/[_-]/g, ' ');
      document.getElementById('session-title').textContent = `${shortName} - Steering Analysis`;
      
      // Build subtitle with optional timeline info
      let subtitle = `${DATA.s.d} | ${DATA.s.dur} min | Wind ${DATA.s.twd}¬∞ (${DATA.s.twdSource})`;
      if (DATA.dataSource === 'garmin') {
        subtitle += ' | üìç GPS (smoothed COG)';
      }
      if (DATA.fullDuration && DATA.timelineStart !== undefined && DATA.timelineEnd !== undefined) {
        const isFiltered = DATA.timelineStart > 0.1 || DATA.timelineEnd < DATA.fullDuration - 0.1;
        if (isFiltered) {
          subtitle += ` | ‚è± ${DATA.timelineStart.toFixed(1)}-${DATA.timelineEnd.toFixed(1)} min`;
        }
      }
      document.getElementById('session-subtitle').textContent = subtitle;
      
      // Update add files button text
      const addBtn = document.getElementById('add-files-btn');
      if (addBtn) {
        addBtn.textContent = ALL_SESSIONS.length > 1 ? 'Add More Files' : 'Load More Files';
      }

      // Stats
      document.getElementById('speed-up').textContent = `${DATA.o.speed_upwind}/${DATA.o.vmg_upwind}`;
      document.getElementById('speed-down').textContent = `${DATA.o.speed_downwind}/${DATA.o.vmg_downwind}`;
      document.getElementById('heel-up').textContent = DATA.o.heel_upwind + '¬∞';
      document.getElementById('heel-down').textContent = DATA.o.heel_downwind + '¬∞';
      document.getElementById('corr-up').textContent = '¬±' + DATA.o.corridor_upwind + '¬∞';
      document.getElementById('corr-down').textContent = '¬±' + DATA.o.corridor_downwind + '¬∞';
      document.getElementById('mag-up').textContent = DATA.o.mag_corridor_upwind + '¬∞';
      document.getElementById('mag-down').textContent = DATA.o.mag_corridor_downwind + '¬∞';
      document.getElementById('mag70-up').textContent = DATA.o.mag70_upwind + '¬∞';
      document.getElementById('mag70-down').textContent = DATA.o.mag70_downwind + '¬∞';
      document.getElementById('linedev-up').textContent = DATA.o.linedev_upwind !== '-' ? `${DATA.o.linedev_upwind}% (${DATA.o.lostm_upwind}m)` : '-';
      document.getElementById('linedev-down').textContent = DATA.o.linedev_downwind !== '-' ? `${DATA.o.linedev_downwind}% (${DATA.o.lostm_downwind}m)` : '-';
      document.getElementById('rate-up').textContent = DATA.o.rate_upwind + '¬∞/s';
      document.getElementById('rate-down').textContent = DATA.o.rate_downwind + '¬∞/s';
      
      // Hide heel and MAG boxes for Garmin data (no independent heading or heel sensor)
      const isGarmin = DATA.dataSource === 'garmin';
      document.getElementById('heel-box').style.display = isGarmin ? 'none' : '';
      document.getElementById('mag-box').style.display = isGarmin ? 'none' : '';
      
      // Tacks/Gybes stats
      const tacks = DATA.legs.filter(l => l.next_maneuver?.type === 'tack');
      const gybes = DATA.legs.filter(l => l.next_maneuver?.type === 'gybe');
      const tackAngles = tacks.map(l => l.next_maneuver.angle).filter(a => a);
      const gybeAngles = gybes.map(l => l.next_maneuver.angle).filter(a => a);
      const medianTackAngle = tackAngles.length ? Math.round(tackAngles.sort((a,b) => a-b)[Math.floor(tackAngles.length/2)]) : null;
      const medianGybeAngle = gybeAngles.length ? Math.round(gybeAngles.sort((a,b) => a-b)[Math.floor(gybeAngles.length/2)]) : null;
      
      document.getElementById('tack-count').textContent = tacks.length;
      document.getElementById('tack-angle').textContent = medianTackAngle !== null ? medianTackAngle + '¬∞' : '-';
      document.getElementById('gybe-count').textContent = gybes.length;
      document.getElementById('gybe-angle').textContent = medianGybeAngle !== null ? medianGybeAngle + '¬∞' : '-';

      renderMap();
      renderLegsTable();
      renderScatterCharts();
      renderPOSBreakdown();
      renderTimeline();
    }

    // Map zoom/pan state
    let mapZoom = 1;
    let mapPanX = 0;
    let mapPanY = 0;
    let mapProjection = 'compass'; // 'compass' (no lat correction) or 'geo' (lat corrected)
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;

    function zoomMap(factor) {
      mapZoom = Math.max(0.5, Math.min(30, mapZoom * factor));
      renderMap();
    }

    function resetMapZoom() {
      mapZoom = 1;
      mapPanX = 0;
      mapPanY = 0;
      renderMap();
    }
    
    function saveMapScreenshot() {
      const mapContainer = document.getElementById('map-container');
      if (!mapContainer) return;
      
      // Use html2canvas to capture the map container with all overlays
      html2canvas(mapContainer, {
        backgroundColor: '#eff6ff',
        scale: 2, // Higher quality
        logging: false,
        useCORS: true
      }).then(canvas => {
        // Create download link
        const link = document.createElement('a');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        link.download = `sailing-map-${timestamp}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
      }).catch(err => {
        console.error('Screenshot failed:', err);
        alert('Failed to capture screenshot');
      });
    }

    function toggleProjection() {
      const toggle = document.getElementById('proj-toggle');
      const slider = document.getElementById('proj-slider');
      const label = document.getElementById('proj-label');
      const track = toggle.nextElementSibling; // The track span
      
      if (toggle.checked) {
        mapProjection = 'geo';
        slider.style.transform = 'translateX(14px)';
        track.style.backgroundColor = '#7c3aed';
        label.textContent = 'Geo';
        label.title = 'Geographic projection: true distances, angles vary with wind direction';
      } else {
        mapProjection = 'compass';
        slider.style.transform = 'translateX(0)';
        track.style.backgroundColor = '#ccc';
        label.textContent = 'Compass';
        label.title = 'Compass projection: angles as sailed, consistent regardless of wind';
      }
      renderMap();
    }

    function fitMapToTrimmedTrack() {
      if (!DATA.track || DATA.track.length < 2) return;
      
      const width = 350, height = 350, padding = 20;
      
      // Get overall map bounds (from original track)
      const trackForBounds = DATA.originalTrack || DATA.track;
      const allLats = trackForBounds.map(p => p.lat);
      const allLons = trackForBounds.map(p => p.lon);
      const minLat = Math.min(...allLats), maxLat = Math.max(...allLats);
      const minLon = Math.min(...allLons), maxLon = Math.max(...allLons);
      const latRange = maxLat - minLat || 0.001;
      const lonRange = maxLon - minLon || 0.001;
      
      // Apply latitude correction only in geo mode
      const centerLat = (minLat + maxLat) / 2;
      const latCorrection = mapProjection === 'geo' ? Math.cos(centerLat * Math.PI / 180) : 1;
      const lonRangeCorrected = lonRange * latCorrection;
      
      const scale = Math.min((width - 2*padding) / lonRangeCorrected, (height - 2*padding) / latRange) * 0.9;
      
      const lonToX = lon => padding + (lon - minLon) * latCorrection * scale + (width - 2*padding - lonRangeCorrected * scale) / 2;
      const latToY = lat => height - padding - (lat - minLat) * scale - (height - 2*padding - latRange * scale) / 2;
      
      // Get trimmed track bounds in SVG coordinates
      const trimXs = DATA.track.map(p => lonToX(p.lon));
      const trimYs = DATA.track.map(p => latToY(p.lat));
      const trimMinX = Math.min(...trimXs), trimMaxX = Math.max(...trimXs);
      const trimMinY = Math.min(...trimYs), trimMaxY = Math.max(...trimYs);
      const trimCenterX = (trimMinX + trimMaxX) / 2;
      const trimCenterY = (trimMinY + trimMaxY) / 2;
      const trimWidth = trimMaxX - trimMinX + 40;
      const trimHeight = trimMaxY - trimMinY + 40;
      
      // Calculate zoom to fit trimmed track with some padding
      mapZoom = Math.min(width / trimWidth, height / trimHeight, 10);
      mapZoom = Math.max(mapZoom, 1); // Don't zoom out beyond 1
      mapPanX = trimCenterX - width / 2;
      mapPanY = trimCenterY - height / 2;
      
      renderMap();
    }

    function zoomToLeg(legId) {
      const leg = DATA.legs.find(l => l.id === legId);
      if (!leg) return;
      
      const points = DATA.track.filter(p => p.t >= leg.start && p.t <= leg.end);
      if (points.length < 2) return;
      
      const width = 350, height = 350, padding = 20;
      
      // Get overall map bounds - MUST match renderMap bounds calculation
      const trackForBounds = DATA.originalTrack || DATA.track;
      const allLats = trackForBounds.map(p => p.lat);
      const allLons = trackForBounds.map(p => p.lon);
      const minLat = Math.min(...allLats), maxLat = Math.max(...allLats);
      const minLon = Math.min(...allLons), maxLon = Math.max(...allLons);
      const latRange = maxLat - minLat || 0.001;
      const lonRange = maxLon - minLon || 0.001;
      
      // Apply latitude correction only in geo mode
      const centerLat = (minLat + maxLat) / 2;
      const latCorrection = mapProjection === 'geo' ? Math.cos(centerLat * Math.PI / 180) : 1;
      const lonRangeCorrected = lonRange * latCorrection;
      
      const scale = Math.min((width - 2*padding) / lonRangeCorrected, (height - 2*padding) / latRange) * 0.9;
      
      const lonToX = lon => padding + (lon - minLon) * latCorrection * scale + (width - 2*padding - lonRangeCorrected * scale) / 2;
      const latToY = lat => height - padding - (lat - minLat) * scale - (height - 2*padding - latRange * scale) / 2;
      
      // Get leg bounds in SVG coordinates
      const legXs = points.map(p => lonToX(p.lon));
      const legYs = points.map(p => latToY(p.lat));
      const legMinX = Math.min(...legXs), legMaxX = Math.max(...legXs);
      const legMinY = Math.min(...legYs), legMaxY = Math.max(...legYs);
      const legCenterX = (legMinX + legMaxX) / 2;
      const legCenterY = (legMinY + legMaxY) / 2;
      const legWidth = legMaxX - legMinX + 40;
      const legHeight = legMaxY - legMinY + 40;
      
      // Calculate zoom to fit leg with some padding
      mapZoom = Math.min(width / legWidth, height / legHeight, 10);
      mapPanX = legCenterX - width / 2;
      mapPanY = legCenterY - height / 2;
      
      renderMap();
    }

    function renderMap() {
      const svg = document.getElementById('map');
      const width = 350, height = 350, padding = 20;

      // === RACE REPLAY MODE ===
      if (raceReplayMode) {
        const sessions = getReplaySessions();
        if (sessions.length === 0) return;
        
        // Calculate bounds from trimmed tracks only (visible legs)
        let allLats = [], allLons = [];
        sessions.forEach(session => {
          // Use trimmed track for bounds
          allLats.push(...session.track.map(p => p.lat));
          allLons.push(...session.track.map(p => p.lon));
        });
        
        const minLat = Math.min(...allLats), maxLat = Math.max(...allLats);
        const minLon = Math.min(...allLons), maxLon = Math.max(...allLons);
        const latRange = maxLat - minLat || 0.001;
        const lonRange = maxLon - minLon || 0.001;
        
        const centerLat = (minLat + maxLat) / 2;
        const latCorrection = mapProjection === 'geo' ? Math.cos(centerLat * Math.PI / 180) : 1;
        const lonRangeCorrected = lonRange * latCorrection;
        
        const scale = Math.min((width - 2*padding) / lonRangeCorrected, (height - 2*padding) / latRange) * 0.9;
        
        const lonToX = lon => padding + (lon - minLon) * latCorrection * scale + (width - 2*padding - lonRangeCorrected * scale) / 2;
        const latToY = lat => height - padding - (lat - minLat) * scale - (height - 2*padding - latRange * scale) / 2;
        const xToLon = x => minLon + (x - padding - (width - 2*padding - lonRangeCorrected * scale) / 2) / (latCorrection * scale);
        const yToLat = y => minLat + (height - padding - y - (height - 2*padding - latRange * scale) / 2) / scale;
        
        // ViewBox for zoom/pan
        const vbWidth = width / mapZoom;
        const vbHeight = height / mapZoom;
        const vbX = (width - vbWidth) / 2 + mapPanX;
        const vbY = (height - vbHeight) / 2 + mapPanY;
        svg.setAttribute('viewBox', `${vbX} ${vbY} ${vbWidth} ${vbHeight}`);
        
        const margin = 0.15;
        const visMinLon = xToLon(vbX - vbWidth * margin);
        const visMaxLon = xToLon(vbX + vbWidth * (1 + margin));
        const visMaxLat = yToLat(vbY - vbHeight * margin);
        const visMinLat = yToLat(vbY + vbHeight * (1 + margin));
        const isVisible = p => p.lon >= visMinLon && p.lon <= visMaxLon && p.lat >= visMinLat && p.lat <= visMaxLat;
        
        const markerScale = 1 / mapZoom;
        
        let html = '';
        
        // Grid
        [0.25, 0.5, 0.75].forEach(f => {
          const y = padding + (height - 2*padding) * f;
          const x = padding + (width - 2*padding) * f;
          html += `<line x1="${padding}" y1="${y}" x2="${width-padding}" y2="${y}" stroke="#e5e7eb" stroke-dasharray="4" vector-effect="non-scaling-stroke"/>`;
          html += `<line x1="${x}" y1="${padding}" x2="${x}" y2="${height-padding}" stroke="#e5e7eb" stroke-dasharray="4" vector-effect="non-scaling-stroke"/>`;
        });
        
        // Draw tracks for each session
        sessions.forEach((session, boatIdx) => {
          const color = BOAT_COLORS[boatIdx % BOAT_COLORS.length];
          const track = session.track;
          const baseStep = Math.max(1, Math.floor(track.length / 400));
          const adaptiveStep = Math.max(1, Math.round(baseStep / mapZoom));
          
          // Calculate playback time relative to this session's track using synchronized time
          const sessionLocalTime = getSessionLocalTime(session, playbackTime);
          const sessionStart = session.timelineStart || 0;
          const trackPlaybackTime = sessionLocalTime - sessionStart;
          
          for (let i = adaptiveStep; i < track.length; i += adaptiveStep) {
            const p0 = track[i - adaptiveStep], p1 = track[i];
            if (!isVisible(p0) && !isVisible(p1)) continue;
            
            // Time-based fading using track-relative time
            // Last 30 min: full opacity, 30-60 min: fade, >60 min: grey
            let opacity = 0.9;
            let strokeColor = color;
            const recentWindow = 15;  // Last 15 min at full opacity
            const fadeWindow = 30;    // Grey out after 30 min
            let isGray = false;
            
            // Only apply fading if we have a valid session local time for this session
            if (sessionLocalTime >= sessionStart && trackPlaybackTime >= 0) {
              const age = trackPlaybackTime - p1.t;
              
              if (p1.t > trackPlaybackTime) {
                // Future track - faded grey
                opacity = 0.15;
                strokeColor = '#9ca3af';
                isGray = true;
              } else if (age <= recentWindow) {
                // Last 30 min - full opacity
                opacity = 0.9;
              } else if (age <= fadeWindow) {
                // 30-60 min - gradient fade
                const fadePct = (age - recentWindow) / (fadeWindow - recentWindow);
                opacity = 0.9 - fadePct * 0.5;  // 0.9 to 0.4
              } else {
                // Older than 60 min - grey
                opacity = 0.2;
                strokeColor = '#9ca3af';
                isGray = true;
              }
            } else if (sessionLocalTime < sessionStart) {
              // Session hasn't started yet - all future
              opacity = 0.15;
              strokeColor = '#9ca3af';
              isGray = true;
            }
            
            // Skip gray tracks if hide mode is enabled
            if (hideGrayTracks && isGray) continue;
            
            html += `<line x1="${lonToX(p0.lon)}" y1="${latToY(p0.lat)}" x2="${lonToX(p1.lon)}" y2="${latToY(p1.lat)}" stroke="${strokeColor}" stroke-width="3" stroke-linecap="round" opacity="${opacity}" vector-effect="non-scaling-stroke"/>`;
          }
        });
        
        // Draw boat markers at current playback position
        // Boat points according to magnetic heading (hdg) when available, falls back to COG
        if (playbackTime > 0) {
          sessions.forEach((session, boatIdx) => {
            const pos = getBoatPositionAtTime(session, playbackTime);
            if (!pos) return;
            
            const x = lonToX(pos.lon);
            const y = latToY(pos.lat);
            const color = BOAT_COLORS[boatIdx % BOAT_COLORS.length];
            const size = 16 * markerScale;
            
            // Draw boat shape - hull silhouette
            // Use magnetic heading (pos.hdg) for boat orientation
            // Heading: 0¬∞=North(up), 90¬∞=East(right), 180¬∞=South(down), 270¬∞=West(left)
            const hdgRad = pos.hdg * Math.PI / 180;
            const cosH = Math.cos(hdgRad);
            const sinH = Math.sin(hdgRad);
            
            // Rotate helper: dx=sideways(+starboard), dy=forward(+bow)
            const rot = (dx, dy) => ({
              x: x + dx * cosH + dy * sinH,
              y: y + dx * sinH - dy * cosH
            });
            
            // Hull shape (wide with pointed bow)
            const bow = rot(0, size * 0.9);           // Front tip
            const sternL = rot(-size * 0.4, -size * 0.5);  // Back left
            const sternR = rot(size * 0.4, -size * 0.5);   // Back right
            const midL = rot(-size * 0.45, size * 0.1);    // Mid left (widest)
            const midR = rot(size * 0.45, size * 0.1);     // Mid right (widest)
            
            // Hull path
            html += `<path d="M${bow.x},${bow.y} Q${midR.x},${midR.y} ${sternR.x},${sternR.y} L${sternL.x},${sternL.y} Q${midL.x},${midL.y} ${bow.x},${bow.y}" fill="${color}" stroke="white" stroke-width="${1.5 * markerScale}" stroke-linejoin="round"/>`;
            
            // Boat number badge
            const badgePos = rot(0, -size * 0.85);
            html += `<circle cx="${badgePos.x}" cy="${badgePos.y}" r="${7 * markerScale}" fill="white" stroke="${color}" stroke-width="${1.5 * markerScale}"/>`;
            html += `<text x="${badgePos.x}" y="${badgePos.y + 3 * markerScale}" text-anchor="middle" font-size="${9 * markerScale}" fill="${color}" font-weight="bold">${boatIdx + 1}</text>`;
          });
        }
        
        svg.innerHTML = html;
        
        // Draw distance line between boats (after svg content is set, using overlay)
        // Calculate distances between boats
        const boatPositions = sessions.map((session, i) => ({
          pos: getBoatPositionAtTime(session, playbackTime),
          color: BOAT_COLORS[i % BOAT_COLORS.length],
          symbol: getBoatSymbol(session.filename),
          idx: i
        })).filter(b => b.pos);
        
        // Draw sailing route between first two boats
        if (boatPositions.length >= 2 && playbackTime > 0) {
          const b1 = boatPositions[0];
          const b2 = boatPositions[1];
          
          // Get sailing route calculation
          const route = calculateSailingRoute(b1.pos, b2.pos, sessions);
          
          if (route && route.waypoints.length >= 2) {
            // Draw the sailing route path
            let pathD = '';
            route.waypoints.forEach((wp, i) => {
              const x = lonToX(wp.lon);
              const y = latToY(wp.lat);
              pathD += (i === 0 ? 'M' : 'L') + `${x},${y}`;
            });
            
            const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            pathEl.setAttribute('d', pathD);
            pathEl.setAttribute('stroke', '#f59e0b');
            pathEl.setAttribute('stroke-width', 2 * markerScale);
            pathEl.setAttribute('stroke-dasharray', `${6 * markerScale},${4 * markerScale}`);
            pathEl.setAttribute('fill', 'none');
            pathEl.setAttribute('opacity', '0.8');
            svg.appendChild(pathEl);
            
            // Draw tack/gybe point marker if exists
            if (route.waypoints.length === 3) {
              const tackPt = route.waypoints[1];
              const tx = lonToX(tackPt.lon);
              const ty = latToY(tackPt.lat);
              
              // Small diamond marker at tack point
              const size = 4 * markerScale;
              const diamond = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              diamond.setAttribute('d', `M${tx},${ty-size} L${tx+size},${ty} L${tx},${ty+size} L${tx-size},${ty} Z`);
              diamond.setAttribute('fill', '#f59e0b');
              diamond.setAttribute('stroke', 'white');
              diamond.setAttribute('stroke-width', 1 * markerScale);
              svg.appendChild(diamond);
            }
            
            // Add distance/time label offset to the side of the route
            // Calculate perpendicular offset from the line between boats
            const x1 = lonToX(route.waypoints[0].lon);
            const y1 = latToY(route.waypoints[0].lat);
            const x2 = lonToX(route.waypoints[route.waypoints.length - 1].lon);
            const y2 = latToY(route.waypoints[route.waypoints.length - 1].lat);
            
            // Midpoint of direct line
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            
            // Perpendicular direction (rotate 90 degrees)
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.sqrt(dx * dx + dy * dy);
            const perpX = len > 0 ? -dy / len : 0;
            const perpY = len > 0 ? dx / len : -1;
            
            // Offset distance (away from boats)
            const offsetDist = 45 * markerScale;
            const labelX = midX + perpX * offsetDist;
            const labelY = midY + perpY * offsetDist;
            
            const formatDist = (m) => m >= 1000 ? `${(m/1000).toFixed(1)}km` : `${Math.round(m)}m`;
            const formatTime = (sec) => {
              if (sec > 3600) return '>1h';
              if (sec > 600) return `${Math.round(sec/60)}m`;
              if (sec >= 60) return `${Math.floor(sec/60)}:${String(Math.round(sec%60)).padStart(2,'0')}`;
              return `${Math.round(sec)}s`;
            };
            
            // Apply 10-second rolling window to sailing time
            const smoothedTime = getSmoothedSailingTime(route.time);
            
            const distStr = `${formatDist(route.directDist)}/${formatDist(route.sailDist)}`;
            const labelStr = `${distStr} ${formatTime(smoothedTime)}`;
            
            // Background for label
            const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            const labelWidth = 100 * markerScale;
            const labelHeight = 14 * markerScale;
            labelBg.setAttribute('x', labelX - labelWidth/2);
            labelBg.setAttribute('y', labelY - labelHeight/2);
            labelBg.setAttribute('width', labelWidth);
            labelBg.setAttribute('height', labelHeight);
            labelBg.setAttribute('rx', 3 * markerScale);
            labelBg.setAttribute('fill', 'rgba(0,0,0,0.7)');
            svg.appendChild(labelBg);
            
            // Distance/time text
            const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            labelText.setAttribute('x', labelX);
            labelText.setAttribute('y', labelY + 3 * markerScale);
            labelText.setAttribute('text-anchor', 'middle');
            labelText.setAttribute('font-size', 10 * markerScale);
            labelText.setAttribute('fill', '#f59e0b');
            labelText.setAttribute('font-weight', 'bold');
            labelText.textContent = labelStr;
            svg.appendChild(labelText);
          }
        }
        
        // Render boat legend with live data (2-sec smoothed) plus leg info
        let legendHtml = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;"><span style="font-size:10px;color:#6b7280;">Boats:</span><button onclick="saveMapScreenshot()" style="font-size:9px;padding:2px 6px;background:#3b82f6;color:white;border:none;border-radius:3px;cursor:pointer;" title="Save map view">üì∑ Save</button></div>';
        sessions.forEach((session, boatIdx) => {
          const color = BOAT_COLORS[boatIdx % BOAT_COLORS.length];
          const boatSymbol = getBoatSymbol(session.filename);
          const smoothed = getSmoothedTelemetry(session, playbackTime, 2);
          const leg = getCurrentLegAtTime(session, playbackTime);
          
          let dataHtml = '';
          if (smoothed) {
            const sogVmg = `${(smoothed.sog || 0).toFixed(1)}/${(smoothed.vmg || 0).toFixed(1)}`;
            const hdg = `${Math.round(smoothed.hdg || 0)}¬∞`;
            dataHtml = `<span style="font-size:11px;color:#6b7280;">${sogVmg} ${hdg}</span>`;
          } else {
            dataHtml = `<span style="font-size:11px;color:#9ca3af;">‚Äî</span>`;
          }
          
          // Leg info: next maneuver
          let legHtml = '';
          if (leg) {
            const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };
            const posColor = posColors[leg.pos] || '#6b7280';
            const posLabel = leg.pos === 'upwind' ? 'Up' : leg.pos === 'downwind' ? 'Dn' : 'Reach';
            const legSpd = leg.avg_speed ? leg.avg_speed.toFixed(1) : '-';
            const legVmg = leg.avg_vmg ? leg.avg_vmg.toFixed(1) : '-';
            const legHdg = leg.avg_hdg ? Math.round(leg.avg_hdg) + '¬∞' : '-';
            
            let nextManeuver = '';
            if (leg.next_maneuver) {
              const type = leg.next_maneuver.type === 'tack' ? 'T' : 'G';
              const angle = leg.next_maneuver.angle ? Math.round(leg.next_maneuver.angle) + '¬∞' : '-';
              const mColor = leg.next_maneuver.type === 'tack' ? '#22c55e' : '#f59e0b';
              nextManeuver = `<span style="color:${mColor};font-weight:500;">${type}${angle}</span>`;
            }
            
            legHtml = `<span style="font-size:10px;color:${posColor};font-weight:500;">${posLabel}</span> <span style="font-size:10px;color:#9ca3af;">${legSpd}/${legVmg} ${legHdg}</span> ${nextManeuver}`;
          }
          
          legendHtml += `
            <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
              <div style="width:18px;height:18px;background:${color};border-radius:50%;display:flex;align-items:center;justify-content:center;color:white;font-size:11px;font-weight:bold;">${boatIdx+1}</div>
              <div style="display:flex;flex-direction:column;line-height:1.2;">
                <span style="font-weight:600;font-size:12px;">${boatSymbol}</span>
                ${dataHtml}
                ${legHtml ? `<div style="margin-top:1px;">${legHtml}</div>` : ''}
              </div>
            </div>`;
        });
        
        document.getElementById('map-legend').innerHTML = legendHtml;
        
        // Wind indicator (use first session's wind)
        const windDeg = sessions[0].s.twd;
        document.getElementById('map-wind').innerHTML = `
          <div style="font-size:9px;color:#666;margin-bottom:2px;">Wind ${windDeg}¬∞</div>
          <svg width="40" height="40" viewBox="0 0 40 40">
            <g transform="rotate(${windDeg}, 20, 20)">
              <line x1="20" y1="8" x2="20" y2="32" stroke="#666" stroke-width="2"/>
              <polygon points="20,32 15,24 25,24" fill="#666"/>
            </g>
          </svg>
        `;
        
        document.getElementById('map-zoom-indicator').textContent = mapZoom !== 1 ? `${mapZoom.toFixed(1)}x` : '';
        
        // No leg click handlers in race replay mode
        return;
      }
      
      // === NORMAL MODE ===
      // Use original track for bounds calculation if available
      const trackForBounds = DATA.originalTrack || DATA.track;
      
      // Calculate bounds
      const lats = trackForBounds.map(p => p.lat);
      const lons = trackForBounds.map(p => p.lon);
      const minLat = Math.min(...lats), maxLat = Math.max(...lats);
      const minLon = Math.min(...lons), maxLon = Math.max(...lons);
      const latRange = maxLat - minLat || 0.001;
      const lonRange = maxLon - minLon || 0.001;
      
      // Apply latitude correction only in geo mode
      // Compass mode: angles appear as true compass values (consistent regardless of wind)
      // Geo mode: geographically accurate, but angles vary with wind direction
      const centerLat = (minLat + maxLat) / 2;
      const latCorrection = mapProjection === 'geo' ? Math.cos(centerLat * Math.PI / 180) : 1;
      const lonRangeCorrected = lonRange * latCorrection;
      
      const scale = Math.min((width - 2*padding) / lonRangeCorrected, (height - 2*padding) / latRange) * 0.9;

      const lonToX = lon => padding + (lon - minLon) * latCorrection * scale + (width - 2*padding - lonRangeCorrected * scale) / 2;
      const latToY = lat => height - padding - (lat - minLat) * scale - (height - 2*padding - latRange * scale) / 2;
      const xToLon = x => minLon + (x - padding - (width - 2*padding - lonRangeCorrected * scale) / 2) / (latCorrection * scale);
      const yToLat = y => minLat + (height - padding - y - (height - 2*padding - latRange * scale) / 2) / scale;

      // Store for later use
      DATA._mapTransform = { lonToX, latToY };

      // Calculate viewBox for zoom/pan
      const vbWidth = width / mapZoom;
      const vbHeight = height / mapZoom;
      const vbX = (width - vbWidth) / 2 + mapPanX;
      const vbY = (height - vbHeight) / 2 + mapPanY;
      svg.setAttribute('viewBox', `${vbX} ${vbY} ${vbWidth} ${vbHeight}`);

      // Calculate visible lat/lon bounds (with margin)
      const margin = 0.15;
      const visMinLon = xToLon(vbX - vbWidth * margin);
      const visMaxLon = xToLon(vbX + vbWidth * (1 + margin));
      const visMaxLat = yToLat(vbY - vbHeight * margin);
      const visMinLat = yToLat(vbY + vbHeight * (1 + margin));

      // Helper: check if point is in visible area
      const isVisible = p => p.lon >= visMinLon && p.lon <= visMaxLon && p.lat >= visMinLat && p.lat <= visMaxLat;

      // Adaptive step: show more detail when zoomed in
      // At zoom 1x: step to get ~400 visible lines
      // At zoom 30x: step=1 (full resolution)
      const baseStep = Math.max(1, Math.floor(DATA.track.length / 400));
      const adaptiveStep = Math.max(1, Math.round(baseStep / mapZoom));

      const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };

      // Build SVG
      let html = '';
      
      // Grid
      [0.25, 0.5, 0.75].forEach(f => {
        const y = padding + (height - 2*padding) * f;
        const x = padding + (width - 2*padding) * f;
        html += `<line x1="${padding}" y1="${y}" x2="${width-padding}" y2="${y}" stroke="#e5e7eb" stroke-dasharray="4" vector-effect="non-scaling-stroke"/>`;
        html += `<line x1="${x}" y1="${padding}" x2="${x}" y2="${height-padding}" stroke="#e5e7eb" stroke-dasharray="4" vector-effect="non-scaling-stroke"/>`;
      });

      // Get timeline filter info
      const fullDuration = DATA.fullDuration || DATA.s.dur;
      const timelineStart = DATA.timelineStart || 0;
      const timelineEnd = DATA.timelineEnd || fullDuration;
      const hasFilter = timelineStart > 0.1 || timelineEnd < fullDuration - 0.1;

      // Draw excluded (grey) portions of track if filter is active
      if (hasFilter && DATA.originalTrack) {
        for (let i = adaptiveStep; i < DATA.originalTrack.length; i += adaptiveStep) {
          const p0 = DATA.originalTrack[i - adaptiveStep], p1 = DATA.originalTrack[i];
          // Skip if neither point visible
          if (!isVisible(p0) && !isVisible(p1)) continue;
          const inExcluded = p0.t < timelineStart || p0.t > timelineEnd || p1.t < timelineStart || p1.t > timelineEnd;
          if (inExcluded) {
            html += `<line x1="${lonToX(p0.lon)}" y1="${latToY(p0.lat)}" x2="${lonToX(p1.lon)}" y2="${latToY(p1.lat)}" stroke="#9ca3af" stroke-width="3" stroke-linecap="round" opacity="0.5" vector-effect="non-scaling-stroke"/>`;
          }
        }
      }

      // Base track (included portion) with viewport culling and adaptive step
      for (let i = adaptiveStep; i < DATA.track.length; i += adaptiveStep) {
        const p0 = DATA.track[i - adaptiveStep], p1 = DATA.track[i];
        if (!isVisible(p0) && !isVisible(p1)) continue;
        html += `<line x1="${lonToX(p0.lon)}" y1="${latToY(p0.lat)}" x2="${lonToX(p1.lon)}" y2="${latToY(p1.lat)}" stroke="#d1d5db" stroke-width="2" stroke-linecap="round" vector-effect="non-scaling-stroke"/>`;
      }

      // Leg segments with viewport culling
      DATA.legs.forEach(leg => {
        const isSelected = selectedLeg?.id === leg.id;
        const color = isSelected ? '#a855f7' : posColors[leg.pos];
        const strokeWidth = isSelected ? 6 : 4;

        // Get points for this leg with adaptive step
        let prevPoint = null;
        let legHasVisiblePoints = false;
        
        for (let i = 0; i < DATA.track.length; i += adaptiveStep) {
          const p = DATA.track[i];
          if (p.t < leg.start || p.t > leg.end) {
            prevPoint = null;
            continue;
          }
          
          if (prevPoint) {
            const visible = isVisible(p) || isVisible(prevPoint);
            if (visible) {
              legHasVisiblePoints = true;
              // Glow for selected
              if (isSelected) {
                html += `<line x1="${lonToX(prevPoint.lon)}" y1="${latToY(prevPoint.lat)}" x2="${lonToX(p.lon)}" y2="${latToY(p.lat)}" stroke="#c084fc" stroke-width="12" stroke-linecap="round" opacity="0.4" vector-effect="non-scaling-stroke"/>`;
              }
              html += `<line x1="${lonToX(prevPoint.lon)}" y1="${latToY(prevPoint.lat)}" x2="${lonToX(p.lon)}" y2="${latToY(p.lat)}" stroke="${color}" stroke-width="${strokeWidth}" stroke-linecap="round" class="leg-segment" data-leg="${leg.id}" style="cursor:pointer" vector-effect="non-scaling-stroke"/>`;
            }
          }
          prevPoint = p;
        }
        
        // Add hit area for leg (one transparent path for click detection)
        if (legHasVisiblePoints) {
          const legPoints = DATA.track.filter(p => p.t >= leg.start && p.t <= leg.end);
          if (legPoints.length >= 2) {
            const pathD = 'M' + legPoints.filter((_, i) => i % adaptiveStep === 0 || i === legPoints.length - 1)
              .map(p => `${lonToX(p.lon)} ${latToY(p.lat)}`).join('L');
            html += `<path d="${pathD}" fill="none" stroke="transparent" stroke-width="15" class="leg-hit" data-leg="${leg.id}" style="cursor:pointer" vector-effect="non-scaling-stroke"/>`;
          }
        }
      });

      // Render outside-trim selected leg from originalTrack
      if (selectedLeg?.isOutsideTrim && DATA.originalTrack) {
        const timeOffset = DATA.timelineStart || 0;
        const legStartTime = selectedLeg.start + timeOffset;
        const legEndTime = selectedLeg.end + timeOffset;
        
        let prevPoint = null;
        for (let i = 0; i < DATA.originalTrack.length; i += adaptiveStep) {
          const p = DATA.originalTrack[i];
          if (p.t < legStartTime || p.t > legEndTime) {
            prevPoint = null;
            continue;
          }
          
          if (prevPoint && (isVisible(p) || isVisible(prevPoint))) {
            // Glow
            html += `<line x1="${lonToX(prevPoint.lon)}" y1="${latToY(prevPoint.lat)}" x2="${lonToX(p.lon)}" y2="${latToY(p.lat)}" stroke="#c084fc" stroke-width="12" stroke-linecap="round" opacity="0.4" vector-effect="non-scaling-stroke"/>`;
            // Line
            html += `<line x1="${lonToX(prevPoint.lon)}" y1="${latToY(prevPoint.lat)}" x2="${lonToX(p.lon)}" y2="${latToY(p.lat)}" stroke="#a855f7" stroke-width="6" stroke-linecap="round" vector-effect="non-scaling-stroke"/>`;
          }
          prevPoint = p;
        }
      }

      // Start/End markers - scale radius inversely with zoom to keep consistent size
      const markerScale = 1 / mapZoom;
      if (selectedLeg) {
        html += `<circle cx="${lonToX(selectedLeg.startLon)}" cy="${latToY(selectedLeg.startLat)}" r="${8 * markerScale}" fill="#22c55e" stroke="white" stroke-width="${3 * markerScale}"/>`;
        html += `<text x="${lonToX(selectedLeg.startLon)}" y="${latToY(selectedLeg.startLat) + 4 * markerScale}" text-anchor="middle" font-size="${10 * markerScale}" fill="white" font-weight="bold">S</text>`;
        html += `<circle cx="${lonToX(selectedLeg.endLon)}" cy="${latToY(selectedLeg.endLat)}" r="${8 * markerScale}" fill="#ef4444" stroke="white" stroke-width="${3 * markerScale}"/>`;
        html += `<text x="${lonToX(selectedLeg.endLon)}" y="${latToY(selectedLeg.endLat) + 4 * markerScale}" text-anchor="middle" font-size="${10 * markerScale}" fill="white" font-weight="bold">E</text>`;
      } else {
        html += `<circle cx="${lonToX(DATA.track[0].lon)}" cy="${latToY(DATA.track[0].lat)}" r="${5 * markerScale}" fill="#22c55e" stroke="white" stroke-width="${2 * markerScale}"/>`;
        html += `<circle cx="${lonToX(DATA.track[DATA.track.length-1].lon)}" cy="${latToY(DATA.track[DATA.track.length-1].lat)}" r="${5 * markerScale}" fill="#ef4444" stroke="white" stroke-width="${2 * markerScale}"/>`;
      }

      svg.innerHTML = html;

      // Render legend in HTML overlay (not affected by zoom)
      let legendHtml = `
        <div style="display:flex;align-items:center;gap:4px;margin-bottom:4px;"><div style="width:10px;height:10px;background:#22c55e;border-radius:2px;"></div><span>Up</span></div>
        <div style="display:flex;align-items:center;gap:4px;margin-bottom:4px;"><div style="width:10px;height:10px;background:#3b82f6;border-radius:2px;"></div><span>Reach</span></div>
        <div style="display:flex;align-items:center;gap:4px;margin-bottom:4px;"><div style="width:10px;height:10px;background:#f59e0b;border-radius:2px;"></div><span>Down</span></div>
      `;
      if (selectedLeg) {
        legendHtml += `<div style="display:flex;align-items:center;gap:4px;"><div style="width:10px;height:10px;background:#a855f7;border-radius:2px;"></div><span>Leg #${selectedLeg.id}</span></div>`;
      }
      document.getElementById('map-legend').innerHTML = legendHtml;

      // Render wind indicator in HTML overlay
      const windHtml = `
        <div style="font-size:9px;color:#666;margin-bottom:2px;">Wind ${DATA.s.twd}¬∞</div>
        <svg width="50" height="50" style="display:block;">
          <line x1="25" y1="10" x2="25" y2="40" stroke="#666" stroke-width="2"/>
          <polygon points="25,40 20,32 30,32" fill="#666"/>
          <text x="25" y="48" text-anchor="middle" font-size="8" fill="#666">‚Üì</text>
        </svg>
      `;
      // Create rotated wind arrow - points in direction wind is GOING TO
      // TWD = where wind comes FROM, so wind goes to (TWD + 180)¬∞
      // Base SVG arrow points down (south=180¬∞). SVG rotate is clockwise.
      // To point at compass direction D: rotate = (D + 180) % 360
      // To point where wind goes: rotate = ((TWD+180) + 180) % 360 = TWD
      const windDeg = DATA.s.twd;
      document.getElementById('map-wind').innerHTML = `
        <div style="font-size:9px;color:#666;margin-bottom:2px;">Wind ${DATA.s.twd}¬∞</div>
        <svg width="40" height="40" viewBox="0 0 40 40">
          <g transform="rotate(${windDeg}, 20, 20)">
            <line x1="20" y1="8" x2="20" y2="32" stroke="#666" stroke-width="2"/>
            <polygon points="20,32 15,24 25,24" fill="#666"/>
          </g>
        </svg>
      `;

      // Zoom indicator
      document.getElementById('map-zoom-indicator').textContent = mapZoom !== 1 ? `${mapZoom.toFixed(1)}x` : '';

      // Add event listeners for leg selection (these need to be re-added since elements are recreated)
      svg.querySelectorAll('.leg-hit').forEach(el => {
        el.addEventListener('click', () => {
          const legId = parseInt(el.dataset.leg);
          selectLeg(DATA.legs.find(l => l.id === legId));
        });
      });
    }

    // Set up map zoom/pan listeners once (not inside renderMap)
    let mapListenersInitialized = false;
    let mapRenderPending = false;
    
    function requestMapRender() {
      if (mapRenderPending) return;
      mapRenderPending = true;
      requestAnimationFrame(() => {
        renderMap();
        mapRenderPending = false;
      });
    }
    
    function initMapListeners() {
      if (mapListenersInitialized) return;
      mapListenersInitialized = true;
      
      const svg = document.getElementById('map');
      
      svg.addEventListener('wheel', (e) => {
        if (!DATA) return;
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        mapZoom = Math.max(0.5, Math.min(30, mapZoom * factor));
        requestMapRender();
      }, { passive: false });

      svg.addEventListener('mousedown', (e) => {
        if (!DATA) return;
        if (e.target.classList.contains('leg-hit') || e.target.classList.contains('leg-segment')) return;
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        svg.style.cursor = 'grabbing';
      });

      svg.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const dx = (e.clientX - dragStartX) / mapZoom;
        const dy = (e.clientY - dragStartY) / mapZoom;
        mapPanX -= dx;
        mapPanY -= dy;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        requestMapRender();
      });

      svg.addEventListener('mouseup', () => {
        isDragging = false;
        svg.style.cursor = 'grab';
      });

      svg.addEventListener('mouseleave', () => {
        isDragging = false;
        svg.style.cursor = 'grab';
      });
    }

    // Initialize map listeners on page load
    initMapListeners();

    function renderLegsTable() {
      const filter = document.getElementById('pos-filter').value;
      let legs = DATA.legs;
      if (filter !== 'all') legs = legs.filter(l => l.pos === filter);

      const tacks = legs.filter(l => l.next_maneuver?.type === 'tack').length;
      const gybes = legs.filter(l => l.next_maneuver?.type === 'gybe').length;
      document.getElementById('legs-summary').textContent = `${legs.length} legs | ${tacks} tacks | ${gybes} gybes`;

      const bestCorr = Math.min(...legs.map(l => l.corridor));
      document.getElementById('best-corridor').textContent = `¬±${bestCorr.toFixed(1)}¬∞`;
      document.getElementById('best-corridor').style.color = getCorridorColor(bestCorr);

      const isGarmin = DATA.dataSource === 'garmin';
      const posNames = { upwind: 'Up', reaching: 'Reach', downwind: 'Down' };
      
      // Update table headers based on data source
      const thead = document.querySelector('#legs-table thead tr');
      thead.innerHTML = `
        <th>#</th>
        <th>POS</th>
        <th style="text-align: right;">Dur</th>
        <th style="text-align: right;">Rate</th>
        <th style="text-align: right;">COG</th>
        <th style="text-align: right;">Dev</th>
        ${!isGarmin ? '<th style="text-align: right;">MAG70/90</th>' : ''}
        ${!isGarmin ? '<th style="text-align: right;">Heel</th>' : ''}
        <th style="text-align: right;">Spd/VMG</th>
        <th>Next</th>
      `;
      
      const tbody = document.getElementById('legs-tbody');
      tbody.innerHTML = legs.map(leg => {
        const isSelected = selectedLeg?.id === leg.id;
        const badgeClass = `badge badge-${leg.pos === 'upwind' ? 'up' : leg.pos === 'reaching' ? 'reach' : 'down'}`;
        let nextHtml = '';
        if (leg.next_maneuver) {
          const mc = leg.next_maneuver.type === 'tack' ? 'badge-tack' : 'badge-gybe';
          nextHtml = `<span class="badge ${mc}">${leg.next_maneuver.type === 'tack' ? 'T' : 'G'}${leg.next_maneuver.angle}¬∞</span>`;
        }
        const devPct = (leg.lineDeviation * 100).toFixed(1);
        const lostM = Math.round(leg.lostMeters);
        return `<tr class="${isSelected ? 'selected' : ''}" data-leg="${leg.id}">
          <td>${leg.id}</td>
          <td><span class="${badgeClass}">${posNames[leg.pos]}</span></td>
          <td style="text-align:right">${leg.dur}s</td>
          <td style="text-align:right;color:${getRateColor(leg.rate)}">${leg.rate.toFixed(2)}</td>
          <td style="text-align:right;color:${getCorridorColor(leg.corridor)}">¬±${leg.corridor.toFixed(1)}¬∞</td>
          <td style="text-align:right;color:${getLineDeviationColor(devPct)}">${devPct}% (${lostM}m)</td>
          ${!isGarmin ? `<td style="text-align:right;color:${getCorridorColor(leg.mag70)}">${leg.mag70.toFixed(1)}¬∞/${leg.mag_corridor.toFixed(1)}¬∞</td>` : ''}
          ${!isGarmin ? `<td style="text-align:right">${leg.heel}¬∞</td>` : ''}
          <td style="text-align:right">${leg.speed}/${leg.vmg}</td>
          <td>${nextHtml}</td>
        </tr>`;
      }).join('');

      tbody.querySelectorAll('tr').forEach(row => {
        row.addEventListener('click', () => {
          const legId = parseInt(row.dataset.leg);
          selectLeg(DATA.legs.find(l => l.id === legId));
        });
      });
    }

    let legRateChart = null;
    let legCogChart = null;
    let legMagChart = null;
    let legHeelChart = null;
    let legSpeedVmgChart = null;

    function renderLegDetail(leg) {
      // Destroy old charts
      if (legRateChart) { legRateChart.destroy(); legRateChart = null; }
      if (legCogChart) { legCogChart.destroy(); legCogChart = null; }
      if (legMagChart) { legMagChart.destroy(); legMagChart = null; }
      if (legHeelChart) { legHeelChart.destroy(); legHeelChart = null; }
      if (legSpeedVmgChart) { legSpeedVmgChart.destroy(); legSpeedVmgChart = null; }

      if (!leg) {
        document.getElementById('leg-detail').innerHTML = '<div style="color:#6b7280;text-align:center;padding:40px;">Select a leg to view details</div>';
        return;
      }

      const isGarmin = DATA.dataSource === 'garmin';
      const posNames = { upwind: 'Upwind', reaching: 'Reaching', downwind: 'Downwind' };
      let maneuverHtml = '';
      if (leg.next_maneuver) {
        const mc = leg.next_maneuver.type === 'tack' ? 'maneuver-tack' : 'maneuver-gybe';
        maneuverHtml = `<div class="maneuver-banner ${mc}">Next: ${leg.next_maneuver.type.toUpperCase()} ${leg.next_maneuver.angle}¬∞</div>`;
      }

      // Build stats grid - different for Garmin (no heel, no MAG)
      const statsRow2 = isGarmin ? `
          <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-top:8px;">
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">COG Corridor</div>
              <div style="font-weight:bold;color:${getCorridorColor(leg.corridor)}">¬±${leg.corridor.toFixed(1)}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Line Deviation</div>
              <div style="font-weight:bold;color:${getLineDeviationColor(leg.lineDeviation * 100)}">${(leg.lineDeviation * 100).toFixed(1)}% (${Math.round(leg.lostMeters)}m)</div>
            </div>
          </div>
      ` : `
          <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:8px;">
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Heel</div>
              <div style="font-weight:bold;">${leg.heel}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">COG Corridor</div>
              <div style="font-weight:bold;color:${getCorridorColor(leg.corridor)}">¬±${leg.corridor.toFixed(1)}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Line Deviation</div>
              <div style="font-weight:bold;color:${getLineDeviationColor(leg.lineDeviation * 100)}">${(leg.lineDeviation * 100).toFixed(1)}% (${Math.round(leg.lostMeters)}m)</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">MAG 70/90</div>
              <div style="font-weight:bold;color:${getCorridorColor(leg.mag70)}">${leg.mag70.toFixed(1)}¬∞ / ${leg.mag_corridor.toFixed(1)}¬∞</div>
            </div>
          </div>
      `;

      // Build charts section - different for Garmin (no MAG chart, no Heel chart)
      const chartsHtml = isGarmin ? `
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Steering Rate</span>
            <span class="text-xs" style="color:#9ca3af;">0-10 ¬∞/s | <span style="color:#22c55e;">‚îÅ</span> 1.5 <span style="color:#3b82f6;">‚îÅ</span> 3</span>
          </div>
          <div style="height:100px;"><canvas id="leg-rate-chart"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">COG Deviation from ${leg.hdg}¬∞</span>
            <span class="text-xs" style="color:#9ca3af;">‚Ü∂ Port | Stbd ‚Ü∑ | <span style="color:#22c55e;">‚îÅ</span> ¬±5¬∞ <span style="color:#f59e0b;">‚îÅ</span> ¬±10¬∞</span>
          </div>
          <div style="height:100px;"><canvas id="leg-cog-chart"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Speed / VMG</span>
            <span class="text-xs" style="color:#9ca3af;"><span style="color:#3b82f6;">‚îÅ</span> Spd <span style="color:#22c55e;">‚îÅ</span> VMG | <span style="color:#ef4444;background:#fecaca;padding:0 3px;border-radius:2px;">!</span> Spd‚Üë VMG‚Üì</span>
          </div>
          <div style="height:100px;"><canvas id="leg-speed-vmg-chart"></canvas></div>
        </div>
      ` : `
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Steering Rate</span>
            <span class="text-xs" style="color:#9ca3af;">0-10 ¬∞/s | <span style="color:#22c55e;">‚îÅ</span> 1.5 <span style="color:#3b82f6;">‚îÅ</span> 3</span>
          </div>
          <div style="height:100px;"><canvas id="leg-rate-chart"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">COG Deviation from ${leg.hdg}¬∞</span>
            <span class="text-xs" style="color:#9ca3af;">‚Ü∂ Port | Stbd ‚Ü∑ | <span style="color:#22c55e;">‚îÅ</span> ¬±5¬∞ <span style="color:#f59e0b;">‚îÅ</span> ¬±10¬∞</span>
          </div>
          <div style="height:100px;"><canvas id="leg-cog-chart"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Mag Heading Deviation from ${leg.hdg}¬∞</span>
            <span class="text-xs" style="color:#9ca3af;">‚Ü∂ Port | Stbd ‚Ü∑ | <span style="color:#22c55e;">‚îÅ</span> ¬±5¬∞ <span style="color:#f59e0b;">‚îÅ</span> ¬±10¬∞</span>
          </div>
          <div style="height:100px;"><canvas id="leg-mag-chart"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Heel Angle</span>
            <span class="text-xs" style="color:#9ca3af;">‚Ü∂ Port | Stbd ‚Ü∑ | <span style="color:#22c55e;">‚îÅ</span> ¬±10¬∞ <span style="color:#f59e0b;">‚îÅ</span> ¬±15¬∞</span>
          </div>
          <div style="height:100px;"><canvas id="leg-heel-chart"></canvas></div>
        </div>
        
        <div style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span class="text-sm" style="font-weight:500;color:#4b5563;">Speed / VMG</span>
            <span class="text-xs" style="color:#9ca3af;"><span style="color:#3b82f6;">‚îÅ</span> Spd <span style="color:#22c55e;">‚îÅ</span> VMG | <span style="color:#ef4444;background:#fecaca;padding:0 3px;border-radius:2px;">!</span> Spd‚Üë VMG‚Üì</span>
          </div>
          <div style="height:100px;"><canvas id="leg-speed-vmg-chart"></canvas></div>
        </div>
      `;

      document.getElementById('leg-detail').innerHTML = `
        <div class="detail-box">
          <div class="detail-header">
            <span class="detail-title">Leg #${leg.id}: ${posNames[leg.pos]}</span>
            <div style="display:flex;align-items:center;gap:8px;">
              <span class="text-sm text-purple">${leg.start.toFixed(1)} - ${leg.end.toFixed(1)} min (${leg.dur}s)</span>
              <button class="zoom-btn" onclick="zoomToLeg(${leg.id})" title="Zoom to leg on map">üîç</button>
            </div>
          </div>
          <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;">
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Wind</div>
              <div style="font-weight:bold;">${leg.localWind || DATA.s.twd}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">TWA</div>
              <div style="font-weight:bold;">${leg.twa}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Leg Hdg</div>
              <div style="font-weight:bold;">${leg.hdg}¬∞</div>
            </div>
            <div style="background:white;border-radius:6px;padding:8px;text-align:center;">
              <div class="text-xs" style="color:#6b7280;">Spd/VMG</div>
              <div style="font-weight:bold;">${leg.speed}/${leg.vmg}</div>
            </div>
          </div>
          ${statsRow2}
          ${maneuverHtml}
        </div>
        ${chartsHtml}
      `;

      // Render charts if we have timeseries data
      if (leg.ts && leg.ts.length > 0) {
        const labels = leg.ts.map(p => p.t.toFixed(1));
        
        // Steering Rate Chart
        const rateCtx = document.getElementById('leg-rate-chart').getContext('2d');
        legRateChart = new Chart(rateCtx, {
          type: 'line',
          data: {
            labels,
            datasets: [{
              data: leg.ts.map(p => p.rate),
              borderColor: '#ef4444',
              backgroundColor: 'rgba(239, 68, 68, 0.1)',
              borderWidth: 2,
              pointRadius: 0,
              tension: 0.3,
              fill: true
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { 
              legend: { display: false },
              annotation: {
                annotations: {
                  line1: { type: 'line', yMin: 1.5, yMax: 1.5, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                  line2: { type: 'line', yMin: 3, yMax: 3, borderColor: '#3b82f6', borderDash: [5,5], borderWidth: 1 }
                }
              }
            },
            scales: {
              x: { 
                display: true,
                ticks: { font: { size: 9 }, maxTicksLimit: 6, callback: v => labels[v] + 'm' }
              },
              y: { 
                display: false,
                min: 0, 
                max: 10
              }
            }
          }
        });

        // Calculate deviation range - round up to nearest 5
        const allDevs = [...leg.ts.map(p => p.dev), ...leg.ts.map(p => p.mdev)];
        const rawMax = Math.max(Math.abs(Math.min(...allDevs)), Math.abs(Math.max(...allDevs)), 15);
        const maxDev = Math.ceil(rawMax / 5) * 5;

        // COG Deviation Chart
        const cogCtx = document.getElementById('leg-cog-chart').getContext('2d');
        legCogChart = new Chart(cogCtx, {
          type: 'line',
          data: {
            labels,
            datasets: [{
              data: leg.ts.map(p => p.dev),
              borderColor: '#3b82f6',
              backgroundColor: 'rgba(59, 130, 246, 0.1)',
              borderWidth: 2,
              pointRadius: 0,
              tension: 0.3,
              fill: true
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { 
              legend: { display: false },
              annotation: {
                annotations: {
                  zero: { type: 'line', yMin: 0, yMax: 0, borderColor: '#666', borderWidth: 2 },
                  plus5: { type: 'line', yMin: 5, yMax: 5, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                  minus5: { type: 'line', yMin: -5, yMax: -5, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                  plus10: { type: 'line', yMin: 10, yMax: 10, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 },
                  minus10: { type: 'line', yMin: -10, yMax: -10, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 }
                }
              }
            },
            scales: {
              x: { 
                display: true,
                ticks: { font: { size: 9 }, maxTicksLimit: 6, callback: v => labels[v] + 'm' }
              },
              y: { 
                display: false,
                min: -maxDev, 
                max: maxDev
              }
            }
          }
        });

        // Mag Heading Deviation Chart and Heel Chart - only for VKX data (not Garmin)
        if (!isGarmin) {
          const magCtx = document.getElementById('leg-mag-chart').getContext('2d');
          legMagChart = new Chart(magCtx, {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: leg.ts.map(p => p.mdev),
                borderColor: '#8b5cf6',
                backgroundColor: 'rgba(139, 92, 246, 0.1)',
                borderWidth: 2,
                pointRadius: 0,
                tension: 0.3,
                fill: true
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: { 
                legend: { display: false },
                annotation: {
                  annotations: {
                    zero: { type: 'line', yMin: 0, yMax: 0, borderColor: '#666', borderWidth: 2 },
                    plus5: { type: 'line', yMin: 5, yMax: 5, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                    minus5: { type: 'line', yMin: -5, yMax: -5, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                    plus10: { type: 'line', yMin: 10, yMax: 10, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 },
                    minus10: { type: 'line', yMin: -10, yMax: -10, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 }
                  }
                }
              },
              scales: {
                x: { 
                  display: true,
                  ticks: { font: { size: 9 }, maxTicksLimit: 6, callback: v => labels[v] + 'm' }
                },
                y: { 
                  display: false,
                  min: -maxDev, 
                  max: maxDev
                }
              }
            }
          });

          // Heel Chart
          const heelData = leg.ts.map(p => p.heel);
          const maxHeel = Math.max(Math.abs(Math.min(...heelData)), Math.abs(Math.max(...heelData)), 15);
          const heelMax = Math.ceil(maxHeel / 5) * 5;
          
          const heelCtx = document.getElementById('leg-heel-chart').getContext('2d');
          legHeelChart = new Chart(heelCtx, {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: heelData,
                borderColor: '#f59e0b',
                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                borderWidth: 2,
                pointRadius: 0,
                tension: 0.3,
                fill: true
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: { 
                legend: { display: false },
                annotation: {
                  annotations: {
                    zero: { type: 'line', yMin: 0, yMax: 0, borderColor: '#666', borderWidth: 2 },
                    plus10: { type: 'line', yMin: 10, yMax: 10, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                    minus10: { type: 'line', yMin: -10, yMax: -10, borderColor: '#22c55e', borderDash: [5,5], borderWidth: 1 },
                    plus15: { type: 'line', yMin: 15, yMax: 15, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 },
                    minus15: { type: 'line', yMin: -15, yMax: -15, borderColor: '#f59e0b', borderDash: [5,5], borderWidth: 1 }
                  }
                }
              },
              scales: {
                x: { 
                  display: true,
                  ticks: { font: { size: 9 }, maxTicksLimit: 6, callback: v => labels[v] + 'm' }
                },
                y: { 
                  display: false,
                  min: -heelMax, 
                  max: heelMax
                }
              }
            }
          });
        }

        // Speed/VMG Chart - for both Garmin and VKX
        const speedVmgCtx = document.getElementById('leg-speed-vmg-chart');
        if (speedVmgCtx) {
          const spdData = leg.ts.map(p => p.spd);
          const vmgData = leg.ts.map(p => p.vmg);
          const maxSpd = Math.max(...spdData, ...vmgData) * 1.1;
          
          // Find regions where speed increases but VMG decreases or stays flat
          // This indicates pointing too high or too low
          const inefficientRegions = [];
          for (let i = 2; i < leg.ts.length - 2; i++) {
            const spdChange = spdData[i] - spdData[i-2];
            const vmgChange = vmgData[i] - vmgData[i-2];
            // Speed increased by >0.3 kts but VMG didn't increase proportionally
            if (spdChange > 0.3 && vmgChange < spdChange * 0.3) {
              inefficientRegions.push(i);
            }
          }
          
          // Create point colors - highlight inefficient regions in red
          const pointColors = spdData.map((_, i) => 
            inefficientRegions.includes(i) ? 'rgba(239, 68, 68, 0.8)' : 'rgba(59, 130, 246, 0)'
          );
          const pointRadius = spdData.map((_, i) => 
            inefficientRegions.includes(i) ? 4 : 0
          );
          
          legSpeedVmgChart = new Chart(speedVmgCtx.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  label: 'Speed',
                  data: spdData,
                  borderColor: '#3b82f6',
                  backgroundColor: 'rgba(59, 130, 246, 0.1)',
                  borderWidth: 2,
                  pointRadius: pointRadius,
                  pointBackgroundColor: pointColors,
                  tension: 0.3,
                  fill: false
                },
                {
                  label: 'VMG',
                  data: vmgData,
                  borderColor: '#22c55e',
                  backgroundColor: 'rgba(34, 197, 94, 0.1)',
                  borderWidth: 2,
                  pointRadius: 0,
                  tension: 0.3,
                  fill: true
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: 'index',
                intersect: false
              },
              plugins: { 
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: ctx => `${ctx.dataset.label}: ${ctx.raw.toFixed(1)} kts`
                  }
                }
              },
              scales: {
                x: { 
                  display: true,
                  ticks: { font: { size: 9 }, maxTicksLimit: 6, callback: v => labels[v] + 'm' }
                },
                y: { 
                  display: true,
                  position: 'right',
                  min: 0,
                  max: Math.ceil(maxSpd),
                  ticks: { font: { size: 9 }, callback: v => v + ' kts' }
                }
              }
            }
          });
        }
      }
    }

    function renderScatterCharts() {
      const filter = document.getElementById('pos-filter').value;
      let intervals = DATA.intervals;
      if (filter !== 'all') intervals = intervals.filter(i => i.pos === filter);

      const isGarmin = DATA.dataSource === 'garmin';
      
      // Hide/show MAG corridor chart based on data source
      const magContainer = document.getElementById('mag-corridor-chart-container');
      if (magContainer) {
        magContainer.style.display = isGarmin ? 'none' : 'block';
      }

      if (intervals.length === 0) {
        document.getElementById('rate-scatter').parentElement.innerHTML = '<p style="text-align:center;color:#6b7280;padding:40px;">No intervals for selected filter</p>';
        document.getElementById('corridor-scatter').parentElement.innerHTML = '<p style="text-align:center;color:#6b7280;padding:40px;">No intervals for selected filter</p>';
        document.getElementById('rate-pct').innerHTML = '';
        document.getElementById('corr-pct').innerHTML = '';
        if (!isGarmin) {
          document.getElementById('mag-corridor-scatter').parentElement.innerHTML = '<p style="text-align:center;color:#6b7280;padding:40px;">No intervals for selected filter</p>';
          document.getElementById('mag-pct').innerHTML = '';
        }
        return;
      }

      const bestRate = Math.min(...intervals.map(i => i.rate));
      const bestCorr = Math.min(...intervals.map(i => i.corridor_pm));
      document.getElementById('best-rate').textContent = bestRate.toFixed(2) + '¬∞/s';
      document.getElementById('best-rate').style.color = getRateColor(bestRate);
      document.getElementById('best-int-corridor').textContent = '¬±' + bestCorr.toFixed(1) + '¬∞';
      document.getElementById('best-int-corridor').style.color = getCorridorColor(bestCorr);

      // Update legend
      if (selectedLeg) {
        document.getElementById('legend-selected-rate').style.display = 'flex';
        document.getElementById('legend-selected-corr').style.display = 'flex';
        document.getElementById('legend-leg-rate').textContent = `Leg #${selectedLeg.id}`;
        document.getElementById('legend-leg-corr').textContent = `Leg #${selectedLeg.id}`;
        if (!isGarmin) {
          document.getElementById('legend-selected-mag').style.display = 'flex';
          document.getElementById('legend-leg-mag').textContent = `Leg #${selectedLeg.id}`;
        }
      } else {
        document.getElementById('legend-selected-rate').style.display = 'none';
        document.getElementById('legend-selected-corr').style.display = 'none';
        if (!isGarmin) {
          document.getElementById('legend-selected-mag').style.display = 'none';
        }
      }

      // Prepare data
      const rateData = intervals.map(i => ({
        x: i.minute,
        y: i.rate,
        legId: i.leg_id,
        color: selectedLeg?.id === i.leg_id ? '#a855f7' : getRateColor(i.rate),
        radius: selectedLeg?.id === i.leg_id ? 8 : 5
      }));

      const corrData = intervals.map(i => ({
        x: i.minute,
        y: i.corridor_pm,
        legId: i.leg_id,
        color: selectedLeg?.id === i.leg_id ? '#a855f7' : getCorridorColor(i.corridor_pm),
        radius: selectedLeg?.id === i.leg_id ? 8 : 5
      }));

      const magCorrData = !isGarmin ? intervals.map(i => ({
        x: i.minute,
        y: i.mag_corridor_pm,
        legId: i.leg_id,
        color: selectedLeg?.id === i.leg_id ? '#a855f7' : getMagCorridorColor(i.mag_corridor_pm),
        radius: selectedLeg?.id === i.leg_id ? 8 : 5
      })) : [];

      // Calculate percentages for each category
      const total = intervals.length;
      
      // Steering Rate percentages
      const rateExpert = intervals.filter(i => i.rate <= 1.5).length;
      const rateClub = intervals.filter(i => i.rate > 1.5 && i.rate <= 3).length;
      const rateRec = intervals.filter(i => i.rate > 3 && i.rate <= 5).length;
      const rateLearning = intervals.filter(i => i.rate > 5).length;
      document.getElementById('rate-pct').innerHTML = 
        `<span style="color:#22c55e">${Math.round(rateExpert/total*100)}%</span> ¬∑ ` +
        `<span style="color:#3b82f6">${Math.round(rateClub/total*100)}%</span> ¬∑ ` +
        `<span style="color:#f59e0b">${Math.round(rateRec/total*100)}%</span> ¬∑ ` +
        `<span style="color:#ef4444">${Math.round(rateLearning/total*100)}%</span>`;
      
      // COG Corridor percentages
      const corrExcellent = intervals.filter(i => i.corridor_pm <= 8).length;
      const corrGood = intervals.filter(i => i.corridor_pm > 8 && i.corridor_pm <= 12).length;
      const corrFair = intervals.filter(i => i.corridor_pm > 12 && i.corridor_pm <= 18).length;
      const corrNeedsWork = intervals.filter(i => i.corridor_pm > 18).length;
      document.getElementById('corr-pct').innerHTML = 
        `<span style="color:#22c55e">${Math.round(corrExcellent/total*100)}%</span> ¬∑ ` +
        `<span style="color:#3b82f6">${Math.round(corrGood/total*100)}%</span> ¬∑ ` +
        `<span style="color:#f59e0b">${Math.round(corrFair/total*100)}%</span> ¬∑ ` +
        `<span style="color:#ef4444">${Math.round(corrNeedsWork/total*100)}%</span>`;
      
      // MAG Corridor percentages (only for VKX)
      if (!isGarmin) {
        const magExcellent = intervals.filter(i => i.mag_corridor_pm <= 5).length;
        const magGood = intervals.filter(i => i.mag_corridor_pm > 5 && i.mag_corridor_pm <= 8).length;
        const magFair = intervals.filter(i => i.mag_corridor_pm > 8 && i.mag_corridor_pm <= 12).length;
        const magNeedsWork = intervals.filter(i => i.mag_corridor_pm > 12).length;
        document.getElementById('mag-pct').innerHTML = 
          `<span style="color:#22c55e">${Math.round(magExcellent/total*100)}%</span> ¬∑ ` +
          `<span style="color:#3b82f6">${Math.round(magGood/total*100)}%</span> ¬∑ ` +
          `<span style="color:#f59e0b">${Math.round(magFair/total*100)}%</span> ¬∑ ` +
          `<span style="color:#ef4444">${Math.round(magNeedsWork/total*100)}%</span>`;
      }

      // Destroy old charts
      if (rateChart) rateChart.destroy();
      if (corridorChart) corridorChart.destroy();
      if (magCorridorChart) magCorridorChart.destroy();

      // Rate chart
      const rateCtx = document.getElementById('rate-scatter').getContext('2d');
      rateChart = new Chart(rateCtx, {
        type: 'scatter',
        data: {
          datasets: [{
            data: rateData,
            backgroundColor: rateData.map(d => d.color),
            pointRadius: rateData.map(d => d.radius),
            pointHoverRadius: 10
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: ctx => {
                  const d = rateData[ctx.dataIndex];
                  return `Min ${d.x} (Leg ${d.legId}): ${d.y.toFixed(2)}¬∞/s`;
                }
              }
            }
          },
          scales: {
            x: { title: { display: true, text: 'Minute' } },
            y: { min: 0, max: 10, title: { display: true, text: '¬∞/s' } }
          },
          onClick: (e, elements) => {
            if (elements.length > 0) {
              const idx = elements[0].index;
              const legId = rateData[idx].legId;
              const leg = DATA.legs.find(l => l.id === legId);
              if (selectedLeg?.id === legId) {
                clearSelection();
              } else {
                selectLeg(leg);
              }
            }
          }
        }
      });

      // Corridor chart
      const corrCtx = document.getElementById('corridor-scatter').getContext('2d');
      corridorChart = new Chart(corrCtx, {
        type: 'scatter',
        data: {
          datasets: [{
            data: corrData,
            backgroundColor: corrData.map(d => d.color),
            pointRadius: corrData.map(d => d.radius),
            pointHoverRadius: 10
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: ctx => {
                  const d = corrData[ctx.dataIndex];
                  return `Min ${d.x} (Leg ${d.legId}): ¬±${d.y.toFixed(1)}¬∞`;
                }
              }
            }
          },
          scales: {
            x: { title: { display: true, text: 'Minute' } },
            y: { min: 0, max: 30, title: { display: true, text: '¬±¬∞' } }
          },
          onClick: (e, elements) => {
            if (elements.length > 0) {
              const idx = elements[0].index;
              const legId = corrData[idx].legId;
              const leg = DATA.legs.find(l => l.id === legId);
              if (selectedLeg?.id === legId) {
                clearSelection();
              } else {
                selectLeg(leg);
              }
            }
          }
        }
      });

      // MAG Corridor chart (only for VKX data)
      if (!isGarmin && magCorrData.length > 0) {
        const magCtx = document.getElementById('mag-corridor-scatter').getContext('2d');
        magCorridorChart = new Chart(magCtx, {
          type: 'scatter',
          data: {
            datasets: [{
              data: magCorrData,
              backgroundColor: magCorrData.map(d => d.color),
              pointRadius: magCorrData.map(d => d.radius),
              pointHoverRadius: 10
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: ctx => {
                    const d = magCorrData[ctx.dataIndex];
                    return `Min ${d.x} (Leg ${d.legId}): ¬±${d.y.toFixed(1)}¬∞`;
                  }
                }
              }
            },
            scales: {
              x: { title: { display: true, text: 'Minute' } },
              y: { min: 0, max: 20, title: { display: true, text: '¬±¬∞' } }
            },
            onClick: (e, elements) => {
              if (elements.length > 0) {
                const idx = elements[0].index;
                const legId = magCorrData[idx].legId;
                const leg = DATA.legs.find(l => l.id === legId);
                if (selectedLeg?.id === legId) {
                  clearSelection();
                } else {
                  selectLeg(leg);
                }
              }
            }
          }
        });
      }
    }

    function renderPOSBreakdown() {
      const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };
      const posNames = { upwind: 'Upwind', reaching: 'Reaching', downwind: 'Downwind' };
      const isGarmin = DATA.dataSource === 'garmin';
      
      document.getElementById('pos-breakdown').innerHTML = ['upwind', 'reaching', 'downwind'].map(pos => {
        const d = DATA.pos[pos];
        const devDisplay = d.linedev !== '-' ? `${d.linedev}% (${d.lostm}m)` : '-';
        return `
          <div class="pos-breakdown" style="border-left: 4px solid ${posColors[pos]};">
            <div class="pos-title" style="color: ${posColors[pos]};">${posNames[pos]}</div>
            <div class="pos-stat"><span>Time</span><span>${Math.round(d.time/60)} min (${d.pct}%)</span></div>
            <div class="pos-stat"><span>Spd/VMG</span><span>${d.speed}/${d.vmg} kts</span></div>
            <div class="pos-stat"><span>COG Corridor</span><span>¬±${d.corridor}¬∞</span></div>
            <div class="pos-stat"><span>Line Deviation</span><span>${devDisplay}</span></div>
            <div class="pos-stat"><span>Steer Rate</span><span>${d.rate}¬∞/s</span></div>
            ${!isGarmin ? `<div class="pos-stat"><span>Avg Heel</span><span>${d.heel}¬∞</span></div>` : ''}
          </div>
        `;
      }).join('');
    }

    function selectLeg(leg) {
      if (selectedLeg?.id === leg?.id) {
        clearSelection();
        return;
      }
      selectedLeg = leg;
      document.getElementById('selected-leg-badge').classList.remove('hidden');
      document.getElementById('selected-leg-text').textContent = `Leg #${leg.id}`;
      
      if (leg.isOutsideTrim) {
        document.getElementById('interval-help').innerHTML = `<span class="text-purple" style="font-weight:500;">Leg #${leg.id}</span> <span style="color:#9ca3af;">(outside trim - limited data)</span>`;
      } else {
        document.getElementById('interval-help').innerHTML = `<span class="text-purple" style="font-weight:500;">Leg #${leg.id} selected</span> - <button onclick="switchTab('legs')" style="color:#7c3aed;text-decoration:underline;background:none;border:none;cursor:pointer;">view details ‚Üí</button>`;
      }
      
      renderMap();
      renderLegsTable();
      renderLegDetail(leg.isOutsideTrim ? null : leg);
      renderScatterCharts();
      renderTimeline();
      
      // Scroll to selected leg row in the table and reset detail panel scroll
      if (!leg.isOutsideTrim) {
        setTimeout(() => {
          const row = document.querySelector(`#legs-tbody tr[data-leg="${leg.id}"]`);
          const scrollContainer = document.getElementById('legs-scroll-container');
          if (row && scrollContainer) {
            const rowTop = row.offsetTop;
            const rowHeight = row.offsetHeight;
            // Position selected row as second from top (one row visible above it)
            // Account for sticky header (~35px)
            scrollContainer.scrollTo({
              top: Math.max(0, rowTop - rowHeight - 35),
              behavior: 'smooth'
            });
          }
          // Scroll detail panel to top
          const detailPanel = document.getElementById('leg-detail');
          if (detailPanel) {
            detailPanel.scrollTo({ top: 0, behavior: 'smooth' });
          }
        }, 50);
      }
    }

    function clearSelection() {
      selectedLeg = null;
      document.getElementById('selected-leg-badge').classList.add('hidden');
      document.getElementById('interval-help').textContent = 'Click dots to select leg on map.';
      renderMap();
      renderLegsTable();
      renderLegDetail(null);
      renderScatterCharts();
      renderTimeline();
    }

    function applyFilter() {
      renderLegsTable();
      renderLegDetail(selectedLeg);
      renderScatterCharts();
    }

    function switchTab(tabId) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');
      document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
      document.getElementById(`tab-${tabId}`).classList.remove('hidden');
    }

    // Store all sessions for comparison
    let ALL_SESSIONS = [];

    function resetDashboard() {
      DATA = null;
      selectedLeg = null;
      mapZoom = 1;
      mapPanX = 0;
      mapPanY = 0;
      if (rateChart) { rateChart.destroy(); rateChart = null; }
      if (corridorChart) { corridorChart.destroy(); corridorChart = null; }
      if (magCorridorChart) { magCorridorChart.destroy(); magCorridorChart = null; }
      if (legRateChart) { legRateChart.destroy(); legRateChart = null; }
      if (legCogChart) { legCogChart.destroy(); legCogChart = null; }
      if (legMagChart) { legMagChart.destroy(); legMagChart = null; }
      if (legHeelChart) { legHeelChart.destroy(); legHeelChart = null; }
      document.getElementById('upload-section').classList.remove('hidden');
      document.getElementById('upload-zone').classList.remove('hidden');
      document.getElementById('dashboard').classList.add('hidden');
      document.getElementById('loading').classList.add('hidden');
      
      // Reset file input by replacing it (allows re-selecting same file)
      const oldInput = document.getElementById('file-input');
      const newInput = document.createElement('input');
      newInput.type = 'file';
      newInput.id = 'file-input';
      // Add accept filter for desktop only (mobile has issues with accept)
      if (!isMobile) {
        newInput.accept = '.vkx,.fit,.gpx,.gz';
      }
      newInput.multiple = true;
      newInput.style.display = 'none';
      newInput.addEventListener('change', handleFileSelect);
      oldInput.parentNode.insertBefore(newInput, oldInput);
      oldInput.remove();
      
      renderComparison();
    }

    function handleFileSelect(e) {
      const files = Array.from(e.target.files).filter(f => {
        const name = f.name.toLowerCase();
        return name.endsWith('.vkx') || name.endsWith('.fit') || name.endsWith('.gpx') || name.endsWith('.gz');
      });
      if (files.length > 0) processFiles(files);
    }

    function clearAllSessions() {
      ALL_SESSIONS = [];
      selectedSessionsForReplay.clear();
      window.lastKnownSessionCount = 0;
      resetDashboard();
    }

    // ===== FILE HANDLING =====
    const uploadZone = document.getElementById('upload-zone');

    uploadZone.addEventListener('click', (e) => {
      if (e.target.tagName !== 'INPUT') {
        document.getElementById('file-input').click();
      }
    });
    uploadZone.addEventListener('dragover', e => { e.preventDefault(); uploadZone.classList.add('dragover'); });
    uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('dragover'));
    uploadZone.addEventListener('drop', e => {
      e.preventDefault();
      uploadZone.classList.remove('dragover');
      const files = Array.from(e.dataTransfer.files).filter(f => {
        const name = f.name.toLowerCase();
        return name.endsWith('.vkx') || name.endsWith('.fit') || name.endsWith('.gpx') || name.endsWith('.gz');
      });
      if (files.length > 0) processFiles(files);
    });
    
    // Initial file input listener
    document.getElementById('file-input').addEventListener('change', handleFileSelect);
    
    // Video file input - use event delegation for iOS compatibility
    document.addEventListener('change', function(e) {
      if (e.target && e.target.id === 'video-file-input') {
        handleVideoFiles(e);
      }
    });
    document.addEventListener('input', function(e) {
      if (e.target && e.target.id === 'video-file-input') {
        handleVideoFiles(e);
      }
    });

    async function processFiles(files) {
      document.getElementById('upload-zone').classList.add('hidden');
      document.getElementById('loading').classList.remove('hidden');

      try {
        for (const file of files) {
          let buffer = await file.arrayBuffer();
          
          // Check if gzipped and decompress
          const bytes = new Uint8Array(buffer);
          if (bytes[0] === 0x1f && bytes[1] === 0x8b) {
            // Gzip compressed - decompress using pako
            const pako = await loadPako();
            const decompressed = pako.ungzip(bytes);
            buffer = decompressed.buffer;
          }
          
          // Detect file type and parse
          const fileType = detectFileType(buffer);
          let records;
          let dataSource = 'vkx';
          
          if (fileType === 'FIT') {
            records = parseFIT(buffer);
            dataSource = 'garmin';
            console.log(`Parsed ${records.length} GPS records from Garmin FIT file: ${file.name}`);
          } else if (fileType === 'GPX') {
            records = parseGPX(buffer);
            dataSource = 'garmin'; // Treat GPX same as Garmin (GPS-only, no compass)
            console.log(`Parsed ${records.length} GPS records from GPX file: ${file.name}`);
          } else {
            records = parseVKX(buffer);
            dataSource = 'vkx';
            console.log(`Parsed ${records.length} telemetry records from VKX file: ${file.name}`);
          }

          const sessionData = analyzeSession(records);
          sessionData.filename = file.name;
          sessionData.rawRecords = records;
          sessionData.dataSource = dataSource; // Track data source for UI adaptation
          
          // Calculate actual session duration from the last leg's end time (not sum of leg durations)
          const actualDuration = sessionData.legs.length > 0 
            ? Math.max(...sessionData.legs.map(l => l.end))
            : sessionData.s.dur;
          
          sessionData.timelineStart = 0; // Start time in minutes (relative)
          sessionData.timelineEnd = actualDuration; // End time in minutes
          sessionData.fullDuration = actualDuration; // Original full duration (actual elapsed time)
          
          // Store original milestones from full analysis (for timeline display)
          sessionData.originalMilestones = sessionData.legs
            .filter(leg => leg.next_maneuver)
            .map(leg => ({
              time: leg.end,
              type: leg.next_maneuver.type,
              angle: leg.next_maneuver.angle
            }));
          // Store original legs for timeline display
          sessionData.originalLegs = sessionData.legs.map(leg => ({
            id: leg.id,
            start: leg.start,
            end: leg.end,
            pos: leg.pos,
            startLat: leg.startLat,
            startLon: leg.startLon,
            endLat: leg.endLat,
            endLon: leg.endLon
          }));
          // Store original track for map display with grey regions
          sessionData.originalTrack = sessionData.track.slice();
          // Store session start timestamp (ms) for time of day labels
          sessionData.startTimestampMs = records[0].timestamp_ms;
          
          ALL_SESSIONS.push(sessionData);
          console.log(`Detected ${sessionData.legs.length} legs, ${sessionData.intervals.length} intervals`);
        }

        // Sort sessions by timestamp (newest first), then by filename
        ALL_SESSIONS.sort((a, b) => {
          // Compare by timestamp (newer sessions first)
          if (a.s.timestamp !== b.s.timestamp) {
            return b.s.timestamp - a.s.timestamp;
          }
          // Same timestamp, sort by filename (descending)
          return b.filename.localeCompare(a.filename);
        });

        // Apply auto-trim if enabled
        if (document.getElementById('auto-trim-checkbox')?.checked) {
          ALL_SESSIONS.forEach((session, idx) => {
            applyAutoTrim(idx);
          });
        }

        // Use first session as active (newest after sorting)
        DATA = ALL_SESSIONS[0];

        document.getElementById('upload-section').classList.add('hidden');
        document.getElementById('dashboard').classList.remove('hidden');
        renderDashboard();
        renderComparison();
        fitMapToTrimmedTrack(); // Auto-fit map to track
      } catch (err) {
        console.error(err);
        alert('Error processing file: ' + err.message);
        document.getElementById('upload-zone').classList.remove('hidden');
        document.getElementById('loading').classList.add('hidden');
      }
    }

    function switchSession(index) {
      DATA = ALL_SESSIONS[index];
      selectedLeg = null;
      
      renderDashboard();
      renderComparison();
      renderTimeline();
      fitMapToTrimmedTrack(); // Auto-fit map to new session's track
    }

    function renderComparison() {
      const container = document.getElementById('comparison-section');
      if (!container) return;
      
      if (ALL_SESSIONS.length < 1) {
        container.classList.add('hidden');
        return;
      }
      
      container.classList.remove('hidden');
      const activeIdx = ALL_SESSIONS.indexOf(DATA);
      
      // Helper: calculate median (robust to outliers, good for "typical" values)
      const median = (arr) => {
        if (!arr.length) return null;
        const sorted = [...arr].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
      };
      
      // Pre-calculate stats for each session
      const sessionStats = ALL_SESSIONS.map(session => {
        const tackAngles = session.legs
          .filter(l => l.next_maneuver?.type === 'tack')
          .map(l => l.next_maneuver.angle);
        const gybeAngles = session.legs
          .filter(l => l.next_maneuver?.type === 'gybe')
          .map(l => l.next_maneuver.angle);
        
        return {
          tackCount: tackAngles.length,
          gybeCount: gybeAngles.length,
          tackAngle: tackAngles.length ? Math.round(median(tackAngles)) : null,
          gybeAngle: gybeAngles.length ? Math.round(median(gybeAngles)) : null,
          speedUp: parseFloat(session.o.speed_upwind) || 0,
          speedDn: parseFloat(session.o.speed_downwind) || 0,
          vmgUp: parseFloat(session.o.vmg_upwind) || 0,
          vmgDn: parseFloat(session.o.vmg_downwind) || 0,
          heelUp: parseFloat(session.o.heel_upwind) || 0,
          heelDn: parseFloat(session.o.heel_downwind) || 0,
          corrUp: parseFloat(session.o.corridor_upwind) || 999,
          corrDn: parseFloat(session.o.corridor_downwind) || 999,
          magUp: parseFloat(session.o.mag_corridor_upwind) || 999,
          magDn: parseFloat(session.o.mag_corridor_downwind) || 999,
          mag70Up: parseFloat(session.o.mag70_upwind) || 999,
          mag70Dn: parseFloat(session.o.mag70_downwind) || 999,
          rateUp: parseFloat(session.o.rate_upwind) || 999,
          rateDn: parseFloat(session.o.rate_downwind) || 999,
          devUp: parseFloat(session.o.linedev_upwind) || 999,
          devDn: parseFloat(session.o.linedev_downwind) || 999
        };
      });
      
      // Find best values for highlighting
      const bestSpeedUp = Math.max(...sessionStats.map(s => s.speedUp));
      const bestSpeedDn = Math.max(...sessionStats.map(s => s.speedDn));
      const bestVmgUp = Math.max(...sessionStats.map(s => s.vmgUp));
      const bestVmgDn = Math.max(...sessionStats.map(s => s.vmgDn));
      const bestCorrUp = Math.min(...sessionStats.filter(s => s.corrUp < 999).map(s => s.corrUp));
      const bestCorrDn = Math.min(...sessionStats.filter(s => s.corrDn < 999).map(s => s.corrDn));
      const bestMagUp = Math.min(...sessionStats.filter(s => s.magUp < 999).map(s => s.magUp));
      const bestMagDn = Math.min(...sessionStats.filter(s => s.magDn < 999).map(s => s.magDn));
      const bestMag70Up = Math.min(...sessionStats.filter(s => s.mag70Up < 999).map(s => s.mag70Up));
      const bestMag70Dn = Math.min(...sessionStats.filter(s => s.mag70Dn < 999).map(s => s.mag70Dn));
      const bestRateUp = Math.min(...sessionStats.filter(s => s.rateUp < 999).map(s => s.rateUp));
      const bestRateDn = Math.min(...sessionStats.filter(s => s.rateDn < 999).map(s => s.rateDn));
      const bestDevUp = Math.min(...sessionStats.filter(s => s.devUp < 999).map(s => s.devUp));
      const bestDevDn = Math.min(...sessionStats.filter(s => s.devDn < 999).map(s => s.devDn));
      
      const summaryView = document.getElementById('summary-view-checkbox')?.checked ?? true;
      const hasGarmin = ALL_SESSIONS.some(s => s.dataSource === 'garmin');
      
      // Only auto-select NEW sessions (not previously seen)
      // Track the max index we've seen to detect truly new additions
      if (!window.lastKnownSessionCount) window.lastKnownSessionCount = 0;
      
      // Add only new sessions (indices >= lastKnownSessionCount)
      for (let idx = window.lastKnownSessionCount; idx < ALL_SESSIONS.length; idx++) {
        selectedSessionsForReplay.add(idx);
      }
      window.lastKnownSessionCount = ALL_SESSIONS.length;
      
      // Remove any indices that no longer exist (e.g., sessions were cleared)
      selectedSessionsForReplay.forEach(idx => {
        if (idx >= ALL_SESSIONS.length) {
          selectedSessionsForReplay.delete(idx);
        }
      });
      
      let html = `
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
          <h3 style="margin:0;">Sessions Comparison (${ALL_SESSIONS.length} files)</h3>
          <div style="display:flex;align-items:center;gap:12px;">
            <button class="btn btn-sm btn-start-replay" onclick="startRaceReplay()" ${selectedSessionsForReplay.size < 1 ? 'disabled title="Select at least 1 session"' : ''}>
              üèÅ Start Race Replay (${selectedSessionsForReplay.size})
            </button>
            <label style="display:flex;align-items:center;gap:4px;font-size:0.75rem;cursor:pointer;">
              <input type="checkbox" id="summary-view-checkbox" ${summaryView ? 'checked' : ''} onchange="renderComparison()">
              Summary View
            </label>
            <button class="btn btn-sm" onclick="clearAllSessions()">Clear All</button>
          </div>
        </div>
        <div style="overflow-x:auto;">
          <table style="width:100%;font-size:0.75rem;">
            <thead>
              <tr>
                <th style="width:30px;text-align:center;"><input type="checkbox" ${selectedSessionsForReplay.size === ALL_SESSIONS.length ? 'checked' : ''} onchange="toggleAllSessionsForReplay(this.checked)" title="Select all for replay"></th>
                <th>File</th>
                <th>Date</th>
                ${!summaryView ? '<th style="text-align:right;">Dur</th>' : ''}
                ${!summaryView ? '<th style="text-align:right;">Wind</th>' : ''}
                ${!summaryView ? '<th style="text-align:right;">Legs</th>' : ''}
                ${!summaryView ? '<th style="text-align:right;">Tacks</th>' : ''}
                <th style="text-align:right;">Tack¬∞</th>
                ${!summaryView ? '<th style="text-align:right;">Gybes</th>' : ''}
                <th style="text-align:right;">Gybe¬∞</th>
                <th style="text-align:right;">Spd/VMG‚Üë</th>
                <th style="text-align:right;">Spd/VMG‚Üì</th>
                ${!hasGarmin ? '<th style="text-align:right;">Heel‚Üë</th>' : ''}
                ${!hasGarmin ? '<th style="text-align:right;">Heel‚Üì</th>' : ''}
                <th style="text-align:right;">COG‚Üë</th>
                <th style="text-align:right;">COG‚Üì</th>
                ${!hasGarmin ? '<th style="text-align:right;">MAG70/90‚Üë</th>' : ''}
                ${!hasGarmin ? '<th style="text-align:right;">MAG70/90‚Üì</th>' : ''}
                <th style="text-align:right;">Dev‚Üë</th>
                <th style="text-align:right;">Dev‚Üì</th>
                <th style="text-align:right;">Rate‚Üë</th>
                <th style="text-align:right;">Rate‚Üì</th>
                <th></th>
              </tr>
            </thead>
            <tbody>
      `;
      
      ALL_SESSIONS.forEach((session, idx) => {
        const isActive = idx === activeIdx;
        const stats = sessionStats[idx];
        
        const bestSpUpStyle = stats.speedUp === bestSpeedUp || stats.vmgUp === bestVmgUp ? 'color:#22c55e;font-weight:bold;' : '';
        const bestSpDnStyle = stats.speedDn === bestSpeedDn || stats.vmgDn === bestVmgDn ? 'color:#22c55e;font-weight:bold;' : '';
        const bestCrUpStyle = stats.corrUp === bestCorrUp ? 'color:#22c55e;font-weight:bold;' : '';
        const bestCrDnStyle = stats.corrDn === bestCorrDn ? 'color:#22c55e;font-weight:bold;' : '';
        const bestMag70UpStyle = stats.mag70Up === bestMag70Up && stats.mag70Up < 999 ? 'color:#22c55e;font-weight:bold;' : '';
        const bestMag70DnStyle = stats.mag70Dn === bestMag70Dn && stats.mag70Dn < 999 ? 'color:#22c55e;font-weight:bold;' : '';
        const bestDevUpStyle = stats.devUp === bestDevUp && stats.devUp < 999 ? 'color:#22c55e;font-weight:bold;' : '';
        const bestDevDnStyle = stats.devDn === bestDevDn && stats.devDn < 999 ? 'color:#22c55e;font-weight:bold;' : '';
        const bestRtUpStyle = stats.rateUp === bestRateUp ? 'color:#22c55e;font-weight:bold;' : '';
        const bestRtDnStyle = stats.rateDn === bestRateDn ? 'color:#22c55e;font-weight:bold;' : '';
        
        const rowStyle = isActive 
          ? 'background:#ede9fe;' 
          : 'cursor:pointer;';
        const hoverAttr = isActive ? '' : 'onmouseover="this.style.background=\'#f5f3ff\'" onmouseout="this.style.background=\'\'"';
        
        html += `
          <tr style="${rowStyle}" ${hoverAttr} ${!isActive ? `onclick="switchSession(${idx})"` : ''}>
            <td style="text-align:center;" onclick="event.stopPropagation()">
              <input type="checkbox" ${selectedSessionsForReplay.has(idx) ? 'checked' : ''} onchange="toggleSessionForReplay(${idx}, this.checked)" title="Include in race replay">
            </td>
            <td style="max-width:120px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;${isActive ? 'font-weight:500;' : ''}" title="${session.filename}">${session.filename}</td>
            <td>${session.s.d}</td>
            ${!summaryView ? `<td style="text-align:right;">${session.s.dur}m</td>` : ''}
            ${!summaryView ? `<td style="text-align:right;">${session.s.twd}¬∞</td>` : ''}
            ${!summaryView ? `<td style="text-align:right;">${session.legs.length}</td>` : ''}
            ${!summaryView ? `<td style="text-align:right;">${stats.tackCount}</td>` : ''}
            <td style="text-align:right;">${stats.tackAngle !== null ? stats.tackAngle + '¬∞' : '-'}</td>
            ${!summaryView ? `<td style="text-align:right;">${stats.gybeCount}</td>` : ''}
            <td style="text-align:right;">${stats.gybeAngle !== null ? stats.gybeAngle + '¬∞' : '-'}</td>
            <td style="text-align:right;${bestSpUpStyle}">${session.o.speed_upwind}/${session.o.vmg_upwind}</td>
            <td style="text-align:right;${bestSpDnStyle}">${session.o.speed_downwind}/${session.o.vmg_downwind}</td>
            ${!hasGarmin ? `<td style="text-align:right;">${session.o.heel_upwind}¬∞</td>` : ''}
            ${!hasGarmin ? `<td style="text-align:right;">${session.o.heel_downwind}¬∞</td>` : ''}
            <td style="text-align:right;${bestCrUpStyle}">¬±${session.o.corridor_upwind}¬∞</td>
            <td style="text-align:right;${bestCrDnStyle}">¬±${session.o.corridor_downwind}¬∞</td>
            ${!hasGarmin ? `<td style="text-align:right;${bestMag70UpStyle}">${session.o.mag70_upwind}¬∞/${session.o.mag_corridor_upwind}¬∞</td>` : ''}
            ${!hasGarmin ? `<td style="text-align:right;${bestMag70DnStyle}">${session.o.mag70_downwind}¬∞/${session.o.mag_corridor_downwind}¬∞</td>` : ''}
            <td style="text-align:right;${bestDevUpStyle}">${session.o.linedev_upwind}% (${session.o.lostm_upwind}m)</td>
            <td style="text-align:right;${bestDevDnStyle}">${session.o.linedev_downwind}% (${session.o.lostm_downwind}m)</td>
            <td style="text-align:right;${bestRtUpStyle}">${session.o.rate_upwind}</td>
            <td style="text-align:right;${bestRtDnStyle}">${session.o.rate_downwind}</td>
            <td style="text-align:center;">${isActive ? '<span style="color:#7c3aed;">‚óè</span>' : ''}</td>
          </tr>
        `;
      });
      
      html += '</tbody></table></div>';
      html += '<p class="text-xs" style="color:#6b7280;margin-top:8px;"><span style="color:#22c55e;">‚óè</span> Best value (higher speed/VMG, lower corridor/deviation/rate) ‚Ä¢ Tack¬∞/Gybe¬∞ = median angle</p>';
      container.innerHTML = html;
    }

    // ===== TIMELINE SELECTION =====
    let timelineCollapsed = false;
    let isDraggingTimeline = null; // { sessionIdx, handle: 'start'|'end' }
    let timelineDragStartX = 0;
    let timelineDragStartPct = 0;
    let timelineDragEndPct = 0;
    let pendingTimelineUpdate = null;

    function toggleTimelineSection() {
      timelineCollapsed = !timelineCollapsed;
      document.getElementById('timeline-content').classList.toggle('collapsed', timelineCollapsed);
      document.getElementById('timeline-fold-icon').classList.toggle('collapsed', timelineCollapsed);
    }

    function getSessionTimelinePcts(session) {
      const fullDur = session.fullDuration || session.s.dur;
      const start = session.timelineStart || 0;
      const end = session.timelineEnd || fullDur;
      return {
        startPct: (start / fullDur) * 100,
        endPct: (end / fullDur) * 100
      };
    }

    function renderTimeline() {
      if (!DATA) return;
      
      const container = document.getElementById('all-timelines-container');
      if (!container) return;
      
      // Count sessions with active filters
      const filteredCount = ALL_SESSIONS.filter(s => {
        const fullDur = s.fullDuration || s.s.dur;
        return (s.timelineStart || 0) > 0.1 || (s.timelineEnd || fullDur) < fullDur - 0.1;
      }).length;
      
      // Update summary
      const summary = document.getElementById('timeline-summary');
      if (filteredCount > 0) {
        summary.textContent = `(${filteredCount} filtered)`;
        document.getElementById('reset-all-btn').style.display = '';
      } else {
        summary.textContent = '';
        document.getElementById('reset-all-btn').style.display = 'none';
      }
      
      let html = '';
      
      // In race replay mode, only show selected sessions
      const sessionsToRender = raceReplayMode 
        ? ALL_SESSIONS.map((s, idx) => ({ session: s, idx })).filter(item => selectedSessionsForReplay.has(item.idx))
        : ALL_SESSIONS.map((s, idx) => ({ session: s, idx }));
      
      sessionsToRender.forEach(({ session, idx }) => {
        const isActive = session === DATA;
        const fullDuration = session.fullDuration || session.s.dur;
        const { startPct, endPct } = getSessionTimelinePcts(session);
        const selStart = (startPct / 100) * fullDuration;
        const selEnd = (endPct / 100) * fullDuration;
        const isFiltered = startPct > 0.1 || endPct < 99.9;
        
        const fullShortName = session.filename.replace('.vkx', '').replace('.fit', '').replace('.gpx', '').replace('.gz', '').substring(0, 30);
        const rangeText = isFiltered ? `${selStart.toFixed(1)}-${selEnd.toFixed(1)}m selected` : '';
        
        // In race replay mode, show boat number and color for selected sessions
        const isInReplay = raceReplayMode && selectedSessionsForReplay.has(idx);
        const boatIdx = isInReplay ? Array.from(selectedSessionsForReplay).sort((a,b)=>a-b).indexOf(idx) : -1;
        const boatColor = isInReplay ? BOAT_COLORS[boatIdx % BOAT_COLORS.length] : null;
        
        // Use boat symbol (first word) in replay mode, full name otherwise
        const shortName = isInReplay ? getBoatSymbol(session.filename) : fullShortName;
        
        const nameColor = isInReplay ? boatColor : (isActive ? '#7c3aed' : '#6b7280');
        const boatBadge = isInReplay ? `<span style="display:inline-flex;align-items:center;justify-content:center;width:18px;height:18px;border-radius:50%;background:${boatColor};color:white;font-size:10px;font-weight:bold;margin-right:6px;">${boatIdx + 1}</span>` : '';
        
        // Don't allow switching sessions by clicking in race replay mode
        const clickHandler = (!isActive && !raceReplayMode) ? `onclick="switchSession(${idx})"` : '';
        
        // In race replay mode, all selected sessions should not have 'inactive' opacity
        const trackClass = isActive ? 'active' : (isInReplay ? 'active' : 'inactive');
        
        html += `
          <div class="timeline-track ${trackClass}" data-session="${idx}" ${clickHandler}>
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
              <span class="text-sm" style="font-weight:${isActive || isInReplay ? '600' : '400'};color:${nameColor};display:flex;align-items:center;">${boatBadge}${shortName}</span>
              ${rangeText ? `<span class="text-xs" style="color:#9ca3af;">${rangeText}</span>` : ''}
            </div>
            <div class="timeline-bar" data-session="${idx}" style="position:relative;height:42px;"></div>
          </div>
        `;
      });
      
      container.innerHTML = html;
      
      // Render each timeline SVG
      sessionsToRender.forEach(({ session, idx }) => {
        renderSingleTimeline(session, idx, session === DATA);
      });
    }

    function renderSingleTimeline(session, sessionIdx, isActive) {
      const container = document.querySelector(`.timeline-bar[data-session="${sessionIdx}"]`);
      if (!container) return;
      
      const fullDuration = session.fullDuration || session.s.dur;
      const { startPct, endPct } = getSessionTimelinePcts(session);
      const originalLegs = session.originalLegs || [];
      const startTimestampMs = session.startTimestampMs || 0;
      
      // Check if this session is in the replay
      const isInReplay = raceReplayMode && selectedSessionsForReplay.has(sessionIdx);
      const boatIdx = isInReplay ? Array.from(selectedSessionsForReplay).sort((a,b)=>a-b).indexOf(sessionIdx) : -1;
      const boatColor = isInReplay ? BOAT_COLORS[boatIdx % BOAT_COLORS.length] : null;
      
      // Helper: time to percentage
      const timeToPct = (min) => (min / fullDuration) * 100;
      
      let html = '';
      
      // Background track - use boat color in replay mode
      const bgColor = isInReplay ? boatColor : (isActive ? '#e5e7eb' : '#f3f4f6');
      const bgOpacity = isInReplay ? '0.2' : '1';
      html += `<div class="tl-track" style="position:absolute;left:0;right:0;top:4px;height:20px;background:${bgColor};opacity:${bgOpacity};border-radius:3px;"></div>`;
      
      // Grey out unselected regions (only for active, and NOT in race replay mode)
      if (isActive && !raceReplayMode) {
        if (startPct > 0.1) {
          html += `<div style="position:absolute;left:0;top:4px;width:${startPct}%;height:20px;background:#9ca3af;opacity:0.4;border-radius:3px 0 0 3px;"></div>`;
        }
        if (endPct < 99.9) {
          html += `<div style="position:absolute;left:${endPct}%;right:0;top:4px;height:20px;background:#9ca3af;opacity:0.4;border-radius:0 3px 3px 0;"></div>`;
        }
      }
      
      // Leg segments - simple divs with percentage positioning
      const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };
      originalLegs.forEach((leg) => {
        const leftPct = timeToPct(leg.start);
        const widthPct = Math.max(0.3, timeToPct(leg.end) - timeToPct(leg.start));
        
        // Check if selected by time overlap (not in race replay mode)
        let isSelected = false;
        if (!raceReplayMode) {
          // selectedLeg times are relative to trimmed start, originalLegs times are relative to full session
          const timeOffset = session.timelineStart || 0;
          if (isActive && selectedLeg) {
            const adjSelectedStart = selectedLeg.start + timeOffset;
            const adjSelectedEnd = selectedLeg.end + timeOffset;
            const overlapStart = Math.max(adjSelectedStart, leg.start);
            const overlapEnd = Math.min(adjSelectedEnd, leg.end);
            const overlap = overlapEnd - overlapStart;
            const legDuration = leg.end - leg.start;
            isSelected = overlap > legDuration * 0.5;
          }
        }
        
        // In replay mode, use boat color for legs
        let color;
        if (isInReplay) {
          // Keep position colors (upwind/downwind/reaching) in replay mode
          color = posColors[leg.pos];
        } else {
          color = isSelected ? '#a855f7' : posColors[leg.pos];
        }
        
        // In replay mode, all selected sessions get full opacity
        let opacity;
        if (isInReplay) {
          opacity = 0.8;
        } else if (isActive) {
          opacity = isSelected ? 1 : 0.8;
        } else {
          opacity = 0.4;
        }
        
        const cursor = (isActive && !raceReplayMode) ? 'pointer' : 'default';
        const glow = isSelected ? 'box-shadow:0 0 6px #c084fc;' : '';
        
        html += `<div class="tl-leg" data-leg-id="${leg.id}" style="position:absolute;left:${leftPct}%;top:6px;width:${widthPct}%;height:16px;background:${color};opacity:${opacity};border-radius:2px;cursor:${cursor};${glow}"></div>`;
      });
      
      // Handles - show for active timeline OR all replay sessions
      const showHandles = isActive || isInReplay;
      if (showHandles) {
        const handleColor = isInReplay ? boatColor : '#7c3aed';
        html += `<div class="tl-handle" data-handle="start" style="position:absolute;left:${startPct}%;top:0;width:8px;height:28px;background:${handleColor};border-radius:3px;cursor:ew-resize;transform:translateX(-50%);z-index:10;"></div>`;
        html += `<div class="tl-handle" data-handle="end" style="position:absolute;left:${endPct}%;top:0;width:8px;height:28px;background:${handleColor};border-radius:3px;cursor:ew-resize;transform:translateX(-50%);z-index:10;"></div>`;
      }
      
      // Playback pointer (in race replay mode)
      if (isInReplay) {
        // Calculate pointer position using real-world time synchronization
        const referenceStartMs = getPlaybackStartTimeMs();
        const currentTimeMs = referenceStartMs + playbackTime * 60000;
        const sessionLocalTimeMin = (currentTimeMs - startTimestampMs) / 60000;
        const playbackPct = (sessionLocalTimeMin / fullDuration) * 100;
        html += `<div class="tl-playback-pointer" data-session="${sessionIdx}" style="position:absolute;left:${Math.max(0, Math.min(100, playbackPct))}%;top:0;width:3px;height:28px;background:${boatColor};border-radius:2px;transform:translateX(-50%);z-index:15;pointer-events:none;box-shadow:0 0 4px ${boatColor};"></div>`;
      }
      
      // Time labels
      if (startTimestampMs) {
        const startDate = new Date(startTimestampMs);
        const startTimeStr = startDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
        html += `<div style="position:absolute;left:0;bottom:0;font-size:9px;color:#6b7280;">${startTimeStr}</div>`;
        
        const endDate = new Date(startTimestampMs + fullDuration * 60000);
        const endTimeStr = endDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
        html += `<div style="position:absolute;right:0;bottom:0;font-size:9px;color:#6b7280;">${endTimeStr}</div>`;
        
        // Add half-hour interval labels (11:30, 12:00, 12:30, etc.)
        const startMinOfDay = startDate.getHours() * 60 + startDate.getMinutes();
        const firstHalfHour = Math.ceil(startMinOfDay / 30) * 30;
        const offsetMin = firstHalfHour - startMinOfDay;
        
        for (let min = offsetMin; min <= fullDuration; min += 30) {
          const pct = (min / fullDuration) * 100;
          // Skip if too close to start or end (within 8%)
          if (pct < 8 || pct > 92) continue;
          
          const labelDate = new Date(startTimestampMs + min * 60000);
          const timeStr = labelDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', hour12: false});
          html += `<div style="position:absolute;left:${pct}%;bottom:0;font-size:9px;color:#9ca3af;transform:translateX(-50%);">${timeStr}</div>`;
        }
      }
      
      container.innerHTML = html;
      
      // Add event listeners
      // Handle drag - allow for active session OR all replay sessions
      if (isActive || isInReplay) {
        container.querySelectorAll('.tl-handle').forEach(handle => {
          handle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            isDraggingTimeline = { sessionIdx, handle: handle.dataset.handle };
            timelineDragStartX = e.clientX;
            const pcts = getSessionTimelinePcts(session);
            timelineDragStartPct = pcts.startPct;
            timelineDragEndPct = pcts.endPct;
          });
        });
      }
      
      // Leg click (only in normal mode for active session)
      if (isActive && !raceReplayMode) {
        container.querySelectorAll('.tl-leg').forEach(legEl => {
          legEl.addEventListener('click', (e) => {
            e.stopPropagation();
            const legId = parseInt(legEl.dataset.legId);
            const origLeg = session.originalLegs.find(l => l.id === legId);
            if (!origLeg) return;
            
            // DATA.legs times are relative to trimmed start, originalLegs times are relative to full session
            // Add timelineStart offset to DATA.legs times for comparison
            const timeOffset = session.timelineStart || 0;
            
            // Find matching leg in DATA.legs by time overlap
            const matchingLeg = DATA.legs.find(l => {
              const adjStart = l.start + timeOffset;
              const adjEnd = l.end + timeOffset;
              const overlapStart = Math.max(adjStart, origLeg.start);
              const overlapEnd = Math.min(adjEnd, origLeg.end);
              const overlap = overlapEnd - overlapStart;
              return overlap > (origLeg.end - origLeg.start) * 0.5;
            });
              
              if (matchingLeg) {
                selectLeg(matchingLeg);
              } else {
                // Leg is outside current trim - select it using origLeg data
                // Adjust times so highlight code works correctly (it will add timeOffset back)
                const pseudoLeg = {
                  ...origLeg,
                  start: origLeg.start - timeOffset,
                  end: origLeg.end - timeOffset,
                  isOutsideTrim: true
                };
                selectLeg(pseudoLeg);
              }
            });
          });
      }
    }

    // Update playback pointer positions on all timelines
    function updateTimelinePlaybackPointer() {
      if (!raceReplayMode) return;
      
      // playbackTime is offset in minutes from the earliest session's trimmed start
      // Convert to real-world timestamp for synchronization
      const referenceStartMs = getPlaybackStartTimeMs();
      const currentTimeMs = referenceStartMs + playbackTime * 60000;
      
      selectedSessionsForReplay.forEach(sessionIdx => {
        const session = ALL_SESSIONS[sessionIdx];
        if (!session) return;
        
        const fullDuration = session.fullDuration || session.s.dur;
        const sessionStartMs = session.startTimestampMs || 0;
        
        // Calculate where currentTimeMs falls on this session's timeline
        // sessionStartMs is when this session started recording
        // The timeline shows 0 to fullDuration minutes from sessionStartMs
        const sessionLocalTimeMin = (currentTimeMs - sessionStartMs) / 60000;
        const playbackPct = (sessionLocalTimeMin / fullDuration) * 100;
        
        const pointer = document.querySelector(`.tl-playback-pointer[data-session="${sessionIdx}"]`);
        if (pointer) {
          pointer.style.left = `${Math.max(0, Math.min(100, playbackPct))}%`;
        }
      });
    }

    // Global mouse handlers for timeline dragging
    document.addEventListener('mousemove', (e) => {
      if (!isDraggingTimeline) return;
      
      const session = ALL_SESSIONS[isDraggingTimeline.sessionIdx];
      if (!session) return;
      
      const bar = document.querySelector(`.timeline-bar[data-session="${isDraggingTimeline.sessionIdx}"]`);
      if (!bar) return;
      
      const rect = bar.getBoundingClientRect();
      const width = rect.width;
      
      const dx = e.clientX - timelineDragStartX;
      const dPct = (dx / width) * 100;
      
      let newStartPct = timelineDragStartPct;
      let newEndPct = timelineDragEndPct;
      
      if (isDraggingTimeline.handle === 'start') {
        newStartPct = Math.max(0, Math.min(newEndPct - 5, timelineDragStartPct + dPct));
      } else if (isDraggingTimeline.handle === 'end') {
        newEndPct = Math.max(newStartPct + 5, Math.min(100, timelineDragEndPct + dPct));
      }
      
      // Update session timeline values immediately for visual feedback
      const fullDuration = session.fullDuration || session.s.dur;
      session.timelineStart = (newStartPct / 100) * fullDuration;
      session.timelineEnd = (newEndPct / 100) * fullDuration;
      
      // Re-render just this timeline for immediate visual feedback
      renderSingleTimeline(session, isDraggingTimeline.sessionIdx, true);
      
      // Update map to show grey areas
      renderMap();
      
      // Debounce the actual re-analysis
      if (pendingTimelineUpdate) {
        clearTimeout(pendingTimelineUpdate);
      }
      pendingTimelineUpdate = setTimeout(() => {
        applyTimelineChange(isDraggingTimeline.sessionIdx, newStartPct, newEndPct, true);
      }, 150);
    });

    document.addEventListener('mouseup', () => {
      if (isDraggingTimeline) {
        // Apply final change
        const session = ALL_SESSIONS[isDraggingTimeline.sessionIdx];
        if (session) {
          const pcts = getSessionTimelinePcts(session);
          applyTimelineChange(isDraggingTimeline.sessionIdx, pcts.startPct, pcts.endPct, true);
        }
        isDraggingTimeline = null;
      }
    });

    function applyTimelineChange(sessionIdx, startPct, endPct, skipTimelineRender = false) {
      const session = ALL_SESSIONS[sessionIdx];
      if (!session || !session.rawRecords) return;
      
      const fullDuration = session.fullDuration || session.s.dur;
      const startMin = (startPct / 100) * fullDuration;
      const endMin = (endPct / 100) * fullDuration;
      
      try {
        const newData = analyzeSession(session.rawRecords, startMin, endMin);
        newData.filename = session.filename;
        newData.rawRecords = session.rawRecords;
        newData.timelineStart = startMin;
        newData.timelineEnd = endMin;
        newData.fullDuration = fullDuration;
        newData.originalMilestones = session.originalMilestones;
        newData.originalLegs = session.originalLegs;
        newData.originalTrack = session.originalTrack;
        newData.startTimestampMs = session.startTimestampMs;
        
        ALL_SESSIONS[sessionIdx] = newData;
        
        if (DATA === session || sessionIdx === ALL_SESSIONS.indexOf(DATA)) {
          DATA = newData;
          selectedLeg = null;
          renderDashboard();
          renderComparison();
          fitMapToTrimmedTrack(); // Auto-center map on trimmed area
        }
        
        if (!skipTimelineRender) {
          renderTimeline();
        }
      } catch (err) {
        console.error('Error applying timeline:', err);
      }
    }

    function resetAllTimelines() {
      try {
        ALL_SESSIONS.forEach((session, idx) => {
          const newData = analyzeSession(session.rawRecords);
          newData.filename = session.filename;
          newData.rawRecords = session.rawRecords;
          newData.timelineStart = 0;
          // Use the stored fullDuration (actual session duration), not the re-analyzed s.dur
          const actualDuration = session.fullDuration || Math.max(...newData.legs.map(l => l.end), newData.s.dur);
          newData.timelineEnd = actualDuration;
          newData.fullDuration = actualDuration;
          newData.originalMilestones = session.originalMilestones;
          newData.originalLegs = session.originalLegs;
          newData.originalTrack = session.originalTrack || newData.track.slice();
          newData.startTimestampMs = session.startTimestampMs;
          
          ALL_SESSIONS[idx] = newData;
        });
        
        // Re-apply auto-trim if enabled
        if (document.getElementById('auto-trim-checkbox')?.checked) {
          ALL_SESSIONS.forEach((session, idx) => {
            applyAutoTrim(idx);
          });
        }
        
        DATA = ALL_SESSIONS.find(s => s.filename === DATA.filename) || ALL_SESSIONS[0];
        selectedLeg = null;
        renderDashboard();
        renderComparison();
        renderTimeline();
        fitMapToTrimmedTrack(); // Reset map to fit track
      } catch (err) {
        alert('Error resetting timelines: ' + err.message);
      }
    }

    // ===== AUTO-TRIM FUNCTIONS =====
    // Haversine formula for distance between two GPS points
    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000; // Earth radius in meters
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }
    
    // Calculate precise sailing route between two boats considering wind angles and tacking/gybing
    // Always assumes tack/gybe is needed - boat continues current leg's COG, then tacks/gybes to target
    // Time calculation uses 2-second smoothed SOG for consistency with telemetry overlay
    function calculateSailingRoute(b1Pos, b2Pos, sessions) {
      const twd = sessions[0].s.twd || 0;
      const session1 = sessions[0];
      
      // Get current leg info for boat 1 (chasing boat)
      const currentLeg = getCurrentLegAtTime(session1, playbackTime);
      const nextLeg = currentLeg ? getNextLeg(session1, currentLeg) : null;
      
      // Get 2-second smoothed telemetry for SOG (consistent with telemetry overlay)
      const smoothedTelemetry = getSmoothedTelemetry(session1, playbackTime, 2);
      const smoothedSog = smoothedTelemetry ? smoothedTelemetry.sog : (b1Pos.sog || 5);
      
      // Current boat state - use leg's COG for stable route calculation
      const currentHdg = (currentLeg && currentLeg.hdg != null) ? currentLeg.hdg : (b1Pos.hdg || b1Pos.cog || 0);
      
      // Calculate current TWA from leg heading
      let currentTwa = Math.abs(angleDiff(currentHdg, twd));
      
      // Use leg TWA if available
      if (currentLeg && currentLeg.twa != null) {
        currentTwa = currentLeg.twa;
      }
      
      // Determine sailing mode: upwind (<90) or downwind (>90)
      const isUpwind = currentTwa < 90;
      
      // Calculate bearing from b1 to b2
      const lat1 = b1Pos.lat * Math.PI / 180;
      const lat2 = b2Pos.lat * Math.PI / 180;
      const dLon = (b2Pos.lon - b1Pos.lon) * Math.PI / 180;
      const y = Math.sin(dLon) * Math.cos(lat2);
      const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
      let bearing = Math.atan2(y, x) * 180 / Math.PI;
      if (bearing < 0) bearing += 360;
      
      // Direct distance
      const directDist = haversineDistance(b1Pos.lat, b1Pos.lon, b2Pos.lat, b2Pos.lon);
      
      // Determine second leg heading after tack/gybe
      // For upwind: mirror current heading across wind
      // For downwind: mirror current heading across downwind axis
      let secondHdg;
      if (isUpwind) {
        // Mirror across TWD: secondHdg = TWD - (currentHdg - TWD) = 2*TWD - currentHdg
        secondHdg = (2 * twd - currentHdg + 360) % 360;
      } else {
        // Mirror across downwind axis (TWD + 180)
        const downwindAxis = (twd + 180) % 360;
        secondHdg = (2 * downwindAxis - currentHdg + 360) % 360;
      }
      
      // Calculate tack/gybe point:
      // Boat 1 continues on currentHdg (leg COG) until it intersects the layline from b2 on secondHdg
      const tackPoint = calculateLaylineIntersection(
        b1Pos.lat, b1Pos.lon, currentHdg,
        b2Pos.lat, b2Pos.lon, (secondHdg + 180) % 360  // Reverse direction for intersection
      );
      
      if (!tackPoint) {
        // Fallback: estimate tack point at midway
        const midLat = (b1Pos.lat + b2Pos.lat) / 2;
        const midLon = (b1Pos.lon + b2Pos.lon) / 2;
        
        // Estimate sailing distance as 1.4x direct (typical upwind factor)
        const sailDist = directDist * (isUpwind ? 1.4 : 1.2);
        const sailTime = smoothedSog > 0.1 ? sailDist / (smoothedSog * 0.514444) : 9999;
        
        return {
          type: isUpwind ? 'tack' : 'gybe',
          waypoints: [b1Pos, { lat: midLat, lon: midLon }, b2Pos],
          directDist: directDist,
          sailDist: sailDist,
          time: sailTime
        };
      }
      
      // Calculate leg distances
      const dist1 = haversineDistance(b1Pos.lat, b1Pos.lon, tackPoint.lat, tackPoint.lon);
      const dist2 = haversineDistance(tackPoint.lat, tackPoint.lon, b2Pos.lat, b2Pos.lon);
      const sailDist = dist1 + dist2;
      
      // Calculate time using 2-second smoothed SOG
      // Convert SOG from knots to m/s: * 0.514444
      const sailTime = smoothedSog > 0.1 ? sailDist / (smoothedSog * 0.514444) : 9999;
      
      return {
        type: isUpwind ? 'tack' : 'gybe',
        waypoints: [b1Pos, tackPoint, b2Pos],
        directDist: directDist,
        sailDist: sailDist,
        time: sailTime,
        leg1: { dist: dist1, hdg: currentHdg },
        leg2: { dist: dist2, hdg: secondHdg }
      };
    }
    
    // Calculate intersection of two rhumb lines (laylines)
    function calculateLaylineIntersection(lat1, lon1, hdg1, lat2, lon2, hdg2) {
      // Use planar approximation for short distances (works well for typical racing distances)
      const R = 6371000; // Earth radius in meters
      const latMid = (lat1 + lat2) / 2;
      const mPerDegLat = R * Math.PI / 180;
      const mPerDegLon = R * Math.PI / 180 * Math.cos(latMid * Math.PI / 180);
      
      // Convert to local x,y coordinates (meters) relative to b1
      const x1 = 0;
      const y1 = 0;
      const x2 = (lon2 - lon1) * mPerDegLon;
      const y2 = (lat2 - lat1) * mPerDegLat;
      
      // Direction vectors (heading 0 = north = +y, 90 = east = +x)
      const hdg1Rad = hdg1 * Math.PI / 180;
      const hdg2Rad = hdg2 * Math.PI / 180;
      const dx1 = Math.sin(hdg1Rad);
      const dy1 = Math.cos(hdg1Rad);
      const dx2 = Math.sin(hdg2Rad);
      const dy2 = Math.cos(hdg2Rad);
      
      // Solve parametric line intersection
      // P1 + t1 * D1 = P2 + t2 * D2
      const det = dx1 * (-dy2) - dy1 * (-dx2);
      if (Math.abs(det) < 1e-10) return null; // Parallel lines
      
      const t1 = ((x2 - x1) * (-dy2) - (y2 - y1) * (-dx2)) / det;
      
      // Only valid if intersection is ahead of starting point
      if (t1 < 0) return null;
      
      // Calculate intersection point in local coords
      const ix = x1 + t1 * dx1;
      const iy = y1 + t1 * dy1;
      
      // Verify second boat can reach intersection (t2 should also be positive-ish)
      const t2 = dx1 !== 0 ? (x1 + t1 * dx1 - x2) / dx2 : (y1 + t1 * dy1 - y2) / dy2;
      if (t2 < -0.1) return null; // Intersection is behind b2's layline
      
      // Convert back to lat/lon
      const iLat = lat1 + iy / mPerDegLat;
      const iLon = lon1 + ix / mPerDegLon;
      
      return { lat: iLat, lon: iLon };
    }
    
    // Rolling window for sailing time smoothing (10 seconds of playback time)
    let sailingTimeHistory = [];
    let lastPlaybackTimeForSmoothing = -1;
    
    function getSmoothedSailingTime(currentTime) {
      const windowMin = 10 / 60; // 10 seconds in minutes
      
      // Detect timeline jump (more than 1 second difference or going backwards)
      const timeDiff = playbackTime - lastPlaybackTimeForSmoothing;
      if (lastPlaybackTimeForSmoothing < 0 || timeDiff < 0 || timeDiff > 0.5) {
        // Timeline jumped - clear history and start fresh
        sailingTimeHistory = [];
      }
      lastPlaybackTimeForSmoothing = playbackTime;
      
      // Add current value with playback timestamp
      sailingTimeHistory.push({ time: currentTime, playbackT: playbackTime });
      
      // Remove entries outside the 10-second playback window
      sailingTimeHistory = sailingTimeHistory.filter(entry => 
        playbackTime - entry.playbackT >= 0 && playbackTime - entry.playbackT < windowMin
      );
      
      // Calculate average
      if (sailingTimeHistory.length === 0) return currentTime;
      
      const sum = sailingTimeHistory.reduce((acc, entry) => acc + entry.time, 0);
      return sum / sailingTimeHistory.length;
    }

    function detectOutlierLegs(legs) {
      if (legs.length < 5) return { trimStart: 0, trimEnd: legs.length };
      
      // Calculate centroid of all leg midpoints (excluding first/last 20%)
      const excludeCount = Math.floor(legs.length * 0.2);
      const middleLegs = legs.slice(excludeCount, legs.length - excludeCount);
      if (middleLegs.length < 3) return { trimStart: 0, trimEnd: legs.length };
      
      let sumLat = 0, sumLon = 0;
      middleLegs.forEach(leg => {
        sumLat += (leg.startLat + leg.endLat) / 2;
        sumLon += (leg.startLon + leg.endLon) / 2;
      });
      const centroidLat = sumLat / middleLegs.length;
      const centroidLon = sumLon / middleLegs.length;
      
      // Calculate distance of each leg's START and END points from centroid (not just midpoint)
      const legDistances = legs.map(leg => {
        const startDist = haversineDistance(centroidLat, centroidLon, leg.startLat, leg.startLon);
        const endDist = haversineDistance(centroidLat, centroidLon, leg.endLat, leg.endLon);
        const midDist = haversineDistance(centroidLat, centroidLon, (leg.startLat + leg.endLat) / 2, (leg.startLon + leg.endLon) / 2);
        // Use maximum of all three - if any point is far, consider the leg an outlier
        return Math.max(startDist, endDist, midDist);
      });
      
      // Find median distance from middle legs only
      const middleDistances = legDistances.slice(excludeCount, legs.length - excludeCount);
      const sortedMiddle = [...middleDistances].sort((a, b) => a - b);
      const medianDist = sortedMiddle[Math.floor(sortedMiddle.length / 2)];
      
      // More aggressive threshold: 2x median or 300m minimum
      const threshold = Math.max(medianDist * 2, 300);
      
      // Find first leg from start that's within threshold (check up to 20 legs)
      let trimStart = 0;
      const maxCheckStart = Math.min(20, legs.length - 3);
      for (let i = 0; i < maxCheckStart; i++) {
        if (legDistances[i] <= threshold) {
          trimStart = i;
          break;
        }
        trimStart = i + 1;
      }
      
      // Find last leg from end that's within threshold (check up to 20 legs)
      let trimEnd = legs.length;
      const minCheckEnd = Math.max(3, legs.length - 20);
      for (let i = legs.length - 1; i >= minCheckEnd; i--) {
        if (legDistances[i] <= threshold) {
          trimEnd = i + 1;
          break;
        }
        trimEnd = i;
      }
      
      // Ensure we keep at least 3 legs
      if (trimEnd - trimStart < 3) {
        return { trimStart: 0, trimEnd: legs.length };
      }
      
      return { trimStart, trimEnd };
    }

    function applyAutoTrim(sessionIdx) {
      const session = ALL_SESSIONS[sessionIdx];
      if (!session || !session.originalLegs || session.originalLegs.length < 5) return;
      
      const { trimStart, trimEnd } = detectOutlierLegs(session.originalLegs);
      
      if (trimStart === 0 && trimEnd === session.originalLegs.length) {
        // No trimming needed
        return;
      }
      
      // Convert leg indices to time
      const fullDuration = session.fullDuration || session.s.dur;
      const startTime = session.originalLegs[trimStart]?.start || 0;
      const endTime = session.originalLegs[trimEnd - 1]?.end || fullDuration;
      
      const startPct = (startTime / fullDuration) * 100;
      const endPct = (endTime / fullDuration) * 100;
      
      console.log(`Auto-trim session ${sessionIdx}: trimming legs 0-${trimStart} and ${trimEnd}-${session.originalLegs.length}, time ${startTime.toFixed(1)}-${endTime.toFixed(1)}m`);
      
      applyTimelineChange(sessionIdx, startPct, endPct, true);
    }

    function toggleAutoTrim() {
      const enabled = document.getElementById('auto-trim-checkbox')?.checked;
      
      if (enabled) {
        // Apply auto-trim to all sessions
        ALL_SESSIONS.forEach((session, idx) => {
          // First reset to full duration
          session.timelineStart = 0;
          session.timelineEnd = session.fullDuration || session.s.dur;
        });
        
        // Then apply auto-trim
        ALL_SESSIONS.forEach((session, idx) => {
          applyAutoTrim(idx);
        });
      } else {
        // Reset all to full duration
        ALL_SESSIONS.forEach((session, idx) => {
          const fullDuration = session.fullDuration || session.s.dur;
          applyTimelineChange(idx, 0, 100, true);
        });
      }
      
      // Refresh current view
      const currentIdx = ALL_SESSIONS.indexOf(DATA);
      if (currentIdx >= 0) {
        DATA = ALL_SESSIONS[currentIdx];
      }
      
      selectedLeg = null;
      renderDashboard();
      renderComparison();
      renderTimeline();
      fitMapToTrimmedTrack(); // Fit map after auto-trim toggle
    }

    // Re-render timeline on window resize
    window.addEventListener('resize', () => {
      if (DATA) renderTimeline();
      // Update race replay leg charts on resize
      if (raceReplayMode) {
        Object.values(raceReplayLegCharts).forEach(chart => {
          if (chart) chart.resize();
        });
      }
    });

    // ===== RACE REPLAY FUNCTIONS =====
    function toggleSessionForReplay(idx, checked) {
      if (checked) {
        selectedSessionsForReplay.add(idx);
      } else {
        selectedSessionsForReplay.delete(idx);
      }
      renderComparison();
      // Update video overlay visibility when sessions change in race replay mode
      if (raceReplayMode) {
        updateVideoTelemetry();
        renderVideoMinimap();
      }
    }

    function toggleAllSessionsForReplay(checked) {
      if (checked) {
        ALL_SESSIONS.forEach((_, idx) => selectedSessionsForReplay.add(idx));
      } else {
        selectedSessionsForReplay.clear();
      }
      renderComparison();
      // Update video overlay visibility when sessions change in race replay mode
      if (raceReplayMode) {
        updateVideoTelemetry();
        renderVideoMinimap();
      }
    }

    // Get the earliest real-world timestamp across all replay sessions (considering trim)
    function getPlaybackStartTimeMs() {
      const sessions = getReplaySessions();
      if (sessions.length === 0) return 0;
      
      let minTimestamp = Infinity;
      sessions.forEach(session => {
        const sessionStartMs = session.startTimestampMs || 0;
        const trimStartMin = session.timelineStart || 0;
        const effectiveStartMs = sessionStartMs + trimStartMin * 60000;
        minTimestamp = Math.min(minTimestamp, effectiveStartMs);
      });
      return minTimestamp;
    }

    // Get the latest real-world timestamp across all replay sessions (considering trim)
    function getPlaybackEndTimeMs() {
      const sessions = getReplaySessions();
      if (sessions.length === 0) return 0;
      
      let maxTimestamp = 0;
      sessions.forEach(session => {
        const sessionStartMs = session.startTimestampMs || 0;
        const trimEndMin = session.timelineEnd || session.s.dur;
        const effectiveEndMs = sessionStartMs + trimEndMin * 60000;
        maxTimestamp = Math.max(maxTimestamp, effectiveEndMs);
      });
      return maxTimestamp;
    }

    // playbackTimeMs is the current real-world timestamp being displayed
    let playbackTimeMs = 0;

    // Get the latest trim start across all replay sessions (so all boats are visible from the start)
    function getPlaybackStartTime() {
      const sessions = getReplaySessions();
      if (sessions.length === 0) return 0;
      
      // Find the latest effective start time across all sessions
      const referenceStartMs = getPlaybackStartTimeMs();  // Earliest absolute start
      let maxOffsetMin = 0;
      
      sessions.forEach(session => {
        const sessionStartMs = session.startTimestampMs || 0;
        const trimStartMin = session.timelineStart || 0;
        const effectiveStartMs = sessionStartMs + trimStartMin * 60000;
        // Calculate offset from reference (earliest) start
        const offsetMin = (effectiveStartMs - referenceStartMs) / 60000;
        maxOffsetMin = Math.max(maxOffsetMin, offsetMin);
      });
      
      return maxOffsetMin;  // Return offset where all boats have started
    }
    
    function getPlaybackDuration() {
      // Return duration in minutes
      const startMs = getPlaybackStartTimeMs();
      const endMs = getPlaybackEndTimeMs();
      return (endMs - startMs) / 60000;
    }

    function startRaceReplay() {
      if (selectedSessionsForReplay.size < 1) return;
      
      raceReplayMode = true;
      playbackTime = getPlaybackStartTime();  // Start at latest trim start
      isPlaying = false;
      currentLegIds = [];  // Reset leg tracking for fresh start
      currentBoatLegsData = [];  // Reset boat legs data
      lastValidBoatLegs = [];  // Reset last valid legs
      
      // Hide normal dashboard elements, show race replay
      // Keep timeline section visible for trimming
      document.getElementById('comparison-section').classList.add('hidden');
      document.getElementById('stats-and-tabs-section').classList.add('hidden');
      document.getElementById('stats-panel').classList.add('hidden');
      document.getElementById('race-replay-right-column').style.display = 'flex';
      document.getElementById('legs-comparison-section').classList.remove('hidden');
      document.getElementById('back-to-sessions-header-btn').classList.remove('hidden');
      
      // Expand container for full-width race replay
      document.querySelector('.container').style.maxWidth = 'none';
      document.querySelector('.container').style.padding = '0 24px';
      
      // Make map bigger for race replay
      const mapEl = document.getElementById('map');
      mapEl.setAttribute('width', '500');
      mapEl.setAttribute('height', '500');
      
      renderRaceReplay();
      renderTimeline();  // Re-render timelines with boat colors and pointers
      updatePlaybackUI();
      updateBoatInfoPanel();
      updateCurrentLegsPanel();
      resetMapZoom();  // Reset map to show all tracks
      renderMap();
      
      // Add keyboard listeners for race replay
      document.addEventListener('keydown', handleRaceReplayKeydown);
    }

    function exitRaceReplay() {
      stopPlayback();
      destroyRaceReplayCharts();  // Clean up leg charts
      currentLegIds = [];  // Reset leg tracking
      currentBoatLegsData = [];  // Reset boat legs data
      lastValidBoatLegs = [];  // Reset last valid legs
      raceReplayMode = false;
      playbackTime = 0;
      
      // Remove keyboard listeners
      document.removeEventListener('keydown', handleRaceReplayKeydown);
      
      // Show normal dashboard elements, hide race replay
      document.getElementById('comparison-section').classList.remove('hidden');
      document.getElementById('stats-and-tabs-section').classList.remove('hidden');
      document.getElementById('stats-panel').classList.remove('hidden');
      document.getElementById('race-replay-right-column').style.display = 'none';
      document.getElementById('legs-comparison-section').classList.add('hidden');
      document.getElementById('back-to-sessions-header-btn').classList.add('hidden');
      
      // Pause all videos
      pauseAllVideos();
      
      // Reset video display to placeholder
      resetVideoDisplay();
      
      // Restore container width
      document.querySelector('.container').style.maxWidth = '1400px';
      document.querySelector('.container').style.padding = '';
      
      // Restore map size
      const mapEl = document.getElementById('map');
      mapEl.setAttribute('width', '350');
      mapEl.setAttribute('height', '350');
      
      renderComparison();
      renderTimeline();  // Re-render timelines to remove boat colors and pointers
      fitMapToTrimmedTrack();
      renderMap();
    }

    function getReplaySessions() {
      return Array.from(selectedSessionsForReplay)
        .sort((a, b) => a - b)
        .map(idx => ALL_SESSIONS[idx])
        .filter(s => s);
    }

    function getPlaybackDuration() {
      const sessions = getReplaySessions();
      if (sessions.length === 0) return 0;
      
      // Find the earliest start and latest end across all sessions
      let minStart = Infinity;
      let maxEnd = 0;
      sessions.forEach(session => {
        const sessionStart = session.timelineStart || 0;
        const sessionEnd = session.timelineEnd || session.s.dur;
        minStart = Math.min(minStart, sessionStart);
        maxEnd = Math.max(maxEnd, sessionEnd);
      });
      
      // Duration is from earliest start to latest end
      return maxEnd;
    }

    function renderRaceReplay() {
      const container = document.getElementById('race-replay-section');
      if (!container) return;
      
      const sessions = getReplaySessions();
      const duration = getPlaybackDuration();
      
      container.innerHTML = `
        <div class="race-replay-container" style="display:flex;align-items:center;gap:12px;flex-wrap:nowrap;">
          <div class="race-replay-title">üèÅ ${sessions.length} Boat${sessions.length !== 1 ? 's' : ''}</div>
          <button class="btn btn-play" id="playback-btn" onclick="togglePlayback()">‚ñ∂ Play</button>
          <div style="display:flex;gap:2px;align-items:center;">
            <button class="speed-btn active" data-speed="1" onclick="setPlaybackSpeed(1)">1√ó</button>
            <button class="speed-btn" data-speed="2" onclick="setPlaybackSpeed(2)">2√ó</button>
            <button class="speed-btn" data-speed="4" onclick="setPlaybackSpeed(4)">4√ó</button>
            <button class="speed-btn" data-speed="8" onclick="setPlaybackSpeed(8)">8√ó</button>
            <button class="speed-btn" data-speed="16" onclick="setPlaybackSpeed(16)">16√ó</button>
          </div>
          <button class="fs-overlay-btn" onclick="decreaseWidgetScale()" style="font-size:11px;padding:2px 6px;background:#374151;color:#9ca3af;border:1px solid #4b5563;border-radius:3px;cursor:pointer;display:none;" title="Decrease overlay size">‚àí</button>
          <button class="fs-overlay-btn" onclick="resetWidgetOverlays()" style="font-size:9px;padding:2px 6px;background:#374151;color:#9ca3af;border:1px solid #4b5563;border-radius:3px;cursor:pointer;white-space:nowrap;display:none;" title="Reset overlay widgets to default position and size">Reset overlays</button>
          <button class="fs-overlay-btn" onclick="increaseWidgetScale()" style="font-size:11px;padding:2px 6px;background:#374151;color:#9ca3af;border:1px solid #4b5563;border-radius:3px;cursor:pointer;display:none;" title="Increase overlay size">+</button>
          <div class="status-dot" style="width:10px;height:10px;border-radius:50%;background:#22c55e;flex-shrink:0;display:none;"></div>
          <div class="timeline-wrapper">
            <div class="video-coverage-bar" id="video-coverage-bar"></div>
            <div class="playback-timeline" id="playback-timeline">
              <div class="playback-progress" id="playback-progress" style="width:0%"></div>
              <div class="playback-handle" id="playback-handle" style="left:0%"></div>
            </div>
          </div>
          <div class="playback-time" id="playback-time" style="font-size:11px;white-space:nowrap;">0:00 / ${formatPlaybackTime(duration)}</div>
        </div>
      `;
      
      // Initialize playback listeners
      initPlaybackListeners();
      updatePlaybackUI();
      
      // Render video timeline markers if videos are loaded
      renderVideoTimelineMarkers();
      updateActiveVideoDisplay();
    }
    
    function toggleHideGrayTracksMap() {
      const toggle = document.getElementById('hide-gray-tracks-map');
      const slider = document.getElementById('hide-gray-slider');
      const track = toggle.nextElementSibling;
      
      hideGrayTracks = toggle ? toggle.checked : false;
      
      if (slider && track) {
        if (hideGrayTracks) {
          slider.style.transform = 'translateX(14px)';
          track.style.backgroundColor = '#7c3aed';
        } else {
          slider.style.transform = 'translateX(0)';
          track.style.backgroundColor = '#ccc';
        }
      }
      
      renderMap();  // Re-render map with new setting
      renderVideoMinimap();  // Re-render minimap too
    }
    
    function resetWidgetOverlays() {
      // Reset all widget states to default
      Object.keys(widgetState).forEach(widgetId => {
        widgetState[widgetId] = { minimized: false, x: null, y: null, dragged: false, width: null, height: null, resized: false };
        
        const widget = document.getElementById(widgetId);
        if (!widget) return;
        
        // Remove dragged class and inline styles
        widget.classList.remove('dragged', 'minimized');
        widget.style.top = '';
        widget.style.left = '';
        widget.style.bottom = '';
        widget.style.right = '';
        widget.style.transform = '';
        widget.style.width = '';
        widget.style.height = '';
        
        // Update minimize button (‚ñº = expanded)
        const btn = widget.querySelector('.fs-minimize-btn');
        if (btn) {
          btn.textContent = '‚ñº';
        }
      });
      
      // Reset leg2 telemetry font size
      const leg2Panel = document.getElementById('minimap-leg2-telemetry');
      if (leg2Panel) {
        leg2Panel.style.fontSize = '';
      }
      const leg2Label = document.getElementById('telem-leg2-label');
      if (leg2Label) {
        leg2Label.style.fontSize = '';
      }
      
      // Reset widget scale to default
      widgetScale = 1.0;
      applyWidgetScale();
      
      // Re-render minimap
      renderVideoMinimap();
    }

    function togglePlayback() {
      if (isPlaying) {
        stopPlayback();
      } else {
        startPlayback();
      }
    }

    function startPlayback() {
      if (!raceReplayMode) return;
      
      const duration = getPlaybackDuration();
      const startTime = getPlaybackStartTime();
      
      if (playbackTime >= duration) {
        playbackTime = startTime;  // Reset to earliest start
      }
      
      isPlaying = true;
      playbackLastFrameTime = 0;  // Will be set on first frame
      // Update all playback buttons (main and fullscreen)
      document.querySelectorAll('#playback-btn').forEach(btn => {
        btn.textContent = '‚è∏ Pause';
        btn.classList.add('playing');
      });
      playbackAnimationId = requestAnimationFrame(playbackLoop);
      
      // Start videos
      playAllVideos();
    }

    function stopPlayback() {
      isPlaying = false;
      // Update all playback buttons (main and fullscreen)
      document.querySelectorAll('#playback-btn').forEach(btn => {
        btn.textContent = '‚ñ∂ Play';
        btn.classList.remove('playing');
      });
      if (playbackAnimationId) {
        cancelAnimationFrame(playbackAnimationId);
        playbackAnimationId = null;
      }
      
      // Pause videos
      pauseAllVideos();
    }

    let lastRenderTime = 0;
    const RENDER_INTERVAL = 100; // Render at most every 100ms (10fps) to give priority to video
    
    // Check if video is currently playing
    function isVideoPlaying() {
      return currentActiveVideo && !currentActiveVideo.element.paused;
    }
    
    function playbackLoop(timestamp) {
      if (!isPlaying) return;
      
      // First frame - initialize timestamp
      if (playbackLastFrameTime === 0) {
        playbackLastFrameTime = timestamp;
        lastRenderTime = timestamp;
        playbackAnimationId = requestAnimationFrame(playbackLoop);
        return;
      }
      
      const elapsed = (timestamp - playbackLastFrameTime) / 1000;  // seconds
      playbackLastFrameTime = timestamp;
      
      // Skip if elapsed is too large (tab was inactive) or negative
      if (elapsed > 0.5 || elapsed < 0) {
        playbackAnimationId = requestAnimationFrame(playbackLoop);
        return;
      }
      
      // If video is stalled, don't advance playback time - wait for video to catch up
      if (videoStalled && currentActiveVideo) {
        // Continue the animation loop but don't advance time
        playbackAnimationId = requestAnimationFrame(playbackLoop);
        return;
      }
      
      // Advance playback time (convert seconds to minutes, apply speed multiplier)
      playbackTime += (elapsed * playbackSpeed) / 60;
      
      const duration = getPlaybackDuration();
      if (playbackTime >= duration) {
        playbackTime = duration;
        stopPlayback();
        updatePlaybackUI();
        updateBoatInfoPanel();
        updateCurrentLegsPanel();
        updateTimelinePlaybackPointer();
        renderMap();
        return;
      }
      
      // Update UI on every frame
      updatePlaybackUI();
      
      // Use longer intervals when video is playing to reduce CPU competition
      const effectiveRenderInterval = isVideoPlaying() ? 200 : RENDER_INTERVAL;
      const CHART_UPDATE_INTERVAL = isVideoPlaying() ? 1000 : 500;
      
      if (timestamp - lastRenderTime >= effectiveRenderInterval) {
        lastRenderTime = timestamp;
        
        // Check if we need to switch videos
        const targetVideo = getCurrentOrNextVideo();
        if (targetVideo !== currentActiveVideo) {
          updateActiveVideoDisplay();
        } else {
          // Update video time display (lightweight operation)
          updateVideoOverlays();
        }
        
        // Use idle callback for heavy renders when video is playing
        if (isVideoPlaying() && window.requestIdleCallback) {
          requestIdleCallback(() => {
            updateBoatInfoPanel();
            updateTimelinePlaybackPointer();
            renderMap();
          }, { timeout: 300 });
        } else {
          updateBoatInfoPanel();
          updateTimelinePlaybackPointer();
          renderMap();
        }
      }
      
      // Update leg charts less frequently
      if (!window.lastChartRenderTime) window.lastChartRenderTime = 0;
      if (timestamp - window.lastChartRenderTime >= CHART_UPDATE_INTERVAL) {
        window.lastChartRenderTime = timestamp;
        
        if (isVideoPlaying() && window.requestIdleCallback) {
          requestIdleCallback(() => {
            updateCurrentLegsPanel();
            updateChartTimePointers();
          }, { timeout: 500 });
        } else {
          updateCurrentLegsPanel();
          updateChartTimePointers();
        }
      }
      
      if (isPlaying) {
        playbackAnimationId = requestAnimationFrame(playbackLoop);
      }
    }

    function setPlaybackSpeed(speed) {
      playbackSpeed = speed;
      document.querySelectorAll('.speed-btn').forEach(btn => {
        btn.classList.toggle('active', parseInt(btn.dataset.speed) === speed);
      });
      
      // Update video mute and playback rate
      updateVideoPlaybackRate();
    }

    function handleRaceReplayKeydown(e) {
      if (!raceReplayMode) return;
      
      const startTime = getPlaybackStartTime();
      const duration = getPlaybackDuration();
      const stepSize = 10 / 60;  // 10 seconds in minutes
      
      if (e.code === 'Space') {
        e.preventDefault();
        togglePlayback();
      } else if (e.code === 'KeyF') {
        e.preventDefault();
        toggleVideoFullscreen();
      } else if (e.code === 'ArrowRight') {
        e.preventDefault();
        playbackTime = Math.min(duration, playbackTime + stepSize);
        updatePlaybackUI();
        updateBoatInfoPanel();
        updateCurrentLegsPanel();
        updateChartTimePointers();
        updateTimelinePlaybackPointer();
        renderMap();
        syncVideosToPlayback(true);  // Force seek on manual scrub
      } else if (e.code === 'ArrowLeft') {
        e.preventDefault();
        playbackTime = Math.max(startTime, playbackTime - stepSize);
        updatePlaybackUI();
        updateBoatInfoPanel();
        updateCurrentLegsPanel();
        updateChartTimePointers();
        updateTimelinePlaybackPointer();
        renderMap();
        syncVideosToPlayback(true);  // Force seek on manual scrub
      }
    }

    function updatePlaybackUI() {
      const duration = getPlaybackDuration();
      const startTime = getPlaybackStartTime();
      const range = duration - startTime;
      const progress = range > 0 ? ((playbackTime - startTime) / range) * 100 : 0;
      
      // Update all matching elements (main and fullscreen)
      document.querySelectorAll('#playback-progress').forEach(el => {
        el.style.width = `${Math.max(0, Math.min(100, progress))}%`;
      });
      document.querySelectorAll('#playback-handle').forEach(el => {
        el.style.left = `${Math.max(0, Math.min(100, progress))}%`;
      });
      document.querySelectorAll('#playback-time').forEach(el => {
        el.textContent = `${formatPlaybackTime(playbackTime)} / ${formatPlaybackTime(duration)}`;
      });
    }

    function formatPlaybackTime(minutes) {
      const m = Math.floor(minutes);
      const s = Math.floor((minutes - m) * 60);
      return `${m}:${s.toString().padStart(2, '0')}`;
    }

    function initPlaybackListeners() {
      const timeline = document.getElementById('playback-timeline');
      const handle = document.getElementById('playback-handle');
      const coverageBar = document.getElementById('video-coverage-bar');
      
      if (!timeline || !handle) return;
      
      // Remove old listeners by cloning
      const newTimeline = timeline.cloneNode(true);
      timeline.parentNode.replaceChild(newTimeline, timeline);
      
      const newHandle = newTimeline.querySelector('#playback-handle');
      
      newHandle.addEventListener('mousedown', handleTimelineDragStart);
      newHandle.addEventListener('touchstart', handleTimelineTouchStart, { passive: false });
      newTimeline.addEventListener('click', handleTimelineClick);
      newTimeline.addEventListener('touchend', handleTimelineTouchEnd, { passive: false });
      
      // Add click listener to coverage bar
      if (coverageBar) {
        coverageBar.addEventListener('click', handleTimelineClick);
        coverageBar.addEventListener('touchend', handleTimelineTouchEnd, { passive: false });
      }
    }
    
    function handleTimelineDragStart(e) {
      e.preventDefault();
      e.stopPropagation();
      isDraggingPlayback = true;
    }
    
    function handleTimelineTouchStart(e) {
      e.preventDefault();
      e.stopPropagation();
      isDraggingPlayback = true;
    }
    
    function handleTimelineTouchEnd(e) {
      if (e.target.id === 'playback-handle') {
        isDraggingPlayback = false;
        return;
      }
      const touch = e.changedTouches[0];
      if (!touch) return;
      const timeline = e.currentTarget;
      const rect = timeline.getBoundingClientRect();
      const pct = Math.max(0, Math.min(1, (touch.clientX - rect.left) / rect.width));
      const startTime = getPlaybackStartTime();
      const duration = getPlaybackDuration();
      playbackTime = startTime + pct * (duration - startTime);
      updatePlaybackUI();
      updateBoatInfoPanel();
      updateCurrentLegsPanel();
      updateChartTimePointers();
      updateTimelinePlaybackPointer();
      renderMap();
      syncVideosToPlayback(true);
    }
    
    function handleTimelineClick(e) {
      if (e.target.id === 'playback-handle') return;
      const timeline = e.currentTarget;
      const rect = timeline.getBoundingClientRect();
      const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      const startTime = getPlaybackStartTime();
      const duration = getPlaybackDuration();
      playbackTime = startTime + pct * (duration - startTime);
      updatePlaybackUI();
      updateBoatInfoPanel();
      updateCurrentLegsPanel();
      updateChartTimePointers();
      updateTimelinePlaybackPointer();
      renderMap();
      syncVideosToPlayback(true);  // Force seek on click
    }
    
    // Global mouse handlers for playback drag
    document.addEventListener('mousemove', (e) => {
      if (!isDraggingPlayback) return;
      // Find visible timeline (main or fullscreen)
      let timeline = document.getElementById('playback-timeline');
      const replayControls = document.getElementById('video-replay-controls');
      if (replayControls && replayControls.style.display !== 'none') {
        const fsTimeline = replayControls.querySelector('.playback-timeline');
        if (fsTimeline) timeline = fsTimeline;
      }
      if (!timeline) return;
      const rect = timeline.getBoundingClientRect();
      const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      const startTime = getPlaybackStartTime();
      const duration = getPlaybackDuration();
      playbackTime = startTime + pct * (duration - startTime);
      updatePlaybackUI();
      updateBoatInfoPanel();
      updateCurrentLegsPanel();
      updateChartTimePointers();
      updateTimelinePlaybackPointer();
      renderMap();
      syncVideosToPlayback(true);  // Force seek on drag
    });
    
    document.addEventListener('mouseup', () => {
      isDraggingPlayback = false;
    });
    
    // Touch event handlers for mobile timeline scrubbing
    document.addEventListener('touchmove', (e) => {
      if (!isDraggingPlayback) return;
      const touch = e.touches[0];
      if (!touch) return;
      
      // Find visible timeline (main or fullscreen)
      let timeline = document.getElementById('playback-timeline');
      const replayControls = document.getElementById('video-replay-controls');
      if (replayControls && replayControls.style.display !== 'none') {
        const fsTimeline = replayControls.querySelector('.playback-timeline');
        if (fsTimeline) timeline = fsTimeline;
      }
      if (!timeline) return;
      const rect = timeline.getBoundingClientRect();
      const pct = Math.max(0, Math.min(1, (touch.clientX - rect.left) / rect.width));
      const startTime = getPlaybackStartTime();
      const duration = getPlaybackDuration();
      playbackTime = startTime + pct * (duration - startTime);
      updatePlaybackUI();
      updateBoatInfoPanel();
      updateCurrentLegsPanel();
      updateChartTimePointers();
      updateTimelinePlaybackPointer();
      renderMap();
      syncVideosToPlayback(true);
    }, { passive: true });
    
    document.addEventListener('touchend', () => {
      isDraggingPlayback = false;
    });

    // Convert global playbackTime to session-local time in minutes
    function getSessionLocalTime(session, globalPlaybackTime) {
      const referenceStartMs = getPlaybackStartTimeMs();
      const currentTimeMs = referenceStartMs + globalPlaybackTime * 60000;
      const sessionStartMs = session.startTimestampMs || 0;
      return (currentTimeMs - sessionStartMs) / 60000;
    }

    function getBoatPositionAtTime(session, globalTimeMin) {
      if (!session || !session.track || session.track.length === 0) return null;
      
      // Convert global time to session-local time
      const sessionLocalTime = getSessionLocalTime(session, globalTimeMin);
      
      const sessionStart = session.timelineStart || 0;
      const sessionEnd = session.timelineEnd || session.s.dur;
      
      // Check if time is within session bounds (in session-local coordinates)
      if (sessionLocalTime < sessionStart || sessionLocalTime > sessionEnd) return null;
      
      // Convert from session-local time to track-relative time
      // Track t values start from 0 (relative to trimmed start)
      const trackTime = sessionLocalTime - sessionStart;
      
      // Find closest track point
      let closestIdx = 0;
      let minDiff = Infinity;
      
      for (let i = 0; i < session.track.length; i++) {
        const diff = Math.abs(session.track[i].t - trackTime);
        if (diff < minDiff) {
          minDiff = diff;
          closestIdx = i;
        }
      }
      
      if (minDiff > 2) return null;
      
      const p = session.track[closestIdx];
      const twd = session.s.twd || 0;
      const twa = Math.abs(angleDiff(p.hdg || p.cog, twd));
      const vmg = Math.abs((p.sog || 0) * Math.cos(twa * Math.PI / 180));
      
      return {
        lat: p.lat,
        lon: p.lon,
        sog: p.sog || 0,
        cog: p.cog || 0,
        hdg: p.hdg || p.cog || 0,
        vmg: vmg,
        twa: twa,
        heel: p.roll_deg || 0,
        t: p.t
      };
    }
    
    // Get smoothed telemetry over a time window (in minutes)
    function getSmoothedTelemetry(session, globalTimeMin, windowSec = 2) {
      if (!session || !session.track || session.track.length === 0) return null;
      
      const sessionLocalTime = getSessionLocalTime(session, globalTimeMin);
      const sessionStart = session.timelineStart || 0;
      const sessionEnd = session.timelineEnd || session.s.dur;
      
      if (sessionLocalTime < sessionStart || sessionLocalTime > sessionEnd) return null;
      
      const trackTime = sessionLocalTime - sessionStart;
      const windowMin = windowSec / 60;
      
      // Find points within the window
      const windowStart = trackTime - windowMin;
      const windowEnd = trackTime;
      
      const pointsInWindow = session.track.filter(p => 
        p.t >= windowStart && p.t <= windowEnd
      );
      
      if (pointsInWindow.length === 0) {
        // Fall back to single point
        const pos = getBoatPositionAtTime(session, globalTimeMin);
        if (pos) pos.steeringRate = 0;
        return pos;
      }
      
      // Calculate averages
      const twd = session.s.twd || 0;
      let sogSum = 0, vmgSum = 0, heelSum = 0;
      let hdgSin = 0, hdgCos = 0;
      
      // Calculate steering rate (heading change rate)
      let steeringRateSum = 0;
      let steeringCount = 0;
      
      pointsInWindow.forEach((p, i) => {
        sogSum += p.sog || 0;
        heelSum += p.roll_deg || 0;
        const hdgRad = (p.hdg || p.cog || 0) * Math.PI / 180;
        hdgSin += Math.sin(hdgRad);
        hdgCos += Math.cos(hdgRad);
        
        const twa = Math.abs(angleDiff(p.hdg || p.cog, twd));
        vmgSum += Math.abs((p.sog || 0) * Math.cos(twa * Math.PI / 180));
        
        // Calculate steering rate between consecutive points
        if (i > 0) {
          const prevP = pointsInWindow[i - 1];
          const dt = (p.t - prevP.t) * 60; // Convert minutes to seconds
          if (dt > 0) {
            const hdgChange = Math.abs(angleDiff(p.hdg || p.cog, prevP.hdg || prevP.cog));
            steeringRateSum += hdgChange / dt;
            steeringCount++;
          }
        }
      });
      
      const n = pointsInWindow.length;
      const avgHdg = Math.atan2(hdgSin / n, hdgCos / n) * 180 / Math.PI;
      const avgSteeringRate = steeringCount > 0 ? steeringRateSum / steeringCount : 0;
      
      return {
        sog: sogSum / n,
        vmg: vmgSum / n,
        hdg: (avgHdg + 360) % 360,
        heel: heelSum / n,
        steeringRate: avgSteeringRate
      };
    }

    function getCurrentLegAtTime(session, globalTimeMin) {
      if (!session || !session.legs) return null;
      
      // Convert global time to session-local time
      const sessionLocalTime = getSessionLocalTime(session, globalTimeMin);
      
      const sessionStart = session.timelineStart || 0;
      // Leg start/end times are relative to the trimmed track (starting from 0)
      const trackTime = sessionLocalTime - sessionStart;
      
      for (const leg of session.legs) {
        if (trackTime >= leg.start && trackTime <= leg.end) {
          return leg;
        }
      }
      return null;
    }

    function updateBoatInfoPanel() {
      const sessions = getReplaySessions();
      
      sessions.forEach((session, i) => {
        const pos = getBoatPositionAtTime(session, playbackTime);
        const sogEl = document.getElementById(`boat-${i}-sog`);
        const vmgEl = document.getElementById(`boat-${i}-vmg`);
        const cogEl = document.getElementById(`boat-${i}-cog`);
        
        if (pos) {
          if (sogEl) sogEl.textContent = `${(pos.sog || 0).toFixed(1)}kt`;
          if (vmgEl) vmgEl.textContent = `${(pos.vmg || 0).toFixed(1)}kt`;
          if (cogEl) cogEl.textContent = `${Math.round(pos.cog || 0)}¬∞`;
        } else {
          if (sogEl) sogEl.textContent = '-';
          if (vmgEl) vmgEl.textContent = '-';
          if (cogEl) cogEl.textContent = '-';
        }
      });
    }

    // Store race replay leg charts
    let raceReplayLegCharts = {};
    // Track current leg IDs to avoid unnecessary rebuilds
    let currentLegIds = [];
    // Track sessions for time pointer updates
    let currentBoatLegsData = [];
    // Store last valid legs for each boat (to show during transitions)
    let lastValidBoatLegs = [];

    function destroyRaceReplayCharts() {
      Object.values(raceReplayLegCharts).forEach(chart => {
        if (chart) chart.destroy();
      });
      raceReplayLegCharts = {};
    }

    function updateChartTimePointers() {
      // Update time pointer annotations on existing charts without rebuilding
      if (currentBoatLegsData.length === 0) return;
      
      currentBoatLegsData.forEach(({ session, leg, idx }) => {
        if (!leg || !leg.ts || leg.ts.length === 0) return;
        
        // Calculate current time position within the leg
        const sessionLocalTime = getSessionLocalTime(session, playbackTime);
        const sessionStart = session.timelineStart || 0;
        const trackTime = sessionLocalTime - sessionStart;
        
        // Find the index in ts array closest to current time
        let timePointerIdx = null;
        if (trackTime >= leg.start && trackTime <= leg.end) {
          let minDiff = Infinity;
          for (let i = 0; i < leg.ts.length; i++) {
            const diff = Math.abs(leg.ts[i].t - trackTime);
            if (diff < minDiff) {
              minDiff = diff;
              timePointerIdx = i;
            }
          }
        }
        
        // Update each chart's annotation
        ['rate', 'cog', 'heel', 'spd'].forEach(chartType => {
          const chart = raceReplayLegCharts[`${chartType}-${idx}`];
          if (chart && chart.options.plugins.annotation) {
            if (timePointerIdx !== null) {
              chart.options.plugins.annotation.annotations.timePointer = {
                type: 'line',
                xMin: timePointerIdx,
                xMax: timePointerIdx,
                borderColor: '#ef4444',
                borderWidth: 2,
                borderDash: [3, 3]
              };
            } else {
              delete chart.options.plugins.annotation.annotations.timePointer;
            }
            chart.update('none');  // Update without animation
          }
        });
      });
    }

    function updateCurrentLegsPanel() {
      const container = document.getElementById('current-legs-content');
      if (!container) return;
      
      const sessions = getReplaySessions();
      const posColors = { upwind: '#22c55e', reaching: '#3b82f6', downwind: '#f59e0b' };
      const posNames = { upwind: 'Upwind', reaching: 'Reaching', downwind: 'Downwind' };
      
      // Get current leg for each session, fall back to last valid leg
      const boatLegs = sessions.map((session, i) => {
        const color = BOAT_COLORS[i % BOAT_COLORS.length];
        const boatSymbol = getBoatSymbol(session.filename);
        let leg = getCurrentLegAtTime(session, playbackTime);
        let isStale = false;
        
        // If no current leg, use last valid leg for this boat
        if (!leg && lastValidBoatLegs[i]) {
          leg = lastValidBoatLegs[i];
          isStale = true;  // Mark as showing previous data
        }
        
        // Update last valid leg if we have a current one
        if (leg && !isStale) {
          lastValidBoatLegs[i] = leg;
        }
        
        return { session, color, boatSymbol, leg, idx: i, isStale };
      });
      
      // Check if legs have changed - only rebuild if different
      const newLegIds = boatLegs.map(b => b.leg ? `${b.leg.id}-${b.isStale}` : null);
      const legsChanged = newLegIds.length !== currentLegIds.length || 
                          newLegIds.some((id, i) => id !== currentLegIds[i]);
      
      if (!legsChanged) {
        return;  // Same legs, no need to rebuild
      }
      
      currentLegIds = newLegIds;
      currentBoatLegsData = boatLegs;  // Save for time pointer updates
      
      // Destroy previous charts only when rebuilding
      destroyRaceReplayCharts();
      
      // Check if any boat has a leg (current or stale)
      const hasAnyLeg = boatLegs.some(b => b.leg);
      
      if (!hasAnyLeg) {
        container.innerHTML = '<div style="color:#9ca3af;text-align:center;padding:12px;min-height:240px;display:flex;align-items:center;justify-content:center;">No leg data available</div>';
        return;
      }
      
      // Build side-by-side detailed leg views
      const cardCount = boatLegs.length;
      let html = '<div style="display:flex;gap:12px;min-height:240px;width:100%;box-sizing:border-box;">';
      
      boatLegs.forEach(({ session, color, boatSymbol, leg, idx, isStale }) => {
        if (!leg) {
          // This should rarely happen now with lastValidBoatLegs fallback
          html += `
            <div style="flex:1 1 0;min-width:0;min-height:220px;background:#f9fafb;border-radius:8px;padding:12px;border-top:3px solid ${color};opacity:0.5;display:flex;flex-direction:column;overflow:hidden;">
              <div style="display:flex;align-items:center;gap:6px;margin-bottom:8px;">
                <div style="width:20px;height:20px;background:${color};border-radius:50%;display:flex;align-items:center;justify-content:center;color:white;font-size:10px;font-weight:bold;">${idx+1}</div>
                <span style="font-weight:600;color:${color};">${boatSymbol}</span>
              </div>
              <div style="color:#9ca3af;text-align:center;flex:1;display:flex;align-items:center;justify-content:center;">Waiting for data...</div>
            </div>
          `;
          return;
        }
        
        const posBadge = leg.pos === 'upwind' ? 'badge-up' : leg.pos === 'reaching' ? 'badge-reach' : 'badge-down';
        const staleOpacity = isStale ? 'opacity:0.6;' : '';
        const staleIndicator = isStale ? '<span style="font-size:8px;color:#9ca3af;margin-left:4px;">(prev)</span>' : '';
        
        // Safe access to leg properties
        const dur = leg.dur != null ? `${leg.dur}s` : '-';
        const rate = leg.rate != null ? leg.rate.toFixed(2) : '-';
        const corridor = leg.corridor != null ? `¬±${leg.corridor.toFixed(1)}¬∞` : '-';
        const devPct = leg.lineDeviation != null ? `${(leg.lineDeviation * 100).toFixed(1)}%` : '-';
        const speed = leg.speed != null ? leg.speed : '-';
        const vmg = leg.vmg != null ? leg.vmg : '-';
        const hdg = leg.hdg != null ? `${leg.hdg}¬∞` : '-';
        const twa = leg.twa != null ? `${leg.twa}¬∞` : '-';
        const twd = leg.localWind != null ? `${leg.localWind}¬∞` : (session.s.twd != null ? `${session.s.twd}¬∞` : '-');
        const heel = leg.heel != null ? `${leg.heel}¬∞` : '-';
        
        // Rate/Corridor colors
        const rateVal = leg.rate || 0;
        const rateColor = rateVal <= 2 ? '#22c55e' : rateVal <= 4 ? '#84cc16' : rateVal <= 6 ? '#eab308' : rateVal <= 10 ? '#f97316' : '#ef4444';
        const corrVal = leg.corridor || 0;
        const corrColor = corrVal <= 5 ? '#22c55e' : corrVal <= 10 ? '#84cc16' : corrVal <= 15 ? '#eab308' : corrVal <= 20 ? '#f97316' : '#ef4444';
        
        // Next maneuver badge
        let nextBadge = '<span style="color:#9ca3af;">‚Äî</span>';
        if (leg.next_maneuver) {
          const bgColor = leg.next_maneuver.type === 'tack' ? '#dbeafe' : '#fef3c7';
          const textColor = leg.next_maneuver.type === 'tack' ? '#1d4ed8' : '#b45309';
          nextBadge = `<span style="background:${bgColor};color:${textColor};padding:2px 6px;border-radius:3px;font-weight:600;">${leg.next_maneuver.type === 'tack' ? 'T' : 'G'}${leg.next_maneuver.angle}¬∞</span>`;
        }
        
        html += `
          <div style="flex:1 1 0;min-width:0;background:#f9fafb;border-radius:8px;padding:12px;border-top:3px solid ${color};${staleOpacity}overflow:hidden;">
            <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">
              <div style="display:flex;align-items:center;gap:6px;">
                <div style="width:20px;height:20px;background:${color};border-radius:50%;display:flex;align-items:center;justify-content:center;color:white;font-size:10px;font-weight:bold;">${idx+1}</div>
                <span style="font-weight:600;color:${color};">${boatSymbol}</span>
              </div>
              <span class="badge ${posBadge}">Leg #${leg.id} ${posNames[leg.pos]}${staleIndicator}</span>
            </div>
            
            <!-- Stats grid -->
            <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:6px;margin-bottom:8px;">
              <div style="background:white;border-radius:4px;padding:6px;text-align:center;">
                <div style="font-size:9px;color:#6b7280;">TWD/Hdg/TWA</div>
                <div style="font-weight:600;font-size:10px;">${twd}/${hdg}/${twa}</div>
              </div>
              <div style="background:white;border-radius:4px;padding:6px;text-align:center;">
                <div style="font-size:9px;color:#6b7280;">Spd/VMG</div>
                <div style="font-weight:600;font-size:11px;">${speed}/${vmg}</div>
              </div>
              <div style="background:white;border-radius:4px;padding:6px;text-align:center;">
                <div style="font-size:9px;color:#6b7280;">Duration</div>
                <div style="font-weight:600;font-size:11px;">${dur}</div>
              </div>
              <div style="background:white;border-radius:4px;padding:6px;text-align:center;">
                <div style="font-size:9px;color:#6b7280;">Next</div>
                <div style="font-weight:600;font-size:11px;">${nextBadge}</div>
              </div>
            </div>
            
            <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:6px;margin-bottom:8px;">
              <div style="background:white;border-radius:4px;padding:6px;text-align:center;">
                <div style="font-size:9px;color:#6b7280;">Rate</div>
                <div style="font-weight:600;font-size:11px;color:${rateColor};">${rate}¬∞/s</div>
              </div>
              <div style="background:white;border-radius:4px;padding:6px;text-align:center;">
                <div style="font-size:9px;color:#6b7280;">COG Corr</div>
                <div style="font-weight:600;font-size:11px;color:${corrColor};">${corridor}</div>
              </div>
              <div style="background:white;border-radius:4px;padding:6px;text-align:center;">
                <div style="font-size:9px;color:#6b7280;">Deviation</div>
                <div style="font-weight:600;font-size:11px;">${devPct}</div>
              </div>
              <div style="background:white;border-radius:4px;padding:6px;text-align:center;">
                <div style="font-size:9px;color:#6b7280;">Heel</div>
                <div style="font-weight:600;font-size:11px;">${heel}</div>
              </div>
            </div>
            
            <!-- Charts -->
            <div style="margin-top:10px;">
              <div style="font-size:9px;color:#6b7280;margin-bottom:2px;">Steering Rate</div>
              <div style="height:50px;position:relative;width:100%;"><canvas id="race-leg-rate-${idx}"></canvas></div>
            </div>
            <div style="margin-top:8px;">
              <div style="font-size:9px;color:#6b7280;margin-bottom:2px;">COG Deviation</div>
              <div style="height:50px;position:relative;width:100%;"><canvas id="race-leg-cog-${idx}"></canvas></div>
            </div>
            <div style="margin-top:8px;">
              <div style="font-size:9px;color:#6b7280;margin-bottom:2px;">Heel</div>
              <div style="height:50px;position:relative;width:100%;"><canvas id="race-leg-heel-${idx}"></canvas></div>
            </div>
            <div style="margin-top:8px;">
              <div style="font-size:9px;color:#6b7280;margin-bottom:2px;">Speed/VMG</div>
              <div style="height:50px;position:relative;width:100%;"><canvas id="race-leg-spd-${idx}"></canvas></div>
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      container.innerHTML = html;
      
      // Render charts for each boat
      boatLegs.forEach(({ session, color, leg, idx }) => {
        if (!leg || !leg.ts || leg.ts.length === 0) return;
        
        const labels = leg.ts.map(p => p.t.toFixed(1));
        
        // Calculate current time position within the leg for the time pointer
        const sessionLocalTime = getSessionLocalTime(session, playbackTime);
        const sessionStart = session.timelineStart || 0;
        const trackTime = sessionLocalTime - sessionStart;
        
        // Find the index in ts array closest to current time
        let timePointerIdx = null;
        if (trackTime >= leg.start && trackTime <= leg.end) {
          let minDiff = Infinity;
          for (let i = 0; i < leg.ts.length; i++) {
            const diff = Math.abs(leg.ts[i].t - trackTime);
            if (diff < minDiff) {
              minDiff = diff;
              timePointerIdx = i;
            }
          }
        }
        
        // Time pointer annotation - always include structure for updates
        const timePointerAnnotation = {
          annotation: {
            annotations: timePointerIdx !== null ? {
              timePointer: {
                type: 'line',
                xMin: timePointerIdx,
                xMax: timePointerIdx,
                borderColor: '#ef4444',
                borderWidth: 2,
                borderDash: [3, 3]
              }
            } : {}
          }
        };
        
        const chartOptions = {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          plugins: { 
            legend: { display: false },
            ...timePointerAnnotation
          },
          scales: {
            x: { display: false },
            y: { 
              display: true,
              ticks: { font: { size: 8 }, maxTicksLimit: 3 },
              grid: { display: false }
            }
          },
          elements: { point: { radius: 0 } }
        };
        
        // Rate chart
        const rateCtx = document.getElementById(`race-leg-rate-${idx}`);
        if (rateCtx) {
          raceReplayLegCharts[`rate-${idx}`] = new Chart(rateCtx.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: leg.ts.map(p => p.rate),
                borderColor: color,
                backgroundColor: `${color}20`,
                borderWidth: 1.5,
                tension: 0.3,
                fill: true
              }]
            },
            options: {
              ...chartOptions,
              scales: {
                ...chartOptions.scales,
                y: { ...chartOptions.scales.y, min: 0, max: 10 }
              }
            }
          });
        }
        
        // COG deviation chart
        const cogCtx = document.getElementById(`race-leg-cog-${idx}`);
        if (cogCtx) {
          raceReplayLegCharts[`cog-${idx}`] = new Chart(cogCtx.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: leg.ts.map(p => p.dev),
                borderColor: color,
                backgroundColor: `${color}20`,
                borderWidth: 1.5,
                tension: 0.3,
                fill: true
              }]
            },
            options: {
              ...chartOptions,
              scales: {
                ...chartOptions.scales,
                y: { ...chartOptions.scales.y, min: -20, max: 20 }
              }
            }
          });
        }
        
        // Heel chart
        const heelCtx = document.getElementById(`race-leg-heel-${idx}`);
        if (heelCtx && leg.ts.some(p => p.heel != null)) {
          raceReplayLegCharts[`heel-${idx}`] = new Chart(heelCtx.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [{
                data: leg.ts.map(p => p.heel),
                borderColor: '#f59e0b',
                backgroundColor: '#f59e0b20',
                borderWidth: 1.5,
                tension: 0.3,
                fill: true
              }]
            },
            options: {
              ...chartOptions,
              scales: {
                ...chartOptions.scales,
                y: { ...chartOptions.scales.y, min: -25, max: 25 }
              }
            }
          });
        }
        
        // Speed/VMG chart
        const spdCtx = document.getElementById(`race-leg-spd-${idx}`);
        if (spdCtx) {
          raceReplayLegCharts[`spd-${idx}`] = new Chart(spdCtx.getContext('2d'), {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  data: leg.ts.map(p => p.spd),
                  borderColor: '#3b82f6',
                  borderWidth: 1.5,
                  tension: 0.3,
                  fill: false
                },
                {
                  data: leg.ts.map(p => p.vmg),
                  borderColor: '#22c55e',
                  borderWidth: 1.5,
                  tension: 0.3,
                  fill: false
                }
              ]
            },
            options: chartOptions
          });
        }
      });
    }

    // ===== VIDEO REPLAY FUNCTIONS =====
    
    // Set file input accept attributes for desktop only (mobile has issues with accept filters)
    if (!isMobile) {
      // Add accept filters for desktop browsers
      const fileInput = document.getElementById('file-input');
      if (fileInput) {
        fileInput.accept = '.vkx,.fit,.gpx,.gz';
      }
      const videoInput = document.getElementById('video-file-input');
      if (videoInput) {
        videoInput.accept = 'video/*,.mp4,.mov,.m4v,.avi,.mkv,.webm';
      }
    }
    
    let swReady = false;
    let videoFileIdCounter = 0;
    
    // Service Worker setup for iOS (provides Range request support for large videos)
    async function ensureServiceWorker() {
      if (!isIOS) return false;
      if (!('serviceWorker' in navigator)) return false;
      if (navigator.serviceWorker.controller) {
        swReady = true;
        return true;
      }

      try {
        await navigator.serviceWorker.register('./sw.js', { scope: './' });
        await navigator.serviceWorker.ready;
        
        if (!navigator.serviceWorker.controller) {
          console.log('Service Worker installed. Reload may be needed.');
          return false;
        }
        swReady = true;
        return true;
      } catch (e) {
        console.log('Service Worker failed, using blob fallback:', e);
        return false;
      }
    }
    
    async function sendFileToSW(file, fileId) {
      if (!navigator.serviceWorker.controller) return false;

      return new Promise((resolve) => {
        const mc = new MessageChannel();
        const timer = setTimeout(() => resolve(false), 2000);

        mc.port1.onmessage = (e) => {
          clearTimeout(timer);
          resolve(e.data && e.data.type === 'FILE_SET');
        };

        navigator.serviceWorker.controller.postMessage(
          { type: 'SET_FILE', file, fileId },
          [mc.port2]
        );
      });
    }
    
    function removeFileFromSW(fileId) {
      if (navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage({ type: 'REMOVE_FILE', fileId });
      }
    }
    
    // Initialize Service Worker for iOS
    if (isIOS) {
      ensureServiceWorker().then(ok => {
        console.log('iOS detected, Service Worker:', ok ? 'ready' : 'fallback to blob');
      });
    }
    
    let loadedVideos = [];  // Array of { element, filename, startTimestampMs, offsetMs }
    
    function parseVideoInfo(filename) {
      // Parse filename like VID_20251130_142618_00_015.mp4
      // Format: VID_YYYYMMDD_HHMMSS_XX_YYY.mp4
      const match = filename.match(/VID_(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})(\d{2})_(\d{2})_(\d{3})/i);
      if (!match) return null;
      
      const [, year, month, day, hour, min, sec, seqHi, seqLo] = match;
      const baseDate = new Date(
        parseInt(year),
        parseInt(month) - 1,  // Month is 0-indexed
        parseInt(day),
        parseInt(hour),
        parseInt(min),
        parseInt(sec)
      );
      
      // Sequence number from XX_YYY (combine as a single number)
      const sequenceNum = parseInt(seqHi) * 1000 + parseInt(seqLo);
      
      // Base key for grouping (date/time without sequence)
      const baseKey = `${year}${month}${day}_${hour}${min}${sec}`;
      
      return {
        baseTimestampMs: baseDate.getTime(),
        sequenceNum: sequenceNum,
        baseKey: baseKey
      };
    }
    
    // Fallback for non-sequence format
    function parseVideoTimestamp(filename) {
      const info = parseVideoInfo(filename);
      if (info) return info.baseTimestampMs;
      
      // Try simpler format without sequence
      const match = filename.match(/VID_(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})(\d{2})/i);
      if (!match) return null;
      
      const [, year, month, day, hour, min, sec] = match;
      const date = new Date(
        parseInt(year),
        parseInt(month) - 1,
        parseInt(day),
        parseInt(hour),
        parseInt(min),
        parseInt(sec)
      );
      return date.getTime();
    }
    
    function handleVideoFiles(event) {
      const file = event.target.files && event.target.files[0];
      if (!file) return;
      
      const inputId = event.target.id;
      const allFiles = Array.from(event.target.files);
      
      // Reset input immediately
      event.target.value = '';
      
      // Show loading
      const p = document.getElementById('video-placeholder');
      if (p) p.textContent = 'Loading ' + allFiles.length + ' video(s)...';
      
      // Mobile: simple direct processing
      // Desktop: full filtering with timeframe and sequence handling
      if (isMobile) {
        processVideoFilesSimple(allFiles);
      } else {
        processVideoFilesWithFiltering(allFiles, inputId);
      }
    }
    
    // Simple processing for mobile - minimal overhead
    async function processVideoFilesSimple(allFiles) {
      for (const file of allFiles) {
        const info = parseVideoInfo(file.name);
        const timestamp = info ? info.baseTimestampMs : parseVideoTimestamp(file.name);
        
        if (!timestamp) {
          console.log('Skipped video (no timestamp):', file.name);
          continue;
        }
        
        await addVideoFile(file, info, timestamp);
      }
      
      // Show remove button and update display
      if (loadedVideos.length > 0) {
        document.getElementById('remove-videos-btn').style.display = '';
      }
      updateActiveVideoDisplay();
      updateBufferingStatus();
    }
    
    // Full processing for desktop with filtering and sequence handling
    async function processVideoFilesWithFiltering(files, inputId) {
      const isFolderSelection = inputId === 'video-folder-input';
      
      let videoFiles;
      
      if (isFolderSelection) {
        // For folder selection, filter for video files
        videoFiles = files.filter(file => {
          const isVideoType = file.type && file.type.startsWith('video/');
          const name = file.name.toLowerCase();
          const isVideoExt = /\.(mp4|mov|avi|mkv|webm|m4v|3gp|3g2)$/.test(name);
          return isVideoType || isVideoExt;
        });
      } else {
        // For direct file selection, accept all files
        videoFiles = files;
      }
      
      if (videoFiles.length === 0) {
        alert('No video files found in selection.');
        return;
      }
      
      // For folder selection, filter to only videos within track timeframe
      let timeframeFilteredCount = 0;
      if (isFolderSelection && ALL_SESSIONS.length > 0) {
        const MARGIN_MS = 60 * 60 * 1000;  // 1 hour margin
        let minTrackTime = Infinity;
        let maxTrackTime = -Infinity;
        
        ALL_SESSIONS.forEach(session => {
          if (session.startTimestampMs) {
            minTrackTime = Math.min(minTrackTime, session.startTimestampMs);
            const durationMs = (session.fullDuration || session.s.dur) * 60 * 1000;
            maxTrackTime = Math.max(maxTrackTime, session.startTimestampMs + durationMs);
          }
        });
        
        if (minTrackTime !== Infinity && maxTrackTime !== -Infinity) {
          const startWindow = minTrackTime - MARGIN_MS;
          const endWindow = maxTrackTime + MARGIN_MS;
          
          const originalCount = videoFiles.length;
          videoFiles = videoFiles.filter(file => {
            const info = parseVideoInfo(file.name);
            const timestamp = info ? info.baseTimestampMs : parseVideoTimestamp(file.name);
            if (!timestamp) return true;  // Keep files we can't parse
            return timestamp >= startWindow && timestamp <= endWindow;
          });
          timeframeFilteredCount = originalCount - videoFiles.length;
        }
      }
      
      if (videoFiles.length === 0) {
        alert(`No video files found matching the track timeframe.\n\n${timeframeFilteredCount} video(s) were outside the sailing session time window.`);
        return;
      }
      
      // Parse all files and group by base timestamp
      const fileInfos = [];
      const sequenceGroups = {};
      const skippedFiles = [];
      
      videoFiles.forEach(file => {
        const info = parseVideoInfo(file.name);
        if (info) {
          fileInfos.push({ file, info });
          if (!sequenceGroups[info.baseKey]) {
            sequenceGroups[info.baseKey] = [];
          }
          sequenceGroups[info.baseKey].push({ file, info });
        } else {
          const timestamp = parseVideoTimestamp(file.name);
          if (timestamp) {
            fileInfos.push({ file, info: { baseTimestampMs: timestamp, sequenceNum: 0, baseKey: null } });
          } else {
            skippedFiles.push(file.name);
          }
        }
      });
      
      // Show alerts for skipped files
      if (skippedFiles.length > 0) {
        const fileList = skippedFiles.length <= 10 
          ? skippedFiles.join('\n') 
          : skippedFiles.slice(0, 10).join('\n') + `\n... and ${skippedFiles.length - 10} more`;
        
        if (fileInfos.length === 0) {
          alert(`Could not parse timestamps from ${skippedFiles.length} video file(s):\n\n${fileList}\n\nExpected format: VID_YYYYMMDD_HHMMSS_XX_YYY.mp4`);
          return;
        } else {
          const timeframeMsg = timeframeFilteredCount > 0 ? `\n\n${timeframeFilteredCount} video(s) filtered (outside track timeframe).` : '';
          alert(`Skipped ${skippedFiles.length} video(s) without valid timestamp:\n\n${fileList}\n\nLoaded ${fileInfos.length} video(s) successfully.${timeframeMsg}`);
        }
      } else if (timeframeFilteredCount > 0) {
        console.log(`Filtered ${timeframeFilteredCount} video(s) outside track timeframe. Loaded ${fileInfos.length} video(s).`);
      }
      
      if (fileInfos.length === 0) {
        return;
      }
      
      // Find minimum sequence number for each group (including both new and existing videos)
      const minSequenceByGroup = {};
      const oldMinSequenceByGroup = {};
      
      Object.keys(sequenceGroups).forEach(key => {
        const group = sequenceGroups[key];
        const existingInGroup = loadedVideos.filter(v => v.baseKey === key);
        
        // Calculate old minimum (from existing videos only)
        if (existingInGroup.length > 0) {
          oldMinSequenceByGroup[key] = Math.min(...existingInGroup.map(v => v.sequenceNum || 0));
        }
        
        // Calculate new minimum (including new files)
        const allSequences = [
          ...group.map(g => g.info.sequenceNum),
          ...existingInGroup.map(v => v.sequenceNum || 0)
        ];
        minSequenceByGroup[key] = Math.min(...allSequences);
      });
      
      // If minimum sequence changed for any group, update existing videos' timestamps
      Object.keys(minSequenceByGroup).forEach(key => {
        if (oldMinSequenceByGroup[key] !== undefined && 
            minSequenceByGroup[key] < oldMinSequenceByGroup[key]) {
          // New file(s) have lower sequence number - shift existing videos forward
          const shiftAmount = (oldMinSequenceByGroup[key] - minSequenceByGroup[key]) * 30 * 60 * 1000;
          
          loadedVideos.forEach(v => {
            if (v.baseKey === key) {
              v.startTimestampMs += shiftAmount;
              v.endTimestampMs += shiftAmount;
              v.offsetMs = v.startTimestampMs - getPlaybackStartTimeMs();
            }
          });
          
          console.log(`Sequence ${key}: shifted existing videos forward by ${shiftAmount / 60000} minutes`);
        }
      });
      
      // Process files with adjusted timestamps for sequences
      const placeholder = document.getElementById('video-placeholder');
      for (let i = 0; i < fileInfos.length; i++) {
        if (placeholder) {
          placeholder.textContent = `Loading video ${i + 1} of ${fileInfos.length}...`;
        }
        
        const { file, info } = fileInfos[i];
        let timestampMs = info.baseTimestampMs;
        
        // Apply sequence offset (30 min per increment from minimum)
        if (info.baseKey && minSequenceByGroup[info.baseKey] !== undefined) {
          const seqOffset = info.sequenceNum - minSequenceByGroup[info.baseKey];
          timestampMs += seqOffset * 30 * 60 * 1000;
        }
        
        await addVideoFile(file, info, timestampMs);
      }
      
      // Re-sort loadedVideos by startTimestampMs to maintain correct order
      loadedVideos.sort((a, b) => a.startTimestampMs - b.startTimestampMs);
      
      // Update timeline markers to reflect any changes
      renderVideoTimelineMarkers();
      
      // Show remove button and update display
      if (loadedVideos.length > 0) {
        document.getElementById('remove-videos-btn').style.display = '';
      }
      updateActiveVideoDisplay();
      updateBufferingStatus();
    }
    
    // Shared function to add a video file
    async function addVideoFile(file, info, timestamp) {
      const referenceStartMs = getPlaybackStartTimeMs();
      const offsetMs = timestamp - referenceStartMs;
      
      const video = document.createElement('video');
      video.muted = playbackSpeed > 2;
      video.playsInline = true;
      video.setAttribute('playsinline', '');
      video.setAttribute('webkit-playsinline', '');
      video.preload = 'metadata';
      video.style.display = 'none';
      
      const fileId = 'video_' + (++videoFileIdCounter) + '_' + Date.now();
      
      let blobUrl = null;
      if (isIOS && swReady) {
        const sent = await sendFileToSW(file, fileId);
        if (sent) {
          video.src = './__localvideo?id=' + fileId + '&ts=' + Date.now();
        } else {
          blobUrl = URL.createObjectURL(file);
          video.src = blobUrl;
        }
      } else {
        blobUrl = URL.createObjectURL(file);
        video.src = blobUrl;
      }
      
      video.load();
      
      const videoData = {
        element: video,
        filename: file.name,
        fileId: fileId,
        blobUrl: blobUrl,
        startTimestampMs: timestamp,
        offsetMs: offsetMs,
        durationSec: 0,
        endTimestampMs: timestamp,
        baseKey: info ? info.baseKey : null,
        sequenceNum: info ? info.sequenceNum : 0,
        buffered: false,
        bufferProgress: 0,
        isWaiting: false,
        loaded: true
      };
      
      video.addEventListener('loadedmetadata', () => {
        videoData.durationSec = video.duration;
        videoData.endTimestampMs = timestamp + video.duration * 1000;
        renderVideoTimelineMarkers();
      });
      
      video.addEventListener('waiting', () => {
        videoData.isWaiting = true;
        if (currentActiveVideo === videoData && isPlaying) {
          videoStalled = true;
          updateVideoStatusIndicator();
        }
      });
      
      video.addEventListener('playing', () => {
        videoData.isWaiting = false;
        if (currentActiveVideo === videoData) {
          videoStalled = false;
        }
        updateVideoStatusIndicator();
      });
      
      video.addEventListener('canplaythrough', () => {
        videoData.buffered = true;
        videoData.bufferProgress = 100;
        updateBufferingStatus();
      });
      
      loadedVideos.push(videoData);
    }
    
    
    function removeVideo(videoData) {
      const idx = loadedVideos.findIndex(v => v === videoData);
      if (idx >= 0) {
        const video = loadedVideos[idx];
        video.element.pause();
        video.element.style.display = 'none';
        if (video.element.parentNode) {
          video.element.parentNode.removeChild(video.element);
        }
        // Clean up blob URL if used
        if (video.blobUrl) {
          URL.revokeObjectURL(video.blobUrl);
        }
        // Clean up Service Worker file if used
        if (video.fileId && isIOS && swReady) {
          removeFileFromSW(video.fileId);
        }
        loadedVideos.splice(idx, 1);
      }
      
      // Reset current active if it was removed
      if (currentActiveVideo === videoData) {
        currentActiveVideo = null;
        videoStalled = false;
      }
      
      updateActiveVideoDisplay();
      renderVideoTimelineMarkers();
      updateBufferingStatus();
      
      if (loadedVideos.length === 0) {
        document.getElementById('remove-videos-btn').style.display = 'none';
      }
    }
    
    function removeAllVideos() {
      loadedVideos.forEach(v => {
        v.element.pause();
        v.element.style.display = 'none';
        if (v.element.parentNode) {
          v.element.parentNode.removeChild(v.element);
        }
        // Clean up blob URL if used
        if (v.blobUrl) {
          URL.revokeObjectURL(v.blobUrl);
        }
        // Clean up Service Worker file if used
        if (v.fileId && isIOS && swReady) {
          removeFileFromSW(v.fileId);
        }
      });
      loadedVideos = [];
      currentActiveVideo = null;
      videoStalled = false;
      
      updateActiveVideoDisplay();
      renderVideoTimelineMarkers();
      updateBufferingStatus();
      
      document.getElementById('remove-videos-btn').style.display = 'none';
    }
    
    function updateBufferingStatus() {
      const statusEl = document.getElementById('video-buffer-status');
      if (!statusEl) return;
      
      if (loadedVideos.length === 0) {
        statusEl.innerHTML = '';
        return;
      }
      
      const bufferedCount = loadedVideos.filter(v => v.buffered).length;
      const totalCount = loadedVideos.length;
      const allBuffered = bufferedCount === totalCount;
      
      if (allBuffered) {
        statusEl.innerHTML = `<span style="color:#22c55e;font-size:10px;">‚úì ${totalCount} video${totalCount > 1 ? 's' : ''} ready</span>`;
      } else {
        // Calculate overall progress
        const totalProgress = loadedVideos.reduce((sum, v) => sum + (v.bufferProgress || 0), 0);
        const avgProgress = Math.round(totalProgress / totalCount);
        statusEl.innerHTML = `<span style="color:#f59e0b;font-size:10px;">‚è≥ Buffering ${bufferedCount}/${totalCount} (${avgProgress}%)</span>`;
      }
      
      // Update per-video indicator if visible
      const indicator = document.getElementById('video-buffer-indicator');
      if (indicator && currentActiveVideo) {
        if (currentActiveVideo.buffered) {
          indicator.textContent = '‚úì';
          indicator.style.color = '#22c55e';
        } else {
          indicator.textContent = `${currentActiveVideo.bufferProgress || 0}%`;
          indicator.style.color = '#f59e0b';
        }
      }
    }
    
    function updateVideoStatusIndicator() {
      // Just delegate to updateVideoOverlays which handles all badge states
      updateVideoOverlays();
    }
    
    function resetVideoDisplay() {
      // Hide all videos
      loadedVideos.forEach(v => {
        v.element.pause();
        v.element.style.display = 'none';
        if (v.element.parentNode) {
          v.element.parentNode.removeChild(v.element);
        }
      });
      
      currentActiveVideo = null;
      videoStalled = false;
      const container = document.getElementById('video-container');
      if (container) {
        if (loadedVideos.length === 0) {
          container.innerHTML = '<div id="video-placeholder" style="color:#9ca3af;text-align:center;padding:20px;width:100%;font-size:12px;">No videos loaded. Add MP4 files with timestamp in filename (e.g., VID_20251130_142618_00_015.mp4)</div>';
        } else {
          container.innerHTML = '<div style="color:#9ca3af;text-align:center;padding:20px;width:100%;font-size:12px;">Videos available. Enter race replay to view.</div>';
        }
      }
    }
    
    let currentActiveVideo = null;
    
    function getCurrentOrNextVideo() {
      if (loadedVideos.length === 0) return null;
      
      const referenceStartMs = getPlaybackStartTimeMs();
      const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
      
      // Sort videos by start time
      const sorted = [...loadedVideos].sort((a, b) => a.startTimestampMs - b.startTimestampMs);
      
      // Find video that contains current time
      for (const v of sorted) {
        // If metadata loaded (durationSec > 0), check proper range
        if (v.durationSec > 0) {
          if (currentAbsoluteMs >= v.startTimestampMs && currentAbsoluteMs <= v.endTimestampMs) {
            return v;
          }
        } else {
          // Metadata not loaded yet - if video started before current time, assume it might contain it
          // (typical video is 30 min, so give it benefit of doubt)
          if (currentAbsoluteMs >= v.startTimestampMs && currentAbsoluteMs <= v.startTimestampMs + 60 * 60 * 1000) {
            return v;
          }
        }
      }
      
      // Find next video (first one that starts after current time)
      for (const v of sorted) {
        if (v.startTimestampMs > currentAbsoluteMs) {
          return v;
        }
      }
      
      // Check if any video started before current time (could still be playing)
      // This handles the case where timeline selection starts mid-video
      for (let i = sorted.length - 1; i >= 0; i--) {
        const v = sorted[i];
        if (v.startTimestampMs <= currentAbsoluteMs) {
          // Video started before current time - might still be playing
          // Check if we're within reasonable range (durationSec if known, else assume up to 1 hour)
          const maxEndMs = v.durationSec > 0 
            ? v.endTimestampMs 
            : v.startTimestampMs + 60 * 60 * 1000;
          if (currentAbsoluteMs <= maxEndMs) {
            return v;
          }
        }
      }
      
      // No current or next - show the last video
      return sorted[sorted.length - 1];
    }
    
    // Lazy load video - create object URL only when needed
    function ensureVideoLoaded(videoData) {
      if (videoData.loaded) return;
      
      const video = videoData.element;
      
      // Create object URL now
      video.src = URL.createObjectURL(videoData.file);
      videoData.loaded = true;
      
      // Set up metadata listener
      video.addEventListener('loadedmetadata', () => {
        videoData.durationSec = video.duration;
        videoData.endTimestampMs = videoData.startTimestampMs + video.duration * 1000;
        renderVideoTimelineMarkers();
      });
      
      // Track when video is stalled/waiting for data
      video.addEventListener('waiting', () => {
        videoData.isWaiting = true;
        if (currentActiveVideo === videoData && isPlaying) {
          videoStalled = true;
          updateVideoStatusIndicator();
        }
      });
      
      video.addEventListener('stalled', () => {
        videoData.isWaiting = true;
        if (currentActiveVideo === videoData && isPlaying) {
          videoStalled = true;
          updateVideoStatusIndicator();
        }
      });
      
      video.addEventListener('playing', () => {
        videoData.isWaiting = false;
        if (currentActiveVideo === videoData) {
          videoStalled = false;
        }
        updateVideoStatusIndicator();
      });
      
      video.addEventListener('canplay', () => {
        videoData.isWaiting = false;
        if (currentActiveVideo === videoData) {
          videoStalled = false;
        }
      });
      
      // Track buffering progress
      video.addEventListener('progress', () => {
        if (video.buffered.length > 0 && video.duration > 0) {
          const bufferedEnd = video.buffered.end(video.buffered.length - 1);
          videoData.bufferProgress = Math.round((bufferedEnd / video.duration) * 100);
          if (window.requestIdleCallback) {
            requestIdleCallback(() => updateBufferingStatus(), { timeout: 500 });
          } else {
            setTimeout(() => updateBufferingStatus(), 100);
          }
        }
      });
      
      // Mark as fully buffered when ready
      video.addEventListener('canplaythrough', () => {
        videoData.buffered = true;
        videoData.bufferProgress = 100;
        updateBufferingStatus();
      });
    }
    
    function updateActiveVideoDisplay() {
      const container = document.getElementById('video-container');
      const targetVideo = getCurrentOrNextVideo();
      const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
      
      // No videos loaded
      if (!targetVideo) {
        if (isFullscreen) {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          }
        }
        container.innerHTML = '<div id="video-placeholder" style="color:#9ca3af;text-align:center;padding:20px;width:100%;font-size:12px;">No videos loaded. Add MP4 files with timestamp in filename (e.g., VID_20251130_142618_00_015.mp4)</div>';
        currentActiveVideo = null;
        videoStalled = false;
        return;
      }
      
      // Same video already active
      if (currentActiveVideo === targetVideo) {
        updateVideoOverlays();
        return;
      }
      
      // Hide and pause old video if different
      if (currentActiveVideo && currentActiveVideo !== targetVideo) {
        currentActiveVideo.element.pause();
        currentActiveVideo.element.style.display = 'none';
        // Remove from DOM if attached
        if (currentActiveVideo.element.parentNode) {
          currentActiveVideo.element.parentNode.removeChild(currentActiveVideo.element);
        }
      }
      
      currentActiveVideo = targetVideo;
      
      // Lazy load video source if not already loaded
      ensureVideoLoaded(targetVideo);
      
      // Reset waiting/stalled state for newly active video
      targetVideo.isWaiting = false;
      videoStalled = false;
      
      // Build video display
      const referenceStartMs = getPlaybackStartTimeMs();
      const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
      const videoTimeMs = currentAbsoluteMs - targetVideo.startTimestampMs;
      const videoTimeSec = videoTimeMs / 1000;
      const isActive = videoTimeSec >= 0 && videoTimeSec <= targetVideo.durationSec;
      const initialTimeDisplay = isActive 
        ? formatVideoDateTime(targetVideo.startTimestampMs) 
        : formatVideoDateTime(targetVideo.startTimestampMs);
      
      // If in fullscreen, just swap the video element without rebuilding wrapper
      if (isFullscreen) {
        const videoContainer = document.getElementById('active-video-element');
        if (videoContainer) {
          // Update filename label (3rd child due to unavailable overlay)
          const filenameLabel = document.querySelector('#video-wrapper > div:nth-child(3) > div:first-child');
          if (filenameLabel) {
            filenameLabel.innerHTML = `
              ${targetVideo.filename.replace(/\.[^.]+$/, '')}
              <span id="video-buffer-indicator" style="font-size:9px;${targetVideo.buffered ? 'color:#22c55e;' : 'color:#f59e0b;'}">${targetVideo.buffered ? '‚úì' : `${targetVideo.bufferProgress || 0}%`}</span>
            `;
          }
          
          // Insert new video element
          targetVideo.element.style.cssText = `
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform: translateZ(0);
            will-change: transform, contents;
            backface-visibility: hidden;
            contain: strict;
            cursor: pointer;
          `;
          targetVideo.element.preservesPitch = false;
          targetVideo.element.onclick = (e) => {
            e.preventDefault();
            togglePlayback();
          };
          videoContainer.appendChild(targetVideo.element);
          
          // Sync video position
          syncVideosToPlayback(true);
          
          // If playing and video is active, play it
          if (isPlaying && isActive) {
            targetVideo.element.playbackRate = Math.min(playbackSpeed, 16);
            targetVideo.element.muted = playbackSpeed > 2;
            targetVideo.element.play().catch(() => {});
          }
          
          updateVideoOverlays();
          return;
        }
      }
      
      container.innerHTML = `
        <div id="video-wrapper" style="width:100%;max-width:100%;background:#1f2937;border-radius:8px;overflow:hidden;position:relative;isolation:isolate;box-sizing:border-box;">
          <div id="active-video-element" style="width:100%;aspect-ratio:16/9;position:relative;background:#000;"></div>
          <div id="video-unavailable-overlay" onclick="jumpToNextVideo()" style="position:absolute;top:0;left:0;right:0;bottom:0;background:#000;display:${isActive ? 'none' : 'flex'};flex-direction:column;align-items:center;justify-content:center;z-index:5;cursor:pointer;">
            <div style="color:#9ca3af;font-size:14px;text-align:center;max-width:80%;">
              <div>No video available for this timeslot</div>
              <div id="video-countdown" style="margin-top:8px;color:#3b82f6;font-size:13px;"></div>
              <div id="video-skip-btn" style="margin-top:12px;padding:8px 16px;background:rgba(59,130,246,0.2);border:1px solid rgba(59,130,246,0.5);border-radius:6px;color:#3b82f6;">‚ñ∂ Skip to next video</div>
            </div>
          </div>
          <div id="video-overlays-container" style="position:absolute;top:0;left:0;right:0;bottom:0;pointer-events:none;transform:translateZ(0);z-index:10;">
            <div style="position:absolute;top:8px;left:8px;background:rgba(0,0,0,0.7);color:white;padding:4px 8px;border-radius:4px;font-size:11px;display:flex;align-items:center;gap:6px;">
              ${targetVideo.filename.replace(/\.[^.]+$/, '')}
              <span id="video-buffer-indicator" style="font-size:9px;${targetVideo.buffered ? 'color:#22c55e;' : 'color:#f59e0b;'}">${targetVideo.buffered ? '‚úì' : `${targetVideo.bufferProgress || 0}%`}</span>
            </div>
            <div id="video-telemetry-overlay" class="fs-widget${isFullscreen && widgetState['video-telemetry-overlay']?.dragged ? ' dragged' : ''}${isFullscreen && widgetState['video-telemetry-overlay']?.minimized ? ' minimized' : ''}" style="position:absolute;background:rgba(0,0,0,0.7);color:white;padding:6px 10px;border-radius:4px;font-size:12px;font-family:monospace;text-align:right;line-height:1.5;display:${isActive ? 'block' : 'none'};${isFullscreen && widgetState['video-telemetry-overlay']?.dragged ? `top:${widgetState['video-telemetry-overlay'].y}px;left:${widgetState['video-telemetry-overlay'].x}px;` : ''}">
              <div class="fs-widget-header">Telemetry <span class="fs-minimize-btn">${isFullscreen && widgetState['video-telemetry-overlay']?.minimized ? '‚ñ≤' : '‚ñº'}</span></div>
              <div class="fs-widget-content">
                <div><span style="color:#9ca3af;">SPD</span> <span id="telem-sog">-.-</span></div>
                <div><span style="color:#9ca3af;">VMG</span> <span id="telem-vmg">-.-</span></div>
                <div><span style="color:#9ca3af;">HDG</span> <span id="telem-hdg">---</span></div>
                <div><span style="color:#9ca3af;">HEEL</span> <span id="telem-heel">--</span></div>
                <div><span style="color:#9ca3af;">STR</span> <span id="telem-str">-.-</span></div>
              </div>
            </div>
            <div id="video-leg-overlay" class="fs-widget${isFullscreen && widgetState['video-leg-overlay']?.dragged ? ' dragged' : ''}${isFullscreen && widgetState['video-leg-overlay']?.minimized ? ' minimized' : ''}" style="position:absolute;background:rgba(0,0,0,0.7);color:white;padding:6px 10px;border-radius:4px;font-size:12px;font-family:monospace;text-align:right;line-height:1.5;display:${isActive ? 'block' : 'none'};${isFullscreen && widgetState['video-leg-overlay']?.dragged ? `top:${widgetState['video-leg-overlay'].y}px;left:${widgetState['video-leg-overlay'].x}px;` : ''}">
              <div class="fs-widget-header"><span id="telem-leg-label">Leg</span> <span class="fs-minimize-btn">${isFullscreen && widgetState['video-leg-overlay']?.minimized ? '‚ñ≤' : '‚ñº'}</span></div>
              <div class="fs-widget-content">
                <div><span style="color:#9ca3af;">SPD</span> <span id="telem-leg-spd">-.-</span></div>
                <div><span style="color:#9ca3af;">VMG</span> <span id="telem-leg-vmg">-.-</span></div>
                <div><span style="color:#9ca3af;">HDG</span> <span id="telem-leg-hdg">---</span></div>
                <div><span style="color:#9ca3af;">Next</span> <span id="telem-leg-next">--</span></div>
              </div>
            </div>
            <div id="video-distance-overlay" class="fs-widget${isFullscreen && widgetState['video-distance-overlay']?.dragged ? ' dragged' : ''}${isFullscreen && widgetState['video-distance-overlay']?.minimized ? ' minimized' : ''}" style="position:absolute;background:rgba(0,0,0,0.7);color:white;padding:6px 12px;border-radius:4px;font-size:14px;font-family:monospace;text-align:center;display:${isActive && getReplaySessions().length >= 2 ? 'block' : 'none'};${isFullscreen && widgetState['video-distance-overlay']?.dragged ? `top:${widgetState['video-distance-overlay'].y}px;left:${widgetState['video-distance-overlay'].x}px;` : ''}">
              <div class="fs-widget-header" style="text-align:left;">Distance <span class="fs-minimize-btn">${isFullscreen && widgetState['video-distance-overlay']?.minimized ? '‚ñ≤' : '‚ñº'}</span></div>
              <div class="fs-widget-content">
                <span id="telem-distance">--</span>
              </div>
            </div>
            <div id="video-minimap-overlay" class="fs-widget${getReplaySessions().length < 2 ? ' single-boat' : ''}${isFullscreen && widgetState['video-minimap-overlay']?.dragged ? ' dragged' : ''}${isFullscreen && widgetState['video-minimap-overlay']?.minimized ? ' minimized' : ''}" style="${isFullscreen && widgetState['video-minimap-overlay']?.dragged ? `top:${widgetState['video-minimap-overlay'].y}px;left:${widgetState['video-minimap-overlay'].x}px;` : ''}">
              <div class="fs-widget-header">Map <span class="fs-minimize-btn">${isFullscreen && widgetState['video-minimap-overlay']?.minimized ? '‚ñ≤' : '‚ñº'}</span></div>
              <div class="fs-widget-content" style="display:flex;gap:4px;height:calc(100% - 24px);">
                <svg id="video-minimap-svg" style="display:block;flex:1;"></svg>
                <div id="minimap-leg2-telemetry" class="${getReplaySessions().length >= 2 ? 'show-boat2' : ''}" style="flex-shrink:0;color:white;font-size:9px;font-family:monospace;line-height:1.4;display:${getReplaySessions().length >= 2 ? 'flex' : 'none'};flex-direction:column;justify-content:center;">
                  <div id="telem-leg2-label" style="font-size:8px;margin-bottom:2px;">Boat 2 Leg</div>
                  <div><span style="color:#9ca3af;">SPD</span> <span id="telem-leg2-spd">-.-</span></div>
                  <div><span style="color:#9ca3af;">VMG</span> <span id="telem-leg2-vmg">-.-</span></div>
                  <div><span style="color:#9ca3af;">HDG</span> <span id="telem-leg2-hdg">---</span></div>
                  <div><span style="color:#9ca3af;">HEEL</span> <span id="telem-leg2-heel">--</span></div>
                  <div><span style="color:#9ca3af;">Next</span> <span id="telem-leg2-next">--</span></div>
                </div>
              </div>
            </div>
            <div id="video-time-display" style="position:absolute;bottom:8px;right:8px;background:rgba(0,0,0,0.7);color:white;padding:4px 8px;border-radius:4px;font-size:11px;font-family:monospace;display:flex;align-items:center;gap:8px;pointer-events:auto;">
              <span id="video-time-text">${initialTimeDisplay}</span>
              <button id="video-fullscreen-btn" onclick="toggleVideoFullscreen(event)" style="background:none;color:white;border:none;font-size:14px;cursor:pointer;padding:0;">‚õ∂</button>
            </div>
            <div id="video-status-badge" style="position:absolute;bottom:8px;left:8px;background:${isActive ? 'rgba(34,197,94,0.9)' : 'rgba(107,114,128,0.9)'};color:white;padding:4px 8px;border-radius:4px;font-size:11px;">
              ${isActive ? '‚óè LIVE' : 'Video not available'}
            </div>
          </div>
          <div id="video-replay-controls" style="display:none;"></div>
        </div>
      `;
      
      // Insert actual video element with GPU acceleration hints
      const videoContainer = document.getElementById('active-video-element');
      targetVideo.element.style.cssText = `
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: contain;
        transform: translateZ(0);
        will-change: transform, contents;
        backface-visibility: hidden;
        contain: strict;
        cursor: pointer;
      `;
      // Allow faster playback without pitch correction overhead
      targetVideo.element.preservesPitch = false;
      // Click on video to toggle play/pause
      targetVideo.element.onclick = (e) => {
        e.preventDefault();
        togglePlayback();
      };
      videoContainer.appendChild(targetVideo.element);
      
      // Sync video position
      syncVideosToPlayback(true);
      
      // If playing and video is active, play it
      if (isPlaying && isActive) {
        targetVideo.element.playbackRate = Math.min(playbackSpeed, 16);
        targetVideo.element.muted = playbackSpeed > 2;
        targetVideo.element.play().catch(() => {});
      }
      
      updateVideoOverlays();
      
      // Init widget dragging and resizing if in fullscreen
      if (document.fullscreenElement || document.webkitFullscreenElement) {
        initWidgetDragging();
        initWidgetResizing();
        restoreWidgetPositions();
        restoreWidgetSizes();
      }
    }
    
    function updateVideoOverlays() {
      if (!currentActiveVideo) return;
      
      const referenceStartMs = getPlaybackStartTimeMs();
      const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
      const videoTimeMs = currentAbsoluteMs - currentActiveVideo.startTimestampMs;
      const videoTimeSec = videoTimeMs / 1000;
      
      const timeText = document.getElementById('video-time-text');
      const statusBadge = document.getElementById('video-status-badge');
      const unavailableOverlay = document.getElementById('video-unavailable-overlay');
      const telemetryOverlay = document.getElementById('video-telemetry-overlay');
      const legOverlay = document.getElementById('video-leg-overlay');
      const distanceOverlay = document.getElementById('video-distance-overlay');
      const countdownEl = document.getElementById('video-countdown');
      const skipBtn = document.getElementById('video-skip-btn');
      const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
      
      // Check if we have 2 boats for distance overlay
      const hasTwoBoats = getReplaySessions().length >= 2;
      
      if (!timeText || !statusBadge) return;
      
      // Calculate actual timestamp for display
      const actualTimestampMs = currentActiveVideo.startTimestampMs + (currentActiveVideo.element.currentTime * 1000);
      
      // Update telemetry overlay
      updateVideoTelemetry();
      
      // Don't override LOADING state if video is waiting/stalled
      if (videoStalled && isPlaying) {
        timeText.textContent = formatVideoDateTime(currentAbsoluteMs);
        statusBadge.textContent = '‚è∏ BUFFERING';
        statusBadge.style.background = 'rgba(239,68,68,0.9)';
        if (unavailableOverlay) unavailableOverlay.style.display = 'none';
        if (telemetryOverlay) telemetryOverlay.style.display = 'block';
        if (legOverlay) legOverlay.style.display = 'block';
        if (distanceOverlay) distanceOverlay.style.display = hasTwoBoats ? 'block' : 'none';
        updateFullscreenStatus();
        // Update minimap in fullscreen mode
        if (isFullscreen) {
          renderVideoMinimap();
        }
        return;
      }
      
      // Use actual duration if loaded, otherwise assume reasonable max (1 hour)
      const effectiveDuration = currentActiveVideo.durationSec > 0 
        ? currentActiveVideo.durationSec 
        : 60 * 60;
      
      const isVideoActive = videoTimeSec >= 0 && videoTimeSec <= effectiveDuration;
      
      if (videoTimeSec < 0) {
        // Video not yet started - show unavailable with countdown
        timeText.textContent = formatVideoDateTime(currentAbsoluteMs);
        statusBadge.textContent = 'Video not available';
        statusBadge.style.background = 'rgba(107,114,128,0.9)';
        if (unavailableOverlay) unavailableOverlay.style.display = 'flex';
        // In fullscreen, keep telemetry visible
        if (telemetryOverlay) telemetryOverlay.style.display = isFullscreen ? 'block' : 'none';
        if (legOverlay) legOverlay.style.display = isFullscreen ? 'block' : 'none';
        if (distanceOverlay) distanceOverlay.style.display = (isFullscreen && hasTwoBoats) ? 'block' : 'none';
        currentActiveVideo.element.style.visibility = 'hidden';
        // Update countdown - video is coming, show skip button
        if (countdownEl) {
          const secsUntilVideo = Math.ceil(-videoTimeSec);
          const mins = Math.floor(secsUntilVideo / 60);
          const secs = secsUntilVideo % 60;
          countdownEl.textContent = `Next video starts in ${mins}:${secs.toString().padStart(2, '0')}`;
        }
        if (skipBtn) skipBtn.style.display = 'block';
      } else if (videoTimeSec > effectiveDuration) {
        // Video ended - show unavailable, find next video
        timeText.textContent = formatVideoDateTime(currentAbsoluteMs);
        statusBadge.textContent = 'Video not available';
        statusBadge.style.background = 'rgba(107,114,128,0.9)';
        if (unavailableOverlay) unavailableOverlay.style.display = 'flex';
        // In fullscreen, keep telemetry visible
        if (telemetryOverlay) telemetryOverlay.style.display = isFullscreen ? 'block' : 'none';
        if (legOverlay) legOverlay.style.display = isFullscreen ? 'block' : 'none';
        if (distanceOverlay) distanceOverlay.style.display = (isFullscreen && hasTwoBoats) ? 'block' : 'none';
        currentActiveVideo.element.style.visibility = 'hidden';
        // Update countdown for next video
        const nextVideo = getNextVideoAfterCurrent();
        if (countdownEl) {
          if (nextVideo) {
            const nextVideoStartMin = (nextVideo.startTimestampMs - referenceStartMs) / 60000;
            const secsUntilNext = Math.ceil((nextVideoStartMin - playbackTime) * 60);
            if (secsUntilNext > 0) {
              const mins = Math.floor(secsUntilNext / 60);
              const secs = secsUntilNext % 60;
              countdownEl.textContent = `Next video starts in ${mins}:${secs.toString().padStart(2, '0')}`;
            } else {
              countdownEl.textContent = '';
            }
          } else {
            countdownEl.textContent = 'No more videos available';
          }
        }
        // Show/hide skip button based on whether there's a next video
        if (skipBtn) skipBtn.style.display = nextVideo ? 'block' : 'none';
      } else {
        // Video active - show live
        timeText.textContent = formatVideoDateTime(actualTimestampMs);
        statusBadge.textContent = '‚óè LIVE';
        statusBadge.style.background = 'rgba(34,197,94,0.9)';
        if (unavailableOverlay) unavailableOverlay.style.display = 'none';
        if (telemetryOverlay) telemetryOverlay.style.display = 'block';
        if (legOverlay) legOverlay.style.display = 'block';
        if (distanceOverlay) distanceOverlay.style.display = hasTwoBoats ? 'block' : 'none';
        currentActiveVideo.element.style.visibility = 'visible';
      }
      
      // Sync fullscreen status
      updateFullscreenStatus();
      
      // Update minimap in fullscreen mode
      if (isFullscreen) {
        renderVideoMinimap();
      }
    }
    
    // Get the next video after current playback time
    function getNextVideoAfterCurrent() {
      if (loadedVideos.length === 0) return null;
      
      const referenceStartMs = getPlaybackStartTimeMs();
      const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
      
      // Find next video that starts after current time
      const futureVideos = loadedVideos.filter(v => v.startTimestampMs > currentAbsoluteMs);
      if (futureVideos.length === 0) return null;
      
      // Return the one that starts soonest
      return futureVideos.reduce((earliest, v) => 
        v.startTimestampMs < earliest.startTimestampMs ? v : earliest
      );
    }
    
    // Render simplified minimap for fullscreen video overlay
    function renderVideoMinimap() {
      const svg = document.getElementById('video-minimap-svg');
      if (!svg) return;
      
      const sessions = getReplaySessions();
      if (sessions.length === 0) {
        svg.innerHTML = '';
        return;
      }
      
      const rect = svg.getBoundingClientRect();
      const width = rect.width || 264;
      const height = rect.height || 184;
      
      // Calculate bounds from all tracks
      let minLat = Infinity, maxLat = -Infinity;
      let minLon = Infinity, maxLon = -Infinity;
      
      sessions.forEach(session => {
        if (!session.track) return;
        session.track.forEach(p => {
          if (p.lat < minLat) minLat = p.lat;
          if (p.lat > maxLat) maxLat = p.lat;
          if (p.lon < minLon) minLon = p.lon;
          if (p.lon > maxLon) maxLon = p.lon;
        });
      });
      
      if (minLat === Infinity) {
        svg.innerHTML = '';
        return;
      }
      
      // Add padding
      const latPad = (maxLat - minLat) * 0.1 || 0.001;
      const lonPad = (maxLon - minLon) * 0.1 || 0.001;
      minLat -= latPad; maxLat += latPad;
      minLon -= lonPad; maxLon += lonPad;
      
      // Coordinate transforms
      const latRange = maxLat - minLat;
      const lonRange = maxLon - minLon;
      const scale = Math.min(width / lonRange, height / latRange);
      
      const lonToX = lon => (lon - minLon) * scale + (width - lonRange * scale) / 2;
      const latToY = lat => height - ((lat - minLat) * scale + (height - latRange * scale) / 2);
      
      let html = '';
      
      // Draw tracks with time-based fading
      sessions.forEach((session, i) => {
        if (!session.track || session.track.length === 0) return;
        const color = BOAT_COLORS[i % BOAT_COLORS.length];
        
        // Get session timing info
        const sessionLocalTime = getSessionLocalTime(session, playbackTime);
        const sessionStart = session.timelineStart || 0;
        const trackPlaybackTime = sessionLocalTime - sessionStart;
        
        // Fading parameters (in minutes)
        const recentWindow = 15;
        const fadeWindow = 30;
        
        // Sample track for performance
        const maxPoints = 300;
        const step = Math.max(1, Math.floor(session.track.length / maxPoints));
        
        // Draw line segments with individual opacity
        for (let idx = step; idx < session.track.length; idx += step) {
          const p0 = session.track[idx - step];
          const p1 = session.track[idx];
          
          // Calculate opacity based on age
          let opacity = 0.8;
          let strokeColor = color;
          let isGray = false;
          
          if (sessionLocalTime >= sessionStart && trackPlaybackTime >= 0) {
            const age = trackPlaybackTime - p1.t;
            
            if (p1.t > trackPlaybackTime) {
              // Future track - faded grey
              opacity = 0.15;
              strokeColor = '#9ca3af';
              isGray = true;
            } else if (age <= recentWindow) {
              // Recent - full opacity
              opacity = 0.8;
            } else if (age <= fadeWindow) {
              // Fading
              const fadePct = (age - recentWindow) / (fadeWindow - recentWindow);
              opacity = 0.8 - fadePct * 0.5;
            } else {
              // Old - grey
              opacity = 0.2;
              strokeColor = '#9ca3af';
              isGray = true;
            }
          } else if (sessionLocalTime < sessionStart) {
            opacity = 0.15;
            strokeColor = '#9ca3af';
            isGray = true;
          }
          
          // Skip gray tracks if hide mode is enabled
          if (hideGrayTracks && isGray) continue;
          
          const x0 = lonToX(p0.lon);
          const y0 = latToY(p0.lat);
          const x1 = lonToX(p1.lon);
          const y1 = latToY(p1.lat);
          
          html += `<line x1="${x0.toFixed(1)}" y1="${y0.toFixed(1)}" x2="${x1.toFixed(1)}" y2="${y1.toFixed(1)}" stroke="${strokeColor}" stroke-width="1.5" stroke-linecap="round" opacity="${opacity.toFixed(2)}"/>`;
        }
      });
      
      // Draw boat positions (no numbers)
      sessions.forEach((session, i) => {
        const color = BOAT_COLORS[i % BOAT_COLORS.length];
        const pos = getBoatPositionAtTime(session, playbackTime);
        
        if (pos) {
          const x = lonToX(pos.lon);
          const y = latToY(pos.lat);
          const hdg = pos.hdg || pos.cog || 0;
          
          // Boat triangle
          const size = 8;
          html += `
            <g transform="translate(${x},${y}) rotate(${hdg})">
              <polygon points="0,${-size} ${size*0.6},${size*0.6} ${-size*0.6},${size*0.6}" 
                       fill="${color}" stroke="white" stroke-width="1"/>
            </g>
          `;
        }
      });
      
      svg.innerHTML = html;
    }
    
    // Jump to next video and start playing
    function jumpToNextVideo() {
      // Find the next video
      const referenceStartMs = getPlaybackStartTimeMs();
      const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
      
      let nextVideo = null;
      
      // First check if current video hasn't started yet
      if (currentActiveVideo) {
        const videoTimeMs = currentAbsoluteMs - currentActiveVideo.startTimestampMs;
        if (videoTimeMs < 0) {
          // Current video is the next one
          nextVideo = currentActiveVideo;
        }
      }
      
      // Otherwise find next video after current time
      if (!nextVideo) {
        nextVideo = getNextVideoAfterCurrent();
      }
      
      if (!nextVideo) return;
      
      // Calculate playback time for video start (add small offset to be inside the video)
      const videoStartMin = (nextVideo.startTimestampMs - referenceStartMs) / 60000;
      playbackTime = videoStartMin + 0.01; // Small offset to ensure we're inside video timeframe
      
      // Update UI first
      updatePlaybackUI();
      
      // Start playback (this sets isPlaying = true and calls playAllVideos)
      if (!isPlaying) {
        startPlayback();
      }
      
      // Update display - will properly set up video
      updateActiveVideoDisplay();
      
      // Force play the video after a short delay to ensure DOM is ready
      setTimeout(() => {
        // Hide unavailable overlay
        const overlay = document.getElementById('video-unavailable-overlay');
        if (overlay) overlay.style.display = 'none';
        
        // Ensure video is visible and playing
        if (currentActiveVideo && currentActiveVideo.element) {
          currentActiveVideo.element.style.visibility = 'visible';
          currentActiveVideo.element.muted = playbackSpeed > 2;
          currentActiveVideo.element.playbackRate = Math.min(playbackSpeed, 16);
          
          // Set to start of video
          const videoStartSec = 0.01;
          currentActiveVideo.element.currentTime = videoStartSec;
          
          // Force play
          const playPromise = currentActiveVideo.element.play();
          if (playPromise !== undefined) {
            playPromise.catch(err => {
              console.log('Play failed, trying muted:', err);
              currentActiveVideo.element.muted = true;
              currentActiveVideo.element.play().catch(() => {});
            });
          }
        }
        
        // Update overlays to show LIVE status
        updateVideoOverlays();
      }, 100);
      
      // Update other UI elements
      updateBoatInfoPanel();
      updateCurrentLegsPanel();
      updateChartTimePointers();
      updateTimelinePlaybackPointer();
      renderMap();
    }
    
    function updateVideoTelemetry() {
      const sogEl = document.getElementById('telem-sog');
      const vmgEl = document.getElementById('telem-vmg');
      const hdgEl = document.getElementById('telem-hdg');
      const heelEl = document.getElementById('telem-heel');
      const strEl = document.getElementById('telem-str');
      const legSpdEl = document.getElementById('telem-leg-spd');
      const legVmgEl = document.getElementById('telem-leg-vmg');
      const legHdgEl = document.getElementById('telem-leg-hdg');
      const legNextEl = document.getElementById('telem-leg-next');
      const legLabelEl = document.getElementById('telem-leg-label');
      const leg2SpdEl = document.getElementById('telem-leg2-spd');
      const leg2VmgEl = document.getElementById('telem-leg2-vmg');
      const leg2HdgEl = document.getElementById('telem-leg2-hdg');
      const leg2HeelEl = document.getElementById('telem-leg2-heel');
      const leg2NextEl = document.getElementById('telem-leg2-next');
      const leg2LabelEl = document.getElementById('telem-leg2-label');
      const distEl = document.getElementById('telem-distance');
      
      // Get first selected session for telemetry
      const sessions = getReplaySessions();
      
      // Hide/show boat 2 related elements based on session count
      const leg2TelemPanel = document.getElementById('minimap-leg2-telemetry');
      const distanceOverlay = document.getElementById('video-distance-overlay');
      const minimapOverlay = document.getElementById('video-minimap-overlay');
      const hasTwoBoats = sessions.length >= 2;
      
      if (leg2TelemPanel) {
        // Use class toggle to work with CSS !important in fullscreen
        if (hasTwoBoats) {
          leg2TelemPanel.classList.add('show-boat2');
          leg2TelemPanel.style.display = 'flex';
        } else {
          leg2TelemPanel.classList.remove('show-boat2');
          leg2TelemPanel.style.display = 'none';
        }
      }
      if (distanceOverlay) {
        distanceOverlay.style.display = hasTwoBoats ? 'block' : 'none';
      }
      // Toggle single-boat class on minimap for narrower width
      if (minimapOverlay) {
        if (hasTwoBoats) {
          minimapOverlay.classList.remove('single-boat');
        } else {
          minimapOverlay.classList.add('single-boat');
        }
      }
      
      if (sessions.length === 0) {
        if (sogEl) sogEl.textContent = '-.-';
        if (vmgEl) vmgEl.textContent = '-.-';
        if (hdgEl) hdgEl.textContent = '---';
        if (heelEl) heelEl.textContent = '--';
        if (strEl) strEl.textContent = '-.-';
        if (legSpdEl) legSpdEl.textContent = '-.-';
        if (legVmgEl) legVmgEl.textContent = '-.-';
        if (legHdgEl) legHdgEl.textContent = '---';
        if (legNextEl) legNextEl.textContent = '--';
        if (leg2SpdEl) leg2SpdEl.textContent = '-.-';
        if (leg2VmgEl) leg2VmgEl.textContent = '-.-';
        if (leg2HdgEl) leg2HdgEl.textContent = '---';
        if (leg2HeelEl) leg2HeelEl.textContent = '--';
        if (leg2NextEl) leg2NextEl.textContent = '--';
        if (distEl) distEl.textContent = '--';
        return;
      }
      
      // Update leg labels with boat names
      if (legLabelEl && sessions.length >= 1) {
        const boat1Name = getBoatSymbol(sessions[0].filename);
        legLabelEl.textContent = `${boat1Name} Leg`;
      }
      if (leg2LabelEl && sessions.length >= 2) {
        const boat2Name = getBoatSymbol(sessions[1].filename);
        const boat2Color = BOAT_COLORS[1 % BOAT_COLORS.length];
        leg2LabelEl.textContent = `${boat2Name} Leg`;
        leg2LabelEl.style.color = boat2Color;
      }
      
      // Use first session for telemetry (usually the main boat)
      const session = sessions[0];
      const telemetry = getSmoothedTelemetry(session, playbackTime, 2);
      
      // Update instant telemetry
      if (telemetry) {
        if (sogEl) sogEl.textContent = telemetry.sog.toFixed(1);
        if (vmgEl) vmgEl.textContent = telemetry.vmg.toFixed(1);
        if (hdgEl) hdgEl.textContent = Math.round(telemetry.hdg).toString().padStart(3, '0');
        if (heelEl) heelEl.textContent = Math.round(telemetry.heel);
        if (strEl) strEl.textContent = (telemetry.steeringRate || 0).toFixed(1);
      } else {
        if (sogEl) sogEl.textContent = '-.-';
        if (vmgEl) vmgEl.textContent = '-.-';
        if (hdgEl) hdgEl.textContent = '---';
        if (heelEl) heelEl.textContent = '--';
        if (strEl) strEl.textContent = '-.-';
      }
      
      // Update leg telemetry
      const currentLeg = getCurrentLegAtTime(session, playbackTime);
      if (currentLeg) {
        if (legSpdEl) legSpdEl.textContent = currentLeg.speed != null ? parseFloat(currentLeg.speed).toFixed(1) : '-.-';
        if (legVmgEl) legVmgEl.textContent = currentLeg.vmg != null ? parseFloat(currentLeg.vmg).toFixed(1) : '-.-';
        if (legHdgEl) legHdgEl.textContent = currentLeg.hdg != null ? Math.round(currentLeg.hdg).toString().padStart(3, '0') : '---';
        
        // Calculate time until next leg and tack angle
        const sessionLocalTime = getSessionLocalTime(session, playbackTime);
        const sessionStart = session.timelineStart || 0;
        const trackTime = sessionLocalTime - sessionStart;
        const timeToEnd = (currentLeg.end - trackTime) * 60; // Convert to seconds
        
        if (legNextEl) {
          // Find next leg
          const nextLeg = getNextLeg(session, currentLeg);
          let tackAngle = '--';
          if (nextLeg && currentLeg.hdg != null && nextLeg.hdg != null) {
            tackAngle = Math.round(Math.abs(angleDiff(currentLeg.hdg, nextLeg.hdg)));
          }
          
          if (timeToEnd > 0) {
            const mins = Math.floor(timeToEnd / 60);
            const secs = Math.floor(timeToEnd % 60);
            legNextEl.textContent = `${tackAngle}${typeof tackAngle === 'number' ? '¬∞' : ''}, ${mins}:${secs.toString().padStart(2, '0')}`;
          } else {
            legNextEl.textContent = `${tackAngle}${typeof tackAngle === 'number' ? '¬∞' : ''}, 0:00`;
          }
        }
      } else {
        if (legSpdEl) legSpdEl.textContent = '-.-';
        if (legVmgEl) legVmgEl.textContent = '-.-';
        if (legHdgEl) legHdgEl.textContent = '---';
        if (legNextEl) legNextEl.textContent = '--';
      }
      
      // Update second boat leg telemetry (if available)
      if (sessions.length >= 2) {
        const session2 = sessions[1];
        const currentLeg2 = getCurrentLegAtTime(session2, playbackTime);
        
        if (currentLeg2) {
          if (leg2SpdEl) leg2SpdEl.textContent = currentLeg2.speed != null ? parseFloat(currentLeg2.speed).toFixed(1) : '-.-';
          if (leg2VmgEl) leg2VmgEl.textContent = currentLeg2.vmg != null ? parseFloat(currentLeg2.vmg).toFixed(1) : '-.-';
          if (leg2HdgEl) leg2HdgEl.textContent = currentLeg2.hdg != null ? Math.round(currentLeg2.hdg).toString().padStart(3, '0') : '---';
          if (leg2HeelEl) leg2HeelEl.textContent = currentLeg2.heel != null ? Math.round(currentLeg2.heel) : '--';
          
          // Calculate time until next leg and tack angle for boat 2
          const sessionLocalTime2 = getSessionLocalTime(session2, playbackTime);
          const sessionStart2 = session2.timelineStart || 0;
          const trackTime2 = sessionLocalTime2 - sessionStart2;
          const timeToEnd2 = (currentLeg2.end - trackTime2) * 60; // Convert to seconds
          
          if (leg2NextEl) {
            const nextLeg2 = getNextLeg(session2, currentLeg2);
            let tackAngle2 = '--';
            if (nextLeg2 && currentLeg2.hdg != null && nextLeg2.hdg != null) {
              tackAngle2 = Math.round(Math.abs(angleDiff(currentLeg2.hdg, nextLeg2.hdg)));
            }
            leg2NextEl.textContent = typeof tackAngle2 === 'number' ? tackAngle2 + '¬∞' : tackAngle2;
          }
        } else {
          if (leg2SpdEl) leg2SpdEl.textContent = '-.-';
          if (leg2VmgEl) leg2VmgEl.textContent = '-.-';
          if (leg2HdgEl) leg2HdgEl.textContent = '---';
          if (leg2HeelEl) leg2HeelEl.textContent = '--';
          if (leg2NextEl) leg2NextEl.textContent = '--';
        }
      } else {
        if (leg2SpdEl) leg2SpdEl.textContent = '-.-';
        if (leg2VmgEl) leg2VmgEl.textContent = '-.-';
        if (leg2HdgEl) leg2HdgEl.textContent = '---';
        if (leg2HeelEl) leg2HeelEl.textContent = '--';
        if (leg2NextEl) leg2NextEl.textContent = '--';
      }
      
      // Update distance between boats
      if (distEl) {
        const distInfo = getBoatDistanceInfo(sessions, playbackTime);
        distEl.textContent = distInfo;
      }
    }
    
    function getNextLeg(session, currentLeg) {
      if (!session || !session.legs || !currentLeg) return null;
      
      const currentIdx = session.legs.findIndex(l => l.id === currentLeg.id);
      if (currentIdx >= 0 && currentIdx < session.legs.length - 1) {
        return session.legs[currentIdx + 1];
      }
      return null;
    }
    
    function getBoatDistanceInfo(sessions, globalTimeMin) {
      if (sessions.length < 2) return '--';
      
      // Get positions for all boats
      const positions = sessions.map(s => getBoatPositionAtTime(s, globalTimeMin)).filter(p => p);
      if (positions.length < 2) return '--';
      
      const b1 = positions[0];
      const b2 = positions[1];
      
      // Use the same precise calculation as the map
      const route = calculateSailingRoute(b1, b2, sessions);
      
      if (!route) return '--';
      
      // Apply 10-second rolling window to sailing time
      const smoothedTime = getSmoothedSailingTime(route.time);
      
      // Format distances
      const formatDist = (m) => m >= 1000 ? `${(m/1000).toFixed(1)}km` : `${Math.round(m)}m`;
      const formatTime = (sec) => {
        if (sec > 3600) return '>1h';
        if (sec > 600) return `${Math.round(sec/60)}m`;
        if (sec >= 60) return `${Math.floor(sec/60)}:${String(Math.round(sec%60)).padStart(2,'0')}`;
        return `${Math.round(sec)}s`;
      };
      
      return `${formatDist(route.directDist)}/${formatDist(route.sailDist)} ${formatTime(smoothedTime)}`;
    }
    
    function renderVideoTimelineMarkers() {
      // Render video coverage segments in the coverage bar
      const coverageBar = document.getElementById('video-coverage-bar');
      if (coverageBar) {
        coverageBar.innerHTML = '';
        
        if (loadedVideos.length > 0) {
          const referenceStartMs = getPlaybackStartTimeMs();
          const startTime = getPlaybackStartTime();
          const duration = getPlaybackDuration();
          const range = duration - startTime;
          
          if (range > 0) {
            loadedVideos.forEach((v) => {
              const videoStartMin = (v.startTimestampMs - referenceStartMs) / 60000;
              const videoEndMin = (v.endTimestampMs - referenceStartMs) / 60000;
              
              const startPct = Math.max(0, Math.min(100, ((videoStartMin - startTime) / range) * 100));
              const endPct = Math.max(0, Math.min(100, ((videoEndMin - startTime) / range) * 100));
              const widthPct = endPct - startPct;
              
              if (widthPct > 0) {
                const segment = document.createElement('div');
                segment.className = 'video-coverage-segment';
                segment.style.left = `${startPct}%`;
                segment.style.width = `${widthPct}%`;
                segment.title = v.filename;
                coverageBar.appendChild(segment);
              }
            });
          }
        }
      }
    }
    
    // Only called on manual scrub (click, drag, keyboard)
    function syncVideosToPlayback(forceSeek = false) {
      // Check if we need to switch videos
      const targetVideo = getCurrentOrNextVideo();
      if (targetVideo !== currentActiveVideo) {
        updateActiveVideoDisplay();
        return;
      }
      
      if (!currentActiveVideo) return;
      
      const referenceStartMs = getPlaybackStartTimeMs();
      const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
      const videoTimeMs = currentAbsoluteMs - currentActiveVideo.startTimestampMs;
      const videoTimeSec = videoTimeMs / 1000;
      
      // Use actual duration if loaded, otherwise assume reasonable max (1 hour)
      const effectiveDuration = currentActiveVideo.durationSec > 0 
        ? currentActiveVideo.durationSec 
        : 60 * 60;
      
      // Only seek on manual scrub
      if (forceSeek) {
        if (videoTimeSec >= 0 && videoTimeSec <= effectiveDuration) {
          currentActiveVideo.element.currentTime = videoTimeSec;
        } else if (videoTimeSec < 0) {
          currentActiveVideo.element.currentTime = 0;
          currentActiveVideo.element.pause();
        } else {
          // Past end
          currentActiveVideo.element.pause();
        }
      }
      
      updateVideoOverlays();
    }
    
    function formatVideoTime(totalSeconds) {
      const mins = Math.floor(Math.abs(totalSeconds) / 60);
      const secs = Math.floor(Math.abs(totalSeconds) % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    function formatVideoDateTime(timestampMs) {
      const date = new Date(timestampMs);
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const day = date.getDate().toString().padStart(2, '0');
      const month = months[date.getMonth()];
      const year = date.getFullYear();
      const hours = date.getHours().toString().padStart(2, '0');
      const mins = date.getMinutes().toString().padStart(2, '0');
      const secs = date.getSeconds().toString().padStart(2, '0');
      return `${day}-${month}-${year} ${hours}:${mins}:${secs}`;
    }
    
    // Widget state management
    const widgetState = {
      'video-telemetry-overlay': { minimized: false, x: null, y: null, dragged: false },
      'video-leg-overlay': { minimized: false, x: null, y: null, dragged: false },
      'video-distance-overlay': { minimized: false, x: null, y: null, dragged: false },
      'video-minimap-overlay': { minimized: false, x: null, y: null, dragged: false }
    };
    
    // Widget scale (1.0 = default, range 0.5 to 2.0)
    let widgetScale = 1.0;
    const WIDGET_SCALE_MIN = 0.5;
    const WIDGET_SCALE_MAX = 2.0;
    const WIDGET_SCALE_STEP = 0.1;
    
    function increaseWidgetScale() {
      widgetScale = Math.min(WIDGET_SCALE_MAX, widgetScale + WIDGET_SCALE_STEP);
      applyWidgetScale();
    }
    
    function decreaseWidgetScale() {
      widgetScale = Math.max(WIDGET_SCALE_MIN, widgetScale - WIDGET_SCALE_STEP);
      applyWidgetScale();
    }
    
    function applyWidgetScale() {
      const widgets = document.querySelectorAll('.fs-widget');
      widgets.forEach(widget => {
        const widgetId = widget.id;
        const state = widgetState[widgetId];
        
        // Set transform origin based on widget position
        // For dragged widgets, use top-left since we position with top/left
        // For non-dragged widgets, use their corner position
        if (state && state.dragged) {
          widget.style.transformOrigin = 'top left';
        } else if (widgetId === 'video-telemetry-overlay') {
          widget.style.transformOrigin = 'top right';
        } else if (widgetId === 'video-leg-overlay') {
          widget.style.transformOrigin = 'bottom right';
        } else if (widgetId === 'video-minimap-overlay') {
          widget.style.transformOrigin = 'bottom left';
        } else if (widgetId === 'video-distance-overlay') {
          widget.style.transformOrigin = 'bottom center';
        }
        
        // Apply scale (or clear if default)
        if (widgetScale === 1.0) {
          // For dragged widgets, keep transform: none; for others, clear
          if (state && state.dragged) {
            widget.style.transform = 'none';
          } else if (widgetId === 'video-distance-overlay' && !widget.classList.contains('dragged')) {
            widget.style.transform = 'translateX(-50%)';
          } else {
            widget.style.transform = '';
          }
        } else {
          // Apply scale
          if (widgetId === 'video-distance-overlay' && !state?.dragged) {
            widget.style.transform = `translateX(-50%) scale(${widgetScale})`;
          } else {
            widget.style.transform = `scale(${widgetScale})`;
          }
        }
      });
      
      // CSS transform handles visual scaling - no need to re-render minimap
    }
    
    let draggedWidget = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    
    function toggleWidgetMinimize(widgetId) {
      const widget = document.getElementById(widgetId);
      if (!widget) return;
      
      widgetState[widgetId].minimized = !widgetState[widgetId].minimized;
      widget.classList.toggle('minimized', widgetState[widgetId].minimized);
      
      // Update button symbol (‚ñ≤ when minimized = click to show, ‚ñº when expanded = click to hide)
      const btn = widget.querySelector('.fs-minimize-btn');
      if (btn) {
        btn.textContent = widgetState[widgetId].minimized ? '‚ñ≤' : '‚ñº';
      }
    }
    
    function initWidgetDragging() {
      const widgets = document.querySelectorAll('.fs-widget');
      widgets.forEach(widget => {
        const header = widget.querySelector('.fs-widget-header');
        if (!header) return;
        
        // Remove existing listeners to avoid duplicates
        const newHeader = header.cloneNode(true);
        header.parentNode.replaceChild(newHeader, header);
        
        let dragStartTime = 0;
        let dragStartX = 0;
        let dragStartY = 0;
        
        newHeader.addEventListener('mousedown', (e) => {
          if (!(document.fullscreenElement || document.webkitFullscreenElement)) return;
          
          dragStartTime = Date.now();
          dragStartX = e.clientX;
          dragStartY = e.clientY;
          
          e.preventDefault();
          draggedWidget = widget;
          
          const rect = widget.getBoundingClientRect();
          dragOffsetX = e.clientX - rect.left;
          dragOffsetY = e.clientY - rect.top;
          
          widget.style.transition = 'none';
          // Set transform origin to top-left for dragged widgets
          widget.style.transformOrigin = 'top left';
        });
        
        // Touch events for mobile widget dragging
        newHeader.addEventListener('touchstart', (e) => {
          if (!(document.fullscreenElement || document.webkitFullscreenElement)) return;
          
          const touch = e.touches[0];
          if (!touch) return;
          
          dragStartTime = Date.now();
          dragStartX = touch.clientX;
          dragStartY = touch.clientY;
          
          e.preventDefault();
          draggedWidget = widget;
          
          const rect = widget.getBoundingClientRect();
          dragOffsetX = touch.clientX - rect.left;
          dragOffsetY = touch.clientY - rect.top;
          
          widget.style.transition = 'none';
          // Set transform origin to top-left for dragged widgets
          widget.style.transformOrigin = 'top left';
        }, { passive: false });
        
        newHeader.addEventListener('touchend', (e) => {
          // Only toggle if it was a tap (not a drag)
          const touch = e.changedTouches[0];
          if (!touch) return;
          
          const dragDuration = Date.now() - dragStartTime;
          const dragDistance = Math.sqrt(Math.pow(touch.clientX - dragStartX, 2) + Math.pow(touch.clientY - dragStartY, 2));
          
          if (dragDuration < 200 && dragDistance < 10) {
            toggleWidgetMinimize(widget.id);
          }
          
          if (draggedWidget) {
            draggedWidget.style.transition = '';
            draggedWidget = null;
          }
        });
        
        newHeader.addEventListener('click', (e) => {
          // Only toggle if it was a click (not a drag)
          const dragDuration = Date.now() - dragStartTime;
          const dragDistance = Math.sqrt(Math.pow(e.clientX - dragStartX, 2) + Math.pow(e.clientY - dragStartY, 2));
          
          if (dragDuration < 200 && dragDistance < 5) {
            toggleWidgetMinimize(widget.id);
          }
        });
      });
      
      // Only add document-level listeners once
      if (!window._widgetDragListenersAdded) {
        window._widgetDragListenersAdded = true;
        
        document.addEventListener('mousemove', (e) => {
          if (!draggedWidget) return;
          
          const x = e.clientX - dragOffsetX;
          const y = e.clientY - dragOffsetY;
          
          // Add dragged class to override CSS default positions
          draggedWidget.classList.add('dragged');
          
          // Set new position
          draggedWidget.style.top = y + 'px';
          draggedWidget.style.left = x + 'px';
          draggedWidget.style.bottom = 'auto';
          draggedWidget.style.right = 'auto';
          
          // Use top-left origin for dragged widgets and preserve scale
          draggedWidget.style.transformOrigin = 'top left';
          if (widgetScale !== 1.0) {
            draggedWidget.style.transform = `scale(${widgetScale})`;
          } else {
            draggedWidget.style.transform = 'none';
          }
          
          // Save position and dragged state
          widgetState[draggedWidget.id] = widgetState[draggedWidget.id] || {};
          widgetState[draggedWidget.id].x = x;
          widgetState[draggedWidget.id].y = y;
          widgetState[draggedWidget.id].dragged = true;
        });
        
        document.addEventListener('mouseup', () => {
          if (draggedWidget) {
            draggedWidget.style.transition = '';
            draggedWidget = null;
          }
        });
        
        // Touch event handlers for mobile widget dragging
        document.addEventListener('touchmove', (e) => {
          if (!draggedWidget) return;
          
          const touch = e.touches[0];
          if (!touch) return;
          
          const x = touch.clientX - dragOffsetX;
          const y = touch.clientY - dragOffsetY;
          
          // Add dragged class to override CSS default positions
          draggedWidget.classList.add('dragged');
          
          // Set new position
          draggedWidget.style.top = y + 'px';
          draggedWidget.style.left = x + 'px';
          draggedWidget.style.bottom = 'auto';
          draggedWidget.style.right = 'auto';
          
          // Use top-left origin for dragged widgets and preserve scale
          draggedWidget.style.transformOrigin = 'top left';
          if (widgetScale !== 1.0) {
            draggedWidget.style.transform = `scale(${widgetScale})`;
          } else {
            draggedWidget.style.transform = 'none';
          }
          
          // Save position and dragged state
          widgetState[draggedWidget.id] = widgetState[draggedWidget.id] || {};
          widgetState[draggedWidget.id].x = x;
          widgetState[draggedWidget.id].y = y;
          widgetState[draggedWidget.id].dragged = true;
        }, { passive: true });
      }
    }
    
    function restoreWidgetPositions() {
      Object.keys(widgetState).forEach(widgetId => {
        const widget = document.getElementById(widgetId);
        const state = widgetState[widgetId];
        if (!widget || !state) return;
        
        if (state.dragged && state.x !== null && state.y !== null) {
          widget.classList.add('dragged');
          widget.style.top = state.y + 'px';
          widget.style.left = state.x + 'px';
          widget.style.bottom = 'auto';
          widget.style.right = 'auto';
          // Set transform origin to top-left for dragged widgets
          widget.style.transformOrigin = 'top left';
          // Preserve scale transform
          if (widgetScale !== 1.0) {
            widget.style.transform = `scale(${widgetScale})`;
          } else {
            widget.style.transform = 'none';
          }
        }
        
        widget.classList.toggle('minimized', state.minimized);
        
        // Update button symbol (‚ñ≤ when minimized, ‚ñº when expanded)
        const btn = widget.querySelector('.fs-minimize-btn');
        if (btn) {
          btn.textContent = state.minimized ? '‚ñ≤' : '‚ñº';
        }
      });
    }
    
    // Widget base sizes for scaling calculations
    const widgetBaseSizes = {
      'video-telemetry-overlay': { width: 180, height: 200, fontSize: 28 },
      'video-leg-overlay': { width: 180, height: 220, fontSize: 28 },
      'video-distance-overlay': { width: 200, height: 80, fontSize: 28 },
      'video-minimap-overlay': { width: 270, height: 200, fontSize: 14 }
    };
    
    let widgetResizeObserver = null;
    
    function initWidgetResizing() {
      // Disconnect existing observer
      if (widgetResizeObserver) {
        widgetResizeObserver.disconnect();
        widgetResizeObserver = null;
      }
      
      // Set up ResizeObserver for minimap to re-render SVG when resized
      const minimap = document.getElementById('video-minimap-overlay');
      if (minimap) {
        widgetResizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            if (entry.target.id === 'video-minimap-overlay') {
              // Save the new size to widget state
              const rect = entry.contentRect;
              widgetState['video-minimap-overlay'] = widgetState['video-minimap-overlay'] || {};
              widgetState['video-minimap-overlay'].width = rect.width;
              widgetState['video-minimap-overlay'].height = rect.height;
              
              // Scale leg2 telemetry font based on minimap height
              const leg2Panel = document.getElementById('minimap-leg2-telemetry');
              if (leg2Panel) {
                // Base font size 14px at height 200px, scale proportionally
                const scaleFactor = Math.max(0.7, Math.min(1.5, rect.height / 200));
                const fontSize = Math.round(14 * scaleFactor);
                const labelFontSize = Math.round(11 * scaleFactor);
                leg2Panel.style.fontSize = fontSize + 'px';
                const label = document.getElementById('telem-leg2-label');
                if (label) {
                  label.style.fontSize = labelFontSize + 'px';
                }
              }
              
              // Re-render minimap SVG with new dimensions
              renderVideoMinimap();
            }
          }
        });
        widgetResizeObserver.observe(minimap);
      }
    }
    
    function restoreWidgetSizes() {
      // Restore minimap size if it was resized
      const minimapState = widgetState['video-minimap-overlay'];
      const minimap = document.getElementById('video-minimap-overlay');
      if (minimap && minimapState && minimapState.width && minimapState.height) {
        minimap.style.width = minimapState.width + 'px';
        minimap.style.height = minimapState.height + 'px';
        
        // Also restore leg2 telemetry font size based on height
        const leg2Panel = document.getElementById('minimap-leg2-telemetry');
        if (leg2Panel) {
          const scaleFactor = Math.max(0.7, Math.min(1.5, minimapState.height / 200));
          const fontSize = Math.round(14 * scaleFactor);
          const labelFontSize = Math.round(11 * scaleFactor);
          leg2Panel.style.fontSize = fontSize + 'px';
          const label = document.getElementById('telem-leg2-label');
          if (label) {
            label.style.fontSize = labelFontSize + 'px';
          }
        }
      }
    }
    
    function clearWidgetInlineStyles() {
      // Clear inline styles that were set during fullscreen
      // In non-fullscreen mode, widgets should use default CSS positions
      Object.keys(widgetState).forEach(widgetId => {
        const widget = document.getElementById(widgetId);
        if (!widget) return;
        
        // Clear all inline position/size/transform styles
        widget.style.top = '';
        widget.style.left = '';
        widget.style.bottom = '';
        widget.style.right = '';
        widget.style.transform = '';
        widget.style.transformOrigin = '';
        widget.style.width = '';
        widget.style.height = '';
        
        // Remove classes - non-fullscreen uses CSS default positions
        widget.classList.remove('dragged', 'minimized');
        
        // Reset button symbol (‚ñº = expanded)
        const btn = widget.querySelector('.fs-minimize-btn');
        if (btn) {
          btn.textContent = '‚ñº';
        }
      });
      
      // Also clear leg2 telemetry font size
      const leg2Panel = document.getElementById('minimap-leg2-telemetry');
      if (leg2Panel) {
        leg2Panel.style.fontSize = '';
      }
      const leg2Label = document.getElementById('telem-leg2-label');
      if (leg2Label) {
        leg2Label.style.fontSize = '';
      }
    }
    
    function toggleVideoFullscreen(event) {
      if (event) {
        event.stopPropagation();
      }
      const wrapper = document.getElementById('video-wrapper');
      if (!wrapper) return;
      
      if (document.fullscreenElement || document.webkitFullscreenElement) {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        }
      } else {
        // Copy race replay controls to fullscreen overlay with status bar
        const replaySection = document.getElementById('race-replay-section');
        const replayControls = document.getElementById('video-replay-controls');
        const timeText = document.getElementById('video-time-text');
        
        if (replaySection && replayControls) {
          // Build fullscreen controls with time above
          const statusHtml = `
            <div id="fullscreen-status-row" style="display:flex;justify-content:flex-end;align-items:center;padding:4px 16px;color:white;">
              <div id="fs-time-text" style="font-family:monospace;font-size:14px;">${timeText ? timeText.textContent : ''}</div>
            </div>
          `;
          replayControls.innerHTML = statusHtml + replaySection.innerHTML;
          replayControls.style.display = 'block';
          
          // Set initial status dot color based on current video state
          const fsStatusDot = replayControls.querySelector('.status-dot');
          if (fsStatusDot) {
            fsStatusDot.style.display = 'block';  // Force visible in fullscreen
            
            // Compute status directly from video state
            let dotColor = '#6b7280'; // gray - default/no video
            if (currentActiveVideo) {
              const referenceStartMs = getPlaybackStartTimeMs();
              const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
              const videoTimeMs = currentAbsoluteMs - currentActiveVideo.startTimestampMs;
              const videoTimeSec = videoTimeMs / 1000;
              const effectiveDuration = currentActiveVideo.durationSec > 0 ? currentActiveVideo.durationSec : 60 * 60;
              
              if (currentActiveVideo.isWaiting && isPlaying) {
                dotColor = '#ef4444'; // red - LOADING
              } else if (videoTimeSec < 0 || videoTimeSec > effectiveDuration) {
                dotColor = '#6b7280'; // gray - Video not available
              } else {
                dotColor = '#22c55e'; // green - LIVE
              }
            }
            fsStatusDot.style.setProperty('background', dotColor, 'important');
          }
          
          // Re-attach timeline listeners for fullscreen
          const fsTimeline = replayControls.querySelector('.playback-timeline');
          const fsHandle = replayControls.querySelector('.playback-handle');
          const fsCoverageBar = replayControls.querySelector('.video-coverage-bar');
          if (fsTimeline) {
            fsTimeline.addEventListener('click', handleTimelineClick);
            if (fsHandle) {
              fsHandle.addEventListener('mousedown', handleTimelineDragStart);
            }
          }
          // Add click listener to fullscreen coverage bar
          if (fsCoverageBar) {
            fsCoverageBar.addEventListener('click', handleTimelineClick);
          }
          
          // Render video coverage in fullscreen
          if (fsCoverageBar && loadedVideos.length > 0) {
            fsCoverageBar.innerHTML = '';
            const referenceStartMs = getPlaybackStartTimeMs();
            const startTime = getPlaybackStartTime();
            const duration = getPlaybackDuration();
            const range = duration - startTime;
            
            if (range > 0) {
              loadedVideos.forEach((v) => {
                const videoStartMin = (v.startTimestampMs - referenceStartMs) / 60000;
                const videoEndMin = (v.endTimestampMs - referenceStartMs) / 60000;
                
                const startPct = Math.max(0, Math.min(100, ((videoStartMin - startTime) / range) * 100));
                const endPct = Math.max(0, Math.min(100, ((videoEndMin - startTime) / range) * 100));
                const widthPct = endPct - startPct;
                
                if (widthPct > 0) {
                  const segment = document.createElement('div');
                  segment.className = 'video-coverage-segment';
                  segment.style.left = `${startPct}%`;
                  segment.style.width = `${widthPct}%`;
                  segment.title = v.filename;
                  fsCoverageBar.appendChild(segment);
                }
              });
            }
          }
        }
        // Request fullscreen with webkit fallback for iOS Safari
        if (wrapper.requestFullscreen) {
          wrapper.requestFullscreen().catch(err => {
            console.log('Fullscreen error:', err);
          });
        } else if (wrapper.webkitRequestFullscreen) {
          wrapper.webkitRequestFullscreen();
        } else if (wrapper.webkitEnterFullscreen) {
          wrapper.webkitEnterFullscreen();
        }
      }
    }
    
    // Helper function to check if in fullscreen (with webkit prefix support)
    function isInFullscreen() {
      return !!(document.fullscreenElement || document.webkitFullscreenElement);
    }
    
    // Fullscreen change handler
    function handleFullscreenChange() {
      const btn = document.getElementById('video-fullscreen-btn');
      const replayControls = document.getElementById('video-replay-controls');
      const inFullscreen = isInFullscreen();
      
      if (btn) {
        btn.textContent = inFullscreen ? '‚úï' : '‚õ∂';
      }
      if (replayControls && !inFullscreen) {
        replayControls.style.display = 'none';
      }
      if (inFullscreen) {
        // Init widget dragging, resizing and restore positions in fullscreen
        initWidgetDragging();
        initWidgetResizing();
        restoreWidgetPositions();
        restoreWidgetSizes();
        applyWidgetScale();
      } else {
        // Disconnect resize observer when exiting fullscreen
        if (widgetResizeObserver) {
          widgetResizeObserver.disconnect();
        }
        // Clear inline styles when exiting fullscreen so CSS works correctly next time
        clearWidgetInlineStyles();
      }
    }
    
    // Update fullscreen button icon based on state
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    
    // Update fullscreen status elements
    function updateFullscreenStatus() {
      const timeText = document.getElementById('video-time-text');
      const replayControls = document.getElementById('video-replay-controls');
      const fsTimeText = document.getElementById('fs-time-text');
      
      // Update status dot color in fullscreen controls based on video state
      if (replayControls) {
        const fsStatusDot = replayControls.querySelector('.status-dot');
        if (fsStatusDot) {
          fsStatusDot.style.display = 'block';  // Ensure visible
          
          // Compute status directly from video state
          let dotColor = '#6b7280'; // gray - default/no video
          if (currentActiveVideo) {
            const referenceStartMs = getPlaybackStartTimeMs();
            const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
            const videoTimeMs = currentAbsoluteMs - currentActiveVideo.startTimestampMs;
            const videoTimeSec = videoTimeMs / 1000;
            const effectiveDuration = currentActiveVideo.durationSec > 0 ? currentActiveVideo.durationSec : 60 * 60;
            
            if (currentActiveVideo.isWaiting && isPlaying) {
              dotColor = '#ef4444'; // red - LOADING
            } else if (videoTimeSec < 0 || videoTimeSec > effectiveDuration) {
              dotColor = '#6b7280'; // gray - Video not available
            } else {
              dotColor = '#22c55e'; // green - LIVE
            }
          }
          fsStatusDot.style.setProperty('background', dotColor, 'important');
        }
      }
      if (fsTimeText && timeText) {
        fsTimeText.textContent = timeText.textContent;
      }
    }
    
    // Check if we need to switch to a different video
    function checkVideoSwitch() {
      const targetVideo = getCurrentOrNextVideo();
      if (targetVideo !== currentActiveVideo) {
        updateActiveVideoDisplay();
      }
    }
    
    function playAllVideos() {
      if (!currentActiveVideo) return;
      
      const referenceStartMs = getPlaybackStartTimeMs();
      const currentAbsoluteMs = referenceStartMs + playbackTime * 60000;
      const videoTimeMs = currentAbsoluteMs - currentActiveVideo.startTimestampMs;
      const videoTimeSec = videoTimeMs / 1000;
      const effectiveDuration = currentActiveVideo.durationSec > 0 ? currentActiveVideo.durationSec : 60 * 60;
      
      // Set playback rate and mute - disable pitch preservation for faster decoding
      currentActiveVideo.element.playbackRate = Math.min(playbackSpeed, 16);
      currentActiveVideo.element.muted = playbackSpeed > 2;
      currentActiveVideo.element.preservesPitch = false;
      
      // Only play if in range
      if (videoTimeSec >= 0 && videoTimeSec < effectiveDuration) {
        currentActiveVideo.element.currentTime = videoTimeSec;
        // Use play promise to catch and ignore autoplay errors
        const playPromise = currentActiveVideo.element.play();
        if (playPromise !== undefined) {
          playPromise.catch(() => {});
        }
      }
    }
    
    function pauseAllVideos() {
      if (currentActiveVideo) {
        currentActiveVideo.element.pause();
      }
    }
    
    function updateVideoPlaybackRate() {
      if (!currentActiveVideo) return;
      currentActiveVideo.element.muted = playbackSpeed > 2;
      currentActiveVideo.element.playbackRate = Math.min(playbackSpeed, 16);
      currentActiveVideo.element.preservesPitch = false;
    }
  </script>
</body>
</html>
